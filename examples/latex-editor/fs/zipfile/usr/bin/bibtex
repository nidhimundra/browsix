// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = (typeof Module !== 'undefined' ? Module : null) || {};

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
var ENVIRONMENT_IS_BROWSIX = false;

// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)

if (Module['ENVIRONMENT']) {
  if (Module['ENVIRONMENT'] === 'WEB') {
    ENVIRONMENT_IS_WEB = true;
  } else if (Module['ENVIRONMENT'] === 'WORKER') {
    ENVIRONMENT_IS_WORKER = true;
  } else if (Module['ENVIRONMENT'] === 'NODE') {
    ENVIRONMENT_IS_NODE = true;
  } else if (Module['ENVIRONMENT'] === 'SHELL') {
    ENVIRONMENT_IS_SHELL = true;
  } else {
    throw new Error('The provided Module[\'ENVIRONMENT\'] value is not valid. It must be one of: WEB|WORKER|NODE|SHELL.');
  }
} else {
  ENVIRONMENT_IS_WEB = typeof window === 'object';
  ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
  ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
  ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;
  ENVIRONMENT_IS_BROWSIX = ENVIRONMENT_IS_WORKER;
  ENVIRONMENT_IS_WORKER = false;
}


if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = console.log;
  if (!Module['printErr']) Module['printErr'] = console.warn;

  var nodeFS;
  var nodePath;

  Module['read'] = function read(filename, binary) {
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    return binary ? ret : ret.toString();
  };

  Module['readBinary'] = function readBinary(filename) {
    var ret = Module['read'](filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  if (!Module['thisProgram']) {
    if (process['argv'].length > 1) {
      Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
    } else {
      Module['thisProgram'] = 'unknown-program';
    }
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    var data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER | ENVIRONMENT_IS_BROWSIX) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  Module['readAsync'] = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
      } else {
        onerror();
      }
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      if (ENVIRONMENT_IS_BROWSIX)
        debugger;
      console.warn(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WORKER) {
    Module['load'] = importScripts;
  }

  if (typeof Module['setWindowTitle'] === 'undefined') {
    Module['setWindowTitle'] = function(title) { document.title = title };
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
if (!Module['thisProgram']) {
  Module['thisProgram'] = './this.program';
}

// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = undefined;



// {{PREAMBLE_ADDITIONS}}

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  setTempRet0: function (value) {
    tempRet0 = value;
  },
  getTempRet0: function () {
    return tempRet0;
  },
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  STACK_ALIGN: 16,
  prepVararg: function (ptr, type) {
    if (type === 'double' || type === 'i64') {
      // move so the load is aligned
      if (ptr & 7) {
        assert((ptr & 7) === 4);
        ptr += 4;
      }
    } else {
      assert((ptr & 3) === 0);
    }
    return ptr;
  },
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
    } else {
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[sig]) {
      Runtime.funcWrappers[sig] = {};
    }
    var sigCache = Runtime.funcWrappers[sig];
    if (!sigCache[func]) {
      // optimize away arguments usage in common cases
      if (sig.length === 1) {
        sigCache[func] = function dynCall_wrapper() {
          return Runtime.dynCall(sig, func);
        };
      } else if (sig.length === 2) {
        sigCache[func] = function dynCall_wrapper(arg) {
          return Runtime.dynCall(sig, func, [arg]);
        };
      } else {
        // general case
        sigCache[func] = function dynCall_wrapper() {
          return Runtime.dynCall(sig, func, Array.prototype.slice.call(arguments));
        };
      }
    }
    return sigCache[func];
  },
  getCompilerSetting: function (name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+15)&-16); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+15)&-16); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + size)|0;DYNAMICTOP = (((DYNAMICTOP)+15)&-16); if (DYNAMICTOP >= TOTAL_MEMORY) { var success = enlargeMemory(); if (!success) { DYNAMICTOP = ret;  return 0; } }; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 16))*(quantum ? quantum : 16); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*(+4294967296))) : ((+((low>>>0)))+((+((high|0)))*(+4294967296)))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}



Module["Runtime"] = Runtime;


var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var OnceEmitter = (function () {
    function OnceEmitter() {
        this.listeners = {};
    }
    OnceEmitter.prototype.once = function (event, cb) {
        var cbs = this.listeners[event];
        if (!cbs)
            cbs = [cb];
        else
            cbs.push(cb);
        this.listeners[event] = cbs;
    };
    OnceEmitter.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var cbs = this.listeners[event];
        this.listeners[event] = [];
        if (!cbs)
            return;
        for (var i = 0; i < cbs.length; i++) {
            cbs[i].apply(null, args);
        }
    };
    return OnceEmitter;
})();
var Process = (function (_super) {
    __extends(Process, _super);
    function Process(argv, environ) {
        _super.call(this);
        this.argv = argv;
        this.env = environ;
        this.syscall = null;
    }
    Process.prototype.exit = function (code) {
        //Module['noExitRuntime'] = false;
        if (code === void 0) { code = 0; }
        SYSCALLS.browsix.syscall.exit(code);
    };
    return Process;
})(OnceEmitter);

if (ENVIRONMENT_IS_BROWSIX) {
  Runtime['process'] = Runtime.process = new Process(null, null);
  if (typeof Atomics !== 'undefined' && !Atomics.wait && Atomics.futexWait)
    Atomics.wait = Atomics.futexWait;
  if (typeof Atomics !== 'undefined' && !Atomics.wake && Atomics.futexWake)
    Atomics.wake = Atomics.futexWake;
}



//========================================
// Runtime essentials
//========================================

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  if (!func) {
    try { func = eval('_' + ident); } catch(e) {}
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

var cwrap, ccall;
(function(){
  var JSfuncs = {
    // Helpers for cwrap -- it can't refer to Runtime directly because it might
    // be renamed by closure, instead it calls JSfuncs['stackSave'].body to find
    // out what the minified function name is.
    'stackSave': function() {
      Runtime.stackSave()
    },
    'stackRestore': function() {
      Runtime.stackRestore()
    },
    // type conversion from js to c
    'arrayToC' : function(arr) {
      var ret = Runtime.stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    },
    'stringToC' : function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        ret = Runtime.stackAlloc((str.length << 2) + 1);
        writeStringToMemory(str, ret);
      }
      return ret;
    }
  };
  // For fast lookup of conversion functions
  var toC = {'string' : JSfuncs['stringToC'], 'array' : JSfuncs['arrayToC']};

  // C calling interface.
  ccall = function ccallFunc(ident, returnType, argTypes, args, opts) {
    var func = getCFunc(ident);
    var cArgs = [];
    var stack = 0;
    if (args) {
      for (var i = 0; i < args.length; i++) {
        var converter = toC[argTypes[i]];
        if (converter) {
          if (stack === 0) stack = Runtime.stackSave();
          cArgs[i] = converter(args[i]);
        } else {
          cArgs[i] = args[i];
        }
      }
    }
    var ret = func.apply(null, cArgs);
    if (returnType === 'string') ret = Pointer_stringify(ret);
    if (stack !== 0) {
      if (opts && opts.async) {
        EmterpreterAsync.asyncFinalizers.push(function() {
          Runtime.stackRestore(stack);
        });
        return;
      }
      Runtime.stackRestore(stack);
    }
    return ret;
  }

  var sourceRegex = /^function\s*[a-zA-Z$_0-9]*\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;
  function parseJSFunc(jsfunc) {
    // Match the body and the return value of a javascript function source
    var parsed = jsfunc.toString().match(sourceRegex).slice(1);
    return {arguments : parsed[0], body : parsed[1], returnValue: parsed[2]}
  }

  // sources of useful functions. we create this lazily as it can trigger a source decompression on this entire file
  var JSsource = null;
  function ensureJSsource() {
    if (!JSsource) {
      JSsource = {};
      for (var fun in JSfuncs) {
        if (JSfuncs.hasOwnProperty(fun)) {
          // Elements of toCsource are arrays of three items:
          // the code, and the return value
          JSsource[fun] = parseJSFunc(JSfuncs[fun]);
        }
      }
    }
  }

  cwrap = function cwrap(ident, returnType, argTypes) {
    argTypes = argTypes || [];
    var cfunc = getCFunc(ident);
    // When the function takes numbers and returns a number, we can just return
    // the original function
    var numericArgs = argTypes.every(function(type){ return type === 'number'});
    var numericRet = (returnType !== 'string');
    if ( numericRet && numericArgs) {
      return cfunc;
    }
    // Creation of the arguments list (["$1","$2",...,"$nargs"])
    var argNames = argTypes.map(function(x,i){return '$'+i});
    var funcstr = "(function(" + argNames.join(',') + ") {";
    var nargs = argTypes.length;
    if (!numericArgs) {
      // Generate the code needed to convert the arguments from javascript
      // values to pointers
      ensureJSsource();
      funcstr += 'var stack = ' + JSsource['stackSave'].body + ';';
      for (var i = 0; i < nargs; i++) {
        var arg = argNames[i], type = argTypes[i];
        if (type === 'number') continue;
        var convertCode = JSsource[type + 'ToC']; // [code, return]
        funcstr += 'var ' + convertCode.arguments + ' = ' + arg + ';';
        funcstr += convertCode.body + ';';
        funcstr += arg + '=(' + convertCode.returnValue + ');';
      }
    }

    // When the code is compressed, the name of cfunc is not literally 'cfunc' anymore
    var cfuncname = parseJSFunc(function(){return cfunc}).returnValue;
    // Call the function
    funcstr += 'var ret = ' + cfuncname + '(' + argNames.join(',') + ');';
    if (!numericRet) { // Return type can only by 'string' or 'number'
      // Convert the result to a string
      var strgfy = parseJSFunc(function(){return Pointer_stringify}).returnValue;
      funcstr += 'ret = ' + strgfy + '(ret);';
    }
    if (!numericArgs) {
      // If we had a stack, restore it
      ensureJSsource();
      funcstr += JSsource['stackRestore'].body.replace('()', '(stack)') + ';';
    }
    funcstr += 'return ret})';
    return eval(funcstr);
  };
})();
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;

function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module["setValue"] = setValue;


function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module["getValue"] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module["ALLOC_NORMAL"] = ALLOC_NORMAL;
Module["ALLOC_STACK"] = ALLOC_STACK;
Module["ALLOC_STATIC"] = ALLOC_STATIC;
Module["ALLOC_DYNAMIC"] = ALLOC_DYNAMIC;
Module["ALLOC_NONE"] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [typeof _malloc === 'function' ? _malloc : Runtime.staticAlloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module["allocate"] = allocate;

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!staticSealed) return Runtime.staticAlloc(size);
  if ((typeof _sbrk !== 'undefined' && !_sbrk.called) || !runtimeInitialized) return Runtime.dynamicAlloc(size);
  return _malloc(size);
}
Module["getMemory"] = getMemory;

function Pointer_stringify(ptr, /* optional */ length) {
  if (length === 0 || !ptr) return '';
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = 0;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))>>0)];
    hasUtf |= t;
    if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (hasUtf < 128) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }
  return Module['UTF8ToString'](ptr);
}
Module["Pointer_stringify"] = Pointer_stringify;

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAP8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}
Module["AsciiToString"] = AsciiToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}
Module["stringToAscii"] = stringToAscii;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

function UTF8ArrayToString(u8Array, idx) {
  var u0, u1, u2, u3, u4, u5;

  var str = '';
  while (1) {
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    u0 = u8Array[idx++];
    if (!u0) return str;
    if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
    u1 = u8Array[idx++] & 63;
    if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
    u2 = u8Array[idx++] & 63;
    if ((u0 & 0xF0) == 0xE0) {
      u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
    } else {
      u3 = u8Array[idx++] & 63;
      if ((u0 & 0xF8) == 0xF0) {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | u3;
      } else {
        u4 = u8Array[idx++] & 63;
        if ((u0 & 0xFC) == 0xF8) {
          u0 = ((u0 & 3) << 24) | (u1 << 18) | (u2 << 12) | (u3 << 6) | u4;
        } else {
          u5 = u8Array[idx++] & 63;
          u0 = ((u0 & 1) << 30) | (u1 << 24) | (u2 << 18) | (u3 << 12) | (u4 << 6) | u5;
        }
      }
    }
    if (u0 < 0x10000) {
      str += String.fromCharCode(u0);
    } else {
      var ch = u0 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    }
  }
}
Module["UTF8ArrayToString"] = UTF8ArrayToString;

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF8ToString(ptr) {
  return UTF8ArrayToString(HEAPU8,ptr);
}
Module["UTF8ToString"] = UTF8ToString;

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x1FFFFF) {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0x3FFFFFF) {
      if (outIdx + 4 >= endIdx) break;
      outU8Array[outIdx++] = 0xF8 | (u >> 24);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 5 >= endIdx) break;
      outU8Array[outIdx++] = 0xFC | (u >> 30);
      outU8Array[outIdx++] = 0x80 | ((u >> 24) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 18) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}
Module["stringToUTF8Array"] = stringToUTF8Array;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}
Module["stringToUTF8"] = stringToUTF8;

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) {
      ++len;
    } else if (u <= 0x7FF) {
      len += 2;
    } else if (u <= 0xFFFF) {
      len += 3;
    } else if (u <= 0x1FFFFF) {
      len += 4;
    } else if (u <= 0x3FFFFFF) {
      len += 5;
    } else {
      len += 6;
    }
  }
  return len;
}
Module["lengthBytesUTF8"] = lengthBytesUTF8;

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}


// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}


// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}


function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}


// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}


// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}


function demangle(func) {
  var hasLibcxxabi = !!Module['___cxa_demangle'];
  if (hasLibcxxabi) {
    try {
      var buf = _malloc(func.length);
      writeStringToMemory(func.substr(1), buf);
      var status = _malloc(4);
      var ret = Module['___cxa_demangle'](buf, 0, 0, status);
      if (getValue(status, 'i32') === 0 && ret) {
        return Pointer_stringify(ret);
      }
      // otherwise, libcxxabi failed
    } catch(e) {
      // ignore problems here
    } finally {
      if (buf) _free(buf);
      if (status) _free(status);
      if (ret) _free(ret);
    }
    // failure when using libcxxabi, don't demangle
    return func;
  }
  Runtime.warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  return func;
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  var js = jsStackTrace();
  if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
  return demangleAll(js);
}
Module["stackTrace"] = stackTrace;

// Memory management

var PAGE_SIZE = 4096;

function alignMemoryPage(x) {
  if (x % 4096 > 0) {
    x += (4096 - (x % 4096));
  }
  return x;
}

var HEAP;
var buffer;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

function updateGlobalBuffer(buf) {
  Module['buffer'] = buffer = buf;
}

function updateGlobalBufferViews() {
  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
  // needed when run under emterpreter.
  if (typeof asm !== 'undefined' && asm.update_heap) {
    asm.update_heap();
  } else {
    HEAP8 = Module['HEAP8'];
    HEAP16 = Module['HEAP16'];
    HEAP32 = Module['HEAP32'];
    HEAPU8 = Module['HEAPU8'];
    HEAPU16 = Module['HEAPU16'];
    HEAPU32 = Module['HEAPU32'];
    HEAPF32 = Module['HEAPF32'];
    HEAPF64 = Module['HEAPF64'];
  }
}

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk



function abortOnCannotGrowMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which adjusts the size at runtime but prevents some optimizations, (3) set Module.TOTAL_MEMORY to a higher value before the program runs, or if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
}

function enlargeMemory() {
  abortOnCannotGrowMemory();
}


var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;

var totalMemory = 64*1024;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  TOTAL_MEMORY = totalMemory;
}

var REAL_TOTAL_MEMORY = TOTAL_MEMORY;
TOTAL_MEMORY = 16*1024*1024;


// Initialize the runtime's memory



// Use a provided buffer, if there is one, or else allocate a new one
if (Module['buffer']) {
  buffer = Module['buffer'];
} else {
  buffer = new ArrayBuffer(TOTAL_MEMORY);
}
updateGlobalBufferViews();


// Endianness check (note: assumes compiler arch was little-endian)
  HEAP32[0] = 0x63736d65; /* 'emsc' */
HEAP16[1] = 0x6373;
if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';

Module['HEAP'] = HEAP;
Module['buffer'] = buffer;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module["addOnPreRun"] = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module["addOnInit"] = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module["addOnPreMain"] = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module["addOnExit"] = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module["addOnPostRun"] = addOnPostRun;

// Tools


function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}
Module["intArrayFromString"] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module["intArrayToString"] = intArrayToString;

function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))>>0)]=chr;
    i = i + 1;
  }
}
Module["writeStringToMemory"] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[((buffer++)>>0)]=array[i];
  }
}
Module["writeArrayToMemory"] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}
Module["writeAsciiToMemory"] = writeAsciiToMemory;

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


if (!Math['clz32']) Math['clz32'] = function(x) {
  x = x >>> 0;
  for (var i = 0; i < 32; i++) {
    if (x & (1 << (31 - i))) return i;
  }
  return 32;
};
Math.clz32 = Math['clz32']

if (!Math['trunc']) Math['trunc'] = function(x) {
  return x < 0 ? Math.ceil(x) : Math.floor(x);
};
Math.trunc = Math['trunc'];

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}
Module["addRunDependency"] = addRunDependency;

function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module["removeRunDependency"] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data



var memoryInitializer = null;





// === Body ===

var ASM_CONSTS = [];




STATIC_BASE = 8;

STATICTOP = STATIC_BASE + 46960;
  /* global initializers */  __ATINIT__.push();
  

/* memory initializer */ allocate([44,2,0,0,84,2,0,0,144,2,0,0,181,2,0,0,252,2,0,0,49,3,0,0,99,3,0,0,0,0,0,0,37,26,0,0,218,38,0,0,231,38,0,0,220,39,0,0,225,39,0,0,0,0,0,0,144,73,0,0,7,49,0,0,1,0,0,0,1,0,0,0,63,0,0,0,88,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,2,0,0,0,37,120,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,204,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,2,0,0,0,45,120,0,0,156,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,1,0,0,5,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,0,2,0,0,0,209,151,0,0,156,31,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,10,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,85,115,97,103,101,58,32,98,105,98,116,101,120,32,91,79,80,84,73,79,78,93,46,46,46,32,65,85,88,70,73,76,69,91,46,97,117,120,93,0,32,32,87,114,105,116,101,32,98,105,98,108,105,111,103,114,97,112,104,121,32,102,111,114,32,101,110,116,114,105,101,115,32,105,110,32,65,85,88,70,73,76,69,32,116,111,32,65,85,88,70,73,76,69,46,98,98,108,44,0,32,32,97,108,111,110,103,32,119,105,116,104,32,97,32,108,111,103,32,102,105,108,101,32,65,85,88,70,73,76,69,46,98,108,103,46,0,45,109,105,110,45,99,114,111,115,115,114,101,102,115,61,78,85,77,66,69,82,32,32,105,110,99,108,117,100,101,32,105,116,101,109,32,97,102,116,101,114,32,78,85,77,66,69,82,32,99,114,111,115,115,45,114,101,102,115,59,32,100,101,102,97,117,108,116,32,50,0,45,116,101,114,115,101,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,100,111,32,110,111,116,32,112,114,105,110,116,32,112,114,111,103,114,101,115,115,32,114,101,112,111,114,116,115,0,45,104,101,108,112,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,100,105,115,112,108,97,121,32,116,104,105,115,32,104,101,108,112,32,97,110,100,32,101,120,105,116,0,45,118,101,114,115,105,111,110,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,111,117,116,112,117,116,32,118,101,114,115,105,111,110,32,105,110,102,111,114,109,97,116,105,111,110,32,97,110,100,32,101,120,105,116,0,83,111,114,114,121,45,45,45,121,111,117,39,118,101,32,101,120,99,101,101,100,101,100,32,66,105,98,84,101,88,39,115,32,0,37,115,10,0,45,45,45,116,104,105,115,32,99,97,110,39,116,32,104,97,112,112,101,110,0,42,80,108,101,97,115,101,32,110,111,116,105,102,121,32,116,104,101,32,66,105,98,84,101,88,32,109,97,105,110,116,97,105,110,101,114,42,0,82,101,97,108,108,111,99,97,116,101,100,32,37,115,32,40,101,108,116,95,115,105,122,101,61,37,108,100,41,32,116,111,32,37,108,100,32,105,116,101,109,115,32,102,114,111,109,32,37,108,100,46,10,0,98,117,102,102,101,114,0,115,118,95,98,117,102,102,101,114,0,101,120,95,98,117,102,0,111,117,116,95,98,117,102,0,110,97,109,101,95,116,111,107,0,110,97,109,101,95,115,101,112,95,99,104,97,114,0,37,115,37,108,100,0,73,108,108,101,103,97,108,32,115,116,114,105,110,103,32,110,117,109,98,101,114,58,0,115,116,114,95,112,111,111,108,0,32,58,32,0,40,69,114,114,111,114,32,109,97,121,32,104,97,118,101,32,98,101,101,110,32,111,110,32,112,114,101,118,105,111,117,115,32,108,105,110,101,41,0,73,39,109,32,115,107,105,112,112,105,110,103,32,119,104,97,116,101,118,101,114,32,114,101,109,97,105,110,115,32,111,102,32,116,104,105,115,32,0,73,32,99,111,117,108,100,110,39,116,32,111,112,101,110,32,102,105,108,101,32,110,97,109,101,32,96,0,37,115,37,108,100,37,115,0,45,45,45,108,105,110,101,32,0,32,111,102,32,102,105,108,101,32,0,99,111,109,109,97,110,100,0,73,108,108,101,103,97,108,44,32,97,110,111,116,104,101,114,32,92,98,105,98,0,100,97,116,97,0,115,116,121,108,101,0,32,99,111,109,109,97,110,100,0,37,115,37,99,37,99,0,78,111,32,34,0,83,116,117,102,102,32,97,102,116,101,114,32,34,0,87,104,105,116,101,32,115,112,97,99,101,32,105,110,32,97,114,103,117,109,101,110,116,0,67,105,116,101,32,104,97,115,104,32,101,114,114,111,114,0,99,105,116,101,95,108,105,115,116,0,116,121,112,101,95,108,105,115,116,0,101,110,116,114,121,95,101,120,105,115,116,115,0,99,105,116,101,95,105,110,102,111,0,73,32,102,111,117,110,100,32,110,111,32,0,45,45,45,119,104,105,108,101,32,114,101,97,100,105,110,103,32,102,105,108,101,32,0,45,45,108,105,110,101,32,0,73,108,108,101,103,97,108,32,101,110,100,32,111,102,32,115,116,121,108,101,32,102,105,108,101,32,105,110,32,99,111,109,109,97,110,100,58,32,0,85,110,107,110,111,119,110,32,102,117,110,99,116,105,111,110,32,99,108,97,115,115,0,98,117,105,108,116,45,105,110,0,119,105,122,97,114,100,45,100,101,102,105,110,101,100,0,105,110,116,101,103,101,114,45,108,105,116,101,114,97,108,0,115,116,114,105,110,103,45,108,105,116,101,114,97,108,0,102,105,101,108,100,0,105,110,116,101,103,101,114,45,101,110,116,114,121,45,118,97,114,105,97,98,108,101,0,115,116,114,105,110,103,45,101,110,116,114,121,45,118,97,114,105,97,98,108,101,0,105,110,116,101,103,101,114,45,103,108,111,98,97,108,45,118,97,114,105,97,98,108,101,0,115,116,114,105,110,103,45,103,108,111,98,97,108,45,118,97,114,105,97,98,108,101,0,73,100,101,110,116,105,102,105,101,114,32,115,99,97,110,110,105,110,103,32,101,114,114,111,114,0,37,99,37,99,37,115,0,34,32,98,101,103,105,110,115,32,105,100,101,110,116,105,102,105,101,114,44,32,99,111,109,109,97,110,100,58,32,0,34,32,105,109,109,101,100,105,97,116,101,108,121,32,102,111,108,108,111,119,115,32,105,100,101,110,116,105,102,105,101,114,44,32,99,111,109,109,97,110,100,58,32,0,34,32,105,115,32,109,105,115,115,105,110,103,32,105,110,32,99,111,109,109,97,110,100,58,32,0,32,105,115,32,97,108,114,101,97,100,121,32,97,32,116,121,112,101,32,34,0,34,32,102,117,110,99,116,105,111,110,32,110,97,109,101,0,101,110,116,114,121,0,102,105,101,108,100,95,105,110,102,111,0,73,108,108,101,103,97,108,32,101,110,100,32,111,102,32,100,97,116,97,98,97,115,101,32,102,105,108,101,0,37,115,37,99,37,115,37,99,37,99,0,73,32,119,97,115,32,101,120,112,101,99,116,105,110,103,32,97,32,96,0,39,32,111,114,32,97,32,96,0,73,32,119,97,115,32,101,120,112,101,99,116,105,110,103,32,97,110,32,34,0,85,110,98,97,108,97,110,99,101,100,32,98,114,97,99,101,115,0,89,111,117,114,32,102,105,101,108,100,32,105,115,32,109,111,114,101,32,116,104,97,110,32,0,32,99,104,97,114,97,99,116,101,114,115,0,87,97,114,110,105,110,103,45,45,115,116,114,105,110,103,32,110,97,109,101,32,34,0,34,32,105,115,32,0,89,111,117,39,114,101,32,109,105,115,115,105,110,103,32,0,34,32,105,109,109,101,100,105,97,116,101,108,121,32,102,111,108,108,111,119,115,32,0,85,110,107,110,111,119,110,32,100,97,116,97,98,97,115,101,45,102,105,108,101,32,99,111,109,109,97,110,100,0,65,32,99,105,116,101,32,107,101,121,32,100,105,115,97,112,112,101,97,114,101,100,0,45,45,101,110,116,114,121,32,34,0,114,101,102,101,114,115,32,116,111,32,101,110,116,114,121,32,34,0,65,32,98,97,100,32,99,114,111,115,115,32,114,101,102,101,114,101,110,99,101,45,0,34,44,32,119,104,105,99,104,32,100,111,101,115,110,39,116,32,101,120,105,115,116,0,87,97,114,110,105,110,103,45,45,73,32,100,105,100,110,39,116,32,102,105,110,100,32,97,32,100,97,116,97,98,97,115,101,32,101,110,116,114,121,32,102,111,114,32,34,0,32,102,111,114,32,101,110,116,114,121,32,0,119,104,105,108,101,32,101,120,101,99,117,116,105,110,103,45,0,119,104,105,108,101,32,101,120,101,99,117,116,105,110,103,0,89,111,117,32,99,97,110,39,116,32,109,101,115,115,32,119,105,116,104,32,101,110,116,114,105,101,115,32,104,101,114,101,0,73,108,108,101,103,97,108,32,108,105,116,101,114,97,108,32,116,121,112,101,0,85,110,107,110,111,119,110,32,108,105,116,101,114,97,108,32,116,121,112,101,0,37,108,100,37,115,0,32,105,115,32,97,110,32,105,110,116,101,103,101,114,32,108,105,116,101,114,97,108,0,34,32,105,115,32,97,32,115,116,114,105,110,103,32,108,105,116,101,114,97,108,0,39,32,105,115,32,97,32,102,117,110,99,116,105,111,110,32,108,105,116,101,114,97,108,0,39,32,105,115,32,97,32,109,105,115,115,105,110,103,32,102,105,101,108,100,0,37,108,100,10,0,87,97,114,110,105,110,103,45,45,121,111,117,39,118,101,32,101,120,99,101,101,100,101,100,32,0,45,115,116,114,105,110,103,45,115,105,122,101,44,0,42,80,108,101,97,115,101,32,110,111,116,105,102,121,32,116,104,101,32,98,105,98,115,116,121,108,101,32,100,101,115,105,103,110,101,114,42,0,87,97,114,110,105,110,103,45,45,34,0,34,32,105,115,110,39,116,32,97,32,98,114,97,99,101,45,98,97,108,97,110,99,101,100,32,115,116,114,105,110,103,0,85,110,107,110,111,119,110,32,116,121,112,101,32,111,102,32,99,97,115,101,32,99,111,110,118,101,114,115,105,111,110,0,89,111,117,39,118,101,32,117,115,101,100,32,0,32,101,110,116,114,121,44,0,32,101,110,116,114,105,101,115,44,0,37,115,37,108,100,37,115,10,0,32,32,32,32,32,32,32,32,32,32,32,32,0,32,119,105,122,95,100,101,102,105,110,101,100,45,102,117,110,99,116,105,111,110,32,108,111,99,97,116,105,111,110,115,44,0,37,115,37,108,100,37,115,37,108,100,37,115,10,0,32,115,116,114,105,110,103,115,32,119,105,116,104,32,0,32,99,104,97,114,97,99,116,101,114,115,44,0,97,110,100,32,116,104,101,32,98,117,105,108,116,95,105,110,32,102,117,110,99,116,105,111,110,45,99,97,108,108,32,99,111,117,110,116,115,44,32,0,32,105,110,32,97,108,108,44,32,97,114,101,58,0,37,115,37,108,100,10,0,32,45,45,32,0,110,117,109,98,101,114,32,111,102,32,115,116,114,105,110,103,115,32,0,104,97,115,104,32,115,105,122,101,32,0,68,117,112,108,105,99,97,116,101,32,115,111,114,116,32,107,101,121,0,67,117,114,115,101,32,121,111,117,44,32,119,105,122,97,114,100,44,32,98,101,102,111,114,101,32,121,111,117,32,114,101,99,117,114,115,101,32,109,101,58,0,102,117,110,99,116,105,111,110,32,0,32,105,115,32,105,108,108,101,103,97,108,32,105,110,32,105,116,115,32,111,119,110,32,100,101,102,105,110,105,116,105,111,110,0,32,105,115,32,97,110,32,117,110,107,110,111,119,110,32,102,117,110,99,116,105,111,110,0,34,32,99,97,110,39,116,32,102,111,108,108,111,119,32,97,32,108,105,116,101,114,97,108,0,102,117,110,99,116,105,111,110,0,73,108,108,101,103,97,108,32,105,110,116,101,103,101,114,32,105,110,32,105,110,116,101,103,101,114,32,108,105,116,101,114,97,108,0,115,105,110,103,108,95,102,117,110,99,116,105,111,110,0,37,115,37,99,37,115,0,78,111,32,96,0,39,32,116,111,32,101,110,100,32,115,116,114,105,110,103,32,108,105,116,101,114,97,108,0,65,108,114,101,97,100,121,32,101,110,99,111,117,110,116,101,114,101,100,32,105,109,112,108,105,99,105,116,32,102,117,110,99,116,105,111,110,0,119,105,122,95,102,117,110,99,116,105,111,110,115,0,65,32,100,105,103,105,116,32,100,105,115,97,112,112,101,97,114,101,100,0,97,32,102,105,101,108,100,32,112,97,114,116,0,117,115,101,100,32,105,110,32,105,116,115,32,111,119,110,32,100,101,102,105,110,105,116,105,111,110,0,117,110,100,101,102,105,110,101,100,0,102,105,101,108,100,95,105,110,102,111,32,105,110,100,101,120,32,105,115,32,111,117,116,32,111,102,32,114,97,110,103,101,0,87,97,114,110,105,110,103,45,45,73,39,109,32,105,103,110,111,114,105,110,103,32,0,39,115,32,101,120,116,114,97,32,34,0,34,32,102,105,101,108,100,0,67,111,110,116,114,111,108,45,115,101,113,117,101,110,99,101,32,104,97,115,104,32,101,114,114,111,114,0,84,104,101,32,102,111,114,109,97,116,32,115,116,114,105,110,103,32,34,0,34,32,104,97,115,32,97,110,32,105,108,108,101,103,97,108,32,98,114,97,99,101,45,108,101,118,101,108,45,49,32,108,101,116,116,101,114,0,108,105,116,95,115,116,97,99,107,0,108,105,116,95,115,116,107,95,116,121,112,101,0,89,111,117,32,99,97,110,39,116,32,112,111,112,32,97,110,32,101,109,112,116,121,32,108,105,116,101,114,97,108,32,115,116,97,99,107,0,78,111,110,116,111,112,32,116,111,112,32,111,102,32,115,116,114,105,110,103,32,115,116,97,99,107,0,44,32,110,111,116,32,97,110,32,105,110,116,101,103,101,114,44,0,44,32,110,111,116,32,97,32,115,116,114,105,110,103,44,0,44,32,110,111,116,32,97,32,102,117,110,99,116,105,111,110,44,0,69,109,112,116,121,32,108,105,116,101,114,97,108,0,112,116,114,61,0,44,32,115,116,97,99,107,61,0,45,45,45,116,104,101,32,108,105,116,101,114,97,108,32,115,116,97,99,107,32,105,115,110,39,116,32,101,109,112,116,121,0,78,111,110,101,109,112,116,121,32,101,109,112,116,121,32,115,116,114,105,110,103,32,115,116,97,99,107,0,44,32,0,45,45,45,116,104,101,121,32,97,114,101,110,39,116,32,116,104,101,32,115,97,109,101,32,108,105,116,101,114,97,108,32,116,121,112,101,115,0,44,32,110,111,116,32,97,110,32,105,110,116,101,103,101,114,32,111,114,32,97,32,115,116,114,105,110,103,44,0,44,32,116,104,101,32,101,110,116,114,121,0,44,32,116,104,101,32,103,108,111,98,97,108,0,89,111,117,32,99,97,110,39,116,32,97,115,115,105,103,110,32,116,111,32,116,121,112,101,32,0,44,32,97,32,110,111,110,118,97,114,105,97,98,108,101,32,102,117,110,99,116,105,111,110,32,99,108,97,115,115,0,32,105,115,32,97,110,32,105,108,108,101,103,97,108,32,99,97,115,101,45,99,111,110,118,101,114,115,105,111,110,32,115,116,114,105,110,103,0,34,32,105,115,110,39,116,32,97,32,115,105,110,103,108,101,32,99,104,97,114,97,99,116,101,114,0,44,32,110,111,116,32,97,32,115,116,114,105,110,103,32,111,114,32,109,105,115,115,105,110,103,32,102,105,101,108,100,44,0,84,104,101,114,101,32,105,115,32,110,111,32,110,97,109,101,32,105,110,32,34,0,84,104,101,114,101,32,97,114,101,110,39,116,32,0,32,110,97,109,101,115,32,105,110,32,34,0,78,97,109,101,32,0,32,105,110,32,34,0,34,32,104,97,115,32,97,32,99,111,109,109,97,32,97,116,32,116,104,101,32,101,110,100,0,84,111,111,32,109,97,110,121,32,99,111,109,109,97,115,32,105,110,32,110,97,109,101,32,0,32,111,102,32,34,0,34,32,105,115,110,39,116,32,98,114,97,99,101,32,98,97,108,97,110,99,101,100,0,73,108,108,101,103,97,108,32,110,117,109,98,101,114,32,111,102,32,99,111,109,109,97,44,115,0,32,105,115,110,39,116,32,118,97,108,105,100,32,65,83,67,73,73,0,87,97,114,110,105,110,103,45,45,0,85,110,107,110,111,119,110,32,98,117,105,108,116,45,105,110,32,102,117,110,99,116,105,111,110,0,114,98,0,65,108,114,101,97,100,121,32,101,110,99,111,117,110,116,101,114,101,100,32,97,117,120,105,108,105,97,114,121,32,102,105,108,101,0,98,105,98,95,108,105,115,116,0,98,105,98,95,102,105,108,101,0,115,95,112,114,101,97,109,98,108,101,0,84,104,105,115,32,100,97,116,97,98,97,115,101,32,102,105,108,101,32,97,112,112,101,97,114,115,32,109,111,114,101,32,116,104,97,110,32,111,110,99,101,58,32,0,73,32,99,111,117,108,100,110,39,116,32,111,112,101,110,32,100,97,116,97,98,97,115,101,32,102,105,108,101,32,0,65,108,114,101,97,100,121,32,101,110,99,111,117,110,116,101,114,101,100,32,115,116,121,108,101,32,102,105,108,101,0,73,32,99,111,117,108,100,110,39,116,32,111,112,101,110,32,115,116,121,108,101,32,102,105,108,101,32,0,84,104,101,32,115,116,121,108,101,32,102,105,108,101,58,32,0,77,117,108,116,105,112,108,101,32,105,110,99,108,117,115,105,111,110,115,32,111,102,32,101,110,116,105,114,101,32,100,97,116,97,98,97,115,101,0,67,97,115,101,32,109,105,115,109,97,116,99,104,32,101,114,114,111,114,32,98,101,116,119,101,101,110,32,99,105,116,101,32,107,101,121,115,32,0,32,97,110,100,32,0,58,32,0,97,117,120,105,108,105,97,114,121,32,102,105,108,101,32,100,101,112,116,104,32,0,32,104,97,115,32,97,32,119,114,111,110,103,32,101,120,116,101,110,115,105,111,110,0,65,108,114,101,97,100,121,32,101,110,99,111,117,110,116,101,114,101,100,32,102,105,108,101,32,0,73,32,99,111,117,108,100,110,39,116,32,111,112,101,110,32,97,117,120,105,108,105,97,114,121,32,102,105,108,101,32,0,65,32,108,101,118,101,108,45,0,32,97,117,120,105,108,105,97,114,121,32,102,105,108,101,58,32,0,85,110,107,110,111,119,110,32,97,117,120,105,108,105,97,114,121,45,102,105,108,101,32,99,111,109,109,97,110,100,0,92,99,105,116,97,116,105,111,110,32,99,111,109,109,97,110,100,115,0,99,105,116,101,32,107,101,121,115,0,92,98,105,98,100,97,116,97,32,99,111,109,109,97,110,100,0,100,97,116,97,98,97,115,101,32,102,105,108,101,115,0,92,98,105,98,115,116,121,108,101,32,99,111,109,109,97,110,100,0,115,116,121,108,101,32,102,105,108,101,0,73,108,108,101,103,97,108,44,32,97,110,111,116,104,101,114,32,101,110,116,114,121,32,99,111,109,109,97,110,100,0,87,97,114,110,105,110,103,45,45,73,32,100,105,100,110,39,116,32,102,105,110,100,32,97,110,121,32,102,105,101,108,100,115,0,32,104,97,115,32,98,97,100,32,102,117,110,99,116,105,111,110,32,116,121,112,101,32,0,73,108,108,101,103,97,108,44,32,101,120,101,99,117,116,101,32,99,111,109,109,97,110,100,32,98,101,102,111,114,101,32,114,101,97,100,32,99,111,109,109,97,110,100,0,101,120,101,99,117,116,101,0,105,110,116,101,103,101,114,115,0,73,108,108,101,103,97,108,44,32,105,116,101,114,97,116,101,32,99,111,109,109,97,110,100,32,98,101,102,111,114,101,32,114,101,97,100,32,99,111,109,109,97,110,100,0,105,116,101,114,97,116,101,0,73,108,108,101,103,97,108,44,32,109,97,99,114,111,32,99,111,109,109,97,110,100,32,97,102,116,101,114,32,114,101,97,100,32,99,111,109,109,97,110,100,0,109,97,99,114,111,0,32,105,115,32,97,108,114,101,97,100,121,32,100,101,102,105,110,101,100,32,97,115,32,97,32,109,97,99,114,111,0,65,32,109,97,99,114,111,32,100,101,102,105,110,105,116,105,111,110,32,109,117,115,116,32,98,101,32,0,45,100,101,108,105,109,105,116,101,100,0,84,104,101,114,101,39,115,32,110,111,32,96,0,39,32,116,111,32,101,110,100,32,109,97,99,114,111,32,100,101,102,105,110,105,116,105,111,110,0,65,110,32,34,0,34,32,100,105,115,97,112,112,101,97,114,101,100,0,97,110,32,101,110,116,114,121,32,116,121,112,101,0,77,105,115,115,105,110,103,32,34,0,34,32,105,110,32,112,114,101,97,109,98,108,101,32,99,111,109,109,97,110,100,0,97,32,115,116,114,105,110,103,32,110,97,109,101,0,34,32,105,110,32,115,116,114,105,110,103,32,99,111,109,109,97,110,100,0,84,104,101,32,99,105,116,101,32,108,105,115,116,32,105,115,32,109,101,115,115,101,100,32,117,112,0,82,101,112,101,97,116,101,100,32,101,110,116,114,121,0,87,97,114,110,105,110,103,45,45,101,110,116,114,121,32,116,121,112,101,32,102,111,114,32,34,0,34,32,105,115,110,39,116,32,115,116,121,108,101,45,102,105,108,101,32,100,101,102,105,110,101,100,0,97,32,102,105,101,108,100,32,110,97,109,101,0,73,108,108,101,103,97,108,44,32,97,110,111,116,104,101,114,32,114,101,97,100,32,99,111,109,109,97,110,100,0,73,108,108,101,103,97,108,44,32,114,101,97,100,32,99,111,109,109,97,110,100,32,98,101,102,111,114,101,32,101,110,116,114,121,32,99,111,109,109,97,110,100,0,68,97,116,97,98,97,115,101,32,102,105,108,101,32,35,0,87,97,114,110,105,110,103,45,45,121,111,117,39,118,101,32,110,101,115,116,101,100,32,99,114,111,115,115,32,114,101,102,101,114,101,110,99,101,115,0,34,44,32,119,104,105,99,104,32,97,108,115,111,32,114,101,102,101,114,115,32,116,111,32,115,111,109,101,116,104,105,110,103,0,73,108,108,101,103,97,108,44,32,114,101,118,101,114,115,101,32,99,111,109,109,97,110,100,32,98,101,102,111,114,101,32,114,101,97,100,32,99,111,109,109,97,110,100,0,114,101,118,101,114,115,101,0,73,108,108,101,103,97,108,44,32,115,111,114,116,32,99,111,109,109,97,110,100,32,98,101,102,111,114,101,32,114,101,97,100,32,99,111,109,109,97,110,100,0,115,116,114,105,110,103,115,0,103,108,98,95,115,116,114,95,112,116,114,0,103,108,111,98,97,108,95,115,116,114,115,0,103,108,98,95,115,116,114,95,101,110,100,0,34,32,99,97,110,39,116,32,115,116,97,114,116,32,97,32,115,116,121,108,101,45,102,105,108,101,32,99,111,109,109,97,110,100,0,32,105,115,32,97,110,32,105,108,108,101,103,97,108,32,115,116,121,108,101,45,102,105,108,101,32,99,111,109,109,97,110,100,0,85,110,107,110,111,119,110,32,115,116,121,108,101,45,102,105,108,101,32,99,111,109,109,97,110,100,0,98,105,98,116,101,120,0,101,110,116,95,115,116,114,95,115,105,122,101,0,103,108,111,98,95,115,116,114,95,115,105,122,101,0,109,97,120,95,115,116,114,105,110,103,115,0,37,108,100,37,115,10,0,32,105,115,32,97,32,98,97,100,32,98,97,100,0,116,101,114,115,101,0,109,105,110,45,99,114,111,115,115,114,101,102,115,0,104,101,108,112,0,118,101,114,115,105,111,110,0,84,104,105,115,32,105,115,32,66,105,98,84,101,88,44,32,86,101,114,115,105,111,110,32,48,46,57,57,100,0,79,114,101,110,32,80,97,116,97,115,104,110,105,107,0,37,115,37,115,10,0,58,32,78,101,101,100,32,101,120,97,99,116,108,121,32,111,110,101,32,102,105,108,101,32,97,114,103,117,109,101,110,116,46,0,37,115,37,108,100,37,115,37,108,100,37,115,37,108,100,10,0,67,97,112,97,99,105,116,121,58,32,109,97,120,95,115,116,114,105,110,103,115,61,0,44,32,104,97,115,104,95,115,105,122,101,61,0,44,32,104,97,115,104,95,112,114,105,109,101,61,0,84,104,101,32,116,111,112,45,108,101,118,101,108,32,97,117,120,105,108,105,97,114,121,32,102,105,108,101,58,32,0,65,98,111,114,116,101,100,32,97,116,32,108,105,110,101,32,0,40,84,104,101,114,101,32,119,97,115,32,49,32,119,97,114,110,105,110,103,41,0,40,84,104,101,114,101,32,119,101,114,101,32,0,32,119,97,114,110,105,110,103,115,41,0,40,84,104,101,114,101,32,119,97,115,32,49,32,101,114,114,111,114,32,109,101,115,115,97,103,101,41,0,32,101,114,114,111,114,32,109,101,115,115,97,103,101,115,41,0,40,84,104,97,116,32,119,97,115,32,97,32,102,97,116,97,108,32,101,114,114,111,114,41,0,72,105,115,116,111,114,121,32,105,115,32,98,117,110,107,0,37,115,58,32,79,111,112,115,59,32,110,111,116,32,101,110,111,117,103,104,32,97,114,103,117,109,101,110,116,115,46,10,0,73,78,80,85,84,0,46,102,108,115,0,119,98,0,80,87,68,32,37,115,10,0,37,115,32,37,115,10,0,79,85,84,80,85,84,0,102,99,108,111,115,101,0,112,114,111,103,95,110,97,109,101,95,101,110,100,32,38,38,32,112,114,111,103,95,118,101,114,115,105,111,110,0,46,46,47,46,46,47,46,46,47,46,46,47,116,101,120,107,47,119,101,98,50,99,47,108,105,98,47,112,114,105,110,116,118,101,114,115,105,111,110,46,99,0,112,114,105,110,116,118,101,114,115,105,111,110,97,110,100,101,120,105,116,0,37,115,32,37,115,37,115,10,0,67,111,112,121,114,105,103,104,116,32,50,48,49,53,32,37,115,46,10,0,84,104,101,114,101,32,105,115,32,78,79,32,119,97,114,114,97,110,116,121,46,32,32,82,101,100,105,115,116,114,105,98,117,116,105,111,110,32,111,102,32,116,104,105,115,32,115,111,102,116,119,97,114,101,32,105,115,0,99,111,118,101,114,101,100,32,98,121,32,116,104,101,32,116,101,114,109,115,32,111,102,32,0,98,111,116,104,32,116,104,101,32,37,115,32,99,111,112,121,114,105,103,104,116,32,97,110,100,10,0,116,104,101,32,76,101,115,115,101,114,32,71,78,85,32,71,101,110,101,114,97,108,32,80,117,98,108,105,99,32,76,105,99,101,110,115,101,46,0,70,111,114,32,109,111,114,101,32,105,110,102,111,114,109,97,116,105,111,110,32,97,98,111,117,116,32,116,104,101,115,101,32,109,97,116,116,101,114,115,44,32,115,101,101,32,116,104,101,32,102,105,108,101,0,110,97,109,101,100,32,67,79,80,89,73,78,71,32,97,110,100,32,116,104,101,32,37,115,32,115,111,117,114,99,101,46,10,0,80,114,105,109,97,114,121,32,97,117,116,104,111,114,32,111,102,32,37,115,58,32,37,115,46,10,0,37,115,58,32,66,97,100,32,118,97,108,117,101,32,40,37,108,100,41,32,105,110,32,101,110,118,105,114,111,110,109,101,110,116,32,111,114,32,116,101,120,109,102,46,99,110,102,32,102,111,114,32,37,115,44,32,107,101,101,112,105,110,103,32,37,108,100,46,10,0,84,114,121,32,96,37,115,32,45,45,104,101,108,112,39,32,102,111,114,32,109,111,114,101,32,105,110,102,111,114,109,97,116,105,111,110,46,10,0,116,101,120,45,107,64,116,117,103,46,111,114,103,0,10,69,109,97,105,108,32,98,117,103,32,114,101,112,111,114,116,115,32,116,111,32,37,115,46,10,0,32,40,84,101,88,32,76,105,118,101,32,50,48,49,53,47,66,114,111,119,115,105,120,41,0,112,107,0,109,102,0,116,101,120,0,116,102,109,0,102,109,116,0,111,102,109,0,111,99,112,0,103,102,0,47,110,111,110,101,115,117,99,104,0,71,70,70,79,78,84,83,0,71,76,89,80,72,70,79,78,84,83,0,84,69,88,70,79,78,84,83,0,99,111,109,112,105,108,101,45,116,105,109,101,32,112,97,116,104,115,46,104,0,112,114,111,103,114,97,109,32,99,111,110,102,105,103,32,102,105,108,101,0,32,101,110,118,105,114,111,110,109,101,110,116,32,118,97,114,105,97,98,108,101,0,97,112,112,108,105,99,97,116,105,111,110,32,111,118,101,114,114,105,100,101,32,118,97,114,105,97,98,108,101,0,32,0,109,107,116,101,120,112,107,0,45,45,109,102,109,111,100,101,0,36,77,65,75,69,84,69,88,95,77,79,68,69,0,45,45,98,100,112,105,0,36,77,65,75,69,84,69,88,95,66,65,83,69,95,68,80,73,0,45,45,109,97,103,0,36,77,65,75,69,84,69,88,95,77,65,71,0,45,45,100,112,105,0,36,75,80,65,84,72,83,69,65,95,68,80,73,0,80,75,70,79,78,84,83,0,84,69,88,80,75,83,0,98,105,116,109,97,112,32,102,111,110,116,0,109,107,116,101,120,116,102,109,0,84,70,77,70,79,78,84,83,0,46,116,102,109,0,97,102,109,0,65,70,77,70,79,78,84,83,0,46,97,102,109,0,109,107,116,101,120,102,109,116,0,98,97,115,101,0,77,70,66,65,83,69,83,0,84,69,88,77,70,73,78,73,0,46,98,97,115,101,0,98,105,98,0,66,73,66,73,78,80,85,84,83,0,84,69,88,66,73,66,0,46,98,105,98,0,98,115,116,0,66,83,84,73,78,80,85,84,83,0,46,98,115,116,0,99,110,102,0,123,36,83,69,76,70,65,85,84,79,76,79,67,44,36,83,69,76,70,65,85,84,79,76,79,67,47,115,104,97,114,101,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,76,79,67,47,115,104,97,114,101,47,116,101,120,109,102,45,100,105,115,116,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,76,79,67,47,115,104,97,114,101,47,116,101,120,109,102,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,76,79,67,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,76,79,67,47,116,101,120,109,102,45,100,105,115,116,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,76,79,67,47,116,101,120,109,102,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,68,73,82,44,36,83,69,76,70,65,85,84,79,68,73,82,47,115,104,97,114,101,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,68,73,82,47,115,104,97,114,101,47,116,101,120,109,102,45,100,105,115,116,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,68,73,82,47,115,104,97,114,101,47,116,101,120,109,102,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,68,73,82,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,68,73,82,47,116,101,120,109,102,45,100,105,115,116,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,68,73,82,47,116,101,120,109,102,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,71,82,65,78,68,80,65,82,69,78,84,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,47,115,104,97,114,101,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,47,115,104,97,114,101,47,116,101,120,109,102,45,100,105,115,116,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,47,115,104,97,114,101,47,116,101,120,109,102,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,47,116,101,120,109,102,45,108,111,99,97,108,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,47,116,101,120,109,102,45,100,105,115,116,47,119,101,98,50,99,44,36,83,69,76,70,65,85,84,79,80,65,82,69,78,84,47,116,101,120,109,102,47,119,101,98,50,99,125,0,84,69,88,77,70,67,78,70,0,46,99,110,102,0,108,115,45,82,0,84,69,88,77,70,68,66,83,0,108,115,45,114,0,84,69,88,70,79,82,77,65,84,83,0,46,102,109,116,0,109,97,112,0,84,69,88,70,79,78,84,77,65,80,83,0,46,109,97,112,0,109,101,109,0,77,80,77,69,77,83,0,46,109,101,109,0,109,107,116,101,120,109,102,0,77,70,73,78,80,85,84,83,0,46,109,102,0,109,102,116,0,77,70,84,73,78,80,85,84,83,0,46,109,102,116,0,109,102,112,111,111,108,0,77,70,80,79,79,76,0,46,112,111,111,108,0,109,112,0,77,80,73,78,80,85,84,83,0,46,109,112,0,109,112,112,111,111,108,0,77,80,80,79,79,76,0,77,101,116,97,80,111,115,116,32,115,117,112,112,111,114,116,0,77,80,83,85,80,80,79,82,84,0,109,107,111,99,112,0,79,67,80,73,78,80,85,84,83,0,46,111,99,112,0,109,107,111,102,109,0,79,70,77,70,79,78,84,83,0,46,111,102,109,0,111,112,108,0,79,80,76,70,79,78,84,83,0,46,111,112,108,0,46,112,108,0,111,116,112,0,79,84,80,73,78,80,85,84,83,0,46,111,116,112,0,111,118,102,0,79,86,70,70,79,78,84,83,0,46,111,118,102,0,46,118,102,0,111,118,112,0,79,86,80,70,79,78,84,83,0,46,111,118,112,0,46,118,112,108,0,103,114,97,112,104,105,99,47,102,105,103,117,114,101,0,84,69,88,80,73,67,84,83,0,84,69,88,73,78,80,85,84,83,0,46,101,112,115,0,46,101,112,115,105,0,109,107,116,101,120,116,101,120,0,46,116,101,120,0,46,115,116,121,0,46,99,108,115,0,46,102,100,0,46,97,117,120,0,46,98,98,108,0,46,100,101,102,0,46,99,108,111,0,46,108,100,102,0,80,111,115,116,83,99,114,105,112,116,32,104,101,97,100,101,114,0,84,69,88,80,83,72,69,65,68,69,82,83,0,80,83,72,69,65,68,69,82,83,0,46,112,114,111,0,84,101,88,32,115,121,115,116,101,109,32,100,111,99,117,109,101,110,116,97,116,105,111,110,0,84,69,88,68,79,67,83,0,116,101,120,112,111,111,108,0,84,69,88,80,79,79,76,0,84,101,88,32,115,121,115,116,101,109,32,115,111,117,114,99,101,115,0,84,69,88,83,79,85,82,67,69,83,0,46,100,116,120,0,46,105,110,115,0,84,114,111,102,102,32,102,111,110,116,115,0,47,117,115,114,123,47,108,111,99,97,108,44,125,47,115,104,97,114,101,47,103,114,111,102,102,47,123,99,117,114,114,101,110,116,47,102,111,110,116,44,115,105,116,101,45,102,111,110,116,125,47,100,101,118,112,115,0,84,82,70,79,78,84,83,0,116,121,112,101,49,32,102,111,110,116,115,0,84,49,70,79,78,84,83,0,84,49,73,78,80,85,84,83,0,46,112,102,97,0,46,112,102,98,0,118,102,0,86,70,70,79,78,84,83,0,100,118,105,112,115,32,99,111,110,102,105,103,0,84,69,88,67,79,78,70,73,71,0,105,115,116,0,84,69,88,73,78,68,69,88,83,84,89,76,69,0,73,78,68,69,88,83,84,89,76,69,0,46,105,115,116,0,116,114,117,101,116,121,112,101,32,102,111,110,116,115,0,84,84,70,79,78,84,83,0,46,116,116,102,0,46,116,116,99,0,46,84,84,70,0,46,84,84,67,0,46,100,102,111,110,116,0,116,121,112,101,52,50,32,102,111,110,116,115,0,84,52,50,70,79,78,84,83,0,46,116,52,50,0,46,84,52,50,0,119,101,98,50,99,32,102,105,108,101,115,0,87,69,66,50,67,0,111,116,104,101,114,32,116,101,120,116,32,102,105,108,101,115,0,36,84,69,88,77,70,47,0,47,47,0,73,78,80,85,84,83,0,111,116,104,101,114,32,98,105,110,97,114,121,32,102,105,108,101,115,0,109,105,115,99,32,102,111,110,116,115,0,77,73,83,67,70,79,78,84,83,0,119,101,98,0,87,69,66,73,78,80,85,84,83,0,46,119,101,98,0,46,99,104,0,99,119,101,98,0,67,87,69,66,73,78,80,85,84,83,0,46,119,0,101,110,99,32,102,105,108,101,115,0,69,78,67,70,79,78,84,83,0,46,101,110,99,0,99,109,97,112,32,102,105,108,101,115,0,67,77,65,80,70,79,78,84,83,0,115,117,98,102,111,110,116,32,100,101,102,105,110,105,116,105,111,110,32,102,105,108,101,115,0,83,70,68,70,79,78,84,83,0,46,115,102,100,0,111,112,101,110,116,121,112,101,32,102,111,110,116,115,0,79,80,69,78,84,89,80,69,70,79,78,84,83,0,46,111,116,102,0,112,100,102,116,101,120,32,99,111,110,102,105,103,0,80,68,70,84,69,88,67,79,78,70,73,71,0,108,105,103,32,102,105,108,101,115,0,76,73,71,70,79,78,84,83,0,46,108,105,103,0,116,101,120,109,102,115,99,114,105,112,116,115,0,84,69,88,77,70,83,67,82,73,80,84,83,0,108,117,97,0,76,85,65,73,78,80,85,84,83,0,46,108,117,97,0,46,108,117,97,116,101,120,0,46,108,117,99,0,46,108,117,99,116,101,120,0,46,116,101,120,108,117,97,0,46,116,101,120,108,117,99,0,46,116,108,117,0,102,111,110,116,32,102,101,97,116,117,114,101,32,102,105,108,101,115,0,70,79,78,84,70,69,65,84,85,82,69,83,0,46,102,101,97,0,99,105,100,32,109,97,112,115,0,70,79,78,84,67,73,68,77,65,80,83,0,46,99,105,100,0,46,99,105,100,109,97,112,0,109,108,98,105,98,0,77,76,66,73,66,73,78,80,85,84,83,0,46,109,108,98,105,98,0,109,108,98,115,116,0,77,76,66,83,84,73,78,80,85,84,83,0,46,109,108,98,115,116,0,99,108,117,97,0,46,58,36,83,69,76,70,65,85,84,79,76,79,67,47,108,105,98,47,123,36,112,114,111,103,110,97,109,101,44,36,101,110,103,105,110,101,44,125,47,108,117,97,47,47,0,67,76,85,65,73,78,80,85,84,83,0,46,100,108,108,0,46,115,111,0,114,105,115,0,82,73,83,73,78,80,85,84,83,0,46,114,105,115,0,98,108,116,120,109,108,0,66,76,84,88,77,76,73,78,80,85,84,83,0,46,98,108,116,120,109,108,0,107,112,115,101,95,105,110,105,116,95,102,111,114,109,97,116,58,32,85,110,107,110,111,119,110,32,102,111,114,109,97,116,32,37,100,0,83,101,97,114,99,104,32,112,97,116,104,32,102,111,114,32,37,115,32,102,105,108,101,115,32,40,102,114,111,109,32,37,115,41,10,0,32,32,61,32,37,115,10,0,32,32,98,101,102,111,114,101,32,101,120,112,97,110,115,105,111,110,32,61,32,37,115,10,0,40,110,111,110,101,41,0,32,32,97,112,112,108,105,99,97,116,105,111,110,32,111,118,101,114,114,105,100,101,32,112,97,116,104,32,61,32,37,115,10,0,32,32,97,112,112,108,105,99,97,116,105,111,110,32,99,111,110,102,105,103,32,102,105,108,101,32,112,97,116,104,32,61,32,37,115,10,0,32,32,116,101,120,109,102,46,99,110,102,32,112,97,116,104,32,61,32,37,115,10,0,32,32,99,111,109,112,105,108,101,45,116,105,109,101,32,112,97,116,104,32,61,32,37,115,10,0,32,32,101,110,118,105,114,111,110,109,101,110,116,32,118,97,114,105,97,98,108,101,115,32,61,32,37,115,10,0,32,32,100,101,102,97,117,108,116,32,115,117,102,102,105,120,101,115,32,61,0,32,40,110,111,110,101,41,10,0,32,32,111,116,104,101,114,32,115,117,102,102,105,120,101,115,32,61,0,32,32,115,101,97,114,99,104,32,111,110,108,121,32,119,105,116,104,32,115,117,102,102,105,120,32,61,32,37,100,10,0,32,32,114,117,110,116,105,109,101,32,103,101,110,101,114,97,116,105,111,110,32,112,114,111,103,114,97,109,32,61,32,37,115,10,0,32,32,114,117,110,116,105,109,101,32,103,101,110,101,114,97,116,105,111,110,32,99,111,109,109,97,110,100,32,61,0,32,32,112,114,111,103,114,97,109,32,101,110,97,98,108,101,100,32,61,32,37,100,10,0,32,32,112,114,111,103,114,97,109,32,101,110,97,98,108,101,32,108,101,118,101,108,32,61,32,37,100,10,0,32,32,111,112,101,110,32,102,105,108,101,115,32,105,110,32,98,105,110,97,114,121,32,109,111,100,101,32,61,32,37,100,10,0,32,32,110,117,109,101,114,105,99,32,102,111,114,109,97,116,32,118,97,108,117,101,32,61,32,37,100,10,0,99,111,110,115,116,95,110,97,109,101,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,116,101,120,45,102,105,108,101,46,99,0,107,112,97,116,104,115,101,97,95,102,105,110,100,95,102,105,108,101,95,103,101,110,101,114,105,99,0,107,112,115,101,95,102,105,110,100,95,102,105,108,101,58,32,115,101,97,114,99,104,105,110,103,32,102,111,114,32,37,115,32,111,102,32,116,121,112,101,32,37,115,32,40,102,114,111,109,32,37,115,41,10,0,116,114,121,95,115,116,100,95,101,120,116,101,110,115,105,111,110,95,102,105,114,115,116,0,111,112,101,110,105,110,95,97,110,121,0,114,101,97,100,105,110,103,32,102,114,111,109,0,119,114,105,116,105,110,103,32,116,111,0,10,37,115,58,32,78,111,116,32,37,115,32,37,115,32,40,37,115,32,61,32,37,115,41,46,10,0,111,112,101,110,111,117,116,95,97,110,121,0,112,0,116,101,120,109,102,46,99,110,102,0,107,112,97,116,104,115,101,97,58,32,37,115,58,32,76,97,115,116,32,108,105,110,101,32,111,102,32,102,105,108,101,32,101,110,100,115,32,119,105,116,104,32,92,0,75,80,65,84,72,83,69,65,95,87,65,82,78,73,78,71,0,48,0,107,112,97,116,104,115,101,97,58,32,99,111,110,102,105,103,117,114,97,116,105,111,110,32,102,105,108,101,32,116,101,120,109,102,46,99,110,102,32,110,111,116,32,102,111,117,110,100,32,105,110,32,116,104,101,115,101,32,100,105,114,101,99,116,111,114,105,101,115,58,32,37,115,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,99,110,102,46,99,0,107,112,97,116,104,115,101,97,95,99,110,102,95,103,101,116,0,108,115,45,114,0,108,115,45,82,0,100,98,58,105,110,105,116,40,41,58,32,115,107,105,112,112,105,110,103,32,100,98,32,115,97,109,101,95,102,105,108,101,95,112], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);
/* memory initializer */ allocate([32,37,115,44,32,119,105,108,108,32,97,100,100,32,37,115,46,10,0,100,98,58,105,110,105,116,40,41,58,32,117,115,105,110,103,32,100,98,32,102,105,108,101,32,37,115,46,10,0,107,112,97,116,104,115,101,97,58,32,37,115,58,32,78,111,32,117,115,97,98,108,101,32,101,110,116,114,105,101,115,32,105,110,32,108,115,45,82,0,107,112,97,116,104,115,101,97,58,32,83,101,101,32,116,104,101,32,109,97,110,117,97,108,32,102,111,114,32,104,111,119,32,116,111,32,103,101,110,101,114,97,116,101,32,108,115,45,82,0,37,115,58,32,37,117,32,101,110,116,114,105,101,115,32,105,110,32,37,100,32,100,105,114,101,99,116,111,114,105,101,115,32,40,37,100,32,104,105,100,100,101,110,41,46,10,0,108,115,45,82,32,104,97,115,104,32,116,97,98,108,101,58,0,97,108,105,97,115,101,115,0,37,115,58,32,37,117,32,97,108,105,97,115,101,115,46,10,0,97,108,105,97,115,32,104,97,115,104,32,116,97,98,108,101,58,0,100,98,58,109,97,116,99,104,40,37,115,44,37,115,41,32,61,32,37,100,10,0,102,111,112,101,110,40,37,115,44,32,37,115,41,32,61,62,32,48,120,37,108,120,10,0,102,99,108,111,115,101,40,48,120,37,108,120,41,32,61,62,32,37,100,10,0,107,112,97,116,104,115,101,97,58,32,37,115,58,32,85,110,109,97,116,99,104,101,100,32,123,0,58,0,75,80,83,69,95,68,79,84,0,116,101,120,102,111,110,116,115,46,109,97,112,0,114,0,64,99,0,105,110,99,108,117,100,101,0,107,112,97,116,104,115,101,97,58,32,37,115,58,37,117,58,32,70,105,108,101,110,97,109,101,32,97,114,103,117,109,101,110,116,32,102,111,114,32,105,110,99,108,117,100,101,32,100,105,114,101,99,116,105,118,101,32,109,105,115,115,105,110,103,0,107,112,97,116,104,115,101,97,58,32,37,115,58,37,117,58,32,67,97,110,39,116,32,102,105,110,100,32,102,111,110,116,110,97,109,101,32,105,110,99,108,117,100,101,32,102,105,108,101,32,96,37,115,39,0,107,112,97,116,104,115,101,97,58,32,37,115,58,37,117,58,32,70,111,110,116,110,97,109,101,32,97,108,105,97,115,32,109,105,115,115,105,110,103,32,102,111,114,32,102,105,108,101,110,97,109,101,32,96,37,115,39,0,104,97,115,104,95,108,111,111,107,117,112,40,37,115,41,32,61,62,0,32,40,110,105,108,41,10,0,37,108,100,0,37,52,100,32,0,58,37,45,53,100,0,32,37,115,61,62,37,115,0,37,117,32,98,117,99,107,101,116,115,44,32,37,117,32,110,111,110,101,109,112,116,121,32,40,37,117,37,37,41,59,32,37,117,32,101,110,116,114,105,101,115,44,32,97,118,101,114,97,103,101,32,99,104,97,105,110,32,37,46,49,102,46,10,0,102,97,108,108,98,97,99,107,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,107,100,101,102,97,117,108,116,46,99,0,107,112,97,116,104,115,101,97,95,101,120,112,97,110,100,95,100,101,102,97,117,108,116,0,115,116,97,114,116,32,115,101,97,114,99,104,40,102,105,108,101,115,61,91,37,115,0,93,44,32,109,117,115,116,95,101,120,105,115,116,61,37,100,44,32,102,105,110,100,95,97,108,108,61,37,100,44,32,112,97,116,104,61,37,115,41,46,10,0,115,101,97,114,99,104,40,91,37,115,0,93,41,32,61,62,0,84,69,88,77,70,76,79,71,0,37,108,117,32,37,115,10,0,115,116,97,114,116,32,115,101,97,114,99,104,40,102,105,108,101,61,37,115,44,32,109,117,115,116,95,101,120,105,115,116,61,37,100,44,32,102,105,110,100,95,97,108,108,61,37,100,44,32,112,97,116,104,61,37,115,41,46,10,0,115,101,97,114,99,104,40,37,115,41,32,61,62,0,108,115,116,97,116,40,37,115,41,32,102,97,105,108,101,100,32,46,46,46,10,0,91,37,115,93,37,115,37,115,32,45,62,32,91,37,115,93,37,115,37,115,10,0,37,115,37,115,91,37,115,93,37,115,37,115,0,37,115,32,45,62,32,37,115,37,115,91,37,115,93,37,115,37,115,10,0,46,46,0,47,46,46,0,37,115,32,61,61,32,37,115,37,115,37,115,37,115,37,115,10,0,37,115,32,61,61,32,37,115,37,115,37,115,10,0,114,101,116,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,112,114,111,103,110,97,109,101,46,99,0,114,101,109,111,118,101,95,100,111,116,115,0,75,80,65,84,72,83,69,65,95,68,69,66,85,71,0,83,69,76,70,65,85,84,79,76,79,67,0,83,69,76,70,65,85,84,79,68,73,82,0,83,69,76,70,65,85,84,79,80,65,82,69,78,84,0,83,69,76,70,65,85,84,79,71,82,65,78,68,80,65,82,69,78,84,0,101,120,101,0,97,0,115,110,112,114,105,110,116,102,32,40,98,117,102,44,32,50,44,32,34,97,34,41,32,61,61,32,49,32,38,38,32,98,117,102,91,49,93,32,61,61,32,39,92,48,39,0,107,112,97,116,104,115,101,97,95,115,101,116,95,112,114,111,103,114,97,109,95,110,97,109,101,0,40,117,110,115,105,103,110,101,100,41,115,110,112,114,105,110,116,102,32,40,98,117,102,44,32,50,44,32,34,97,98,34,41,32,62,61,32,50,32,38,38,32,98,117,102,91,49,93,32,61,61,32,39,92,48,39,0,97,98,99,0,40,117,110,115,105,103,110,101,100,41,115,110,112,114,105,110,116,102,32,40,98,117,102,44,32,50,44,32,34,97,98,99,34,41,32,62,61,32,50,32,38,38,32,98,117,102,91,49,93,32,61,61,32,39,92,48,39,0,112,114,111,103,110,97,109,101,0,114,101,97,100,97,98,108,101,0,84,69,88,95,72,85,83,72,0,97,108,108,0,110,111,110,101,0,107,112,97,116,104,115,101,97,58,109,97,107,101,95,116,101,120,58,32,73,110,118,97,108,105,100,32,102,111,110,116,110,97,109,101,32,96,37,115,39,44,32,115,116,97,114,116,115,32,119,105,116,104,32,39,37,99,39,10,0,107,112,97,116,104,115,101,97,58,109,97,107,101,95,116,101,120,58,32,73,110,118,97,108,105,100,32,102,111,110,116,110,97,109,101,32,96,37,115,39,44,32,99,111,110,116,97,105,110,115,32,39,37,99,39,10,0,75,80,65,84,72,83,69,65,95,68,80,73,0,77,65,75,69,84,69,88,95,66,65,83,69,95,68,80,73,0,100,112,105,32,33,61,32,48,32,38,38,32,98,100,112,105,32,33,61,32,48,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,116,101,120,45,109,97,107,101,46,99,0,115,101,116,95,109,97,107,101,116,101,120,95,109,97,103,0,37,117,43,37,117,47,37,117,0,37,117,43,37,117,47,40,37,117,42,37,117,43,37,117,41,0,37,117,43,37,117,47,40,37,117,42,37,117,41,0,37,117,43,37,117,47,40,52,48,48,48,43,37,117,41,0,45,0,109,97,103,115,116,101,112,92,40,37,115,37,100,46,37,100,92,41,0,77,65,75,69,84,69,88,95,77,65,71,0,10,107,112,97,116,104,115,101,97,58,32,82,117,110,110,105,110,103,0,47,100,101,118,47,110,117,108,108,0,107,112,97,116,104,115,101,97,58,32,111,112,101,110,40,34,47,100,101,118,47,110,117,108,108,34,44,32,79,95,82,68,79,78,76,89,41,0,107,112,97,116,104,115,101,97,58,32,112,105,112,101,40,41,0,107,112,97,116,104,115,101,97,58,32,111,112,101,110,40,34,47,100,101,118,47,110,117,108,108,34,44,32,79,95,87,82,79,78,76,89,41,0,107,112,97,116,104,115,101,97,58,32,102,111,114,107,40,41,0,107,112,97,116,104,115,101,97,58,32,114,101,97,100,40,41,0,107,112,97,116,104,115,101,97,58,32,37,115,32,111,117,116,112,117,116,32,96,37,115,39,32,105,110,115,116,101,97,100,32,111,102,32,97,32,102,105,108,101,110,97,109,101,0,77,73,83,83,70,79,78,84,95,76,79,71,0,109,105,115,115,102,111,110,116,46,108,111,103,0,97,98,0,84,69,88,77,70,79,85,84,80,85,84,0,107,112,97,116,104,115,101,97,58,32,65,112,112,101,110,100,105,110,103,32,102,111,110,116,32,99,114,101,97,116,105,111,110,32,99,111,109,109,97,110,100,115,32,116,111,32,37,115,46,10,0,110,97,109,101,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,116,105,108,100,101,46,99,0,107,112,97,116,104,115,101,97,95,116,105,108,100,101,95,101,120,112,97,110,100,0,33,33,0,72,79,77,69,0,107,112,115,101,45,62,112,114,111,103,114,97,109,95,110,97,109,101,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,118,97,114,105,97,98,108,101,46,99,0,107,112,97,116,104,115,101,97,95,118,97,114,95,118,97,108,117,101,0,95,0,40,110,105,108,41,0,118,97,114,105,97,98,108,101,58,32,37,115,32,61,32,37,115,10,0,119,97,114,110,105,110,103,58,32,0,107,112,97,116,104,115,101,97,58,32,118,97,114,105,97,98,108,101,32,96,37,115,39,32,114,101,102,101,114,101,110,99,101,115,32,105,116,115,101,108,102,32,40,101,118,101,110,116,117,97,108,108,121,41,0,107,112,97,116,104,115,101,97,58,32,37,115,58,32,78,111,32,109,97,116,99,104,105,110,103,32,125,32,102,111,114,32,36,123,0,107,112,97,116,104,115,101,97,58,32,37,115,58,32,85,110,114,101,99,111,103,110,105,122,101,100,32,118,97,114,105,97,98,108,101,32,99,111,110,115,116,114,117,99,116,32,96,36,37,99,39,0,107,112,97,116,104,115,101,97,32,118,101,114,115,105,111,110,32,54,46,50,46,49,0,102,105,108,101,110,97,109,101,32,38,38,32,109,111,100,101,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,120,102,111,112,101,110,46,99,0,120,102,111,112,101,110,0,102,0,120,102,99,108,111,115,101,0,37,115,58,32,0,103,101,116,99,119,100,0,102,97,116,97,108,58,32,109,101,109,111,114,121,32,101,120,104,97,117,115,116,101,100,32,40,120,109,97,108,108,111,99,32,111,102,32,37,108,117,32,98,121,116,101,115,41,46,10,0,61,0,37,115,58,32,102,97,116,97,108,58,32,0,112,117,116,101,110,118,40,37,115,41,0,46,10,0,102,97,116,97,108,58,32,109,101,109,111,114,121,32,101,120,104,97,117,115,116,101,100,32,40,114,101,97,108,108,111,99,32,111,102,32,37,108,117,32,98,121,116,101,115,41,46,10,0,80,79,83,73,88,76,89,95,67,79,82,82,69,67,84,0,45,45,0,37,115,58,32,111,112,116,105,111,110,32,96,37,115,39,32,105,115,32,97,109,98,105,103,117,111,117,115,10,0,37,115,58,32,111,112,116,105,111,110,32,96,45,45,37,115,39,32,100,111,101,115,110,39,116,32,97,108,108,111,119,32,97,110,32,97,114,103,117,109,101,110,116,10,0,37,115,58,32,111,112,116,105,111,110,32,96,37,99,37,115,39,32,100,111,101,115,110,39,116,32,97,108,108,111,119,32,97,110,32,97,114,103,117,109,101,110,116,10,0,37,115,58,32,111,112,116,105,111,110,32,96,37,115,39,32,114,101,113,117,105,114,101,115,32,97,110,32,97,114,103,117,109,101,110,116,10,0,37,115,58,32,117,110,114,101,99,111,103,110,105,122,101,100,32,111,112,116,105,111,110,32,96,45,45,37,115,39,10,0,37,115,58,32,117,110,114,101,99,111,103,110,105,122,101,100,32,111,112,116,105,111,110,32,96,37,99,37,115,39,10,0,37,115,58,32,105,108,108,101,103,97,108,32,111,112,116,105,111,110,32,45,45,32,37,99,10,0,37,115,58,32,105,110,118,97,108,105,100,32,111,112,116,105,111,110,32,45,45,32,37,99,10,0,37,115,58,32,111,112,116,105,111,110,32,114,101,113,117,105,114,101,115,32,97,110,32,97,114,103,117,109,101,110,116,32,45,45,32,37,99,10,0,37,115,58,32,111,112,116,105,111,110,32,96,45,87,32,37,115,39,32,105,115,32,97,109,98,105,103,117,111,117,115,10,0,37,115,58,32,111,112,116,105,111,110,32,96,45,87,32,37,115,39,32,100,111,101,115,110,39,116,32,97,108,108,111,119,32,97,110,32,97,114,103,117,109,101,110,116,10,0,107,112,115,101,95,110,111,114,109,97,108,105,122,101,95,112,97,116,104,32,40,37,115,41,32,61,62,32,37,117,10,0,73,83,95,68,73,82,95,83,69,80,95,67,72,32,40,101,108,116,91,101,108,116,95,108,101,110,103,116,104,32,45,32,49,93,41,32,124,124,32,73,83,95,68,69,86,73,67,69,95,83,69,80,32,40,101,108,116,91,101,108,116,95,108,101,110,103,116,104,32,45,32,49,93,41,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,101,108,116,45,100,105,114,115,46,99,0,100,111,95,115,117,98,100,105,114,0,47,0,112,97,116,104,32,101,108,101,109,101,110,116,32,37,115,32,61,62,0,32,37,115,0,70,78,95,83,84,82,73,78,71,32,40,42,102,41,32,33,61,32,78,85,76,76,0,46,46,47,46,46,47,46,46,47,116,101,120,107,47,107,112,97,116,104,115,101,97,47,102,110,46,99,0,102,110,95,102,114,101,101,0,70,78,95,76,69,78,71,84,72,32,40,42,102,41,32,62,32,108,111,99,0,102,110,95,115,104,114,105,110,107,95,116,111,0,107,100,101,98,117,103,58,0,100,105,114,95,108,105,110,107,115,40,37,115,41,32,61,62,32,37,108,100,10,0,84,33,34,25,13,1,2,3,17,75,28,12,16,4,11,29,18,30,39,104,110,111,112,113,98,32,5,6,15,19,20,21,26,8,22,7,40,36,23,24,9,10,14,27,31,37,35,131,130,125,38,42,43,60,61,62,63,67,71,74,77,88,89,90,91,92,93,94,95,96,97,99,100,101,102,103,105,106,107,108,114,115,116,121,122,123,124,0,73,108,108,101,103,97,108,32,98,121,116,101,32,115,101,113,117,101,110,99,101,0,68,111,109,97,105,110,32,101,114,114,111,114,0,82,101,115,117,108,116,32,110,111,116,32,114,101,112,114,101,115,101,110,116,97,98,108,101,0,78,111,116,32,97,32,116,116,121,0,80,101,114,109,105,115,115,105,111,110,32,100,101,110,105,101,100,0,79,112,101,114,97,116,105,111,110,32,110,111,116,32,112,101,114,109,105,116,116,101,100,0,78,111,32,115,117,99,104,32,102,105,108,101,32,111,114,32,100,105,114,101,99,116,111,114,121,0,78,111,32,115,117,99,104,32,112,114,111,99,101,115,115,0,70,105,108,101,32,101,120,105,115,116,115,0,86,97,108,117,101,32,116,111,111,32,108,97,114,103,101,32,102,111,114,32,100,97,116,97,32,116,121,112,101,0,78,111,32,115,112,97,99,101,32,108,101,102,116,32,111,110,32,100,101,118,105,99,101,0,79,117,116,32,111,102,32,109,101,109,111,114,121,0,82,101,115,111,117,114,99,101,32,98,117,115,121,0,73,110,116,101,114,114,117,112,116,101,100,32,115,121,115,116,101,109,32,99,97,108,108,0,82,101,115,111,117,114,99,101,32,116,101,109,112,111,114,97,114,105,108,121,32,117,110,97,118,97,105,108,97,98,108,101,0,73,110,118,97,108,105,100,32,115,101,101,107,0,67,114,111,115,115,45,100,101,118,105,99,101,32,108,105,110,107,0,82,101,97,100,45,111,110,108,121,32,102,105,108,101,32,115,121,115,116,101,109,0,68,105,114,101,99,116,111,114,121,32,110,111,116,32,101,109,112,116,121,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,112,101,101,114,0,79,112,101,114,97,116,105,111,110,32,116,105,109,101,100,32,111,117,116,0,67,111,110,110,101,99,116,105,111,110,32,114,101,102,117,115,101,100,0,72,111,115,116,32,105,115,32,100,111,119,110,0,72,111,115,116,32,105,115,32,117,110,114,101,97,99,104,97,98,108,101,0,65,100,100,114,101,115,115,32,105,110,32,117,115,101,0,66,114,111,107,101,110,32,112,105,112,101,0,73,47,79,32,101,114,114,111,114,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,32,111,114,32,97,100,100,114,101,115,115,0,66,108,111,99,107,32,100,101,118,105,99,101,32,114,101,113,117,105,114,101,100,0,78,111,32,115,117,99,104,32,100,101,118,105,99,101,0,78,111,116,32,97,32,100,105,114,101,99,116,111,114,121,0,73,115,32,97,32,100,105,114,101,99,116,111,114,121,0,84,101,120,116,32,102,105,108,101,32,98,117,115,121,0,69,120,101,99,32,102,111,114,109,97,116,32,101,114,114,111,114,0,73,110,118,97,108,105,100,32,97,114,103,117,109,101,110,116,0,65,114,103,117,109,101,110,116,32,108,105,115,116,32,116,111,111,32,108,111,110,103,0,83,121,109,98,111,108,105,99,32,108,105,110,107,32,108,111,111,112,0,70,105,108,101,110,97,109,101,32,116,111,111,32,108,111,110,103,0,84,111,111,32,109,97,110,121,32,111,112,101,110,32,102,105,108,101,115,32,105,110,32,115,121,115,116,101,109,0,78,111,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,115,32,97,118,97,105,108,97,98,108,101,0,66,97,100,32,102,105,108,101,32,100,101,115,99,114,105,112,116,111,114,0,78,111,32,99,104,105,108,100,32,112,114,111,99,101,115,115,0,66,97,100,32,97,100,100,114,101,115,115,0,70,105,108,101,32,116,111,111,32,108,97,114,103,101,0,84,111,111,32,109,97,110,121,32,108,105,110,107,115,0,78,111,32,108,111,99,107,115,32,97,118,97,105,108,97,98,108,101,0,82,101,115,111,117,114,99,101,32,100,101,97,100,108,111,99,107,32,119,111,117,108,100,32,111,99,99,117,114,0,83,116,97,116,101,32,110,111,116,32,114,101,99,111,118,101,114,97,98,108,101,0,80,114,101,118,105,111,117,115,32,111,119,110,101,114,32,100,105,101,100,0,79,112,101,114,97,116,105,111,110,32,99,97,110,99,101,108,101,100,0,70,117,110,99,116,105,111,110,32,110,111,116,32,105,109,112,108,101,109,101,110,116,101,100,0,78,111,32,109,101,115,115,97,103,101,32,111,102,32,100,101,115,105,114,101,100,32,116,121,112,101,0,73,100,101,110,116,105,102,105,101,114,32,114,101,109,111,118,101,100,0,68,101,118,105,99,101,32,110,111,116,32,97,32,115,116,114,101,97,109,0,78,111,32,100,97,116,97,32,97,118,97,105,108,97,98,108,101,0,68,101,118,105,99,101,32,116,105,109,101,111,117,116,0,79,117,116,32,111,102,32,115,116,114,101,97,109,115,32,114,101,115,111,117,114,99,101,115,0,76,105,110,107,32,104,97,115,32,98,101,101,110,32,115,101,118,101,114,101,100,0,80,114,111,116,111,99,111,108,32,101,114,114,111,114,0,66,97,100,32,109,101,115,115,97,103,101,0,70,105,108,101,32,100,101,115,99,114,105,112,116,111,114,32,105,110,32,98,97,100,32,115,116,97,116,101,0,78,111,116,32,97,32,115,111,99,107,101,116,0,68,101,115,116,105,110,97,116,105,111,110,32,97,100,100,114,101,115,115,32,114,101,113,117,105,114,101,100,0,77,101,115,115,97,103,101,32,116,111,111,32,108,97,114,103,101,0,80,114,111,116,111,99,111,108,32,119,114,111,110,103,32,116,121,112,101,32,102,111,114,32,115,111,99,107,101,116,0,80,114,111,116,111,99,111,108,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,80,114,111,116,111,99,111,108,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,83,111,99,107,101,116,32,116,121,112,101,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,78,111,116,32,115,117,112,112,111,114,116,101,100,0,80,114,111,116,111,99,111,108,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,0,65,100,100,114,101,115,115,32,102,97,109,105,108,121,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,98,121,32,112,114,111,116,111,99,111,108,0,65,100,100,114,101,115,115,32,110,111,116,32,97,118,97,105,108,97,98,108,101,0,78,101,116,119,111,114,107,32,105,115,32,100,111,119,110,0,78,101,116,119,111,114,107,32,117,110,114,101,97,99,104,97,98,108,101,0,67,111,110,110,101,99,116,105,111,110,32,114,101,115,101,116,32,98,121,32,110,101,116,119,111,114,107,0,67,111,110,110,101,99,116,105,111,110,32,97,98,111,114,116,101,100,0,78,111,32,98,117,102,102,101,114,32,115,112,97,99,101,32,97,118,97,105,108,97,98,108,101,0,83,111,99,107,101,116,32,105,115,32,99,111,110,110,101,99,116,101,100,0,83,111,99,107,101,116,32,110,111,116,32,99,111,110,110,101,99,116,101,100,0,67,97,110,110,111,116,32,115,101,110,100,32,97,102,116,101,114,32,115,111,99,107,101,116,32,115,104,117,116,100,111,119,110,0,79,112,101,114,97,116,105,111,110,32,97,108,114,101,97,100,121,32,105,110,32,112,114,111,103,114,101,115,115,0,79,112,101,114,97,116,105,111,110,32,105,110,32,112,114,111,103,114,101,115,115,0,83,116,97,108,101,32,102,105,108,101,32,104,97,110,100,108,101,0,82,101,109,111,116,101,32,73,47,79,32,101,114,114,111,114,0,81,117,111,116,97,32,101,120,99,101,101,100,101,100,0,78,111,32,109,101,100,105,117,109,32,102,111,117,110,100,0,87,114,111,110,103,32,109,101,100,105,117,109,32,116,121,112,101,0,78,111,32,101,114,114,111,114,32,105,110,102,111,114,109,97,116,105,111,110,0,0,17,0,10,0,17,17,17,0,0,0,0,5,0,0,0,0,0,0,9,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,15,10,17,17,17,3,10,7,0,1,19,9,11,11,0,0,9,6,11,0,0,11,0,6,17,0,0,0,17,17,17,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,17,0,10,10,17,17,17,0,10,0,0,2,0,9,11,0,0,0,9,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,14,0,0,0,0,0,0,0,0,0,0,0,13,0,0,0,4,13,0,0,0,0,9,14,0,0,0,0,0,14,0,0,14,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,15,0,0,0,0,15,0,0,0,0,9,16,0,0,0,0,0,16,0,0,16,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,0,0,0,18,18,18,0,0,0,0,0,0,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,0,0,0,0,0,0,0,0,0,10,0,0,0,0,10,0,0,0,0,9,11,0,0,0,0,0,11,0,0,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,0,0,0,0,0,0,0,12,0,0,0,0,12,0,0,0,0,9,12,0,0,0,0,0,12,0,0,12,0,0,45,43,32,32,32,48,88,48,120,0,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,40,110,117,108,108,41,0,45,48,88,43,48,88,32,48,88,45,48,120,43,48,120,32,48,120,0,105,110,102,0,73,78,70,0,110,97,110,0,78,65,78,0,46,0,114,119,97,0,80,65,84,72,0,47,117,115,114,47,108,111,99,97,108,47,98,105,110,58,47,98,105,110,58,47,117,115,114,47,98,105,110,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE+10240);





/* no memory initializer */
var tempDoublePtr = STATICTOP; STATICTOP += 16;

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}

// {{PRE_LIBRARY}}


   
  Module["_i64Subtract"] = _i64Subtract;

  function ___assert_fail(condition, filename, line, func) {
      ABORT = true;
      throw 'Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'] + ' at ' + stackTrace();
    }

  
  var PROCINFO={ppid:1,pid:42,sid:42,pgid:42};
  
  
  
  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};
  
  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
  
  function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
      return value;
    }
  
  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function (stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = new Buffer(BUFSIZE);
              var bytesRead = 0;
  
              var fd = process.stdin.fd;
              // Linux and Mac cannot use process.stdin.fd (which isn't set up as sync)
              var usingDevice = false;
              try {
                fd = fs.openSync('/dev/stdin', 'r');
                usingDevice = true;
              } catch (e) {}
  
              bytesRead = fs.readSync(fd, buf, 0, BUFSIZE, null);
  
              if (usingDevice) { fs.closeSync(fd); }
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
  
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['print'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function (tty) {
          if (tty.output && tty.output.length > 0) {
            Module['printErr'](UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.buffer.byteLength which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function (node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function (node) {
        if (!node.contents) return new Uint8Array;
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function (node, newCapacity) {
        // If we are asked to expand the size of a file that already exists, revert to using a standard JS array to store the file
        // instead of a typed array. This makes resizing the array more flexible because we can just .push() elements at the back to
        // increase the size.
        if (node.contents && node.contents.subarray && newCapacity > node.contents.length) {
          node.contents = MEMFS.getFileDataAsRegularArray(node);
          node.usedBytes = node.contents.length; // We might be writing to a lazy-loaded file which had overridden this property, so force-reset it.
        }
  
        if (!node.contents || node.contents.subarray) { // Keep using a typed array if creating a new storage, or if old one was a typed array as well.
          var prevCapacity = node.contents ? node.contents.buffer.byteLength : 0;
          if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
          // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
          // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
          // avoid overshooting the allocation cap by a very large margin.
          var CAPACITY_DOUBLING_MAX = 1024 * 1024;
          newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) | 0);
          if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newCapacity); // Allocate new storage.
          if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
          return;
        }
        // Not using a typed array to back the file storage. Use a standard JS array instead.
        if (!node.contents && newCapacity > 0) node.contents = [];
        while (node.contents.length < newCapacity) node.contents.push(0);
      },resizeFileStorage:function (node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(new ArrayBuffer(newSize)); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) { // Can we just reuse the buffer we are given?
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = new Uint8Array(buffer.subarray(offset, offset + length));
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position+length);
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < stream.node.usedBytes) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function (stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  var IDBFS={dbs:{},indexedDB:function () {
        if (typeof indexedDB !== 'undefined') return indexedDB;
        var ret = null;
        if (typeof window === 'object') ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        assert(ret, 'IDBFS used, but indexedDB not supported');
        return ret;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);
  
          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);
  
            var src = populate ? remote : local;
            var dst = populate ? local : remote;
  
            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:function (name, callback) {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }
  
        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        if (!req) {
          return callback("Unable to connect to IndexedDB");
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;
  
          var fileStore;
  
          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }
  
          if (!fileStore.indexNames.contains('timestamp')) {
            fileStore.createIndex('timestamp', 'timestamp', { unique: false });
          }
        };
        req.onsuccess = function() {
          db = req.result;
  
          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },getLocalSet:function (mount, callback) {
        var entries = {};
  
        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };
  
        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
  
        while (check.length) {
          var path = check.pop();
          var stat;
  
          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }
  
          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }
  
          entries[path] = { timestamp: stat.mtime };
        }
  
        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:function (mount, callback) {
        var entries = {};
  
        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);
  
          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function(e) {
            callback(this.error);
            e.preventDefault();
          };
  
          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          var index = store.index('timestamp');
  
          index.openKeyCursor().onsuccess = function(event) {
            var cursor = event.target.result;
  
            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }
  
            entries[cursor.primaryKey] = { timestamp: cursor.key };
  
            cursor.continue();
          };
        });
      },loadLocalEntry:function (path, callback) {
        var stat, node;
  
        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }
  
        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (FS.isFile(stat.mode)) {
          // Performance consideration: storing a normal JavaScript array to a IndexedDB is much slower than storing a typed array.
          // Therefore always convert the file contents to a typed array first before writing the data to IndexedDB.
          node.contents = MEMFS.getFileDataAsTypedArray(node);
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }
  
          FS.chmod(path, entry.mode);
          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },removeLocalEntry:function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);
  
          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }
  
        callback(null);
      },loadRemoteEntry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },storeRemoteEntry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },removeRemoteEntry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function(e) {
          callback(this.error);
          e.preventDefault();
        };
      },reconcile:function (src, dst, callback) {
        var total = 0;
  
        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });
  
        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });
  
        if (!total) {
          return callback(null);
        }
  
        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };
  
        transaction.onerror = function(e) {
          done(this.error);
          e.preventDefault();
        };
  
        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });
  
        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach(function(path) {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};
  
  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        flags &= ~0100000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~02000000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          if (length === 0) return 0; // node errors on 0 length reads
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
  
          return position;
        }}};
  
  var WORKERFS={DIR_MODE:16895,FILE_MODE:33279,reader:null,mount:function (mount) {
        assert(ENVIRONMENT_IS_WORKER);
        if (!WORKERFS.reader) WORKERFS.reader = new FileReaderSync();
        var root = WORKERFS.createNode(null, '/', WORKERFS.DIR_MODE, 0);
        var createdParents = {};
        function ensureParent(path) {
          // return the parent node, creating subdirs as necessary
          var parts = path.split('/');
          var parent = root;
          for (var i = 0; i < parts.length-1; i++) {
            var curr = parts.slice(0, i+1).join('/');
            // Issue 4254: Using curr as a node name will prevent the node
            // from being found in FS.nameTable when FS.open is called on
            // a path which holds a child of this node,
            // given that all FS functions assume node names
            // are just their corresponding parts within their given path,
            // rather than incremental aggregates which include their parent's
            // directories.
            if (!createdParents[curr]) {
              createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0);
            }
            parent = createdParents[curr];
          }
          return parent;
        }
        function base(path) {
          var parts = path.split('/');
          return parts[parts.length-1];
        }
        // We also accept FileList here, by using Array.prototype
        Array.prototype.forEach.call(mount.opts["files"] || [], function(file) {
          WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate);
        });
        (mount.opts["blobs"] || []).forEach(function(obj) {
          WORKERFS.createNode(ensureParent(obj["name"]), base(obj["name"]), WORKERFS.FILE_MODE, 0, obj["data"]);
        });
        (mount.opts["packages"] || []).forEach(function(pack) {
          pack['metadata'].files.forEach(function(file) {
            var name = file.filename.substr(1); // remove initial slash
            WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack['blob'].slice(file.start, file.end));
          });
        });
        return root;
      },createNode:function (parent, name, mode, dev, contents, mtime) {
        var node = FS.createNode(parent, name, mode);
        node.mode = mode;
        node.node_ops = WORKERFS.node_ops;
        node.stream_ops = WORKERFS.stream_ops;
        node.timestamp = (mtime || new Date).getTime();
        assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE);
        if (mode === WORKERFS.FILE_MODE) {
          node.size = contents.size;
          node.contents = contents;
        } else {
          node.size = 4096;
          node.contents = {};
        }
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },node_ops:{getattr:function (node) {
          return {
            dev: 1,
            ino: undefined,
            mode: node.mode,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: undefined,
            size: node.size,
            atime: new Date(node.timestamp),
            mtime: new Date(node.timestamp),
            ctime: new Date(node.timestamp),
            blksize: 4096,
            blocks: Math.ceil(node.size / 4096),
          };
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
        },lookup:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        },mknod:function (parent, name, mode, dev) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },rename:function (oldNode, newDir, newName) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },unlink:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },rmdir:function (parent, name) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },readdir:function (node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },symlink:function (parent, newName, oldPath) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        },readlink:function (node) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          if (position >= stream.node.size) return 0;
          var chunk = stream.node.contents.slice(position, position + length);
          var ab = WORKERFS.reader.readAsArrayBuffer(chunk);
          buffer.set(new Uint8Array(ab), offset);
          return chunk.size;
        },write:function (stream, buffer, offset, length, position) {
          throw new FS.ErrnoError(ERRNO_CODES.EIO);
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.size;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return position;
        }}};
  
  var _stdin=STATICTOP; STATICTOP += 16;;
  
  var _stdout=STATICTOP; STATICTOP += 16;;
  
  var _stderr=STATICTOP; STATICTOP += 16;;var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };
  
          FS.FSNode.prototype = {};
  
          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;
  
          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); }
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); }
            }
          });
        }
  
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return !!node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        var err = FS.nodePermissions(dir, 'x');
        if (err) return err;
        if (!dir.node_ops.lookup) return ERRNO_CODES.EACCES;
        return 0;
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },getMounts:function (mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          console.log('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(err) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(err);
        }
  
        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        if (!PATH.resolve(oldpath)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var err = FS.mayOpen(node, flags);
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function (stream) {
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function (stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function (stream) {
        return 0;
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto !== 'undefined') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else if (ENVIRONMENT_IS_NODE) {
          // for nodejs
          random_device = function() { return require('crypto').randomBytes(1)[0]; };
        } else {
          // default for ES5 platforms
          random_device = function() { return (Math.random()*256)|0; };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function () {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode('/proc/self', 'fd', 16384 | 0777, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
  
        var stdout = FS.open('/dev/stdout', 'w');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
  
        var stderr = FS.open('/dev/stderr', 'w');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno, node) {
          //Module.printErr(stackTrace()); // useful for debugging
          this.node = node;
          this.setErrno = function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        if (ENVIRONMENT_IS_BROWSIX) {
          Module["noFSInit"] = true;
          return;
        }
  
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
          'IDBFS': IDBFS,
          'NODEFS': NODEFS,
          'WORKERFS': WORKERFS,
        };
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(xhr.response || []);
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            console.log("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  
  
  
  
  var _environ=STATICTOP; STATICTOP += 16;;var ___environ=_environ;function ___buildEnvironment(env) {
      // WARNING: Arbitrary limit!
      var MAX_ENV_VALUES = 64;
      var TOTAL_ENV_SIZE = 1024;
  
      // Statically allocate memory for the environment.
      var poolPtr;
      var envPtr;
      if (!___buildEnvironment.called) {
        ___buildEnvironment.called = true;
        // Set default values. Use string keys for Closure Compiler compatibility.
        // ENV['USER'] = ENV['LOGNAME'] = 'web_user';
        // ENV['PATH'] = '/';
        // ENV['PWD'] = '/';
        // ENV['HOME'] = '/home/web_user';
        // ENV['LANG'] = 'C';
        // ENV['_'] = Module['thisProgram'];
        // Allocate memory.
        poolPtr = allocate(TOTAL_ENV_SIZE, 'i8', ALLOC_NORMAL);
        envPtr = allocate(MAX_ENV_VALUES * 4,
                          'i8*', ALLOC_NORMAL);
        HEAP32[((envPtr)>>2)]=poolPtr;
        HEAP32[((_environ)>>2)]=envPtr;
      } else {
        envPtr = HEAP32[((_environ)>>2)];
        poolPtr = HEAP32[((envPtr)>>2)];
      }
  
      // Collect key=value lines.
      var strings = [];
      var totalSize = 0;
      for (var key in env) {
        if (typeof env[key] === 'string') {
          var line = key + '=' + env[key];
          strings.push(line);
          totalSize += line.length;
        }
      }
      if (totalSize > TOTAL_ENV_SIZE) {
        throw new Error('Environment size exceeded TOTAL_ENV_SIZE!');
      }
  
      // Make new.
      var ptrSize = 4;
      for (var i = 0; i < strings.length; i++) {
        var line = strings[i];
        writeAsciiToMemory(line, poolPtr);
        HEAP32[(((envPtr)+(i * ptrSize))>>2)]=poolPtr;
        poolPtr += line.length + 1;
      }
      HEAP32[(((envPtr)+(strings.length * ptrSize))>>2)]=0;
    }var ENV={};var SYSCALLS={DEFAULT_POLLMASK:5,mappings:{},umask:511,calculateAt:function (dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      },doStat:function (func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -ERRNO_CODES.ENOTDIR;
          }
          throw e;
        }
        HEAP32[((buf)>>2)]=stat.dev;
        HEAP32[(((buf)+(4))>>2)]=0;
        HEAP32[(((buf)+(8))>>2)]=stat.ino;
        HEAP32[(((buf)+(12))>>2)]=stat.mode;
        HEAP32[(((buf)+(16))>>2)]=stat.nlink;
        HEAP32[(((buf)+(20))>>2)]=stat.uid;
        HEAP32[(((buf)+(24))>>2)]=stat.gid;
        HEAP32[(((buf)+(28))>>2)]=stat.rdev;
        HEAP32[(((buf)+(32))>>2)]=0;
        HEAP32[(((buf)+(36))>>2)]=stat.size;
        HEAP32[(((buf)+(40))>>2)]=4096;
        HEAP32[(((buf)+(44))>>2)]=stat.blocks;
        HEAP32[(((buf)+(48))>>2)]=(stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(52))>>2)]=0;
        HEAP32[(((buf)+(56))>>2)]=(stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)]=0;
        HEAP32[(((buf)+(64))>>2)]=(stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)]=0;
        HEAP32[(((buf)+(72))>>2)]=stat.ino;
        return 0;
      },doMsync:function (addr, stream, len, flags) {
        var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len));
        FS.msync(stream, buffer, 0, len, flags);
      },doMkdir:function (path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function (path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -ERRNO_CODES.EINVAL;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function (path, buf, bufsize) {
        if (bufsize <= 0) return -ERRNO_CODES.EINVAL;
        var ret = FS.readlink(path);
        ret = ret.slice(0, Math.max(0, bufsize));
        writeStringToMemory(ret, buf, true);
        return ret.length;
      },doAccess:function (path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -ERRNO_CODES.EINVAL;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -ERRNO_CODES.EACCES;
        }
        return 0;
      },doDup:function (path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function (stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:0,get:function (varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function () {
        var ret = Pointer_stringify(SYSCALLS.get());
        return ret;
      },getStreamFromFD:function () {
        var stream = FS.getStream(SYSCALLS.get());
        if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        return stream;
      },getSocketFromFD:function () {
        var socket = SOCKFS.getSocket(SYSCALLS.get());
        if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        return socket;
      },getSocketAddress:function (allowNull) {
        var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get();
        if (allowNull && addrp === 0) return null;
        var info = __read_sockaddr(addrp, addrlen);
        if (info.errno) throw new FS.ErrnoError(info.errno);
        info.addr = DNS.lookup_addr(info.addr) || info.addr;
        return info;
      },get64:function () {
        var low = SYSCALLS.get(), high = SYSCALLS.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      },getZero:function () {
        assert(SYSCALLS.get() === 0);
      },browsix:{async:true,waitOff:-1,syncMsg:{trap:0,args:[0,0,0,0,0,0]},SyscallResponseFrom:function (ev) {
          var requiredOnData = ['id', 'name', 'args'];
          if (!ev.data)
            return;
          for (var i = 0; i < requiredOnData.length; i++) {
            if (!ev.data.hasOwnProperty(requiredOnData[i]))
              return;
          }
          var args = ev.data.args; //.map(convertApiErrors);
          return {id: ev.data.id, name: ev.data.name, args: args};
        },syscall:{msgIdSeq:1,outstanding:{},signalHandlers:{init:[function init1(data) {
          // 0: args
          // 1: environ
          // 2: debug flag
          // 3: pid (if fork)
          // 4: heap (if fork)
          // 5: fork args (if fork)
  
          var args = data.args[0];
          var environ = data.args[1];
          // args[4] is a copy of the heap - replace anything we just
          // alloc'd with it.
          if (data.args[4]) {
            var pid = data.args[3];
            var heap = data.args[4];
            var forkArgs = data.args[5];
  
            Runtime.process.parentBuffer = heap;
            Runtime.process.pid = pid;
            Runtime.process.forkArgs = forkArgs;
  
            updateGlobalBuffer(Runtime.process.parentBuffer);
            updateGlobalBufferViews();
  
            assert(HEAP32.buffer === Runtime.process.parentBuffer);
  
            if (typeof asmModule !== 'undefined')
              asm = asmModule(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
            else
              asm = asm(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
            initReceiving();
            initRuntimeFuncs();
  
            asm.stackRestore(forkArgs.stackSave);
            asm.emtStackRestore(forkArgs.emtStackTop);
          }
  
          args = [args[0]].concat(args);
  
          Runtime.process.argv = args;
          Runtime.process.env = environ;
  
          if (typeof SharedArrayBuffer !== 'function') {
            var done = function() {
              SYSCALLS.browsix.syscall.exit(-1);
            };
            var msg = 'ERROR: requires SharedArrayBuffer support, exiting\n';
            var buf = new Uint8Array(msg.length);
            for (var i = 0; i < msg.length; i++)
              buf[i] = msg.charCodeAt(i);
  
            SYSCALLS.browsix.syscall.syscallAsync(done, 'pwrite', [2, buf, -1]);
            console.log('Embrowsix: shared array buffers required');
            return;
          }
  
          if (typeof gc === 'function') gc();
  
          init2();
          function init2(attempt) {
            if (!attempt)
              attempt = 0;
  
            if (typeof gc === 'function') gc();
  
            var oldHEAP8 = HEAP8;
            var b = null;
            try {
              b = new SharedArrayBuffer(REAL_TOTAL_MEMORY);
            } catch (e) {
              if (attempt >= 16)
                throw e;
  
              console.log('couldnt allocate SharedArrayBuffer(' + REAL_TOTAL_MEMORY + '), retrying');
  
              var delay = 200*attempt;
              if (delay > 2000)
                delay = 2000;
  
              if (typeof gc === 'function') gc();
              setTimeout(init2, delay, attempt+1);
              if (typeof gc === 'function') gc();
  
              return;
            }
            TOTAL_MEMORY = REAL_TOTAL_MEMORY;
            REAL_TOTAL_MEMORY = undefined;
  
            // copy whatever was in the old guy to here
            new Int8Array(b).set(oldHEAP8);
            updateGlobalBuffer(b);
            updateGlobalBufferViews();
            if (typeof asmModule !== 'undefined')
              asm = asmModule(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
            else
              asm = asm(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
            initReceiving();
            initRuntimeFuncs();
  
            var PER_BLOCKING = 0x80;
            // it seems malloc overflows into our static allocation, so
            // just reserve that, throw it away, and never use it.  The
            // first number is in bytes, no matter what the 'i*' specifier
            // is :\
            getMemory(1024);
            var waitOff = getMemory(1024) + 512;
            getMemory(1024);
            SYSCALLS.browsix.waitOff = waitOff;
  
            // the original spec called for buffer to be in the transfer
            // list, but the current spec (and dev versions of Chrome)
            // don't support that.  Try it the old way, and if it
            // doesn't work try it the new way.
            try {
              SYSCALLS.browsix.syscall.syscallAsync(personalityChanged, 'personality',
                                                    [PER_BLOCKING, buffer, waitOff], [buffer]);
            } catch (e) {
              SYSCALLS.browsix.syscall.syscallAsync(personalityChanged, 'personality',
                                                    [PER_BLOCKING, buffer, waitOff], []);
            }
            function personalityChanged(err) {
              if (err) {
                console.log('personality: ' + err);
                return;
              }
              SYSCALLS.browsix.async = false;
              if (Runtime.process && Runtime.process.env && Runtime.process.env['BROWSIX_PERF']) {
                var binary = Runtime.process.env['BROWSIX_PERF'];
                console.log('PERF: start ' + binary);
                var stopXhr = new XMLHttpRequest();
                stopXhr.open('GET', 'http://localhost:9000/start?binary=' + binary, false);
                stopXhr.send();
              }
              Runtime.process.emit('ready');
            }
          }
        }]},syscallAsync:function (cb, name, args, transferrables) {
            var msgId = this.nextMsgId();
            this.outstanding[msgId] = cb;
            self.postMessage({
              id: msgId,
              name: name,
              args: args,
            }, transferrables);
          },sync:function (trap, a1, a2, a3, a4, a5, a6) {
            var waitOff = SYSCALLS.browsix.waitOff;
            var syncMsg = SYSCALLS.browsix.syncMsg;
            syncMsg.trap = trap|0;
            syncMsg.args[0] = a1|0;
            syncMsg.args[1] = a2|0;
            syncMsg.args[2] = a3|0;
            syncMsg.args[3] = a4|0;
            syncMsg.args[4] = a5|0;
            syncMsg.args[5] = a6|0;
  
            Atomics.store(HEAP32, waitOff >> 2, 0);
            self.postMessage(syncMsg);
            var paranoid = Atomics.load(HEAP32, waitOff >> 2)|0;
            if (paranoid !== 1 && paranoid !== 0) {
              Module.printErr('WARN: someone wrote over our futex alloc(' + waitOff + '): ' + paranoid);
              debugger;
            }
            Atomics.wait(HEAP32, waitOff >> 2, 0);
            Atomics.store(HEAP32, waitOff >> 2, 0);
            return Atomics.load(HEAP32, (waitOff >> 2) + 1);
          },usleep:function (useconds) {
            // int usleep(useconds_t useconds);
            // http://pubs.opengroup.org/onlinepubs/000095399/functions/usleep.html
            var msec = useconds / 1000;
            var target = performance.now() + msec;
            var waitOff = SYSCALLS.browsix.waitOff;
  
            var paranoid = Atomics.load(HEAP32, (waitOff >> 2)+8);
            if (paranoid !== 0) {
              Module.printErr('WARN: someone wrote over our futex alloc(' + waitOff + '): ' + paranoid);
            }
  
            Atomics.store(HEAP32, (waitOff >> 2)+8, 0);
  
            var msecsToSleep;
            while (performance.now() < target) {
              msecsToSleep = target - performance.now();
              if (msecsToSleep > 0) {
                Atomics.wait(HEAP32, (waitOff >> 2)+8, 0, msecsToSleep);
              }
            }
            return 0;
          },exit:function (code) {
            if (Runtime.process && Runtime.process.env && Runtime.process.env['BROWSIX_PERF']) {
              var binary = Runtime.process.env['BROWSIX_PERF'];
              console.log('PERF: stop ' + binary);
              var stopXhr = new XMLHttpRequest();
              stopXhr.open('GET', 'http://localhost:9000/stop?binary=' + binary, false);
              stopXhr.send();
            }
            // FIXME: this will only work in sync mode.
            Module['_fflush'](0);
            if (SYSCALLS.browsix.async) {
              this.syscallAsync(null, 'exit', [code]);
            } else {
              this.sync(252 /* SYS_exit_group */, code);
            }
            close();
          },addEventListener:function (type, handler) {
            if (!handler)
              return;
            if (this.signalHandlers[type])
              this.signalHandlers[type].push(handler);
            else
              this.signalHandlers[type] = [handler];
          },resultHandler:function (ev) {
            var response = SYSCALLS.browsix.SyscallResponseFrom(ev);
            if (!response) {
              console.log('bad usyscall message, dropping');
              console.log(ev);
              return;
            }
            if (response.name) {
              var handlers = this.signalHandlers[response.name];
              if (handlers) {
                for (var i = 0; i < handlers.length; i++)
                  handlers[i](response);
              }
              else {
                console.log('unhandled signal ' + response.name);
              }
              return;
            }
            this.complete(response.id, response.args);
          },complete:function (id, args) {
            var cb = this.outstanding[id];
            delete this.outstanding[id];
            if (cb) {
              cb.apply(undefined, args);
            }
            else {
              console.log('unknown callback for msg ' + id + ' - ' + args);
            }
          },nextMsgId:function () {
            return ++this.msgIdSeq;
          }}}};function ___syscall20(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // getpid
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_GETPID = 20;
        return SYSCALLS.browsix.syscall.sync(SYS_GETPID);
      }
      return PROCINFO.pid;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

   
  Module["_memset"] = _memset;

  function ___wait() {
  Module['printErr']('missing function: __wait'); abort(-1);
  }

   
  Module["_bitshift64Shl"] = _bitshift64Shl;

  function _abort() {
      Module['abort']();
    }

  function ___syscall195(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // SYS_stat64
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_STAT = 195;
        var path = SYSCALLS.get(), buf = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_STAT, path, buf);
      }
      var path = SYSCALLS.getStr(), buf = SYSCALLS.get();
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall196(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // SYS_lstat64
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_LSTAT = 196;
        var path = SYSCALLS.get(), buf = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_LSTAT, path, buf);
      }
      var path = SYSCALLS.getStr(), buf = SYSCALLS.get();
      return SYSCALLS.doStat(FS.lstat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___lock() {}

  function ___unlock() {}

   
  Module["_i64Add"] = _i64Add;

  function _putenv(string) {
      // int putenv(char *string);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/putenv.html
      // WARNING: According to the standard (and the glibc implementation), the
      //          string is taken by reference so future changes are reflected.
      //          We copy it instead, possibly breaking some uses.
      if (string === 0) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      }
      string = Pointer_stringify(string);
      var splitPoint = string.indexOf('=')
      if (string === '' || string.indexOf('=') === -1) {
        ___setErrNo(ERRNO_CODES.EINVAL);
        return -1;
      }
      var name = string.slice(0, splitPoint);
      var value = string.slice(splitPoint + 1);
      if (!(name in ENV) || ENV[name] !== value) {
        ENV[name] = value;
        ___buildEnvironment(ENV);
      }
      return 0;
    }

  
  
  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      Module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }function __Exit(status) {
      __exit(status);
    }

  function ___syscall114(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // wait4
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_WAIT4 = 114;
        var pid = SYSCALLS.get(), wstatus = SYSCALLS.get(), options = SYSCALLS.get(), rusage = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_WAIT4, pid, wstatus, options, rusage);
      }
      abort('cannot wait on child processes');
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function _realloc() { throw 'bad' }
  Module["_realloc"] = _realloc; 
  Module["_saveSetjmp"] = _saveSetjmp;


  function ___syscall175(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // rt_sigprocmask
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_SIGPROCMASK = 174;
        var how = SYSCALLS.get(), set = SYSCALLS.get(), oldset = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_SIGPROCMASK, how, set, oldset);
      }
      //console.log('TODO: sigprocmask');
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // close
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_CLOSE = 6;
        var fd = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_CLOSE, fd);
      }
      var stream = SYSCALLS.getStreamFromFD();
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // ioctl
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_IOCTL = 54;
        var fd = SYSCALLS.get(), op = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_IOCTL, fd, op);
      }
      var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get();
      switch (op) {
        case 21505: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          return 0;
        }
        case 21506: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)]=0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -ERRNO_CODES.ENOTTY;
          return -ERRNO_CODES.EINVAL; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

   
  Module["_bitshift64Lshr"] = _bitshift64Lshr;

  
   
  Module["_testSetjmp"] = _testSetjmp;function _longjmp(env, value) {
      asm['setThrew'](env, value || 1);
      throw 'longjmp';
    }

  function ___syscall220(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // SYS_getdents64
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_GETDENTS64 = 220;
        var fd = SYSCALLS.get(), dirp = SYSCALLS.get(), count = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_GETDENTS64, fd, dirp, count);
      }
      var stream = SYSCALLS.getStreamFromFD(), dirp = SYSCALLS.get(), count = SYSCALLS.get();
      if (!stream.getdents) {
        stream.getdents = FS.readdir(stream.path);
      }
      var pos = 0;
      while (stream.getdents.length > 0 && pos + 268 < count) {
        var id;
        var type;
        var name = stream.getdents.pop();
        assert(name.length < 256); // limit of dirent struct
        if (name[0] === '.') {
          id = 1;
          type = 4; // DT_DIR
        } else {
          var child = FS.lookupNode(stream.node, name);
          id = child.id;
          type = FS.isChrdev(child.mode) ? 2 :  // DT_CHR, character device.
                 FS.isDir(child.mode) ? 4 :     // DT_DIR, directory.
                 FS.isLink(child.mode) ? 10 :   // DT_LNK, symbolic link.
                 8;                             // DT_REG, regular file.
        }
        HEAP32[((dirp + pos)>>2)]=id;
        HEAP32[(((dirp + pos)+(4))>>2)]=stream.position;
        HEAP16[(((dirp + pos)+(8))>>1)]=268;
        HEAP8[(((dirp + pos)+(10))>>0)]=type;
        for (var i = 0; i < name.length; i++) {
          HEAP8[(((dirp + pos)+(11 + i))>>0)]=name.charCodeAt(i);
        }
        HEAP8[(((dirp + pos)+(11 + i))>>0)]=0;
        pos += 268;
      }
      return pos;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function _pthread_cleanup_push(routine, arg) {
      __ATEXIT__.push(function() { Runtime.dynCall('vi', routine, [arg]) })
      _pthread_cleanup_push.level = __ATEXIT__.length;
    }

  function ___syscall11(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // execve
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_EXECVE = 11;
        var filename = SYSCALLS.get(), argv = SYSCALLS.get(), envp = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_EXECVE, filename, argv, envp);
      }
      abort('execve not supported without Browsix');
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function _getenv(name) {
      // char *getenv(const char *name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/getenv.html
      if (name === 0) return 0;
      name = Pointer_stringify(name);
      if (!ENV.hasOwnProperty(name)) return 0;
  
      if (_getenv.ret) _free(_getenv.ret);
      _getenv.ret = allocate(intArrayFromString(ENV[name]), 'i8', ALLOC_NORMAL);
      return _getenv.ret;
    }

  function _pthread_cleanup_pop() {
      assert(_pthread_cleanup_push.level == __ATEXIT__.length, 'cannot pop if something else added meanwhile!');
      __ATEXIT__.pop();
      _pthread_cleanup_push.level = __ATEXIT__.length;
    }

  function ___syscall183(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // getcwd
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_GETCWD = 183;
        var buf = SYSCALLS.get(), size = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_GETCWD, buf, size);
      }
      var buf = SYSCALLS.get(), size = SYSCALLS.get();
      if (size === 0) return -ERRNO_CODES.EINVAL;
      var cwd = FS.cwd();
      if (size < cwd.length + 1) return -ERRNO_CODES.ERANGE;
      writeAsciiToMemory(cwd, buf);
      return buf;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function _getpwnam() {
      ___setErrNo(ERRNO_CODES.ENOENT);
      return 0;
    }

  function ___syscall3(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // read
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_READ = 3;
        var fd = SYSCALLS.get(), buf = SYSCALLS.get(), count = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_READ, fd, buf, count);
      }
      var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get();
      return FS.read(stream, HEAP8,buf, count);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall2(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // fork
      if (ENVIRONMENT_IS_BROWSIX) {
        abort('fork not supported in sync Browsix');
      }
      abort('fork not supported without Browsix');
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall5(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // open
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_OPEN = 5;
        var path = SYSCALLS.get(), flags = SYSCALLS.get(), mode = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_OPEN, path, flags, mode);
      }
      var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get() // optional TODO
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    } 
  Module["_memcpy"] = _memcpy;

  function _llvm_stackrestore(p) {
      var self = _llvm_stacksave;
      var ret = self.LLVM_SAVEDSTACKS[p];
      self.LLVM_SAVEDSTACKS.splice(p, 1);
      Runtime.stackRestore(ret);
    }

  
  
  var cttz_i8 = allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0], "i8", ALLOC_STATIC); 
  Module["_llvm_cttz_i32"] = _llvm_cttz_i32; 
  Module["___udivmoddi4"] = ___udivmoddi4; 
  Module["___udivdi3"] = ___udivdi3;

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) {
        var success = self.alloc(bytes);
        if (!success) return -1 >>> 0; // sbrk failure code
      }
      return ret;  // Previous break location.
    }

  function _llvm_stacksave() {
      var self = _llvm_stacksave;
      if (!self.LLVM_SAVEDSTACKS) {
        self.LLVM_SAVEDSTACKS = [];
      }
      self.LLVM_SAVEDSTACKS.push(Runtime.stackSave());
      return self.LLVM_SAVEDSTACKS.length-1;
    }

  function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // writev
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_WRITE = 4;
        var fd = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          if (len === 0)
            continue;
          var written = SYSCALLS.browsix.syscall.sync(SYS_WRITE, fd, ptr, len);
          if (written < 0)
            return ret === 0 ? written : ret;
          ret += written;
        }
        return ret;
      }
      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
      return SYSCALLS.doWritev(stream, iov, iovcnt);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

   
  Module["_memmove"] = _memmove;

   
  Module["___uremdi3"] = ___uremdi3;

  function ___syscall85(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // readlink
      if (ENVIRONMENT_IS_BROWSIX) {
        console.log('TODO: readlink');
        abort('unsupported syscall readlink');
        return 0;
      }
      var path = SYSCALLS.getStr(), buf = SYSCALLS.get(), bufsize = SYSCALLS.get();
      return SYSCALLS.doReadlink(path, buf, bufsize);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function _time(ptr) {
      var ret = (Date.now()/1000)|0;
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

   
  Module["_pthread_self"] = _pthread_self;

  function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // llseek
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_LLSEEK = 140;
        var fd = SYSCALLS.get(), offhi = SYSCALLS.get(), offlo = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_LLSEEK, fd, offhi, offlo, result, whence);
      }
      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
      var offset = offset_low;
      assert(offset_high === 0);
      FS.llseek(stream, offset, whence);
      HEAP32[((result)>>2)]=stream.position;
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall145(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // readv
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_READ = 3;
        var fd = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          if (len === 0)
            continue;
          var read = SYSCALLS.browsix.syscall.sync(SYS_READ, fd, ptr, len);
          if (read < 0)
            return ret === 0 ? read : ret;
          ret += read;
        }
        return ret;
      }
      var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
      return SYSCALLS.doReadv(stream, iov, iovcnt);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall42(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // pipe
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_PIPE2 = 41;
        var pipefd = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_PIPE2, pipefd, 0);
      }
      return -ERRNO_CODES.ENOSYS; // unsupported features
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall221(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // fcntl64
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_FCNTL64 = 221;
        var fd = SYSCALLS.get(), cmd = SYSCALLS.get();
        var arg = 0;
  
        // only some of the commands have multiple arguments.
        switch (cmd) {
        case 0:
        case 4:
        case 12:
        case 12:
          arg = SYSCALLS.get();
        }
  
        return SYSCALLS.browsix.syscall.sync(SYS_FCNTL64, fd, cmd, arg);
      }
      var stream = SYSCALLS.getStreamFromFD(), cmd = SYSCALLS.get();
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -ERRNO_CODES.EINVAL;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        case 12: {
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)]=2;
          return 0;
        }
        case 13:
        case 14:
        case 13:
        case 14:
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -ERRNO_CODES.EINVAL; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          ___setErrNo(ERRNO_CODES.EINVAL);
          return -1;
        default: {
          return -ERRNO_CODES.EINVAL;
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall41(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // dup
      if (ENVIRONMENT_IS_BROWSIX) {
        var SYS_DUP = 41;
        var fd1 = SYSCALLS.get();
        return SYSCALLS.browsix.syscall.sync(SYS_DUP, fd1);
      }
      var old = SYSCALLS.getStreamFromFD();
      return FS.open(old.path, old.flags, 0).fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

FS.staticInit();__ATINIT__.unshift(function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() });__ATMAIN__.push(function() { FS.ignorePermissions = false });__ATEXIT__.push(function() { FS.quit() });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;Module["FS_unlink"] = FS.unlink;;
__ATINIT__.unshift(function() { TTY.init() });__ATEXIT__.push(function() { TTY.shutdown() });;
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); var NODEJS_PATH = require("path"); NODEFS.staticInit(); };
if (!ENVIRONMENT_IS_BROWSIX) ___buildEnvironment(ENV);;
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + TOTAL_STACK;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);



function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vi(index,a1) {
  try {
    Module["dynCall_vi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_ii(index,a1) {
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  try {
    return Module["dynCall_iiiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

Module.asmGlobalArg = { "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array, "NaN": NaN, "Infinity": Infinity };

Module.asmLibraryArg = { "abort": abort, "assert": assert, "invoke_iiii": invoke_iiii, "invoke_vi": invoke_vi, "invoke_vii": invoke_vii, "invoke_ii": invoke_ii, "invoke_v": invoke_v, "invoke_iiiii": invoke_iiiii, "invoke_iii": invoke_iii, "_pthread_cleanup_pop": _pthread_cleanup_pop, "___syscall220": ___syscall220, "_putenv": _putenv, "___syscall85": ___syscall85, "_abort": _abort, "___syscall41": ___syscall41, "___syscall42": ___syscall42, "_pthread_cleanup_push": _pthread_cleanup_push, "___syscall20": ___syscall20, "_llvm_stackrestore": _llvm_stackrestore, "___assert_fail": ___assert_fail, "___buildEnvironment": ___buildEnvironment, "_longjmp": _longjmp, "___wait": ___wait, "__Exit": __Exit, "___setErrNo": ___setErrNo, "_sbrk": _sbrk, "___syscall196": ___syscall196, "_emscripten_memcpy_big": _emscripten_memcpy_big, "___syscall175": ___syscall175, "___syscall195": ___syscall195, "___syscall221": ___syscall221, "_llvm_stacksave": _llvm_stacksave, "___syscall114": ___syscall114, "_getenv": _getenv, "___syscall54": ___syscall54, "___unlock": ___unlock, "___syscall11": ___syscall11, "_getpwnam": _getpwnam, "___syscall3": ___syscall3, "___syscall2": ___syscall2, "___lock": ___lock, "___syscall6": ___syscall6, "___syscall5": ___syscall5, "___syscall183": ___syscall183, "_time": _time, "___syscall140": ___syscall140, "_exit": _exit, "___syscall145": ___syscall145, "___syscall146": ___syscall146, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "cttz_i8": cttz_i8, "___environ": ___environ };
// EMSCRIPTEN_START_ASM
var asm = undefined;
var asmModule = (function(global, env, buffer) {
  'use asm';
  
  
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);


  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var cttz_i8=env.cttz_i8|0;
  var ___environ=env.___environ|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = global.NaN, inf = global.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;
  var tempRet0 = 0;

  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_clz32=global.Math.clz32;
  var abort=env.abort;
  var assert=env.assert;
  var invoke_iiii=env.invoke_iiii;
  var invoke_vi=env.invoke_vi;
  var invoke_vii=env.invoke_vii;
  var invoke_ii=env.invoke_ii;
  var invoke_v=env.invoke_v;
  var invoke_iiiii=env.invoke_iiiii;
  var invoke_iii=env.invoke_iii;
  var _pthread_cleanup_pop=env._pthread_cleanup_pop;
  var ___syscall220=env.___syscall220;
  var _putenv=env._putenv;
  var ___syscall85=env.___syscall85;
  var _abort=env._abort;
  var ___syscall41=env.___syscall41;
  var ___syscall42=env.___syscall42;
  var _pthread_cleanup_push=env._pthread_cleanup_push;
  var ___syscall20=env.___syscall20;
  var _llvm_stackrestore=env._llvm_stackrestore;
  var ___assert_fail=env.___assert_fail;
  var ___buildEnvironment=env.___buildEnvironment;
  var _longjmp=env._longjmp;
  var ___wait=env.___wait;
  var __Exit=env.__Exit;
  var ___setErrNo=env.___setErrNo;
  var _sbrk=env._sbrk;
  var ___syscall196=env.___syscall196;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var ___syscall175=env.___syscall175;
  var ___syscall195=env.___syscall195;
  var ___syscall221=env.___syscall221;
  var _llvm_stacksave=env._llvm_stacksave;
  var ___syscall114=env.___syscall114;
  var _getenv=env._getenv;
  var ___syscall54=env.___syscall54;
  var ___unlock=env.___unlock;
  var ___syscall11=env.___syscall11;
  var _getpwnam=env._getpwnam;
  var ___syscall3=env.___syscall3;
  var ___syscall2=env.___syscall2;
  var ___lock=env.___lock;
  var ___syscall6=env.___syscall6;
  var ___syscall5=env.___syscall5;
  var ___syscall183=env.___syscall183;
  var _time=env._time;
  var ___syscall140=env.___syscall140;
  var _exit=env._exit;
  var ___syscall145=env.___syscall145;
  var ___syscall146=env.___syscall146;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS

function _mainbody() {
 var $$jprime$0$i = 0, $$lcssa$i$i$reg2mem$0 = 0, $$lcssa$i$reg2mem$0 = 0, $$reg2mem451$0 = 0, $$reg2mem453$0 = 0, $$reg2mem455$0 = 0, $$reg2mem457$0 = 0, $$reg2mem459$0 = 0, $$reg2mem467$0 = 0, $$reg2mem485$0 = 0, $$reg2mem495$0 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $127 = 0, $128 = 0, $129 = 0, $130 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $16 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $186 = 0, $187 = 0, $191 = 0, $192 = 0, $196 = 0, $198 = 0, $2 = 0, $201 = 0, $202 = 0, $203 = 0, $205 = 0, $208 = 0, $211 = 0, $213 = 0, $215 = 0, $216 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $228 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $260 = 0, $262 = 0, $263 = 0, $264 = 0, $266 = 0, $267 = 0, $268 = 0, $271 = 0, $273 = 0, $274 = 0, $275 = 0, $277 = 0, $278 = 0, $279 = 0, $281 = 0, $282 = 0, $283 = 0, $285 = 0, $286 = 0, $287 = 0, $29 = 0, $292 = 0, $293 = 0, $294 = 0, $296 = 0, $297 = 0, $298 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $32 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $330 = 0, $331 = 0, $332 = 0, $334 = 0, $336 = 0, $341 = 0, $342 = 0, $344 = 0, $346 = 0, $351 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $36 = 0, $362 = 0, $363 = 0, $364 = 0, $366 = 0, $367 = 0, $368 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $39 = 0, $390 = 0, $392 = 0, $393 = 0, $394 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $401 = 0, $402 = 0, $403 = 0, $405 = 0, $406 = 0, $407 = 0, $409 = 0, $410 = 0, $411 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $42 = 0, $421 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $466 = 0, $467 = 0, $468 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $496 = 0, $497 = 0, $498 = 0, $50 = 0, $51 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $9 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $99 = 0, $j$08$i$reg2mem489$0 = 0, $j$1$i$reg2mem483$0 = 0, $j$2$i$reg2mem477$0 = 0, $jprime$04$i$reg2mem471$0 = 0, $k$07$i$reg2mem487$0 = 0, $n$03$i$reg2mem469$0 = 0, $o$09$i$reg2mem491$0 = 0, $o$1$i$reg2mem481$0 = 0, $o$2$i$reg2mem475$0 = 0, $square$010$i$reg2mem493$0 = 0, $square$1$i$reg2mem479$0 = 0, $square$2$i$reg2mem473$0 = 0, $vararg_buffer = 0, $vararg_buffer497 = 0, $vararg_buffer500 = 0, $vararg_buffer503 = 0, $vararg_buffer511 = 0, $vararg_buffer516 = 0, $vararg_buffer521 = 0, $vararg_buffer524 = 0, $vararg_buffer527 = 0, $vararg_buffer532 = 0, $vararg_buffer537 = 0, $vararg_buffer540 = 0, $vararg_buffer543 = 0, $vararg_buffer548 = 0, $vararg_buffer553 = 0, $vararg_buffer556 = 0, $vararg_buffer559 = 0, $vararg_buffer562 = 0, $vararg_buffer565 = 0, $vararg_buffer568 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $vararg_buffer568 = sp + 216 | 0;
 $vararg_buffer565 = sp + 208 | 0;
 $vararg_buffer562 = sp + 200 | 0;
 $vararg_buffer559 = sp + 192 | 0;
 $vararg_buffer556 = sp + 184 | 0;
 $vararg_buffer553 = sp + 176 | 0;
 $vararg_buffer548 = sp + 160 | 0;
 $vararg_buffer543 = sp + 144 | 0;
 $vararg_buffer540 = sp + 136 | 0;
 $vararg_buffer537 = sp + 128 | 0;
 $vararg_buffer532 = sp + 112 | 0;
 $vararg_buffer527 = sp + 96 | 0;
 $vararg_buffer524 = sp + 88 | 0;
 $vararg_buffer521 = sp + 80 | 0;
 $vararg_buffer516 = sp + 64 | 0;
 $vararg_buffer511 = sp + 48 | 0;
 $vararg_buffer503 = sp + 24 | 0;
 $vararg_buffer500 = sp + 16 | 0;
 $vararg_buffer497 = sp + 8 | 0;
 $vararg_buffer = sp;
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 HEAP32[4697] = HEAP32[50];
 HEAP32[3990] = HEAP32[79];
 HEAP32[4043] = 65e3;
 HEAP32[3992] = 2e4;
 HEAP32[4667] = 20;
 HEAP32[4694] = 10;
 HEAP32[4148] = 5e3;
 HEAP32[4098] = 750;
 HEAP32[4314] = 3e3;
 HEAP32[4363] = 50;
 __THREW__ = 0;
 invoke_v(1);
 $2 = __THREW__;
 __THREW__ = 0;
 if (($2 | 0) != 0 & (threwValue | 0) != 0) {
  $3 = _testSetjmp(HEAP32[$2 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (!$3) _longjmp($2 | 0, threwValue | 0);
  tempRet0 = threwValue;
 } else $3 = -1;
 $4 = tempRet0;
 L1 : do switch ($3 | 0) {
 case 1:
  {
   $$reg2mem457$0 = $4;
   label = 79;
   break;
  }
 case 2:
  {
   $$reg2mem459$0 = $4;
   label = 44;
   break;
  }
 default:
  {
   __THREW__ = 0;
   $8 = invoke_ii(2, (HEAP32[4667] << 2) + 4 | 0) | 0;
   $9 = __THREW__;
   __THREW__ = 0;
   if (($9 | 0) != 0 & (threwValue | 0) != 0) {
    $10 = _testSetjmp(HEAP32[$9 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$10) _longjmp($9 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $10 = -1;
   $11 = tempRet0;
   switch ($10 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $11;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $11;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4316] = $8;
   __THREW__ = 0;
   $15 = invoke_ii(2, (HEAP32[4667] << 2) + 4 | 0) | 0;
   $16 = __THREW__;
   __THREW__ = 0;
   if (($16 | 0) != 0 & (threwValue | 0) != 0) {
    $17 = _testSetjmp(HEAP32[$16 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$17) _longjmp($16 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $17 = -1;
   $18 = tempRet0;
   switch ($17 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $18;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $18;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4094] = $15;
   HEAP32[4369] = 0;
   HEAP32[4258] = 0;
   __THREW__ = 0;
   $22 = invoke_ii(2, (HEAP32[4314] << 2) + 4 | 0) | 0;
   $23 = __THREW__;
   __THREW__ = 0;
   if (($23 | 0) != 0 & (threwValue | 0) != 0) {
    $24 = _testSetjmp(HEAP32[$23 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$24) _longjmp($23 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $24 = -1;
   $25 = tempRet0;
   switch ($24 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $25;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $25;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4315] = $22;
   __THREW__ = 0;
   $29 = invoke_ii(2, (HEAP32[4148] << 2) + 4 | 0) | 0;
   $30 = __THREW__;
   __THREW__ = 0;
   if (($30 | 0) != 0 & (threwValue | 0) != 0) {
    $31 = _testSetjmp(HEAP32[$30 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$31) _longjmp($30 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $31 = -1;
   $32 = tempRet0;
   switch ($31 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $32;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $32;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4149] = $29;
   __THREW__ = 0;
   $36 = invoke_ii(2, (HEAP32[4667] << 2) + 4 | 0) | 0;
   $37 = __THREW__;
   __THREW__ = 0;
   if (($37 | 0) != 0 & (threwValue | 0) != 0) {
    $38 = _testSetjmp(HEAP32[$37 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$38) _longjmp($37 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $38 = -1;
   $39 = tempRet0;
   switch ($38 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $39;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $39;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4325] = $36;
   __THREW__ = 0;
   $42 = invoke_ii(2, (HEAP32[4043] | 0) + 1 | 0) | 0;
   $43 = __THREW__;
   __THREW__ = 0;
   if (($43 | 0) != 0 & (threwValue | 0) != 0) {
    $44 = _testSetjmp(HEAP32[$43 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$44) _longjmp($43 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $44 = -1;
   $45 = tempRet0;
   switch ($44 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $45;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $45;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4042] = $42;
   __THREW__ = 0;
   $48 = invoke_ii(2, (HEAP32[3992] | 0) + 1 | 0) | 0;
   $49 = __THREW__;
   __THREW__ = 0;
   if (($49 | 0) != 0 & (threwValue | 0) != 0) {
    $50 = _testSetjmp(HEAP32[$49 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$50) _longjmp($49 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $50 = -1;
   $51 = tempRet0;
   switch ($50 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $51;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $51;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[3993] = $48;
   __THREW__ = 0;
   $54 = invoke_ii(2, (HEAP32[3992] | 0) + 1 | 0) | 0;
   $55 = __THREW__;
   __THREW__ = 0;
   if (($55 | 0) != 0 & (threwValue | 0) != 0) {
    $56 = _testSetjmp(HEAP32[$55 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$56) _longjmp($55 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $56 = -1;
   $57 = tempRet0;
   switch ($56 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $57;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $57;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[3994] = $54;
   __THREW__ = 0;
   $60 = invoke_ii(2, (HEAP32[3992] | 0) + 1 | 0) | 0;
   $61 = __THREW__;
   __THREW__ = 0;
   if (($61 | 0) != 0 & (threwValue | 0) != 0) {
    $62 = _testSetjmp(HEAP32[$61 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$62) _longjmp($61 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $62 = -1;
   $63 = tempRet0;
   switch ($62 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $63;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $63;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[3995] = $60;
   __THREW__ = 0;
   $66 = invoke_ii(2, (HEAP32[3992] | 0) + 1 | 0) | 0;
   $67 = __THREW__;
   __THREW__ = 0;
   if (($67 | 0) != 0 & (threwValue | 0) != 0) {
    $68 = _testSetjmp(HEAP32[$67 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$68) _longjmp($67 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $68 = -1;
   $69 = tempRet0;
   switch ($68 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $69;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $69;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[3996] = $66;
   __THREW__ = 0;
   $73 = invoke_ii(2, (HEAP32[3992] << 2) + 4 | 0) | 0;
   $74 = __THREW__;
   __THREW__ = 0;
   if (($74 | 0) != 0 & (threwValue | 0) != 0) {
    $75 = _testSetjmp(HEAP32[$74 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$75) _longjmp($74 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $75 = -1;
   $76 = tempRet0;
   switch ($75 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $76;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $76;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[3997] = $73;
   __THREW__ = 0;
   $79 = invoke_ii(2, (HEAP32[3992] | 0) + 1 | 0) | 0;
   $80 = __THREW__;
   __THREW__ = 0;
   if (($80 | 0) != 0 & (threwValue | 0) != 0) {
    $81 = _testSetjmp(HEAP32[$80 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$81) _longjmp($80 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $81 = -1;
   $82 = tempRet0;
   switch ($81 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $82;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $82;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[3998] = $79;
   __THREW__ = 0;
   $85 = invoke_ii(2, HEAP32[4694] << 2 | 0) | 0;
   $86 = __THREW__;
   __THREW__ = 0;
   if (($86 | 0) != 0 & (threwValue | 0) != 0) {
    $87 = _testSetjmp(HEAP32[$86 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$87) _longjmp($86 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $87 = -1;
   $88 = tempRet0;
   switch ($87 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $88;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $88;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4373] = $85;
   $92 = Math_imul((HEAP32[4307] | 0) + 1 | 0, HEAP32[4694] | 0) | 0;
   __THREW__ = 0;
   $93 = invoke_ii(2, $92 | 0) | 0;
   $94 = __THREW__;
   __THREW__ = 0;
   if (($94 | 0) != 0 & (threwValue | 0) != 0) {
    $95 = _testSetjmp(HEAP32[$94 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$95) _longjmp($94 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $95 = -1;
   $96 = tempRet0;
   switch ($95 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $96;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $96;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4375] = $93;
   __THREW__ = 0;
   $99 = invoke_ii(2, HEAP32[4694] << 2 | 0) | 0;
   $100 = __THREW__;
   __THREW__ = 0;
   if (($100 | 0) != 0 & (threwValue | 0) != 0) {
    $101 = _testSetjmp(HEAP32[$100 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$101) _longjmp($100 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $101 = -1;
   $102 = tempRet0;
   switch ($101 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $102;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $102;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4376] = $99;
   __THREW__ = 0;
   $106 = invoke_ii(2, (HEAP32[4098] << 2) + 4 | 0) | 0;
   $107 = __THREW__;
   __THREW__ = 0;
   if (($107 | 0) != 0 & (threwValue | 0) != 0) {
    $108 = _testSetjmp(HEAP32[$107 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$108) _longjmp($107 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $108 = -1;
   $109 = tempRet0;
   switch ($108 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $109;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $109;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4099] = $106;
   __THREW__ = 0;
   $113 = invoke_ii(2, (HEAP32[4098] << 2) + 4 | 0) | 0;
   $114 = __THREW__;
   __THREW__ = 0;
   if (($114 | 0) != 0 & (threwValue | 0) != 0) {
    $115 = _testSetjmp(HEAP32[$114 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$115) _longjmp($114 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $115 = -1;
   $116 = tempRet0;
   switch ($115 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $116;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $116;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4100] = $113;
   __THREW__ = 0;
   $120 = invoke_ii(2, (HEAP32[4098] << 2) + 4 | 0) | 0;
   $121 = __THREW__;
   __THREW__ = 0;
   if (($121 | 0) != 0 & (threwValue | 0) != 0) {
    $122 = _testSetjmp(HEAP32[$121 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$122) _longjmp($121 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $122 = -1;
   $123 = tempRet0;
   switch ($122 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $123;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $123;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4101] = $120;
   __THREW__ = 0;
   $127 = invoke_ii(2, (HEAP32[4098] << 2) + 4 | 0) | 0;
   $128 = __THREW__;
   __THREW__ = 0;
   if (($128 | 0) != 0 & (threwValue | 0) != 0) {
    $129 = _testSetjmp(HEAP32[$128 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$129) _longjmp($128 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $129 = -1;
   $130 = tempRet0;
   switch ($129 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $130;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $130;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4102] = $127;
   __THREW__ = 0;
   $134 = invoke_ii(2, (HEAP32[4001] << 2) + 4 | 0) | 0;
   $135 = __THREW__;
   __THREW__ = 0;
   if (($135 | 0) != 0 & (threwValue | 0) != 0) {
    $136 = _testSetjmp(HEAP32[$135 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$136) _longjmp($135 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $136 = -1;
   $137 = tempRet0;
   switch ($136 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $137;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $137;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4041] = $134;
   __THREW__ = 0;
   $141 = invoke_ii(2, (HEAP32[4695] << 2) + 4 | 0) | 0;
   $142 = __THREW__;
   __THREW__ = 0;
   if (($142 | 0) != 0 & (threwValue | 0) != 0) {
    $143 = _testSetjmp(HEAP32[$142 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$143) _longjmp($142 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $143 = -1;
   $144 = tempRet0;
   switch ($143 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $144;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $144;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4243] = $141;
   __THREW__ = 0;
   $148 = invoke_ii(2, (HEAP32[4695] << 2) + 4 | 0) | 0;
   $149 = __THREW__;
   __THREW__ = 0;
   if (($149 | 0) != 0 & (threwValue | 0) != 0) {
    $150 = _testSetjmp(HEAP32[$149 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$150) _longjmp($149 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $150 = -1;
   $151 = tempRet0;
   switch ($150 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $151;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $151;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4145] = $148;
   __THREW__ = 0;
   $154 = invoke_ii(2, (HEAP32[4695] | 0) + 1 | 0) | 0;
   $155 = __THREW__;
   __THREW__ = 0;
   if (($155 | 0) != 0 & (threwValue | 0) != 0) {
    $156 = _testSetjmp(HEAP32[$155 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$156) _longjmp($155 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $156 = -1;
   $157 = tempRet0;
   switch ($156 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $157;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $157;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4242] = $154;
   __THREW__ = 0;
   $161 = invoke_ii(2, (HEAP32[4695] << 2) + 4 | 0) | 0;
   $162 = __THREW__;
   __THREW__ = 0;
   if (($162 | 0) != 0 & (threwValue | 0) != 0) {
    $163 = _testSetjmp(HEAP32[$162 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$163) _longjmp($162 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $163 = -1;
   $164 = tempRet0;
   switch ($163 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $164;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $164;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4249] = $161;
   __THREW__ = 0;
   $167 = invoke_ii(2, (HEAP32[4695] | 0) + 1 | 0) | 0;
   $168 = __THREW__;
   __THREW__ = 0;
   if (($168 | 0) != 0 & (threwValue | 0) != 0) {
    $169 = _testSetjmp(HEAP32[$168 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$169) _longjmp($168 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $169 = -1;
   $170 = tempRet0;
   switch ($169 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $170;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $170;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4144] = $167;
   __THREW__ = 0;
   $174 = invoke_ii(2, (HEAP32[4363] << 2) + 4 | 0) | 0;
   $175 = __THREW__;
   __THREW__ = 0;
   if (($175 | 0) != 0 & (threwValue | 0) != 0) {
    $176 = _testSetjmp(HEAP32[$175 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$176) _longjmp($175 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $176 = -1;
   $177 = tempRet0;
   switch ($176 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $177;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $177;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4361] = $174;
   __THREW__ = 0;
   $180 = invoke_ii(2, (HEAP32[4363] | 0) + 1 | 0) | 0;
   $181 = __THREW__;
   __THREW__ = 0;
   if (($181 | 0) != 0 & (threwValue | 0) != 0) {
    $182 = _testSetjmp(HEAP32[$181 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$182) _longjmp($181 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $182 = -1;
   $183 = tempRet0;
   switch ($182 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $183;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $183;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP32[4362] = $180;
   $186 = ((HEAP32[4245] | 0) / 20 | 0) * 17 | 0;
   HEAP32[4240] = 2;
   $187 = HEAP32[4243] | 0;
   HEAP32[$187 + 4 >> 2] = 2;
   if ((HEAP32[4240] | 0) < ($186 | 0)) {
    $$reg2mem495$0 = $187;
    $j$08$i$reg2mem489$0 = 1;
    $k$07$i$reg2mem487$0 = 1;
    $o$09$i$reg2mem491$0 = 2;
    $square$010$i$reg2mem493$0 = 9;
    while (1) {
     $191 = HEAP32[4145] | 0;
     $$reg2mem485$0 = $$reg2mem495$0;
     $j$1$i$reg2mem483$0 = $j$08$i$reg2mem489$0;
     $o$1$i$reg2mem481$0 = $o$09$i$reg2mem491$0;
     $square$1$i$reg2mem479$0 = $square$010$i$reg2mem493$0;
     while (1) {
      $192 = $j$1$i$reg2mem483$0 + 2 | 0;
      if (($192 | 0) == ($square$1$i$reg2mem479$0 | 0)) {
       HEAP32[$191 + ($o$1$i$reg2mem481$0 << 2) >> 2] = $square$1$i$reg2mem479$0;
       $196 = $o$1$i$reg2mem481$0 + 1 | 0;
       $198 = HEAP32[$$reg2mem485$0 + ($196 << 2) >> 2] | 0;
       $j$2$i$reg2mem477$0 = $j$1$i$reg2mem483$0 + 4 | 0;
       $o$2$i$reg2mem475$0 = $196;
       $square$2$i$reg2mem473$0 = Math_imul($198, $198) | 0;
      } else {
       $j$2$i$reg2mem477$0 = $192;
       $o$2$i$reg2mem475$0 = $o$1$i$reg2mem481$0;
       $square$2$i$reg2mem473$0 = $square$1$i$reg2mem479$0;
      }
      if (($o$2$i$reg2mem475$0 | 0) <= 2) break;
      $201 = HEAP32[4243] | 0;
      $jprime$04$i$reg2mem471$0 = 1;
      $n$03$i$reg2mem469$0 = 2;
      while (1) {
       $202 = $191 + ($n$03$i$reg2mem469$0 << 2) | 0;
       $203 = HEAP32[$202 >> 2] | 0;
       if (($203 | 0) < ($j$2$i$reg2mem477$0 | 0)) {
        $205 = $201 + ($n$03$i$reg2mem469$0 << 2) | 0;
        $$reg2mem467$0 = $203;
        while (1) {
         $208 = (HEAP32[$205 >> 2] << 1) + $$reg2mem467$0 | 0;
         HEAP32[$202 >> 2] = $208;
         if (($208 | 0) < ($j$2$i$reg2mem477$0 | 0)) $$reg2mem467$0 = $208; else {
          $$lcssa$i$reg2mem$0 = $208;
          break;
         }
        }
       } else $$lcssa$i$reg2mem$0 = $203;
       $$jprime$0$i = ($$lcssa$i$reg2mem$0 | 0) == ($j$2$i$reg2mem477$0 | 0) ? 0 : $jprime$04$i$reg2mem471$0;
       $211 = $n$03$i$reg2mem469$0 + 1 | 0;
       $213 = ($$jprime$0$i | 0) != 0;
       if (($211 | 0) < ($o$2$i$reg2mem475$0 | 0) & $213) {
        $jprime$04$i$reg2mem471$0 = $$jprime$0$i;
        $n$03$i$reg2mem469$0 = $211;
       } else break;
      }
      if ($213) break; else {
       $$reg2mem485$0 = $201;
       $j$1$i$reg2mem483$0 = $j$2$i$reg2mem477$0;
       $o$1$i$reg2mem481$0 = $o$2$i$reg2mem475$0;
       $square$1$i$reg2mem479$0 = $square$2$i$reg2mem473$0;
      }
     }
     $215 = $k$07$i$reg2mem487$0 + 1 | 0;
     HEAP32[4240] = $j$2$i$reg2mem477$0;
     $216 = HEAP32[4243] | 0;
     HEAP32[$216 + ($215 << 2) >> 2] = $j$2$i$reg2mem477$0;
     if ((HEAP32[4240] | 0) < ($186 | 0)) {
      $$reg2mem495$0 = $216;
      $j$08$i$reg2mem489$0 = $j$2$i$reg2mem477$0;
      $k$07$i$reg2mem487$0 = $215;
      $o$09$i$reg2mem491$0 = $o$2$i$reg2mem475$0;
      $square$010$i$reg2mem493$0 = $square$2$i$reg2mem473$0;
     } else break;
    }
   }
   __THREW__ = 0;
   invoke_v(2);
   $220 = __THREW__;
   __THREW__ = 0;
   if (($220 | 0) != 0 & (threwValue | 0) != 0) {
    $221 = _testSetjmp(HEAP32[$220 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$221) _longjmp($220 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $221 = -1;
   $222 = tempRet0;
   switch ($221 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $222;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $222;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   _setjmpTable = _saveSetjmp(16008, 2, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   _setjmpTableSize = tempRet0;
   __THREW__ = 0;
   $223 = __THREW__;
   __THREW__ = 0;
   if (($223 | 0) != 0 & (threwValue | 0) != 0) {
    $224 = _testSetjmp(HEAP32[$223 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$224) _longjmp($223 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $224 = -1;
   $225 = tempRet0;
   switch ($224 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $225;
     label = 79;
     break L1;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $225;
     label = 44;
     break L1;
     break;
    }
   default:
    {}
   }
   $$reg2mem459$0 = 0;
   label = 44;
  }
 } while (0);
 L51 : while (1) {
  if ((label | 0) == 44) {
   label = 0;
   if (($$reg2mem459$0 | 0) != 1) {
    $228 = (HEAP32[4669] | 0) == 0;
    __THREW__ = 0;
    invoke_iiiii(1, 5749, 29, 1, HEAP32[3989] | 0) | 0;
    $230 = __THREW__;
    __THREW__ = 0;
    if (($230 | 0) != 0 & (threwValue | 0) != 0) {
     $231 = _testSetjmp(HEAP32[$230 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$231) _longjmp($230 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $231 = -1;
    $232 = tempRet0;
    switch ($231 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $232;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $232;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    if ($228) {
     $247 = HEAP32[3989] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer500 >> 2] = HEAP32[10];
     invoke_iiii(6, $247 | 0, 960, $vararg_buffer500 | 0) | 0;
     $249 = __THREW__;
     __THREW__ = 0;
     if (($249 | 0) != 0 & (threwValue | 0) != 0) {
      $250 = _testSetjmp(HEAP32[$249 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$250) _longjmp($249 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $250 = -1;
     $251 = tempRet0;
     switch ($250 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $251;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $251;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
    } else {
     __THREW__ = 0;
     invoke_iiiii(1, 5749, 29, 1, HEAP32[3990] | 0) | 0;
     $234 = __THREW__;
     __THREW__ = 0;
     if (($234 | 0) != 0 & (threwValue | 0) != 0) {
      $235 = _testSetjmp(HEAP32[$234 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$235) _longjmp($234 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $235 = -1;
     $236 = tempRet0;
     switch ($235 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $236;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $236;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $237 = HEAP32[3989] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer >> 2] = HEAP32[10];
     invoke_iiii(6, $237 | 0, 960, $vararg_buffer | 0) | 0;
     $239 = __THREW__;
     __THREW__ = 0;
     if (($239 | 0) != 0 & (threwValue | 0) != 0) {
      $240 = _testSetjmp(HEAP32[$239 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$240) _longjmp($239 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $240 = -1;
     $241 = tempRet0;
     switch ($240 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $241;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $241;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $242 = HEAP32[3990] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer497 >> 2] = HEAP32[10];
     invoke_iiii(6, $242 | 0, 960, $vararg_buffer497 | 0) | 0;
     $244 = __THREW__;
     __THREW__ = 0;
     if (($244 | 0) != 0 & (threwValue | 0) != 0) {
      $245 = _testSetjmp(HEAP32[$244 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$245) _longjmp($244 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $245 = -1;
     $246 = tempRet0;
     switch ($245 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $246;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $246;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
    }
    $252 = HEAP32[3989] | 0;
    $253 = HEAP32[4001] | 0;
    $254 = HEAP32[4245] | 0;
    $255 = HEAP32[4240] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer503 >> 2] = 5851;
    HEAP32[$vararg_buffer503 + 4 >> 2] = $253;
    HEAP32[$vararg_buffer503 + 8 >> 2] = 5874;
    HEAP32[$vararg_buffer503 + 12 >> 2] = $254;
    HEAP32[$vararg_buffer503 + 16 >> 2] = 5887;
    HEAP32[$vararg_buffer503 + 20 >> 2] = $255;
    invoke_iiii(6, $252 | 0, 5834, $vararg_buffer503 | 0) | 0;
    $256 = __THREW__;
    __THREW__ = 0;
    if (($256 | 0) != 0 & (threwValue | 0) != 0) {
     $257 = _testSetjmp(HEAP32[$256 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$257) _longjmp($256 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $257 = -1;
    $258 = tempRet0;
    switch ($257 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $258;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $258;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    $260 = (HEAP32[4669] | 0) == 0;
    __THREW__ = 0;
    invoke_iiiii(1, 5901, 30, 1, HEAP32[3989] | 0) | 0;
    $262 = __THREW__;
    __THREW__ = 0;
    if (($262 | 0) != 0 & (threwValue | 0) != 0) {
     $263 = _testSetjmp(HEAP32[$262 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$263) _longjmp($262 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $263 = -1;
    $264 = tempRet0;
    switch ($263 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $264;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $264;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    if ($260) {
     __THREW__ = 0;
     invoke_vii(1, HEAP32[3989] | 0, HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0);
     $292 = __THREW__;
     __THREW__ = 0;
     if (($292 | 0) != 0 & (threwValue | 0) != 0) {
      $293 = _testSetjmp(HEAP32[$292 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$293) _longjmp($292 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $293 = -1;
     $294 = tempRet0;
     switch ($293 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $294;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $294;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     __THREW__ = 0;
     invoke_iii(1, 10, HEAP32[3989] | 0) | 0;
     $296 = __THREW__;
     __THREW__ = 0;
     if (($296 | 0) != 0 & (threwValue | 0) != 0) {
      $297 = _testSetjmp(HEAP32[$296 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$297) _longjmp($296 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $297 = -1;
     $298 = tempRet0;
     switch ($297 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $298;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $298;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
    } else {
     __THREW__ = 0;
     invoke_iiiii(1, 5901, 30, 1, HEAP32[3990] | 0) | 0;
     $266 = __THREW__;
     __THREW__ = 0;
     if (($266 | 0) != 0 & (threwValue | 0) != 0) {
      $267 = _testSetjmp(HEAP32[$266 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$267) _longjmp($266 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $267 = -1;
     $268 = tempRet0;
     switch ($267 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $268;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $268;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $271 = HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0;
     __THREW__ = 0;
     invoke_vii(1, HEAP32[3990] | 0, $271 | 0);
     $273 = __THREW__;
     __THREW__ = 0;
     if (($273 | 0) != 0 & (threwValue | 0) != 0) {
      $274 = _testSetjmp(HEAP32[$273 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$274) _longjmp($273 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $274 = -1;
     $275 = tempRet0;
     switch ($274 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $275;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $275;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     __THREW__ = 0;
     invoke_vii(1, HEAP32[3989] | 0, $271 | 0);
     $277 = __THREW__;
     __THREW__ = 0;
     if (($277 | 0) != 0 & (threwValue | 0) != 0) {
      $278 = _testSetjmp(HEAP32[$277 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$278) _longjmp($277 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $278 = -1;
     $279 = tempRet0;
     switch ($278 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $279;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $279;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     __THREW__ = 0;
     invoke_iii(1, 10, HEAP32[3989] | 0) | 0;
     $281 = __THREW__;
     __THREW__ = 0;
     if (($281 | 0) != 0 & (threwValue | 0) != 0) {
      $282 = _testSetjmp(HEAP32[$281 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$282) _longjmp($281 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $282 = -1;
     $283 = tempRet0;
     switch ($282 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $283;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $283;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     __THREW__ = 0;
     invoke_iii(1, 10, HEAP32[3990] | 0) | 0;
     $285 = __THREW__;
     __THREW__ = 0;
     if (($285 | 0) != 0 & (threwValue | 0) != 0) {
      $286 = _testSetjmp(HEAP32[$285 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$286) _longjmp($285 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $286 = -1;
     $287 = tempRet0;
     switch ($286 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $287;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $287;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
    }
    L94 : do if (!(HEAP32[3988] | 0)) {
     while (1) {
      $300 = HEAP32[4050] | 0;
      $301 = 16288 + ($300 << 2) | 0;
      HEAP32[$301 >> 2] = (HEAP32[$301 >> 2] | 0) + 1;
      __THREW__ = 0;
      $306 = invoke_ii(3, HEAP32[18576 + ($300 << 2) >> 2] | 0) | 0;
      $307 = __THREW__;
      __THREW__ = 0;
      if (($307 | 0) != 0 & (threwValue | 0) != 0) {
       $308 = _testSetjmp(HEAP32[$307 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
       if (!$308) _longjmp($307 | 0, threwValue | 0);
       tempRet0 = threwValue;
      } else $308 = -1;
      $309 = tempRet0;
      switch ($308 | 0) {
      case 1:
       {
        $$reg2mem457$0 = $309;
        label = 79;
        continue L51;
        break;
       }
      case 2:
       {
        $$reg2mem459$0 = $309;
        label = 44;
        continue L51;
        break;
       }
      default:
       {}
      }
      if (!$306) {
       __THREW__ = 0;
       invoke_vi(1, HEAP32[18576 + (HEAP32[4050] << 2) >> 2] | 0);
       $314 = __THREW__;
       __THREW__ = 0;
       if (($314 | 0) != 0 & (threwValue | 0) != 0) {
        $315 = _testSetjmp(HEAP32[$314 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (!$315) _longjmp($314 | 0, threwValue | 0);
        tempRet0 = threwValue;
       } else $315 = -1;
       $316 = tempRet0;
       switch ($315 | 0) {
       case 1:
        {
         $$reg2mem457$0 = $316;
         label = 79;
         continue L51;
         break;
        }
       case 2:
        {
         $$reg2mem459$0 = $316;
         label = 44;
         continue L51;
         break;
        }
       default:
        {}
       }
       $317 = HEAP32[4050] | 0;
       if (!$317) break;
       HEAP32[4050] = $317 + -1;
      } else {
       __THREW__ = 0;
       invoke_v(3);
       $321 = __THREW__;
       __THREW__ = 0;
       if (($321 | 0) != 0 & (threwValue | 0) != 0) {
        $322 = _testSetjmp(HEAP32[$321 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (!$322) _longjmp($321 | 0, threwValue | 0);
        tempRet0 = threwValue;
       } else $322 = -1;
       $323 = tempRet0;
       switch ($322 | 0) {
       case 1:
        {
         $$reg2mem457$0 = $323;
         label = 79;
         continue L51;
         break;
        }
       case 2:
        {
         $$reg2mem459$0 = $323;
         label = 44;
         continue L51;
         break;
        }
       default:
        {}
       }
      }
      if (HEAP32[3988] | 0) break L94;
     }
     HEAP32[3988] = 1;
    } while (0);
    __THREW__ = 0;
    invoke_v(4);
    $324 = __THREW__;
    __THREW__ = 0;
    if (($324 | 0) != 0 & (threwValue | 0) != 0) {
     $325 = _testSetjmp(HEAP32[$324 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$325) _longjmp($324 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $325 = -1;
    $326 = tempRet0;
    switch ($325 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $326;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $326;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    if (!(HEAP32[4096] | 0)) label = 91; else {
     HEAP32[4103] = 0;
     HEAP32[4156] = 1;
     HEAP32[4045] = HEAP32[3999];
     _setjmpTable = _saveSetjmp(16420, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     _setjmpTableSize = tempRet0;
     __THREW__ = 0;
     $330 = __THREW__;
     __THREW__ = 0;
     if (($330 | 0) != 0 & (threwValue | 0) != 0) {
      $331 = _testSetjmp(HEAP32[$330 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$331) _longjmp($330 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $331 = -1;
     $332 = tempRet0;
     switch ($331 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $332;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $332;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $$reg2mem457$0 = 0;
     label = 79;
     continue;
    }
   }
  } else if ((label | 0) == 79) {
   label = 0;
   L54 : do if (!$$reg2mem457$0) while (1) {
    $$reg2mem455$0 = HEAP32[4045] | 0;
    while (1) {
     $334 = HEAP32[3993] | 0;
     $336 = HEAP8[$334 + $$reg2mem455$0 >> 0] | 0;
     $341 = HEAP32[3999] | 0;
     $342 = ($$reg2mem455$0 | 0) < ($341 | 0);
     if ((HEAP8[25877 + ($336 & 255) >> 0] | 0) == 1 & $342) {
      $$reg2mem453$0 = $$reg2mem455$0;
      while (1) {
       $344 = $$reg2mem453$0 + 1 | 0;
       HEAP32[4045] = $344;
       $346 = HEAP8[$334 + $344 >> 0] | 0;
       $351 = ($344 | 0) < ($341 | 0);
       if ($351 & (HEAP8[25877 + ($346 & 255) >> 0] | 0) == 1) $$reg2mem453$0 = $344; else {
        $$lcssa$i$i$reg2mem$0 = $351;
        $$reg2mem451$0 = $346;
        break;
       }
      }
     } else {
      $$lcssa$i$i$reg2mem$0 = $342;
      $$reg2mem451$0 = $336;
     }
     if (!($$reg2mem451$0 << 24 >> 24 == 37 | $$lcssa$i$i$reg2mem$0 ^ 1)) break;
     __THREW__ = 0;
     $355 = invoke_ii(3, HEAP32[4104] | 0) | 0;
     $356 = __THREW__;
     __THREW__ = 0;
     if (($356 | 0) != 0 & (threwValue | 0) != 0) {
      $357 = _testSetjmp(HEAP32[$356 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$357) _longjmp($356 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $357 = -1;
     $358 = tempRet0;
     switch ($357 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $358;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $358;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     if (!$355) break L54;
     HEAP32[4103] = (HEAP32[4103] | 0) + 1;
     HEAP32[4045] = 0;
     $$reg2mem455$0 = 0;
    }
    __THREW__ = 0;
    invoke_v(5);
    $362 = __THREW__;
    __THREW__ = 0;
    if (($362 | 0) != 0 & (threwValue | 0) != 0) {
     $363 = _testSetjmp(HEAP32[$362 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$363) _longjmp($362 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $363 = -1;
    $364 = tempRet0;
    switch ($363 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $364;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $364;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
   } while (0);
   __THREW__ = 0;
   invoke_vi(1, HEAP32[4104] | 0);
   $366 = __THREW__;
   __THREW__ = 0;
   if (($366 | 0) != 0 & (threwValue | 0) != 0) {
    $367 = _testSetjmp(HEAP32[$366 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$367) _longjmp($366 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $367 = -1;
   $368 = tempRet0;
   switch ($367 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $368;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $368;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   label = 91;
  }
  if ((label | 0) == 91) {
   label = 0;
   __THREW__ = 0;
   invoke_vi(1, HEAP32[4155] | 0);
   $370 = __THREW__;
   __THREW__ = 0;
   if (($370 | 0) != 0 & (threwValue | 0) != 0) {
    $371 = _testSetjmp(HEAP32[$370 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$371) _longjmp($370 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $371 = -1;
   $372 = tempRet0;
   switch ($371 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $372;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $372;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
  }
  if (!((HEAP32[4684] | 0) == 0 | (HEAP32[4685] | 0) != 0)) {
   $377 = HEAP32[3989] | 0;
   $378 = HEAP32[4146] | 0;
   __THREW__ = 0;
   HEAP32[$vararg_buffer511 >> 2] = 5932;
   HEAP32[$vararg_buffer511 + 4 >> 2] = $378;
   HEAP32[$vararg_buffer511 + 8 >> 2] = 1297;
   invoke_iiii(6, $377 | 0, 1280, $vararg_buffer511 | 0) | 0;
   $379 = __THREW__;
   __THREW__ = 0;
   if (($379 | 0) != 0 & (threwValue | 0) != 0) {
    $380 = _testSetjmp(HEAP32[$379 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$380) _longjmp($379 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $380 = -1;
   $381 = tempRet0;
   switch ($380 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $381;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $381;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   $382 = HEAP32[3990] | 0;
   $383 = HEAP32[4146] | 0;
   __THREW__ = 0;
   HEAP32[$vararg_buffer516 >> 2] = 5932;
   HEAP32[$vararg_buffer516 + 4 >> 2] = $383;
   HEAP32[$vararg_buffer516 + 8 >> 2] = 1297;
   invoke_iiii(6, $382 | 0, 1280, $vararg_buffer516 | 0) | 0;
   $384 = __THREW__;
   __THREW__ = 0;
   if (($384 | 0) != 0 & (threwValue | 0) != 0) {
    $385 = _testSetjmp(HEAP32[$384 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$385) _longjmp($384 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $385 = -1;
   $386 = tempRet0;
   switch ($385 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $386;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $386;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   $390 = HEAP32[(HEAP32[4094] | 0) + (HEAP32[4093] << 2) >> 2] | 0;
   __THREW__ = 0;
   invoke_vii(1, HEAP32[3990] | 0, $390 | 0);
   $392 = __THREW__;
   __THREW__ = 0;
   if (($392 | 0) != 0 & (threwValue | 0) != 0) {
    $393 = _testSetjmp(HEAP32[$392 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$393) _longjmp($392 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $393 = -1;
   $394 = tempRet0;
   switch ($393 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $394;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $394;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   __THREW__ = 0;
   invoke_vii(1, HEAP32[3989] | 0, $390 | 0);
   $396 = __THREW__;
   __THREW__ = 0;
   if (($396 | 0) != 0 & (threwValue | 0) != 0) {
    $397 = _testSetjmp(HEAP32[$396 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$397) _longjmp($396 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $397 = -1;
   $398 = tempRet0;
   switch ($397 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $398;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $398;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   $399 = HEAP32[4095] | 0;
   __THREW__ = 0;
   invoke_vii(1, HEAP32[3990] | 0, $399 | 0);
   $401 = __THREW__;
   __THREW__ = 0;
   if (($401 | 0) != 0 & (threwValue | 0) != 0) {
    $402 = _testSetjmp(HEAP32[$401 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$402) _longjmp($401 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $402 = -1;
   $403 = tempRet0;
   switch ($402 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $403;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $403;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   __THREW__ = 0;
   invoke_vii(1, HEAP32[3989] | 0, $399 | 0);
   $405 = __THREW__;
   __THREW__ = 0;
   if (($405 | 0) != 0 & (threwValue | 0) != 0) {
    $406 = _testSetjmp(HEAP32[$405 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$406) _longjmp($405 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $406 = -1;
   $407 = tempRet0;
   switch ($406 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $407;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $407;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   __THREW__ = 0;
   invoke_iii(1, 10, HEAP32[3989] | 0) | 0;
   $409 = __THREW__;
   __THREW__ = 0;
   if (($409 | 0) != 0 & (threwValue | 0) != 0) {
    $410 = _testSetjmp(HEAP32[$409 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$410) _longjmp($409 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $410 = -1;
   $411 = tempRet0;
   switch ($410 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $411;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $411;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
   __THREW__ = 0;
   invoke_iii(1, 10, HEAP32[3990] | 0) | 0;
   $413 = __THREW__;
   __THREW__ = 0;
   if (($413 | 0) != 0 & (threwValue | 0) != 0) {
    $414 = _testSetjmp(HEAP32[$413 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (!$414) _longjmp($413 | 0, threwValue | 0);
    tempRet0 = threwValue;
   } else $414 = -1;
   $415 = tempRet0;
   switch ($414 | 0) {
   case 1:
    {
     $$reg2mem457$0 = $415;
     label = 79;
     continue L51;
     break;
    }
   case 2:
    {
     $$reg2mem459$0 = $415;
     label = 44;
     continue L51;
     break;
    }
   default:
    {}
   }
  }
  __THREW__ = 0;
  invoke_v(6);
  $416 = __THREW__;
  __THREW__ = 0;
  if (($416 | 0) != 0 & (threwValue | 0) != 0) {
   $417 = _testSetjmp(HEAP32[$416 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (!$417) _longjmp($416 | 0, threwValue | 0);
   tempRet0 = threwValue;
  } else $417 = -1;
  $418 = tempRet0;
  switch ($417 | 0) {
  case 1:
   {
    $$reg2mem457$0 = $418;
    label = 79;
    continue L51;
    break;
   }
  case 2:
   {
    $$reg2mem459$0 = $418;
    label = 44;
    continue L51;
    break;
   }
  default:
   {}
  }
  L126 : do switch (HEAPU8[25620] | 0) {
  case 0:
   break;
  case 1:
   {
    $421 = HEAP32[3991] | 0;
    $423 = HEAP32[3989] | 0;
    if (($421 | 0) == 1) {
     __THREW__ = 0;
     HEAP32[$vararg_buffer521 >> 2] = 5949;
     invoke_iiii(6, $423 | 0, 960, $vararg_buffer521 | 0) | 0;
     $424 = __THREW__;
     __THREW__ = 0;
     if (($424 | 0) != 0 & (threwValue | 0) != 0) {
      $425 = _testSetjmp(HEAP32[$424 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$425) _longjmp($424 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $425 = -1;
     $426 = tempRet0;
     switch ($425 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $426;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $426;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $427 = HEAP32[3990] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer524 >> 2] = 5949;
     invoke_iiii(6, $427 | 0, 960, $vararg_buffer524 | 0) | 0;
     $428 = __THREW__;
     __THREW__ = 0;
     if (($428 | 0) != 0 & (threwValue | 0) != 0) {
      $429 = _testSetjmp(HEAP32[$428 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$429) _longjmp($428 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $429 = -1;
     $430 = tempRet0;
     switch ($429 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $430;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $430;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     break L126;
    } else {
     __THREW__ = 0;
     HEAP32[$vararg_buffer527 >> 2] = 5971;
     HEAP32[$vararg_buffer527 + 4 >> 2] = $421;
     HEAP32[$vararg_buffer527 + 8 >> 2] = 5984;
     invoke_iiii(6, $423 | 0, 2703, $vararg_buffer527 | 0) | 0;
     $431 = __THREW__;
     __THREW__ = 0;
     if (($431 | 0) != 0 & (threwValue | 0) != 0) {
      $432 = _testSetjmp(HEAP32[$431 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$432) _longjmp($431 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $432 = -1;
     $433 = tempRet0;
     switch ($432 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $433;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $433;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $434 = HEAP32[3990] | 0;
     $435 = HEAP32[3991] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer532 >> 2] = 5971;
     HEAP32[$vararg_buffer532 + 4 >> 2] = $435;
     HEAP32[$vararg_buffer532 + 8 >> 2] = 5984;
     invoke_iiii(6, $434 | 0, 2703, $vararg_buffer532 | 0) | 0;
     $436 = __THREW__;
     __THREW__ = 0;
     if (($436 | 0) != 0 & (threwValue | 0) != 0) {
      $437 = _testSetjmp(HEAP32[$436 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$437) _longjmp($436 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $437 = -1;
     $438 = tempRet0;
     switch ($437 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $438;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $438;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     break L126;
    }
    break;
   }
  case 2:
   {
    $439 = HEAP32[3991] | 0;
    $441 = HEAP32[3989] | 0;
    if (($439 | 0) == 1) {
     __THREW__ = 0;
     HEAP32[$vararg_buffer537 >> 2] = 5995;
     invoke_iiii(6, $441 | 0, 960, $vararg_buffer537 | 0) | 0;
     $442 = __THREW__;
     __THREW__ = 0;
     if (($442 | 0) != 0 & (threwValue | 0) != 0) {
      $443 = _testSetjmp(HEAP32[$442 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$443) _longjmp($442 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $443 = -1;
     $444 = tempRet0;
     switch ($443 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $444;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $444;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $445 = HEAP32[3990] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer540 >> 2] = 5995;
     invoke_iiii(6, $445 | 0, 960, $vararg_buffer540 | 0) | 0;
     $446 = __THREW__;
     __THREW__ = 0;
     if (($446 | 0) != 0 & (threwValue | 0) != 0) {
      $447 = _testSetjmp(HEAP32[$446 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$447) _longjmp($446 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $447 = -1;
     $448 = tempRet0;
     switch ($447 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $448;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $448;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     break L126;
    } else {
     __THREW__ = 0;
     HEAP32[$vararg_buffer543 >> 2] = 5971;
     HEAP32[$vararg_buffer543 + 4 >> 2] = $439;
     HEAP32[$vararg_buffer543 + 8 >> 2] = 6023;
     invoke_iiii(6, $441 | 0, 2703, $vararg_buffer543 | 0) | 0;
     $449 = __THREW__;
     __THREW__ = 0;
     if (($449 | 0) != 0 & (threwValue | 0) != 0) {
      $450 = _testSetjmp(HEAP32[$449 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$450) _longjmp($449 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $450 = -1;
     $451 = tempRet0;
     switch ($450 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $451;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $451;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     $452 = HEAP32[3990] | 0;
     $453 = HEAP32[3991] | 0;
     __THREW__ = 0;
     HEAP32[$vararg_buffer548 >> 2] = 5971;
     HEAP32[$vararg_buffer548 + 4 >> 2] = $453;
     HEAP32[$vararg_buffer548 + 8 >> 2] = 6023;
     invoke_iiii(6, $452 | 0, 2703, $vararg_buffer548 | 0) | 0;
     $454 = __THREW__;
     __THREW__ = 0;
     if (($454 | 0) != 0 & (threwValue | 0) != 0) {
      $455 = _testSetjmp(HEAP32[$454 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (!$455) _longjmp($454 | 0, threwValue | 0);
      tempRet0 = threwValue;
     } else $455 = -1;
     $456 = tempRet0;
     switch ($455 | 0) {
     case 1:
      {
       $$reg2mem457$0 = $456;
       label = 79;
       continue L51;
       break;
      }
     case 2:
      {
       $$reg2mem459$0 = $456;
       label = 44;
       continue L51;
       break;
      }
     default:
      {}
     }
     break L126;
    }
    break;
   }
  case 3:
   {
    $457 = HEAP32[3989] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer553 >> 2] = 6040;
    invoke_iiii(6, $457 | 0, 960, $vararg_buffer553 | 0) | 0;
    $458 = __THREW__;
    __THREW__ = 0;
    if (($458 | 0) != 0 & (threwValue | 0) != 0) {
     $459 = _testSetjmp(HEAP32[$458 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$459) _longjmp($458 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $459 = -1;
    $460 = tempRet0;
    switch ($459 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $460;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $460;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    $461 = HEAP32[3990] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer556 >> 2] = 6040;
    invoke_iiii(6, $461 | 0, 960, $vararg_buffer556 | 0) | 0;
    $462 = __THREW__;
    __THREW__ = 0;
    if (($462 | 0) != 0 & (threwValue | 0) != 0) {
     $463 = _testSetjmp(HEAP32[$462 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$463) _longjmp($462 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $463 = -1;
    $464 = tempRet0;
    switch ($463 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $464;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $464;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    break;
   }
  default:
   {
    __THREW__ = 0;
    invoke_iiiii(1, 6065, 15, 1, HEAP32[3989] | 0) | 0;
    $466 = __THREW__;
    __THREW__ = 0;
    if (($466 | 0) != 0 & (threwValue | 0) != 0) {
     $467 = _testSetjmp(HEAP32[$466 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$467) _longjmp($466 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $467 = -1;
    $468 = tempRet0;
    switch ($467 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $468;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $468;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    __THREW__ = 0;
    invoke_iiiii(1, 6065, 15, 1, HEAP32[3990] | 0) | 0;
    $470 = __THREW__;
    __THREW__ = 0;
    if (($470 | 0) != 0 & (threwValue | 0) != 0) {
     $471 = _testSetjmp(HEAP32[$470 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$471) _longjmp($470 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $471 = -1;
    $472 = tempRet0;
    switch ($471 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $472;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $472;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    $473 = HEAP32[3989] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer559 >> 2] = 964;
    invoke_iiii(6, $473 | 0, 960, $vararg_buffer559 | 0) | 0;
    $474 = __THREW__;
    __THREW__ = 0;
    if (($474 | 0) != 0 & (threwValue | 0) != 0) {
     $475 = _testSetjmp(HEAP32[$474 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$475) _longjmp($474 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $475 = -1;
    $476 = tempRet0;
    switch ($475 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $476;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $476;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    $477 = HEAP32[3990] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer562 >> 2] = 964;
    invoke_iiii(6, $477 | 0, 960, $vararg_buffer562 | 0) | 0;
    $478 = __THREW__;
    __THREW__ = 0;
    if (($478 | 0) != 0 & (threwValue | 0) != 0) {
     $479 = _testSetjmp(HEAP32[$478 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$479) _longjmp($478 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $479 = -1;
    $480 = tempRet0;
    switch ($479 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $480;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $480;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    $481 = HEAP32[3989] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer565 >> 2] = 985;
    invoke_iiii(6, $481 | 0, 960, $vararg_buffer565 | 0) | 0;
    $482 = __THREW__;
    __THREW__ = 0;
    if (($482 | 0) != 0 & (threwValue | 0) != 0) {
     $483 = _testSetjmp(HEAP32[$482 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$483) _longjmp($482 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $483 = -1;
    $484 = tempRet0;
    switch ($483 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $484;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $484;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    $485 = HEAP32[3990] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer568 >> 2] = 985;
    invoke_iiii(6, $485 | 0, 960, $vararg_buffer568 | 0) | 0;
    $486 = __THREW__;
    __THREW__ = 0;
    if (($486 | 0) != 0 & (threwValue | 0) != 0) {
     $487 = _testSetjmp(HEAP32[$486 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (!$487) _longjmp($486 | 0, threwValue | 0);
     tempRet0 = threwValue;
    } else $487 = -1;
    $488 = tempRet0;
    switch ($487 | 0) {
    case 1:
     {
      $$reg2mem457$0 = $488;
      label = 79;
      continue L51;
      break;
     }
    case 2:
     {
      $$reg2mem459$0 = $488;
      label = 44;
      continue L51;
      break;
     }
    default:
     {}
    }
    HEAP8[25620] = 3;
   }
  } while (0);
  __THREW__ = 0;
  invoke_vi(1, HEAP32[3989] | 0);
  $490 = __THREW__;
  __THREW__ = 0;
  if (($490 | 0) != 0 & (threwValue | 0) != 0) {
   $491 = _testSetjmp(HEAP32[$490 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (!$491) _longjmp($490 | 0, threwValue | 0);
   tempRet0 = threwValue;
  } else $491 = -1;
  $492 = tempRet0;
  switch ($491 | 0) {
  case 1:
   {
    $$reg2mem457$0 = $492;
    label = 79;
    continue L51;
    break;
   }
  case 2:
   {
    $$reg2mem459$0 = $492;
    label = 44;
    continue L51;
    break;
   }
  default:
   {}
  }
  $493 = HEAP8[25620] | 0;
  if (($493 & 255) <= 1) {
   label = 133;
   break;
  }
  __THREW__ = 0;
  invoke_vi(2, $493 & 255 | 0);
  $496 = __THREW__;
  __THREW__ = 0;
  if (($496 | 0) != 0 & (threwValue | 0) != 0) {
   $497 = _testSetjmp(HEAP32[$496 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (!$497) _longjmp($496 | 0, threwValue | 0);
   tempRet0 = threwValue;
  } else $497 = -1;
  $498 = tempRet0;
  switch ($497 | 0) {
  case 1:
   {
    $$reg2mem457$0 = $498;
    label = 79;
    break;
   }
  case 2:
   {
    $$reg2mem459$0 = $498;
    label = 44;
    break;
   }
  default:
   {
    label = 132;
    break L51;
   }
  }
 }
 if ((label | 0) == 132) {} else if ((label | 0) == 133) {
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return;
 }
}

function _getbibcommandorentryandprocess() {
 var $$lcssa$i = 0, $$lcssa$i$i = 0, $$lcssa$i$i14 = 0, $$lcssa$i$i140 = 0, $$lcssa$i$i146 = 0, $$lcssa$i$i181 = 0, $$lcssa$i$i187 = 0, $$lcssa$i$i20 = 0, $$lcssa$i$i26 = 0, $$lcssa$i$i32 = 0, $$lcssa$i$i51 = 0, $$lcssa$i$i57 = 0, $$lcssa$i$i79 = 0, $$lcssa$i$i85 = 0, $$lcssa256 = 0, $$lcssa608 = 0, $$lcssa800 = 0, $$lcssa802 = 0, $$lcssa804 = 0, $$lcssa806 = 0, $$lcssa812 = 0, $$lcssa814 = 0, $$lcssa816 = 0, $$lcssa818 = 0, $$lcssa820 = 0, $$lcssa821 = 0, $$lcssa822 = 0, $$lcssa823 = 0, $$lcssa826 = 0, $$lcssa828 = 0, $$lcssa830 = 0, $$lcssa835 = 0, $$lcssa837 = 0, $$lcssa839 = 0, $$lcssa841 = 0, $$lcssa846 = 0, $$lcssa848 = 0, $$lcssa850 = 0, $$lcssa852 = 0, $$lcssa854 = 0, $$lcssa855 = 0, $$lcssa856 = 0, $$lcssa857 = 0, $$lcssa862 = 0, $$lcssa864 = 0, $$lcssa866 = 0, $$lcssa868 = 0, $$lcssa871 = 0, $$lcssa881 = 0, $$lcssa883 = 0, $$lcssa885 = 0, $$lcssa892 = 0, $$lcssa894 = 0, $$lcssa899 = 0, $$lcssa901 = 0, $$lcssa903 = 0, $$lcssa905 = 0, $$lcssa909 = 0, $$lcssa910 = 0, $$lcssa911 = 0, $$lcssa912 = 0, $$lcssa915 = 0, $$lcssa917 = 0, $$lcssa919 = 0, $$lcssa924 = 0, $$lcssa926 = 0, $$lcssa928 = 0, $$lcssa930 = 0, $$pr199$pre = 0, $$pr202338 = 0, $$pre$i24 = 0, $$pre3$pre$i = 0, $$pre3$pre$i$lcssa = 0, $$pre331 = 0, $$pre333 = 0, $$pre334 = 0, $$pre342 = 0, $$pre343 = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $1002 = 0, $1003 = 0, $1005 = 0, $1006 = 0, $101 = 0, $1022 = 0, $1023 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1034 = 0, $1037 = 0, $104 = 0, $1043 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $1050 = 0, $1052 = 0, $1056 = 0, $1058 = 0, $1068 = 0, $1074 = 0, $1081 = 0, $1082 = 0, $1083 = 0, $1088 = 0, $1089 = 0, $1091 = 0, $1092 = 0, $1094 = 0, $1099 = 0, $11 = 0, $110 = 0, $1112 = 0, $1114 = 0, $1115 = 0, $1117 = 0, $1120 = 0, $1126 = 0, $1127 = 0, $1129 = 0, $113 = 0, $1130 = 0, $1137 = 0, $114 = 0, $115 = 0, $1152 = 0, $1153 = 0, $1156 = 0, $1157 = 0, $1158 = 0, $1159 = 0, $116 = 0, $1160 = 0, $1161 = 0, $1162 = 0, $1163 = 0, $1164 = 0, $1165 = 0, $1166 = 0, $1167 = 0, $1168 = 0, $1169 = 0, $117 = 0, $1170 = 0, $1171 = 0, $1172 = 0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $119 = 0, $123 = 0, $125 = 0, $135 = 0, $141 = 0, $145 = 0, $146 = 0, $149 = 0, $156 = 0, $157 = 0, $164 = 0, $165 = 0, $174 = 0, $176 = 0, $177 = 0, $182 = 0, $183 = 0, $185 = 0, $186 = 0, $188 = 0, $193 = 0, $205 = 0, $207 = 0, $209 = 0, $210 = 0, $212 = 0, $214 = 0, $217 = 0, $22 = 0, $223 = 0, $224 = 0, $226 = 0, $227 = 0, $234 = 0, $24 = 0, $248 = 0, $25 = 0, $252 = 0, $255 = 0, $258 = 0, $259 = 0, $264 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $274 = 0, $275 = 0, $277 = 0, $278 = 0, $28 = 0, $280 = 0, $285 = 0, $29 = 0, $297 = 0, $299 = 0, $3 = 0, $30 = 0, $301 = 0, $302 = 0, $304 = 0, $306 = 0, $309 = 0, $31 = 0, $315 = 0, $316 = 0, $318 = 0, $319 = 0, $326 = 0, $34 = 0, $340 = 0, $348 = 0, $349 = 0, $351 = 0, $352 = 0, $366 = 0, $367 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $384 = 0, $386 = 0, $387 = 0, $392 = 0, $393 = 0, $395 = 0, $396 = 0, $398 = 0, $4 = 0, $40 = 0, $403 = 0, $41 = 0, $416 = 0, $418 = 0, $419 = 0, $421 = 0, $424 = 0, $43 = 0, $430 = 0, $431 = 0, $433 = 0, $434 = 0, $44 = 0, $441 = 0, $455 = 0, $459 = 0, $462 = 0, $465 = 0, $466 = 0, $471 = 0, $476 = 0, $484 = 0, $488 = 0, $492 = 0, $494 = 0, $5 = 0, $504 = 0, $51 = 0, $510 = 0, $517 = 0, $518 = 0, $519 = 0, $524 = 0, $525 = 0, $527 = 0, $528 = 0, $530 = 0, $535 = 0, $547 = 0, $549 = 0, $551 = 0, $552 = 0, $554 = 0, $556 = 0, $559 = 0, $565 = 0, $567 = 0, $568 = 0, $575 = 0, $588 = 0, $590 = 0, $596 = 0, $598 = 0, $600 = 0, $607 = 0, $611 = 0, $613 = 0, $615 = 0, $617 = 0, $623 = 0, $624 = 0, $627 = 0, $632 = 0, $633 = 0, $635 = 0, $637 = 0, $638 = 0, $639 = 0, $640 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $653 = 0, $656 = 0, $662 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $671 = 0, $675 = 0, $677 = 0, $687 = 0, $693 = 0, $695 = 0, $697 = 0, $7 = 0, $701 = 0, $703 = 0, $705 = 0, $711 = 0, $714 = 0, $715 = 0, $718 = 0, $73 = 0, $734 = 0, $735 = 0, $737 = 0, $739 = 0, $74 = 0, $743 = 0, $747 = 0, $751 = 0, $753 = 0, $755 = 0, $758 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $765 = 0, $768 = 0, $769 = 0, $77 = 0, $771 = 0, $772 = 0, $773 = 0, $781 = 0, $783 = 0, $785 = 0, $786 = 0, $788 = 0, $791 = 0, $797 = 0, $799 = 0, $8 = 0, $800 = 0, $801 = 0, $802 = 0, $804 = 0, $808 = 0, $810 = 0, $820 = 0, $826 = 0, $832 = 0, $835 = 0, $837 = 0, $838 = 0, $839 = 0, $840 = 0, $844 = 0, $845 = 0, $846 = 0, $856 = 0, $876 = 0, $877 = 0, $878 = 0, $887 = 0, $888 = 0, $890 = 0, $891 = 0, $893 = 0, $90 = 0, $901 = 0, $904 = 0, $905 = 0, $909 = 0, $91 = 0, $911 = 0, $917 = 0, $918 = 0, $920 = 0, $921 = 0, $928 = 0, $931 = 0, $932 = 0, $944 = 0, $946 = 0, $948 = 0, $950 = 0, $952 = 0, $953 = 0, $955 = 0, $957 = 0, $959 = 0, $961 = 0, $962 = 0, $967 = 0, $968 = 0, $970 = 0, $971 = 0, $973 = 0, $978 = 0, $98 = 0, $99 = 0, $994 = 0, $h$0$lcssa$i = 0, $h$0$lcssa$i104 = 0, $h$0$lcssa$i123 = 0, $h$0$lcssa$i167 = 0, $h$0$lcssa$i65 = 0, $h$06$i = 0, $h$06$i102 = 0, $h$06$i121 = 0, $h$06$i165 = 0, $h$06$i63 = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $h$1$i103 = 0, $h$1$i103$lcssa = 0, $h$1$i122 = 0, $h$1$i122$lcssa = 0, $h$1$i166 = 0, $h$1$i166$lcssa = 0, $h$1$i64 = 0, $h$1$i64$lcssa = 0, $i$0$i = 0, $i$0$i116 = 0, $i$0$i160 = 0, $i$0$i46 = 0, $i$0$i97 = 0, $i$01$i$i = 0, $i$01$i$i110 = 0, $i$01$i$i129 = 0, $i$01$i$i135 = 0, $i$01$i$i173 = 0, $i$01$i$i71 = 0, $i$01$i1$i = 0, $j$02$i$i = 0, $j$02$i$i109 = 0, $j$02$i$i128 = 0, $j$02$i$i172 = 0, $j$02$i$i70 = 0, $k$07$i = 0, $k$07$i101 = 0, $k$07$i120 = 0, $k$07$i164 = 0, $k$07$i62 = 0, $notlhs = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa908 = 0, $p$0$i106 = 0, $p$0$i106$lcssa = 0, $p$0$i106$lcssa887 = 0, $p$0$i125 = 0, $p$0$i125$lcssa = 0, $p$0$i125$lcssa886 = 0, $p$0$i169 = 0, $p$0$i169$lcssa = 0, $p$0$i169$lcssa858 = 0, $p$0$i67 = 0, $p$0$i67$lcssa = 0, $p$0$i67$lcssa907 = 0, $storemerge = 0, $storemerge210 = 0, $storemerge211 = 0, $storemerge212 = 0, $storemerge213 = 0, $storemerge214 = 0, $storemerge215 = 0, $storemerge216 = 0, $storemerge217 = 0, $storemerge218 = 0, $storemerge219 = 0, $storemerge220 = 0, $storemerge2200 = 0, $storemerge221 = 0, $storemerge222 = 0, $storemerge223 = 0, $storemerge3 = 0, $storemerge4 = 0, $vararg_buffer = 0, $vararg_buffer103 = 0, $vararg_buffer11 = 0, $vararg_buffer110 = 0, $vararg_buffer113 = 0, $vararg_buffer116 = 0, $vararg_buffer119 = 0, $vararg_buffer122 = 0, $vararg_buffer125 = 0, $vararg_buffer128 = 0, $vararg_buffer135 = 0, $vararg_buffer14 = 0, $vararg_buffer142 = 0, $vararg_buffer147 = 0, $vararg_buffer17 = 0, $vararg_buffer20 = 0, $vararg_buffer26 = 0, $vararg_buffer3 = 0, $vararg_buffer32 = 0, $vararg_buffer38 = 0, $vararg_buffer45 = 0, $vararg_buffer52 = 0, $vararg_buffer57 = 0, $vararg_buffer62 = 0, $vararg_buffer69 = 0, $vararg_buffer76 = 0, $vararg_buffer8 = 0, $vararg_buffer81 = 0, $vararg_buffer86 = 0, $vararg_buffer91 = 0, $vararg_buffer96 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 480 | 0;
 $vararg_buffer147 = sp + 464 | 0;
 $vararg_buffer142 = sp + 448 | 0;
 $vararg_buffer135 = sp + 424 | 0;
 $vararg_buffer128 = sp + 400 | 0;
 $vararg_buffer125 = sp + 392 | 0;
 $vararg_buffer122 = sp + 384 | 0;
 $vararg_buffer119 = sp + 376 | 0;
 $vararg_buffer116 = sp + 368 | 0;
 $vararg_buffer113 = sp + 360 | 0;
 $vararg_buffer110 = sp + 352 | 0;
 $vararg_buffer103 = sp + 328 | 0;
 $vararg_buffer96 = sp + 304 | 0;
 $vararg_buffer91 = sp + 288 | 0;
 $vararg_buffer86 = sp + 272 | 0;
 $vararg_buffer81 = sp + 256 | 0;
 $vararg_buffer76 = sp + 240 | 0;
 $vararg_buffer69 = sp + 216 | 0;
 $vararg_buffer62 = sp + 192 | 0;
 $vararg_buffer57 = sp + 176 | 0;
 $vararg_buffer52 = sp + 160 | 0;
 $vararg_buffer45 = sp + 136 | 0;
 $vararg_buffer38 = sp + 112 | 0;
 $vararg_buffer32 = sp + 96 | 0;
 $vararg_buffer26 = sp + 80 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer17 = sp + 56 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[4147] = 0;
 $0 = HEAP32[4045] | 0;
 while (1) {
  HEAP32[4044] = $0;
  $1 = HEAP32[3993] | 0;
  $3 = HEAP8[$1 + $0 >> 0] | 0;
  $4 = HEAP32[3999] | 0;
  $5 = ($0 | 0) < ($4 | 0);
  if ($3 << 24 >> 24 != 64 & $5) {
   $8 = $0;
   while (1) {
    $7 = $8 + 1 | 0;
    HEAP32[4045] = $7;
    $10 = HEAP8[$1 + $7 >> 0] | 0;
    $11 = ($7 | 0) < ($4 | 0);
    if ($11 & $10 << 24 >> 24 != 64) $8 = $7; else {
     $$lcssa$i = $11;
     $1157 = $10;
     $1158 = $7;
     break;
    }
   }
  } else {
   $$lcssa$i = $5;
   $1157 = $3;
   $1158 = $0;
  }
  if ($$lcssa$i) {
   $$lcssa924 = $1;
   $$lcssa926 = $4;
   $$lcssa928 = $1157;
   $$lcssa930 = $1158;
   break;
  }
  if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
   label = 298;
   break;
  }
  HEAP32[4146] = (HEAP32[4146] | 0) + 1;
  HEAP32[4045] = 0;
  $0 = 0;
 }
 if ((label | 0) == 298) {
  STACKTOP = sp;
  return;
 }
 if ($$lcssa928 << 24 >> 24 != 64) {
  $22 = HEAP32[3989] | 0;
  $24 = HEAPU8[26197] | 0;
  HEAP32[$vararg_buffer >> 2] = 5044;
  HEAP32[$vararg_buffer + 4 >> 2] = $24;
  HEAP32[$vararg_buffer + 8 >> 2] = 5049;
  _fprintf($22, 3109, $vararg_buffer) | 0;
  $25 = HEAP32[3990] | 0;
  $27 = HEAPU8[26197] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 5044;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $27;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 5049;
  _fprintf($25, 3109, $vararg_buffer3) | 0;
  $28 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer8 >> 2] = 964;
  _fprintf($28, 960, $vararg_buffer8) | 0;
  $29 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer11 >> 2] = 964;
  _fprintf($29, 960, $vararg_buffer11) | 0;
  $30 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer14 >> 2] = 985;
  _fprintf($30, 960, $vararg_buffer14) | 0;
  $31 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer17 >> 2] = 985;
  _fprintf($31, 960, $vararg_buffer17) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
 $34 = $$lcssa924;
 $41 = $$lcssa926;
 $storemerge210 = $$lcssa930 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge210;
  $40 = ($storemerge210 | 0) < ($41 | 0);
  if ((HEAP8[25877 + (HEAPU8[$34 + $storemerge210 >> 0] | 0) >> 0] | 0) == 1 & $40) {
   $44 = $storemerge210;
   while (1) {
    $43 = $44 + 1 | 0;
    HEAP32[4045] = $43;
    $51 = ($43 | 0) < ($41 | 0);
    if ($51 & (HEAP8[25877 + (HEAPU8[$34 + $43 >> 0] | 0) >> 0] | 0) == 1) $44 = $43; else {
     $$lcssa$i$i = $51;
     $1159 = $43;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $40;
   $1159 = $storemerge210;
  }
  if ($$lcssa$i$i) {
   $$lcssa915 = $41;
   $$lcssa917 = $34;
   $$lcssa919 = $1159;
   break;
  }
  if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
   label = 15;
   break;
  }
  HEAP32[4146] = (HEAP32[4146] | 0) + 1;
  $34 = HEAP32[3993] | 0;
  $41 = HEAP32[3999] | 0;
  $storemerge210 = 0;
 }
 if ((label | 0) == 15) {
  _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
  _biberrprint();
  STACKTOP = sp;
  return;
 }
 HEAP32[4044] = $$lcssa919;
 $65 = HEAPU8[$$lcssa917 + $$lcssa919 >> 0] | 0;
 L27 : do if ((HEAP8[25877 + $65 >> 0] | 0) == 3) $storemerge211 = 0; else if ((HEAP8[26390 + $65 >> 0] | 0) == 1 & ($$lcssa919 | 0) < ($$lcssa915 | 0)) {
  $74 = $$lcssa919;
  while (1) {
   $73 = $74 + 1 | 0;
   HEAP32[4045] = $73;
   $76 = HEAP8[$$lcssa917 + $73 >> 0] | 0;
   $77 = $76 & 255;
   if (($73 | 0) < ($$lcssa915 | 0) & (HEAP8[26390 + $77 >> 0] | 0) == 1) $74 = $73; else {
    $$lcssa909 = $74;
    $$lcssa910 = $73;
    $$lcssa911 = $76;
    $$lcssa912 = $77;
    break;
   }
  }
  if (($$lcssa910 | 0) == ($$lcssa919 | 0)) $storemerge211 = 0; else {
   if ((HEAP8[25877 + $$lcssa912 >> 0] | 0) == 1 | ($$lcssa910 | 0) == ($$lcssa915 | 0)) $storemerge212 = 3; else switch ($$lcssa911 << 24 >> 24) {
   case 40:
   case 123:
    {
     $storemerge212 = 1;
     break;
    }
   default:
    {
     $storemerge211 = 2;
     break L27;
    }
   }
   HEAP8[26389] = $storemerge212;
   if (($$lcssa909 | 0) < ($$lcssa919 | 0)) {
    $$pre$i24 = $$lcssa910;
    $104 = $$lcssa917;
    $99 = $$lcssa919;
   } else {
    $i$0$i = $$lcssa919;
    while (1) {
     $90 = $$lcssa917 + $i$0$i | 0;
     $91 = HEAP8[$90 >> 0] | 0;
     if (($91 + -65 & 255) < 26) HEAP8[$90 >> 0] = ($91 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa909 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $$pre$i24 = HEAP32[4045] | 0;
    $104 = HEAP32[3993] | 0;
    $99 = HEAP32[4044] | 0;
   }
   $98 = $$pre$i24 - $99 | 0;
   $100 = ($98 | 0) > 0;
   if ($100) {
    $101 = HEAP32[4240] | 0;
    $h$06$i = 0;
    $k$07$i = $99;
    while (1) {
     $h$1$i = (HEAPU8[$104 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
     while (1) if (($h$1$i | 0) < ($101 | 0)) {
      $h$1$i$lcssa = $h$1$i;
      break;
     } else $h$1$i = $h$1$i - $101 | 0;
     $110 = $k$07$i + 1 | 0;
     if (($110 | 0) < ($$pre$i24 | 0)) {
      $h$06$i = $h$1$i$lcssa;
      $k$07$i = $110;
     } else {
      $h$0$lcssa$i = $h$1$i$lcssa;
      break;
     }
    }
   } else $h$0$lcssa$i = 0;
   HEAP32[4241] = 0;
   $113 = HEAP32[4145] | 0;
   $114 = HEAP32[4041] | 0;
   $115 = HEAP32[4042] | 0;
   $116 = HEAP32[4242] | 0;
   $117 = HEAP32[4243] | 0;
   $p$0$i = $h$0$lcssa$i + 1 | 0;
   L52 : while (1) {
    $119 = HEAP32[$113 + ($p$0$i << 2) >> 2] | 0;
    L54 : do if (($119 | 0) > 0) {
     $123 = HEAP32[$114 + ($119 + 1 << 2) >> 2] | 0;
     $125 = HEAP32[$114 + ($119 << 2) >> 2] | 0;
     if (($123 - $125 | 0) == ($98 | 0)) {
      if (($123 | 0) > ($125 | 0)) {
       $i$01$i$i = $99;
       $j$02$i$i = $125;
       while (1) {
        if ((HEAP8[$115 + $j$02$i$i >> 0] | 0) != (HEAP8[$104 + $i$01$i$i >> 0] | 0)) break L54;
        $135 = $j$02$i$i + 1 | 0;
        if (($135 | 0) < ($123 | 0)) {
         $i$01$i$i = $i$01$i$i + 1 | 0;
         $j$02$i$i = $135;
        } else break;
       }
      }
      if ((HEAP8[$116 + $p$0$i >> 0] | 0) == 12) {
       $p$0$i$lcssa = $p$0$i;
       label = 41;
       break L52;
      }
     }
    } while (0);
    $141 = HEAP32[$117 + ($p$0$i << 2) >> 2] | 0;
    if (!$141) {
     $p$0$i$lcssa908 = $p$0$i;
     break;
    } else $p$0$i = $141;
   }
   if ((label | 0) == 41) {
    HEAP32[4241] = 1;
    $145 = HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0;
    HEAP32[4321] = $145;
    HEAP32[4147] = 1;
    switch ($145 | 0) {
    case 1:
     {
      $146 = HEAP32[4304] | 0;
      if (($146 | 0) == (HEAP32[4667] | 0)) {
       $149 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer20 >> 2] = 4165;
       HEAP32[$vararg_buffer20 + 4 >> 2] = 4;
       HEAP32[$vararg_buffer20 + 8 >> 2] = $146 + 20;
       HEAP32[$vararg_buffer20 + 12 >> 2] = $146;
       _fprintf($149, 1023, $vararg_buffer20) | 0;
       HEAP32[4094] = _xrealloc(HEAP32[4094] | 0, (HEAP32[4667] << 2) + 84 | 0) | 0;
       $156 = HEAP32[3989] | 0;
       $157 = HEAP32[4667] | 0;
       HEAP32[$vararg_buffer26 >> 2] = 4174;
       HEAP32[$vararg_buffer26 + 4 >> 2] = 4;
       HEAP32[$vararg_buffer26 + 8 >> 2] = $157 + 20;
       HEAP32[$vararg_buffer26 + 12 >> 2] = $157;
       _fprintf($156, 1023, $vararg_buffer26) | 0;
       HEAP32[4316] = _xrealloc(HEAP32[4316] | 0, (HEAP32[4667] << 2) + 84 | 0) | 0;
       $164 = HEAP32[3989] | 0;
       $165 = HEAP32[4667] | 0;
       HEAP32[$vararg_buffer32 >> 2] = 4183;
       HEAP32[$vararg_buffer32 + 4 >> 2] = 4;
       HEAP32[$vararg_buffer32 + 8 >> 2] = $165 + 20;
       HEAP32[$vararg_buffer32 + 12 >> 2] = $165;
       _fprintf($164, 1023, $vararg_buffer32) | 0;
       HEAP32[4325] = _xrealloc(HEAP32[4325] | 0, (HEAP32[4667] << 2) + 84 | 0) | 0;
       HEAP32[4667] = (HEAP32[4667] | 0) + 20;
       $176 = HEAP32[4045] | 0;
      } else $176 = $$pre$i24;
      while (1) {
       $174 = HEAP32[3993] | 0;
       $177 = HEAP8[$174 + $176 >> 0] | 0;
       $182 = HEAP32[3999] | 0;
       $183 = ($176 | 0) < ($182 | 0);
       if ((HEAP8[25877 + ($177 & 255) >> 0] | 0) == 1 & $183) {
        $186 = $176;
        while (1) {
         $185 = $186 + 1 | 0;
         HEAP32[4045] = $185;
         $188 = HEAP8[$174 + $185 >> 0] | 0;
         $193 = ($185 | 0) < ($182 | 0);
         if ($193 & (HEAP8[25877 + ($188 & 255) >> 0] | 0) == 1) $186 = $185; else {
          $$lcssa$i$i14 = $193;
          $1160 = $188;
          $1161 = $185;
          break;
         }
        }
       } else {
        $$lcssa$i$i14 = $183;
        $1160 = $177;
        $1161 = $176;
       }
       if ($$lcssa$i$i14) {
        $$lcssa800 = $174;
        $$lcssa802 = $182;
        $$lcssa804 = $1160;
        $$lcssa806 = $1161;
        break;
       }
       if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
        label = 49;
        break;
       }
       HEAP32[4146] = (HEAP32[4146] | 0) + 1;
       HEAP32[4045] = 0;
       $176 = 0;
      }
      if ((label | 0) == 49) {
       _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
       _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
       _biberrprint();
       STACKTOP = sp;
       return;
      }
      switch ($$lcssa804 << 24 >> 24) {
      case 123:
       {
        $storemerge4 = 125;
        break;
       }
      case 40:
       {
        $storemerge4 = 41;
        break;
       }
      default:
       {
        $205 = HEAP32[3989] | 0;
        $207 = HEAPU8[26256] | 0;
        $209 = HEAPU8[26173] | 0;
        HEAP32[$vararg_buffer38 >> 2] = 1952;
        HEAP32[$vararg_buffer38 + 4 >> 2] = $207;
        HEAP32[$vararg_buffer38 + 8 >> 2] = 1972;
        HEAP32[$vararg_buffer38 + 12 >> 2] = $209;
        HEAP32[$vararg_buffer38 + 16 >> 2] = 39;
        _fprintf($205, 1941, $vararg_buffer38) | 0;
        $210 = HEAP32[3990] | 0;
        $212 = HEAPU8[26256] | 0;
        $214 = HEAPU8[26173] | 0;
        HEAP32[$vararg_buffer45 >> 2] = 1952;
        HEAP32[$vararg_buffer45 + 4 >> 2] = $212;
        HEAP32[$vararg_buffer45 + 8 >> 2] = 1972;
        HEAP32[$vararg_buffer45 + 12 >> 2] = $214;
        HEAP32[$vararg_buffer45 + 16 >> 2] = 39;
        _fprintf($210, 1941, $vararg_buffer45) | 0;
        _biberrprint();
        STACKTOP = sp;
        return;
       }
      }
      HEAP8[26647] = $storemerge4;
      $217 = $$lcssa800;
      $224 = $$lcssa802;
      $storemerge217 = $$lcssa806 + 1 | 0;
      while (1) {
       HEAP32[4045] = $storemerge217;
       $223 = ($storemerge217 | 0) < ($224 | 0);
       if ((HEAP8[25877 + (HEAPU8[$217 + $storemerge217 >> 0] | 0) >> 0] | 0) == 1 & $223) {
        $227 = $storemerge217;
        while (1) {
         $226 = $227 + 1 | 0;
         HEAP32[4045] = $226;
         $234 = ($226 | 0) < ($224 | 0);
         if ($234 & (HEAP8[25877 + (HEAPU8[$217 + $226 >> 0] | 0) >> 0] | 0) == 1) $227 = $226; else {
          $$lcssa$i$i20 = $234;
          break;
         }
        }
       } else $$lcssa$i$i20 = $223;
       if ($$lcssa$i$i20) break;
       if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
        label = 59;
        break;
       }
       HEAP32[4146] = (HEAP32[4146] | 0) + 1;
       $217 = HEAP32[3993] | 0;
       $224 = HEAP32[3999] | 0;
       $storemerge217 = 0;
      }
      if ((label | 0) == 59) {
       _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
       _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
       _biberrprint();
       STACKTOP = sp;
       return;
      }
      HEAP32[4318] = 1;
      if (!(_scanandstorethefieldvalueandeatwhite() | 0)) {
       STACKTOP = sp;
       return;
      }
      $248 = HEAP32[4045] | 0;
      $252 = HEAP8[26647] | 0;
      if ((HEAP8[(HEAP32[3993] | 0) + $248 >> 0] | 0) == $252 << 24 >> 24) {
       HEAP32[4045] = $248 + 1;
       STACKTOP = sp;
       return;
      } else {
       $255 = HEAP32[3989] | 0;
       $258 = HEAPU8[26133 + ($252 & 255) >> 0] | 0;
       HEAP32[$vararg_buffer52 >> 2] = 5077;
       HEAP32[$vararg_buffer52 + 4 >> 2] = $258;
       HEAP32[$vararg_buffer52 + 8 >> 2] = 5087;
       _fprintf($255, 3109, $vararg_buffer52) | 0;
       $259 = HEAP32[3990] | 0;
       $264 = HEAPU8[26133 + (HEAPU8[26647] | 0) >> 0] | 0;
       HEAP32[$vararg_buffer57 >> 2] = 5077;
       HEAP32[$vararg_buffer57 + 4 >> 2] = $264;
       HEAP32[$vararg_buffer57 + 8 >> 2] = 5087;
       _fprintf($259, 3109, $vararg_buffer57) | 0;
       _biberrprint();
       STACKTOP = sp;
       return;
      }
      break;
     }
    case 2:
     {
      $267 = $104;
      $268 = $$pre$i24;
      while (1) {
       $269 = HEAP8[$267 + $268 >> 0] | 0;
       $274 = HEAP32[3999] | 0;
       $275 = ($268 | 0) < ($274 | 0);
       if ((HEAP8[25877 + ($269 & 255) >> 0] | 0) == 1 & $275) {
        $278 = $268;
        while (1) {
         $277 = $278 + 1 | 0;
         HEAP32[4045] = $277;
         $280 = HEAP8[$267 + $277 >> 0] | 0;
         $285 = ($277 | 0) < ($274 | 0);
         if ($285 & (HEAP8[25877 + ($280 & 255) >> 0] | 0) == 1) $278 = $277; else {
          $$lcssa$i$i26 = $285;
          $1162 = $280;
          $1163 = $277;
          break;
         }
        }
       } else {
        $$lcssa$i$i26 = $275;
        $1162 = $269;
        $1163 = $268;
       }
       if ($$lcssa$i$i26) {
        $$lcssa835 = $267;
        $$lcssa837 = $274;
        $$lcssa839 = $1162;
        $$lcssa841 = $1163;
        break;
       }
       if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
        label = 69;
        break;
       }
       HEAP32[4146] = (HEAP32[4146] | 0) + 1;
       HEAP32[4045] = 0;
       $267 = HEAP32[3993] | 0;
       $268 = 0;
      }
      if ((label | 0) == 69) {
       _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
       _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
       _biberrprint();
       STACKTOP = sp;
       return;
      }
      switch ($$lcssa839 << 24 >> 24) {
      case 123:
       {
        $storemerge3 = 125;
        break;
       }
      case 40:
       {
        $storemerge3 = 41;
        break;
       }
      default:
       {
        $297 = HEAP32[3989] | 0;
        $299 = HEAPU8[26256] | 0;
        $301 = HEAPU8[26173] | 0;
        HEAP32[$vararg_buffer62 >> 2] = 1952;
        HEAP32[$vararg_buffer62 + 4 >> 2] = $299;
        HEAP32[$vararg_buffer62 + 8 >> 2] = 1972;
        HEAP32[$vararg_buffer62 + 12 >> 2] = $301;
        HEAP32[$vararg_buffer62 + 16 >> 2] = 39;
        _fprintf($297, 1941, $vararg_buffer62) | 0;
        $302 = HEAP32[3990] | 0;
        $304 = HEAPU8[26256] | 0;
        $306 = HEAPU8[26173] | 0;
        HEAP32[$vararg_buffer69 >> 2] = 1952;
        HEAP32[$vararg_buffer69 + 4 >> 2] = $304;
        HEAP32[$vararg_buffer69 + 8 >> 2] = 1972;
        HEAP32[$vararg_buffer69 + 12 >> 2] = $306;
        HEAP32[$vararg_buffer69 + 16 >> 2] = 39;
        _fprintf($302, 1941, $vararg_buffer69) | 0;
        _biberrprint();
        STACKTOP = sp;
        return;
       }
      }
      HEAP8[26647] = $storemerge3;
      $309 = $$lcssa835;
      $316 = $$lcssa837;
      $storemerge213 = $$lcssa841 + 1 | 0;
      while (1) {
       HEAP32[4045] = $storemerge213;
       $315 = ($storemerge213 | 0) < ($316 | 0);
       if ((HEAP8[25877 + (HEAPU8[$309 + $storemerge213 >> 0] | 0) >> 0] | 0) == 1 & $315) {
        $319 = $storemerge213;
        while (1) {
         $318 = $319 + 1 | 0;
         HEAP32[4045] = $318;
         $326 = ($318 | 0) < ($316 | 0);
         if ($326 & (HEAP8[25877 + (HEAPU8[$309 + $318 >> 0] | 0) >> 0] | 0) == 1) $319 = $318; else {
          $$lcssa$i$i32 = $326;
          $1164 = $318;
          break;
         }
        }
       } else {
        $$lcssa$i$i32 = $315;
        $1164 = $storemerge213;
       }
       if ($$lcssa$i$i32) {
        $$lcssa826 = $316;
        $$lcssa828 = $309;
        $$lcssa830 = $1164;
        break;
       }
       if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
        label = 79;
        break;
       }
       HEAP32[4146] = (HEAP32[4146] | 0) + 1;
       $309 = HEAP32[3993] | 0;
       $316 = HEAP32[3999] | 0;
       $storemerge213 = 0;
      }
      if ((label | 0) == 79) {
       _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
       _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
       _biberrprint();
       STACKTOP = sp;
       return;
      }
      HEAP32[4044] = $$lcssa830;
      $340 = HEAPU8[$$lcssa828 + $$lcssa830 >> 0] | 0;
      do if ((HEAP8[25877 + $340 >> 0] | 0) == 3) $storemerge214 = 0; else if ((HEAP8[26390 + $340 >> 0] | 0) == 1 & ($$lcssa830 | 0) < ($$lcssa826 | 0)) {
       $349 = $$lcssa830;
       while (1) {
        $348 = $349 + 1 | 0;
        HEAP32[4045] = $348;
        $351 = HEAP8[$$lcssa828 + $348 >> 0] | 0;
        $352 = $351 & 255;
        if (($348 | 0) < ($$lcssa826 | 0) & (HEAP8[26390 + $352 >> 0] | 0) == 1) $349 = $348; else {
         $$lcssa820 = $349;
         $$lcssa821 = $348;
         $$lcssa822 = $351;
         $$lcssa823 = $352;
         break;
        }
       }
       if (($$lcssa821 | 0) == ($$lcssa830 | 0)) $storemerge214 = 0; else {
        if ((HEAP8[25877 + $$lcssa823 >> 0] | 0) == 1 | ($$lcssa821 | 0) == ($$lcssa826 | 0)) $storemerge215 = 3; else if ($$lcssa822 << 24 >> 24 == 61) $storemerge215 = 1; else {
         $storemerge214 = 2;
         break;
        }
        HEAP8[26389] = $storemerge215;
        if (($$lcssa820 | 0) < ($$lcssa830 | 0)) {
         $375 = $$lcssa830;
         $376 = $$lcssa821;
         $377 = $$lcssa828;
        } else {
         $i$0$i46 = $$lcssa830;
         while (1) {
          $366 = $$lcssa828 + $i$0$i46 | 0;
          $367 = HEAP8[$366 >> 0] | 0;
          if (($367 + -65 & 255) < 26) HEAP8[$366 >> 0] = ($367 & 255) + 32;
          if (($i$0$i46 | 0) < ($$lcssa820 | 0)) $i$0$i46 = $i$0$i46 + 1 | 0; else break;
         }
         $375 = HEAP32[4044] | 0;
         $376 = HEAP32[4045] | 0;
         $377 = HEAP32[3993] | 0;
        }
        $378 = _zstrlookup($377, $375, $376 - $375 | 0, 13, 1) | 0;
        HEAP32[4322] = $378;
        HEAP32[(HEAP32[4249] | 0) + ($378 << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + ($378 << 2) >> 2];
        $386 = HEAP32[4045] | 0;
        while (1) {
         $384 = HEAP32[3993] | 0;
         $387 = HEAP8[$384 + $386 >> 0] | 0;
         $392 = HEAP32[3999] | 0;
         $393 = ($386 | 0) < ($392 | 0);
         if ((HEAP8[25877 + ($387 & 255) >> 0] | 0) == 1 & $393) {
          $396 = $386;
          while (1) {
           $395 = $396 + 1 | 0;
           HEAP32[4045] = $395;
           $398 = HEAP8[$384 + $395 >> 0] | 0;
           $403 = ($395 | 0) < ($392 | 0);
           if ($403 & (HEAP8[25877 + ($398 & 255) >> 0] | 0) == 1) $396 = $395; else {
            $$lcssa$i$i51 = $403;
            $1165 = $398;
            $1166 = $395;
            break;
           }
          }
         } else {
          $$lcssa$i$i51 = $393;
          $1165 = $387;
          $1166 = $386;
         }
         if ($$lcssa$i$i51) {
          $$lcssa812 = $384;
          $$lcssa814 = $392;
          $$lcssa816 = $1165;
          $$lcssa818 = $1166;
          break;
         }
         if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
          label = 98;
          break;
         }
         HEAP32[4146] = (HEAP32[4146] | 0) + 1;
         HEAP32[4045] = 0;
         $386 = 0;
        }
        if ((label | 0) == 98) {
         _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
         _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
         _biberrprint();
         STACKTOP = sp;
         return;
        }
        if ($$lcssa816 << 24 >> 24 != 61) {
         $416 = HEAP32[3989] | 0;
         $418 = HEAPU8[26194] | 0;
         HEAP32[$vararg_buffer76 >> 2] = 1981;
         HEAP32[$vararg_buffer76 + 4 >> 2] = $418;
         HEAP32[$vararg_buffer76 + 8 >> 2] = 34;
         _fprintf($416, 1357, $vararg_buffer76) | 0;
         $419 = HEAP32[3990] | 0;
         $421 = HEAPU8[26194] | 0;
         HEAP32[$vararg_buffer81 >> 2] = 1981;
         HEAP32[$vararg_buffer81 + 4 >> 2] = $421;
         HEAP32[$vararg_buffer81 + 8 >> 2] = 34;
         _fprintf($419, 1357, $vararg_buffer81) | 0;
         _biberrprint();
         STACKTOP = sp;
         return;
        }
        $424 = $$lcssa812;
        $431 = $$lcssa814;
        $storemerge216 = $$lcssa818 + 1 | 0;
        while (1) {
         HEAP32[4045] = $storemerge216;
         $430 = ($storemerge216 | 0) < ($431 | 0);
         if ((HEAP8[25877 + (HEAPU8[$424 + $storemerge216 >> 0] | 0) >> 0] | 0) == 1 & $430) {
          $434 = $storemerge216;
          while (1) {
           $433 = $434 + 1 | 0;
           HEAP32[4045] = $433;
           $441 = ($433 | 0) < ($431 | 0);
           if ($441 & (HEAP8[25877 + (HEAPU8[$424 + $433 >> 0] | 0) >> 0] | 0) == 1) $434 = $433; else {
            $$lcssa$i$i57 = $441;
            break;
           }
          }
         } else $$lcssa$i$i57 = $430;
         if ($$lcssa$i$i57) break;
         if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
          label = 107;
          break;
         }
         HEAP32[4146] = (HEAP32[4146] | 0) + 1;
         $424 = HEAP32[3993] | 0;
         $431 = HEAP32[3999] | 0;
         $storemerge216 = 0;
        }
        if ((label | 0) == 107) {
         _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
         _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
         _biberrprint();
         STACKTOP = sp;
         return;
        }
        HEAP32[4318] = 1;
        if (!(_scanandstorethefieldvalueandeatwhite() | 0)) {
         STACKTOP = sp;
         return;
        }
        $455 = HEAP32[4045] | 0;
        $459 = HEAP8[26647] | 0;
        if ((HEAP8[(HEAP32[3993] | 0) + $455 >> 0] | 0) == $459 << 24 >> 24) {
         HEAP32[4045] = $455 + 1;
         STACKTOP = sp;
         return;
        } else {
         $462 = HEAP32[3989] | 0;
         $465 = HEAPU8[26133 + ($459 & 255) >> 0] | 0;
         HEAP32[$vararg_buffer86 >> 2] = 5077;
         HEAP32[$vararg_buffer86 + 4 >> 2] = $465;
         HEAP32[$vararg_buffer86 + 8 >> 2] = 5123;
         _fprintf($462, 3109, $vararg_buffer86) | 0;
         $466 = HEAP32[3990] | 0;
         $471 = HEAPU8[26133 + (HEAPU8[26647] | 0) >> 0] | 0;
         HEAP32[$vararg_buffer91 >> 2] = 5077;
         HEAP32[$vararg_buffer91 + 4 >> 2] = $471;
         HEAP32[$vararg_buffer91 + 8 >> 2] = 5123;
         _fprintf($466, 3109, $vararg_buffer91) | 0;
         _biberrprint();
         STACKTOP = sp;
         return;
        }
       }
      } else $storemerge214 = 0; while (0);
      HEAP8[26389] = $storemerge214;
      _bibidprint();
      _fwrite(5109, 13, 1, HEAP32[3989] | 0) | 0;
      _fwrite(5109, 13, 1, HEAP32[3990] | 0) | 0;
      _biberrprint();
      STACKTOP = sp;
      return;
     }
    case 0:
     {
      STACKTOP = sp;
      return;
     }
    default:
     _bibcmdconfusion();
    }
   }
   HEAP32[4321] = HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa908 << 2) >> 2];
   if ($100) {
    $476 = HEAP32[4240] | 0;
    $h$06$i63 = 0;
    $k$07$i62 = $99;
    while (1) {
     $h$1$i64 = (HEAPU8[$104 + $k$07$i62 >> 0] | 0) + ($h$06$i63 << 1) | 0;
     while (1) if (($h$1$i64 | 0) < ($476 | 0)) {
      $h$1$i64$lcssa = $h$1$i64;
      break;
     } else $h$1$i64 = $h$1$i64 - $476 | 0;
     $484 = $k$07$i62 + 1 | 0;
     if (($484 | 0) < ($$pre$i24 | 0)) {
      $h$06$i63 = $h$1$i64$lcssa;
      $k$07$i62 = $484;
     } else {
      $h$0$lcssa$i65 = $h$1$i64$lcssa;
      break;
     }
    }
   } else $h$0$lcssa$i65 = 0;
   HEAP32[4241] = 0;
   $p$0$i67 = $h$0$lcssa$i65 + 1 | 0;
   L201 : while (1) {
    $488 = HEAP32[$113 + ($p$0$i67 << 2) >> 2] | 0;
    L203 : do if (($488 | 0) > 0) {
     $492 = HEAP32[$114 + ($488 + 1 << 2) >> 2] | 0;
     $494 = HEAP32[$114 + ($488 << 2) >> 2] | 0;
     if (($492 - $494 | 0) == ($98 | 0)) {
      if (($492 | 0) > ($494 | 0)) {
       $i$01$i$i71 = $99;
       $j$02$i$i70 = $494;
       while (1) {
        if ((HEAP8[$115 + $j$02$i$i70 >> 0] | 0) != (HEAP8[$104 + $i$01$i$i71 >> 0] | 0)) break L203;
        $504 = $j$02$i$i70 + 1 | 0;
        if (($504 | 0) < ($492 | 0)) {
         $i$01$i$i71 = $i$01$i$i71 + 1 | 0;
         $j$02$i$i70 = $504;
        } else break;
       }
      }
      if ((HEAP8[$116 + $p$0$i67 >> 0] | 0) == 11) {
       $p$0$i67$lcssa = $p$0$i67;
       label = 127;
       break L201;
      }
     }
    } while (0);
    $510 = HEAP32[$117 + ($p$0$i67 << 2) >> 2] | 0;
    if (!$510) {
     $p$0$i67$lcssa907 = $p$0$i67;
     label = 126;
     break;
    } else $p$0$i67 = $510;
   }
   if ((label | 0) == 126) {
    HEAP32[4678] = $p$0$i67$lcssa907;
    $storemerge218 = 0;
   } else if ((label | 0) == 127) {
    HEAP32[4241] = 1;
    HEAP32[4678] = $p$0$i67$lcssa;
    $storemerge218 = (HEAP8[(HEAP32[4144] | 0) + $p$0$i67$lcssa >> 0] | 0) == 1 & 1;
   }
   HEAP32[4679] = $storemerge218;
   $517 = $104;
   $518 = $$pre$i24;
   while (1) {
    $519 = HEAP8[$517 + $518 >> 0] | 0;
    $524 = HEAP32[3999] | 0;
    $525 = ($518 | 0) < ($524 | 0);
    if ((HEAP8[25877 + ($519 & 255) >> 0] | 0) == 1 & $525) {
     $528 = $518;
     while (1) {
      $527 = $528 + 1 | 0;
      HEAP32[4045] = $527;
      $530 = HEAP8[$517 + $527 >> 0] | 0;
      $535 = ($527 | 0) < ($524 | 0);
      if ($535 & (HEAP8[25877 + ($530 & 255) >> 0] | 0) == 1) $528 = $527; else {
       $$lcssa$i$i79 = $535;
       $1167 = $530;
       $1168 = $527;
       break;
      }
     }
    } else {
     $$lcssa$i$i79 = $525;
     $1167 = $519;
     $1168 = $518;
    }
    if ($$lcssa$i$i79) {
     $$lcssa899 = $517;
     $$lcssa901 = $524;
     $$lcssa903 = $1167;
     $$lcssa905 = $1168;
     break;
    }
    if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
     label = 134;
     break;
    }
    HEAP32[4146] = (HEAP32[4146] | 0) + 1;
    HEAP32[4045] = 0;
    $517 = HEAP32[3993] | 0;
    $518 = 0;
   }
   if ((label | 0) == 134) {
    _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
    _biberrprint();
    STACKTOP = sp;
    return;
   }
   switch ($$lcssa903 << 24 >> 24) {
   case 123:
    {
     $storemerge = 125;
     break;
    }
   case 40:
    {
     $storemerge = 41;
     break;
    }
   default:
    {
     $547 = HEAP32[3989] | 0;
     $549 = HEAPU8[26256] | 0;
     $551 = HEAPU8[26173] | 0;
     HEAP32[$vararg_buffer96 >> 2] = 1952;
     HEAP32[$vararg_buffer96 + 4 >> 2] = $549;
     HEAP32[$vararg_buffer96 + 8 >> 2] = 1972;
     HEAP32[$vararg_buffer96 + 12 >> 2] = $551;
     HEAP32[$vararg_buffer96 + 16 >> 2] = 39;
     _fprintf($547, 1941, $vararg_buffer96) | 0;
     $552 = HEAP32[3990] | 0;
     $554 = HEAPU8[26256] | 0;
     $556 = HEAPU8[26173] | 0;
     HEAP32[$vararg_buffer103 >> 2] = 1952;
     HEAP32[$vararg_buffer103 + 4 >> 2] = $554;
     HEAP32[$vararg_buffer103 + 8 >> 2] = 1972;
     HEAP32[$vararg_buffer103 + 12 >> 2] = $556;
     HEAP32[$vararg_buffer103 + 16 >> 2] = 39;
     _fprintf($552, 1941, $vararg_buffer103) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    }
   }
   HEAP8[26647] = $storemerge;
   $$pre3$pre$i = $$lcssa901;
   $559 = $$lcssa899;
   $storemerge219 = $$lcssa905 + 1 | 0;
   while (1) {
    HEAP32[4045] = $storemerge219;
    $565 = ($storemerge219 | 0) < ($$pre3$pre$i | 0);
    if ((HEAP8[25877 + (HEAPU8[$559 + $storemerge219 >> 0] | 0) >> 0] | 0) == 1 & $565) {
     $568 = $storemerge219;
     while (1) {
      $567 = $568 + 1 | 0;
      HEAP32[4045] = $567;
      $575 = ($567 | 0) < ($$pre3$pre$i | 0);
      if ($575 & (HEAP8[25877 + (HEAPU8[$559 + $567 >> 0] | 0) >> 0] | 0) == 1) $568 = $567; else {
       $$lcssa$i$i85 = $575;
       $1169 = $567;
       break;
      }
     }
    } else {
     $$lcssa$i$i85 = $565;
     $1169 = $storemerge219;
    }
    if ($$lcssa$i$i85) {
     $$lcssa892 = $559;
     $$lcssa894 = $1169;
     $$pre3$pre$i$lcssa = $$pre3$pre$i;
     break;
    }
    if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
     label = 144;
     break;
    }
    HEAP32[4146] = (HEAP32[4146] | 0) + 1;
    $$pre3$pre$i = HEAP32[3999] | 0;
    $559 = HEAP32[3993] | 0;
    $storemerge219 = 0;
   }
   if ((label | 0) == 144) {
    _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
    _biberrprint();
    STACKTOP = sp;
    return;
   }
   $588 = (HEAP8[26647] | 0) == 41;
   HEAP32[4044] = $$lcssa894;
   $590 = HEAP8[$$lcssa892 + $$lcssa894 >> 0] | 0;
   L245 : do if ($588) if ($590 << 24 >> 24 == 44 ? 1 : (HEAP8[25877 + ($590 & 255) >> 0] | 0) == 1) $617 = $$lcssa894; else {
    $596 = $$lcssa894;
    while (1) {
     if (($596 | 0) >= ($$pre3$pre$i$lcssa | 0)) {
      $617 = $596;
      break L245;
     }
     $598 = $596 + 1 | 0;
     HEAP32[4045] = $598;
     $600 = HEAP8[$$lcssa892 + $598 >> 0] | 0;
     if ($600 << 24 >> 24 == 44 ? 1 : (HEAP8[25877 + ($600 & 255) >> 0] | 0) == 1) {
      $617 = $598;
      break;
     } else $596 = $598;
    }
   } else {
    switch ($590 << 24 >> 24) {
    case 44:
    case 125:
     {
      $617 = $$lcssa894;
      break L245;
      break;
     }
    default:
     {
      $607 = $590;
      $611 = $$lcssa894;
     }
    }
    while (1) {
     if (!(($611 | 0) < ($$pre3$pre$i$lcssa | 0) ? (HEAP8[25877 + ($607 & 255) >> 0] | 0) != 1 : 0)) {
      $617 = $611;
      break L245;
     }
     $613 = $611 + 1 | 0;
     HEAP32[4045] = $613;
     $615 = HEAP8[$$lcssa892 + $613 >> 0] | 0;
     switch ($615 << 24 >> 24) {
     case 44:
     case 125:
      {
       $617 = $613;
       break L245;
       break;
      }
     default:
      {
       $607 = $615;
       $611 = $613;
      }
     }
    }
   } while (0);
   HEAP32[4252] = $$lcssa894;
   if (($$lcssa894 | 0) < ($617 | 0)) {
    HEAP8[(HEAP32[3995] | 0) + $$lcssa894 >> 0] = HEAP8[$$lcssa892 + $$lcssa894 >> 0] | 0;
    $623 = (HEAP32[4252] | 0) + 1 | 0;
    HEAP32[4252] = $623;
    $624 = HEAP32[4045] | 0;
    if (($623 | 0) < ($624 | 0)) {
     $627 = $623;
     while (1) {
      HEAP8[(HEAP32[3995] | 0) + $627 >> 0] = HEAP8[(HEAP32[3993] | 0) + $627 >> 0] | 0;
      $632 = (HEAP32[4252] | 0) + 1 | 0;
      HEAP32[4252] = $632;
      $633 = HEAP32[4045] | 0;
      if (($632 | 0) < ($633 | 0)) $627 = $632; else {
       $$lcssa608 = $633;
       break;
      }
     }
    } else $$lcssa608 = $624;
    $$lcssa256 = $$lcssa608;
    $637 = HEAP32[4044] | 0;
   } else {
    $$lcssa256 = $617;
    $637 = $$lcssa894;
   }
   $635 = HEAP32[3995] | 0;
   if (($$lcssa256 | 0) > ($637 | 0)) {
    $638 = $$lcssa256 + -1 | 0;
    $i$0$i97 = $637;
    while (1) {
     $639 = $635 + $i$0$i97 | 0;
     $640 = HEAP8[$639 >> 0] | 0;
     if (($640 + -65 & 255) < 26) HEAP8[$639 >> 0] = ($640 & 255) + 32;
     if (($i$0$i97 | 0) < ($638 | 0)) $i$0$i97 = $i$0$i97 + 1 | 0; else break;
    }
    $650 = HEAP32[4044] | 0;
    $651 = HEAP32[4045] | 0;
    $656 = HEAP32[3995] | 0;
   } else {
    $650 = $637;
    $651 = $$lcssa256;
    $656 = $635;
   }
   $649 = $651 - $650 | 0;
   do if (!(HEAP32[4328] | 0)) {
    if (($649 | 0) > 0) {
     $653 = HEAP32[4240] | 0;
     $h$06$i102 = 0;
     $k$07$i101 = $650;
     while (1) {
      $h$1$i103 = (HEAPU8[$656 + $k$07$i101 >> 0] | 0) + ($h$06$i102 << 1) | 0;
      while (1) if (($h$1$i103 | 0) < ($653 | 0)) {
       $h$1$i103$lcssa = $h$1$i103;
       break;
      } else $h$1$i103 = $h$1$i103 - $653 | 0;
      $662 = $k$07$i101 + 1 | 0;
      if (($662 | 0) < ($651 | 0)) {
       $h$06$i102 = $h$1$i103$lcssa;
       $k$07$i101 = $662;
      } else {
       $h$0$lcssa$i104 = $h$1$i103$lcssa;
       break;
      }
     }
    } else $h$0$lcssa$i104 = 0;
    HEAP32[4241] = 0;
    $665 = HEAP32[4145] | 0;
    $666 = HEAP32[4041] | 0;
    $667 = HEAP32[4042] | 0;
    $668 = HEAP32[4242] | 0;
    $669 = HEAP32[4243] | 0;
    $p$0$i106 = $h$0$lcssa$i104 + 1 | 0;
    L281 : while (1) {
     $671 = HEAP32[$665 + ($p$0$i106 << 2) >> 2] | 0;
     L283 : do if (($671 | 0) > 0) {
      $675 = HEAP32[$666 + ($671 + 1 << 2) >> 2] | 0;
      $677 = HEAP32[$666 + ($671 << 2) >> 2] | 0;
      if (($675 - $677 | 0) == ($649 | 0)) {
       if (($675 | 0) > ($677 | 0)) {
        $i$01$i$i110 = $650;
        $j$02$i$i109 = $677;
        while (1) {
         if ((HEAP8[$667 + $j$02$i$i109 >> 0] | 0) != (HEAP8[$656 + $i$01$i$i110 >> 0] | 0)) break L283;
         $687 = $j$02$i$i109 + 1 | 0;
         if (($687 | 0) < ($675 | 0)) {
          $i$01$i$i110 = $i$01$i$i110 + 1 | 0;
          $j$02$i$i109 = $687;
         } else break;
        }
       }
       if ((HEAP8[$668 + $p$0$i106 >> 0] | 0) == 10) {
        $p$0$i106$lcssa = $p$0$i106;
        label = 175;
        break L281;
       }
      }
     } while (0);
     $693 = HEAP32[$669 + ($p$0$i106 << 2) >> 2] | 0;
     if (!$693) {
      $p$0$i106$lcssa887 = $p$0$i106;
      label = 177;
      break;
     } else $p$0$i106 = $693;
    }
    if ((label | 0) == 175) {
     HEAP32[4241] = 1;
     HEAP32[4250] = $p$0$i106$lcssa;
     $$pr202338 = 1;
     $703 = 0;
     $storemerge2200 = $p$0$i106$lcssa;
     label = 180;
     break;
    } else if ((label | 0) == 177) {
     HEAP32[4250] = $p$0$i106$lcssa887;
     $844 = 0;
     break;
    }
   } else {
    $695 = _zstrlookup($656, $650, $649, 10, 1) | 0;
    $$pr199$pre = HEAP32[4241] | 0;
    HEAP32[4250] = $695;
    if (!$$pr199$pre) $844 = 0; else {
     $$pr202338 = $$pr199$pre;
     $703 = HEAP32[4328] | 0;
     $storemerge2200 = $695;
     label = 180;
    }
   } while (0);
   L297 : do if ((label | 0) == 180) {
    $697 = HEAP32[4249] | 0;
    $701 = HEAP32[$697 + (HEAP32[$697 + ($storemerge2200 << 2) >> 2] << 2) >> 2] | 0;
    HEAP32[4326] = $701;
    $notlhs = ($703 | 0) != 0;
    $705 = ($701 | 0) < (HEAP32[4329] | 0);
    do if ($notlhs & ($701 | 0) >= (HEAP32[4671] | 0) & $705) if (!(HEAP32[(HEAP32[4101] | 0) + ($701 << 2) >> 2] | 0)) {
     HEAP32[4251] = 0;
     $734 = HEAP32[4102] | 0;
     $735 = $734 + ($701 << 2) | 0;
     $737 = HEAP32[4041] | 0;
     $739 = HEAP32[$737 + (HEAP32[$735 >> 2] << 2) >> 2] | 0;
     HEAP32[4252] = $739;
     $743 = HEAP32[$737 + ((HEAP32[$735 >> 2] | 0) + 1 << 2) >> 2] | 0;
     HEAP32[4253] = $743;
     if (($739 | 0) < ($743 | 0)) {
      $747 = $739;
      $751 = 0;
      while (1) {
       HEAP8[(HEAP32[3995] | 0) + $751 >> 0] = HEAP8[(HEAP32[4042] | 0) + $747 >> 0] | 0;
       $753 = (HEAP32[4251] | 0) + 1 | 0;
       HEAP32[4251] = $753;
       $755 = (HEAP32[4252] | 0) + 1 | 0;
       HEAP32[4252] = $755;
       if (($755 | 0) < (HEAP32[4253] | 0)) {
        $747 = $755;
        $751 = $753;
       } else break;
      }
      $760 = HEAP32[4102] | 0;
      $761 = HEAP32[4326] | 0;
      $765 = HEAP32[4041] | 0;
     } else {
      $760 = $734;
      $761 = $701;
      $765 = $737;
     }
     $758 = HEAP32[3995] | 0;
     $762 = HEAP32[$760 + ($761 << 2) >> 2] | 0;
     $768 = HEAP32[$765 + ($762 << 2) >> 2] | 0;
     $769 = (HEAP32[$765 + ($762 + 1 << 2) >> 2] | 0) - $768 | 0;
     if (($769 | 0) > 0) {
      $771 = $769 + -1 | 0;
      $i$0$i116 = 0;
      while (1) {
       $772 = $758 + $i$0$i116 | 0;
       $773 = HEAP8[$772 >> 0] | 0;
       if (($773 + -65 & 255) < 26) HEAP8[$772 >> 0] = ($773 & 255) + 32;
       if (($i$0$i116 | 0) < ($771 | 0)) $i$0$i116 = $i$0$i116 + 1 | 0; else break;
      }
      $$pre331 = HEAP32[4326] | 0;
      $$pre333 = HEAP32[(HEAP32[4102] | 0) + ($$pre331 << 2) >> 2] | 0;
      $$pre334 = HEAP32[4041] | 0;
      $1170 = $$pre331;
      $781 = $$pre333;
      $783 = $$pre334;
      $786 = HEAP32[$$pre334 + ($$pre333 << 2) >> 2] | 0;
      $791 = HEAP32[3995] | 0;
     } else {
      $1170 = $761;
      $781 = $762;
      $783 = $765;
      $786 = $768;
      $791 = $758;
     }
     $785 = (HEAP32[$783 + ($781 + 1 << 2) >> 2] | 0) - $786 | 0;
     if (($785 | 0) > 0) {
      $788 = HEAP32[4240] | 0;
      $h$06$i121 = 0;
      $k$07$i120 = 0;
      while (1) {
       $h$1$i122 = (HEAPU8[$791 + $k$07$i120 >> 0] | 0) + ($h$06$i121 << 1) | 0;
       while (1) if (($h$1$i122 | 0) < ($788 | 0)) {
        $h$1$i122$lcssa = $h$1$i122;
        break;
       } else $h$1$i122 = $h$1$i122 - $788 | 0;
       $797 = $k$07$i120 + 1 | 0;
       if (($797 | 0) == ($785 | 0)) {
        $h$0$lcssa$i123 = $h$1$i122$lcssa;
        break;
       } else {
        $h$06$i121 = $h$1$i122$lcssa;
        $k$07$i120 = $797;
       }
      }
     } else $h$0$lcssa$i123 = 0;
     HEAP32[4241] = 0;
     $799 = HEAP32[4145] | 0;
     $800 = HEAP32[4042] | 0;
     $801 = HEAP32[4242] | 0;
     $802 = HEAP32[4243] | 0;
     $p$0$i125 = $h$0$lcssa$i123 + 1 | 0;
     L324 : while (1) {
      $804 = HEAP32[$799 + ($p$0$i125 << 2) >> 2] | 0;
      L326 : do if (($804 | 0) > 0) {
       $808 = HEAP32[$783 + ($804 + 1 << 2) >> 2] | 0;
       $810 = HEAP32[$783 + ($804 << 2) >> 2] | 0;
       if (($808 - $810 | 0) != ($785 | 0)) break;
       if (($808 | 0) > ($810 | 0)) {
        $i$01$i$i129 = 0;
        $j$02$i$i128 = $810;
        while (1) {
         if ((HEAP8[$800 + $j$02$i$i128 >> 0] | 0) != (HEAP8[$791 + $i$01$i$i129 >> 0] | 0)) break L326;
         $820 = $j$02$i$i128 + 1 | 0;
         if (($820 | 0) < ($808 | 0)) {
          $i$01$i$i129 = $i$01$i$i129 + 1 | 0;
          $j$02$i$i128 = $820;
         } else break;
        }
       }
       if ((HEAP8[$801 + $p$0$i125 >> 0] | 0) == 10) {
        $p$0$i125$lcssa = $p$0$i125;
        label = 209;
        break L324;
       }
      } while (0);
      $826 = HEAP32[$802 + ($p$0$i125 << 2) >> 2] | 0;
      if (!$826) {
       $p$0$i125$lcssa886 = $p$0$i125;
       label = 208;
       break;
      } else $p$0$i125 = $826;
     }
     if ((label | 0) == 208) {
      HEAP32[4680] = $p$0$i125$lcssa886;
      _citekeydisappearedconfusion();
     } else if ((label | 0) == 209) {
      HEAP32[4241] = 1;
      HEAP32[4680] = $p$0$i125$lcssa;
      if (($p$0$i125$lcssa | 0) == (HEAP32[4250] | 0)) {
       $844 = 1;
       break L297;
      } else {
       $832 = $1170;
       break;
      }
     }
    } else $832 = $701; else if (!(HEAP32[(HEAP32[4100] | 0) + ($701 << 2) >> 2] | 0)) {
     if ($notlhs | $705) {
      $844 = $$pr202338;
      break L297;
     }
     $711 = HEAP32[4044] | 0;
     $714 = _zstrlookup(HEAP32[3993] | 0, $711, (HEAP32[4045] | 0) - $711 | 0, 9, 1) | 0;
     HEAP32[4248] = $714;
     $715 = HEAP32[4241] | 0;
     if ($715 | 0) {
      $844 = $715;
      break L297;
     }
     $718 = HEAP32[4249] | 0;
     HEAP32[$718 + (HEAP32[4250] << 2) >> 2] = $714;
     HEAP32[$718 + (HEAP32[4248] << 2) >> 2] = HEAP32[4326];
     HEAP32[(HEAP32[4099] | 0) + (HEAP32[4326] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4248] << 2) >> 2];
     HEAP32[4241] = 1;
     $844 = 1;
     break L297;
    } else $832 = $701; while (0);
    $835 = HEAP32[3989] | 0;
    if (!(HEAP32[(HEAP32[4100] | 0) + ($832 << 2) >> 2] | 0)) {
     _fwrite(5143, 26, 1, $835) | 0;
     _fwrite(5143, 26, 1, HEAP32[3990] | 0) | 0;
     $837 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer110 >> 2] = 964;
     _fprintf($837, 960, $vararg_buffer110) | 0;
     $838 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer113 >> 2] = 964;
     _fprintf($838, 960, $vararg_buffer113) | 0;
     $839 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer116 >> 2] = 985;
     _fprintf($839, 960, $vararg_buffer116) | 0;
     $840 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer119 >> 2] = 985;
     _fprintf($840, 960, $vararg_buffer119) | 0;
     HEAP8[25620] = 3;
     _longjmp(16008, 1);
    }
    _fwrite(5170, 14, 1, $835) | 0;
    _fwrite(5170, 14, 1, HEAP32[3990] | 0) | 0;
    _biberrprint();
    STACKTOP = sp;
    return;
   } while (0);
   HEAP32[4681] = 1;
   $845 = ($844 | 0) != 0;
   do if (!(HEAP32[4328] | 0)) if ($845) label = 222; else HEAP32[4681] = 0; else {
    if ($845) {
     $846 = HEAP32[4326] | 0;
     if (($846 | 0) < (HEAP32[4671] | 0)) {
      label = 222;
      break;
     }
     HEAP32[(HEAP32[4101] | 0) + ($846 << 2) >> 2] = 1;
     HEAP32[4248] = HEAP32[(HEAP32[4249] | 0) + (HEAP32[4250] << 2) >> 2];
    } else {
     $856 = HEAP32[4044] | 0;
     HEAP32[4248] = _zstrlookup(HEAP32[3993] | 0, $856, (HEAP32[4045] | 0) - $856 | 0, 9, 1) | 0;
     if (HEAP32[4241] | 0) _hashciteconfusion();
    }
    HEAP32[4326] = HEAP32[4150];
    _zzadddatabasecite(16600);
    if (HEAP32[4681] | 0) label = 222;
   } while (0);
   L358 : do if ((label | 0) == 222) {
    if (HEAP32[4679] | 0) {
     HEAP32[(HEAP32[4100] | 0) + (HEAP32[4326] << 2) >> 2] = HEAP32[4678];
     break;
    }
    HEAP32[(HEAP32[4100] | 0) + (HEAP32[4326] << 2) >> 2] = HEAP32[4386];
    _fwrite(5185, 25, 1, HEAP32[3989] | 0) | 0;
    _fwrite(5185, 25, 1, HEAP32[3990] | 0) | 0;
    $876 = HEAP32[3990] | 0;
    $877 = HEAP32[4044] | 0;
    $878 = HEAP32[4045] | 0;
    if (($877 | 0) < ($878 | 0)) {
     $i$01$i$i135 = $877;
     while (1) {
      _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i$i135 >> 0] | 0) >> 0] | 0, $876) | 0;
      $887 = $i$01$i$i135 + 1 | 0;
      $888 = HEAP32[4045] | 0;
      if (($887 | 0) < ($888 | 0)) $i$01$i$i135 = $887; else {
       $$lcssa885 = $888;
       break;
      }
     }
     $891 = HEAP32[4044] | 0;
     $893 = $$lcssa885;
    } else {
     $891 = $877;
     $893 = $878;
    }
    $890 = HEAP32[3989] | 0;
    if (($891 | 0) < ($893 | 0)) {
     $i$01$i1$i = $891;
     while (1) {
      _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $890) | 0;
      $901 = $i$01$i1$i + 1 | 0;
      if (($901 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $901; else break;
     }
     $904 = HEAP32[3989] | 0;
    } else $904 = $890;
    HEAP32[$vararg_buffer122 >> 2] = 5211;
    _fprintf($904, 960, $vararg_buffer122) | 0;
    $905 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer125 >> 2] = 5211;
    _fprintf($905, 960, $vararg_buffer125) | 0;
    _biblnnumprint();
    switch (HEAP8[25620] | 0) {
    case 1:
     {
      HEAP32[3991] = (HEAP32[3991] | 0) + 1;
      break L358;
      break;
     }
    case 0:
     {
      HEAP8[25620] = 1;
      HEAP32[3991] = 1;
      break L358;
      break;
     }
    default:
     break L358;
    }
   } while (0);
   $911 = HEAP32[4045] | 0;
   while (1) {
    $909 = HEAP32[3993] | 0;
    $917 = HEAP32[3999] | 0;
    $918 = ($911 | 0) < ($917 | 0);
    if ((HEAP8[25877 + (HEAPU8[$909 + $911 >> 0] | 0) >> 0] | 0) == 1 & $918) {
     $921 = $911;
     while (1) {
      $920 = $921 + 1 | 0;
      HEAP32[4045] = $920;
      $928 = ($920 | 0) < ($917 | 0);
      if ($928 & (HEAP8[25877 + (HEAPU8[$909 + $920 >> 0] | 0) >> 0] | 0) == 1) $921 = $920; else {
       $$lcssa$i$i140 = $928;
       $1171 = $920;
       break;
      }
     }
    } else {
     $$lcssa$i$i140 = $918;
     $1171 = $911;
    }
    if ($$lcssa$i$i140) {
     $$lcssa881 = $909;
     $$lcssa883 = $1171;
     break;
    }
    if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
     label = 240;
     break;
    }
    HEAP32[4146] = (HEAP32[4146] | 0) + 1;
    HEAP32[4045] = 0;
    $911 = 0;
   }
   if ((label | 0) == 240) {
    _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
    _biberrprint();
    STACKTOP = sp;
    return;
   }
   $931 = HEAP8[$$lcssa881 + $$lcssa883 >> 0] | 0;
   $932 = HEAP8[26647] | 0;
   L389 : do if ($931 << 24 >> 24 == $932 << 24 >> 24) $1156 = $$lcssa883; else {
    $1172 = $932;
    $1173 = $$lcssa881;
    $944 = $931;
    $959 = $$lcssa883;
    L390 : while (1) {
     if ($944 << 24 >> 24 != 44) {
      $$lcssa871 = $1172;
      label = 242;
      break;
     }
     $961 = $1173;
     $storemerge220 = $959 + 1 | 0;
     while (1) {
      HEAP32[4045] = $storemerge220;
      $962 = HEAP8[$961 + $storemerge220 >> 0] | 0;
      $967 = HEAP32[3999] | 0;
      $968 = ($storemerge220 | 0) < ($967 | 0);
      if ((HEAP8[25877 + ($962 & 255) >> 0] | 0) == 1 & $968) {
       $971 = $storemerge220;
       while (1) {
        $970 = $971 + 1 | 0;
        HEAP32[4045] = $970;
        $973 = HEAP8[$961 + $970 >> 0] | 0;
        $978 = ($970 | 0) < ($967 | 0);
        if ($978 & (HEAP8[25877 + ($973 & 255) >> 0] | 0) == 1) $971 = $970; else {
         $$lcssa$i$i146 = $978;
         $1174 = $973;
         $1175 = $970;
         break;
        }
       }
      } else {
       $$lcssa$i$i146 = $968;
       $1174 = $962;
       $1175 = $storemerge220;
      }
      if ($$lcssa$i$i146) {
       $$lcssa846 = $961;
       $$lcssa848 = $967;
       $$lcssa850 = $1174;
       $$lcssa852 = $1175;
       break;
      }
      if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
       label = 249;
       break L390;
      }
      HEAP32[4146] = (HEAP32[4146] | 0) + 1;
      $961 = HEAP32[3993] | 0;
      $storemerge220 = 0;
     }
     if ($$lcssa850 << 24 >> 24 == (HEAP8[26647] | 0)) {
      $1156 = $$lcssa852;
      break L389;
     }
     HEAP32[4044] = $$lcssa852;
     $994 = HEAPU8[$$lcssa846 + $$lcssa852 >> 0] | 0;
     if ((HEAP8[25877 + $994 >> 0] | 0) == 3) {
      $storemerge221 = 0;
      label = 257;
      break;
     }
     if ((HEAP8[26390 + $994 >> 0] | 0) == 1 & ($$lcssa852 | 0) < ($$lcssa848 | 0)) $1003 = $$lcssa852; else {
      $storemerge221 = 0;
      label = 257;
      break;
     }
     while (1) {
      $1002 = $1003 + 1 | 0;
      HEAP32[4045] = $1002;
      $1005 = HEAP8[$$lcssa846 + $1002 >> 0] | 0;
      $1006 = $1005 & 255;
      if (($1002 | 0) < ($$lcssa848 | 0) & (HEAP8[26390 + $1006 >> 0] | 0) == 1) $1003 = $1002; else {
       $$lcssa854 = $1003;
       $$lcssa855 = $1002;
       $$lcssa856 = $1005;
       $$lcssa857 = $1006;
       break;
      }
     }
     if (($$lcssa855 | 0) == ($$lcssa852 | 0)) {
      $storemerge221 = 0;
      label = 257;
      break;
     }
     if ((HEAP8[25877 + $$lcssa857 >> 0] | 0) == 1 | ($$lcssa855 | 0) == ($$lcssa848 | 0)) $storemerge222 = 3; else if ($$lcssa856 << 24 >> 24 == 61) $storemerge222 = 1; else {
      $storemerge221 = 2;
      label = 257;
      break;
     }
     HEAP8[26389] = $storemerge222;
     HEAP32[4318] = 0;
     do if (!(HEAP32[4681] | 0)) {
      $1081 = $$lcssa846;
      $1082 = $$lcssa855;
     } else {
      if (($$lcssa854 | 0) < ($$lcssa852 | 0)) {
       $1031 = $$lcssa852;
       $1032 = $$lcssa855;
       $1037 = $$lcssa846;
      } else {
       $i$0$i160 = $$lcssa852;
       while (1) {
        $1022 = $$lcssa846 + $i$0$i160 | 0;
        $1023 = HEAP8[$1022 >> 0] | 0;
        if (($1023 + -65 & 255) < 26) HEAP8[$1022 >> 0] = ($1023 & 255) + 32;
        if (($i$0$i160 | 0) < ($$lcssa854 | 0)) $i$0$i160 = $i$0$i160 + 1 | 0; else break;
       }
       $1031 = HEAP32[4044] | 0;
       $1032 = HEAP32[4045] | 0;
       $1037 = HEAP32[3993] | 0;
      }
      $1030 = $1032 - $1031 | 0;
      if (($1030 | 0) > 0) {
       $1034 = HEAP32[4240] | 0;
       $h$06$i165 = 0;
       $k$07$i164 = $1031;
       while (1) {
        $h$1$i166 = (HEAPU8[$1037 + $k$07$i164 >> 0] | 0) + ($h$06$i165 << 1) | 0;
        while (1) if (($h$1$i166 | 0) < ($1034 | 0)) {
         $h$1$i166$lcssa = $h$1$i166;
         break;
        } else $h$1$i166 = $h$1$i166 - $1034 | 0;
        $1043 = $k$07$i164 + 1 | 0;
        if (($1043 | 0) < ($1032 | 0)) {
         $h$06$i165 = $h$1$i166$lcssa;
         $k$07$i164 = $1043;
        } else {
         $h$0$lcssa$i167 = $h$1$i166$lcssa;
         break;
        }
       }
      } else $h$0$lcssa$i167 = 0;
      HEAP32[4241] = 0;
      $1046 = HEAP32[4145] | 0;
      $1047 = HEAP32[4041] | 0;
      $1048 = HEAP32[4042] | 0;
      $1049 = HEAP32[4242] | 0;
      $1050 = HEAP32[4243] | 0;
      $p$0$i169 = $h$0$lcssa$i167 + 1 | 0;
      L429 : while (1) {
       $1052 = HEAP32[$1046 + ($p$0$i169 << 2) >> 2] | 0;
       L431 : do if (($1052 | 0) > 0) {
        $1056 = HEAP32[$1047 + ($1052 + 1 << 2) >> 2] | 0;
        $1058 = HEAP32[$1047 + ($1052 << 2) >> 2] | 0;
        if (($1056 - $1058 | 0) != ($1030 | 0)) break;
        if (($1056 | 0) > ($1058 | 0)) {
         $i$01$i$i173 = $1031;
         $j$02$i$i172 = $1058;
         while (1) {
          if ((HEAP8[$1048 + $j$02$i$i172 >> 0] | 0) != (HEAP8[$1037 + $i$01$i$i173 >> 0] | 0)) break L431;
          $1068 = $j$02$i$i172 + 1 | 0;
          if (($1068 | 0) < ($1056 | 0)) {
           $i$01$i$i173 = $i$01$i$i173 + 1 | 0;
           $j$02$i$i172 = $1068;
          } else break;
         }
        }
        if ((HEAP8[$1049 + $p$0$i169 >> 0] | 0) == 11) {
         $p$0$i169$lcssa = $p$0$i169;
         break L429;
        }
       } while (0);
       $1074 = HEAP32[$1050 + ($p$0$i169 << 2) >> 2] | 0;
       if (!$1074) {
        $p$0$i169$lcssa858 = $p$0$i169;
        label = 277;
        break;
       } else $p$0$i169 = $1074;
      }
      if ((label | 0) == 277) {
       label = 0;
       HEAP32[4327] = $p$0$i169$lcssa858;
       $1081 = $1037;
       $1082 = $1032;
       break;
      }
      HEAP32[4241] = 1;
      HEAP32[4327] = $p$0$i169$lcssa;
      if ((HEAP8[(HEAP32[4144] | 0) + $p$0$i169$lcssa >> 0] | 0) != 4) {
       $1081 = $1037;
       $1082 = $1032;
       break;
      }
      HEAP32[4318] = 1;
      $1081 = $1037;
      $1082 = $1032;
     } while (0);
     while (1) {
      $1083 = HEAP8[$1081 + $1082 >> 0] | 0;
      $1088 = HEAP32[3999] | 0;
      $1089 = ($1082 | 0) < ($1088 | 0);
      if ((HEAP8[25877 + ($1083 & 255) >> 0] | 0) == 1 & $1089) {
       $1092 = $1082;
       while (1) {
        $1091 = $1092 + 1 | 0;
        HEAP32[4045] = $1091;
        $1094 = HEAP8[$1081 + $1091 >> 0] | 0;
        $1099 = ($1091 | 0) < ($1088 | 0);
        if ($1099 & (HEAP8[25877 + ($1094 & 255) >> 0] | 0) == 1) $1092 = $1091; else {
         $$lcssa$i$i181 = $1099;
         $1176 = $1094;
         $1177 = $1091;
         break;
        }
       }
      } else {
       $$lcssa$i$i181 = $1089;
       $1176 = $1083;
       $1177 = $1082;
      }
      if ($$lcssa$i$i181) {
       $$lcssa862 = $1081;
       $$lcssa864 = $1088;
       $$lcssa866 = $1176;
       $$lcssa868 = $1177;
       break;
      }
      if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
       label = 285;
       break L390;
      }
      HEAP32[4146] = (HEAP32[4146] | 0) + 1;
      HEAP32[4045] = 0;
      $1081 = HEAP32[3993] | 0;
      $1082 = 0;
     }
     if ($$lcssa866 << 24 >> 24 != 61) {
      label = 287;
      break;
     }
     $1120 = $$lcssa862;
     $1127 = $$lcssa864;
     $storemerge223 = $$lcssa868 + 1 | 0;
     while (1) {
      HEAP32[4045] = $storemerge223;
      $1126 = ($storemerge223 | 0) < ($1127 | 0);
      if ((HEAP8[25877 + (HEAPU8[$1120 + $storemerge223 >> 0] | 0) >> 0] | 0) == 1 & $1126) {
       $1130 = $storemerge223;
       while (1) {
        $1129 = $1130 + 1 | 0;
        HEAP32[4045] = $1129;
        $1137 = ($1129 | 0) < ($1127 | 0);
        if ($1137 & (HEAP8[25877 + (HEAPU8[$1120 + $1129 >> 0] | 0) >> 0] | 0) == 1) $1130 = $1129; else {
         $$lcssa$i$i187 = $1137;
         break;
        }
       }
      } else $$lcssa$i$i187 = $1126;
      if ($$lcssa$i$i187) break;
      if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
       label = 294;
       break L390;
      }
      HEAP32[4146] = (HEAP32[4146] | 0) + 1;
      $1120 = HEAP32[3993] | 0;
      $1127 = HEAP32[3999] | 0;
      $storemerge223 = 0;
     }
     if (!(_scanandstorethefieldvalueandeatwhite() | 0)) {
      label = 298;
      break;
     }
     $$pre342 = HEAP32[4045] | 0;
     $$pre343 = HEAP32[3993] | 0;
     $1152 = HEAP8[$$pre343 + $$pre342 >> 0] | 0;
     $1153 = HEAP8[26647] | 0;
     if ($1152 << 24 >> 24 == $1153 << 24 >> 24) {
      $1156 = $$pre342;
      break L389;
     } else {
      $1172 = $1153;
      $1173 = $$pre343;
      $944 = $1152;
      $959 = $$pre342;
     }
    }
    if ((label | 0) == 242) {
     $946 = HEAP32[3989] | 0;
     $948 = HEAPU8[26177] | 0;
     $950 = 26133 + ($$lcssa871 & 255) | 0;
     $952 = HEAPU8[$950 >> 0] | 0;
     HEAP32[$vararg_buffer128 >> 2] = 1952;
     HEAP32[$vararg_buffer128 + 4 >> 2] = $948;
     HEAP32[$vararg_buffer128 + 8 >> 2] = 1972;
     HEAP32[$vararg_buffer128 + 12 >> 2] = $952;
     HEAP32[$vararg_buffer128 + 16 >> 2] = 39;
     _fprintf($946, 1941, $vararg_buffer128) | 0;
     $953 = HEAP32[3990] | 0;
     $955 = HEAPU8[26177] | 0;
     $957 = HEAPU8[$950 >> 0] | 0;
     HEAP32[$vararg_buffer135 >> 2] = 1952;
     HEAP32[$vararg_buffer135 + 4 >> 2] = $955;
     HEAP32[$vararg_buffer135 + 8 >> 2] = 1972;
     HEAP32[$vararg_buffer135 + 12 >> 2] = $957;
     HEAP32[$vararg_buffer135 + 16 >> 2] = 39;
     _fprintf($953, 1941, $vararg_buffer135) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 249) {
     _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
     _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 257) {
     HEAP8[26389] = $storemerge221;
     _bibidprint();
     _fwrite(5238, 12, 1, HEAP32[3989] | 0) | 0;
     _fwrite(5238, 12, 1, HEAP32[3990] | 0) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 285) {
     _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
     _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 287) {
     $1112 = HEAP32[3989] | 0;
     $1114 = HEAPU8[26194] | 0;
     HEAP32[$vararg_buffer142 >> 2] = 1981;
     HEAP32[$vararg_buffer142 + 4 >> 2] = $1114;
     HEAP32[$vararg_buffer142 + 8 >> 2] = 34;
     _fprintf($1112, 1357, $vararg_buffer142) | 0;
     $1115 = HEAP32[3990] | 0;
     $1117 = HEAPU8[26194] | 0;
     HEAP32[$vararg_buffer147 >> 2] = 1981;
     HEAP32[$vararg_buffer147 + 4 >> 2] = $1117;
     HEAP32[$vararg_buffer147 + 8 >> 2] = 34;
     _fprintf($1115, 1357, $vararg_buffer147) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 294) {
     _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
     _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
     _biberrprint();
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 298) {
     STACKTOP = sp;
     return;
    }
   } while (0);
   HEAP32[4045] = $1156 + 1;
   STACKTOP = sp;
   return;
  }
 } else $storemerge211 = 0; while (0);
 HEAP8[26389] = $storemerge211;
 _bibidprint();
 _fwrite(5063, 13, 1, HEAP32[3989] | 0) | 0;
 _fwrite(5063, 13, 1, HEAP32[3990] | 0) | 0;
 _biberrprint();
 STACKTOP = sp;
 return;
}
function _kpathsea_init_format_return_varlist($kpse, $format) {
 $kpse = $kpse | 0;
 $format = $format | 0;
 var $0 = 0, $1 = 0, $101 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $110 = 0, $111 = 0, $113 = 0, $114 = 0, $117 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $125 = 0, $126 = 0, $128 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $139 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $150 = 0, $151 = 0, $153 = 0, $154 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $163 = 0, $165 = 0, $166 = 0, $168 = 0, $169 = 0, $17 = 0, $172 = 0, $174 = 0, $175 = 0, $177 = 0, $179 = 0, $18 = 0, $180 = 0, $182 = 0, $183 = 0, $185 = 0, $186 = 0, $188 = 0, $189 = 0, $19 = 0, $191 = 0, $192 = 0, $194 = 0, $195 = 0, $197 = 0, $198 = 0, $200 = 0, $201 = 0, $203 = 0, $21 = 0, $210 = 0, $214 = 0, $22 = 0, $220 = 0, $223 = 0, $227 = 0, $230 = 0, $234 = 0, $236 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $243 = 0, $245 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $254 = 0, $257 = 0, $259 = 0, $26 = 0, $261 = 0, $262 = 0, $263 = 0, $27 = 0, $271 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $34 = 0, $35 = 0, $37 = 0, $4 = 0, $42 = 0, $43 = 0, $45 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $52 = 0, $53 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $72 = 0, $73 = 0, $76 = 0, $77 = 0, $8 = 0, $80 = 0, $81 = 0, $83 = 0, $84 = 0, $86 = 0, $87 = 0, $9 = 0, $90 = 0, $91 = 0, $93 = 0, $94 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $alt$01428 = 0, $arg$013 = 0, $envvar_list$0 = 0, $ext$01630 = 0, $new_elt$0$ph7$i = 0, $p$0$lcssa2$i = 0, $p$0$ph6$i = 0, $p$03$us$i = 0, $q$0$ph$lcssa$i = 0, $q$0$ph5$i = 0, $vararg_buffer = 0, $vararg_buffer102 = 0, $vararg_buffer106 = 0, $vararg_buffer111 = 0, $vararg_buffer115 = 0, $vararg_buffer119 = 0, $vararg_buffer123 = 0, $vararg_buffer126 = 0, $vararg_buffer13 = 0, $vararg_buffer130 = 0, $vararg_buffer134 = 0, $vararg_buffer137 = 0, $vararg_buffer141 = 0, $vararg_buffer145 = 0, $vararg_buffer148 = 0, $vararg_buffer153 = 0, $vararg_buffer156 = 0, $vararg_buffer161 = 0, $vararg_buffer165 = 0, $vararg_buffer169 = 0, $vararg_buffer174 = 0, $vararg_buffer178 = 0, $vararg_buffer182 = 0, $vararg_buffer185 = 0, $vararg_buffer190 = 0, $vararg_buffer194 = 0, $vararg_buffer198 = 0, $vararg_buffer201 = 0, $vararg_buffer205 = 0, $vararg_buffer208 = 0, $vararg_buffer212 = 0, $vararg_buffer216 = 0, $vararg_buffer219 = 0, $vararg_buffer223 = 0, $vararg_buffer228 = 0, $vararg_buffer232 = 0, $vararg_buffer236 = 0, $vararg_buffer24 = 0, $vararg_buffer240 = 0, $vararg_buffer243 = 0, $vararg_buffer247 = 0, $vararg_buffer252 = 0, $vararg_buffer256 = 0, $vararg_buffer260 = 0, $vararg_buffer264 = 0, $vararg_buffer267 = 0, $vararg_buffer270 = 0, $vararg_buffer274 = 0, $vararg_buffer277 = 0, $vararg_buffer281 = 0, $vararg_buffer284 = 0, $vararg_buffer289 = 0, $vararg_buffer293 = 0, $vararg_buffer298 = 0, $vararg_buffer303 = 0, $vararg_buffer307 = 0, $vararg_buffer31 = 0, $vararg_buffer311 = 0, $vararg_buffer315 = 0, $vararg_buffer319 = 0, $vararg_buffer322 = 0, $vararg_buffer326 = 0, $vararg_buffer331 = 0, $vararg_buffer335 = 0, $vararg_buffer340 = 0, $vararg_buffer345 = 0, $vararg_buffer349 = 0, $vararg_buffer353 = 0, $vararg_buffer357 = 0, $vararg_buffer362 = 0, $vararg_buffer366 = 0, $vararg_buffer37 = 0, $vararg_buffer371 = 0, $vararg_buffer374 = 0, $vararg_buffer378 = 0, $vararg_buffer381 = 0, $vararg_buffer385 = 0, $vararg_buffer396 = 0, $vararg_buffer4 = 0, $vararg_buffer401 = 0, $vararg_buffer405 = 0, $vararg_buffer409 = 0, $vararg_buffer41 = 0, $vararg_buffer413 = 0, $vararg_buffer416 = 0, $vararg_buffer421 = 0, $vararg_buffer425 = 0, $vararg_buffer429 = 0, $vararg_buffer433 = 0, $vararg_buffer436 = 0, $vararg_buffer441 = 0, $vararg_buffer445 = 0, $vararg_buffer448 = 0, $vararg_buffer456 = 0, $vararg_buffer463 = 0, $vararg_buffer468 = 0, $vararg_buffer473 = 0, $vararg_buffer477 = 0, $vararg_buffer481 = 0, $vararg_buffer485 = 0, $vararg_buffer488 = 0, $vararg_buffer493 = 0, $vararg_buffer497 = 0, $vararg_buffer501 = 0, $vararg_buffer506 = 0, $vararg_buffer510 = 0, $vararg_buffer518 = 0, $vararg_buffer52 = 0, $vararg_buffer523 = 0, $vararg_buffer527 = 0, $vararg_buffer532 = 0, $vararg_buffer536 = 0, $vararg_buffer539 = 0, $vararg_buffer546 = 0, $vararg_buffer550 = 0, $vararg_buffer553 = 0, $vararg_buffer560 = 0, $vararg_buffer564 = 0, $vararg_buffer567 = 0, $vararg_buffer57 = 0, $vararg_buffer572 = 0, $vararg_buffer576 = 0, $vararg_buffer580 = 0, $vararg_buffer583 = 0, $vararg_buffer587 = 0, $vararg_buffer591 = 0, $vararg_buffer595 = 0, $vararg_buffer598 = 0, $vararg_buffer603 = 0, $vararg_buffer607 = 0, $vararg_buffer61 = 0, $vararg_buffer612 = 0, $vararg_buffer616 = 0, $vararg_buffer620 = 0, $vararg_buffer625 = 0, $vararg_buffer629 = 0, $vararg_buffer634 = 0, $vararg_buffer638 = 0, $vararg_buffer64 = 0, $vararg_buffer642 = 0, $vararg_buffer647 = 0, $vararg_buffer651 = 0, $vararg_buffer655 = 0, $vararg_buffer659 = 0, $vararg_buffer662 = 0, $vararg_buffer667 = 0, $vararg_buffer671 = 0, $vararg_buffer675 = 0, $vararg_buffer679 = 0, $vararg_buffer682 = 0, $vararg_buffer686 = 0, $vararg_buffer689 = 0, $vararg_buffer69 = 0, $vararg_buffer699 = 0, $vararg_buffer703 = 0, $vararg_buffer706 = 0, $vararg_buffer710 = 0, $vararg_buffer714 = 0, $vararg_buffer717 = 0, $vararg_buffer722 = 0, $vararg_buffer728 = 0, $vararg_buffer73 = 0, $vararg_buffer733 = 0, $vararg_buffer738 = 0, $vararg_buffer743 = 0, $vararg_buffer747 = 0, $vararg_buffer752 = 0, $vararg_buffer756 = 0, $vararg_buffer759 = 0, $vararg_buffer764 = 0, $vararg_buffer768 = 0, $vararg_buffer77 = 0, $vararg_buffer771 = 0, $vararg_buffer775 = 0, $vararg_buffer779 = 0, $vararg_buffer782 = 0, $vararg_buffer786 = 0, $vararg_buffer789 = 0, $vararg_buffer792 = 0, $vararg_buffer796 = 0, $vararg_buffer799 = 0, $vararg_buffer802 = 0, $vararg_buffer805 = 0, $vararg_buffer808 = 0, $vararg_buffer811 = 0, $vararg_buffer814 = 0, $vararg_buffer817 = 0, $vararg_buffer82 = 0, $vararg_buffer820 = 0, $vararg_buffer823 = 0, $vararg_buffer826 = 0, $vararg_buffer829 = 0, $vararg_buffer832 = 0, $vararg_buffer835 = 0, $vararg_buffer838 = 0, $vararg_buffer841 = 0, $vararg_buffer86 = 0, $vararg_buffer9 = 0, $vararg_buffer90 = 0, $vararg_buffer93 = 0, $vararg_buffer98 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 2192 | 0;
 $vararg_buffer841 = sp + 2176 | 0;
 $vararg_buffer838 = sp + 2168 | 0;
 $vararg_buffer835 = sp + 2160 | 0;
 $vararg_buffer832 = sp + 2152 | 0;
 $vararg_buffer829 = sp + 2144 | 0;
 $vararg_buffer826 = sp + 2136 | 0;
 $vararg_buffer823 = sp + 2128 | 0;
 $vararg_buffer820 = sp + 2120 | 0;
 $vararg_buffer817 = sp + 2112 | 0;
 $vararg_buffer814 = sp + 2104 | 0;
 $vararg_buffer811 = sp + 2096 | 0;
 $vararg_buffer808 = sp + 2088 | 0;
 $vararg_buffer805 = sp + 2080 | 0;
 $vararg_buffer802 = sp + 2072 | 0;
 $vararg_buffer799 = sp + 2064 | 0;
 $vararg_buffer796 = sp + 2056 | 0;
 $vararg_buffer792 = sp + 2048 | 0;
 $vararg_buffer789 = sp + 2040 | 0;
 $vararg_buffer786 = sp + 2032 | 0;
 $vararg_buffer782 = sp + 2024 | 0;
 $vararg_buffer779 = sp + 2016 | 0;
 $vararg_buffer775 = sp + 2008 | 0;
 $vararg_buffer771 = sp + 2e3 | 0;
 $vararg_buffer768 = sp + 1992 | 0;
 $vararg_buffer764 = sp + 1984 | 0;
 $vararg_buffer759 = sp + 1968 | 0;
 $vararg_buffer756 = sp + 1960 | 0;
 $vararg_buffer752 = sp + 1952 | 0;
 $vararg_buffer747 = sp + 1936 | 0;
 $vararg_buffer743 = sp + 1928 | 0;
 $vararg_buffer738 = sp + 1912 | 0;
 $vararg_buffer733 = sp + 1896 | 0;
 $vararg_buffer728 = sp + 1880 | 0;
 $vararg_buffer722 = sp + 1864 | 0;
 $vararg_buffer717 = sp + 1848 | 0;
 $vararg_buffer714 = sp + 1840 | 0;
 $vararg_buffer710 = sp + 1832 | 0;
 $vararg_buffer706 = sp + 1824 | 0;
 $vararg_buffer703 = sp + 1816 | 0;
 $vararg_buffer699 = sp + 1808 | 0;
 $vararg_buffer689 = sp + 1776 | 0;
 $vararg_buffer686 = sp + 1768 | 0;
 $vararg_buffer682 = sp + 1760 | 0;
 $vararg_buffer679 = sp + 1752 | 0;
 $vararg_buffer675 = sp + 1744 | 0;
 $vararg_buffer671 = sp + 1736 | 0;
 $vararg_buffer667 = sp + 1728 | 0;
 $vararg_buffer662 = sp + 1712 | 0;
 $vararg_buffer659 = sp + 1704 | 0;
 $vararg_buffer655 = sp + 1696 | 0;
 $vararg_buffer651 = sp + 1688 | 0;
 $vararg_buffer647 = sp + 1680 | 0;
 $vararg_buffer642 = sp + 1664 | 0;
 $vararg_buffer638 = sp + 1656 | 0;
 $vararg_buffer634 = sp + 1648 | 0;
 $vararg_buffer629 = sp + 1632 | 0;
 $vararg_buffer625 = sp + 1624 | 0;
 $vararg_buffer620 = sp + 1608 | 0;
 $vararg_buffer616 = sp + 1600 | 0;
 $vararg_buffer612 = sp + 1592 | 0;
 $vararg_buffer607 = sp + 1576 | 0;
 $vararg_buffer603 = sp + 1568 | 0;
 $vararg_buffer598 = sp + 1552 | 0;
 $vararg_buffer595 = sp + 1544 | 0;
 $vararg_buffer591 = sp + 1536 | 0;
 $vararg_buffer587 = sp + 1528 | 0;
 $vararg_buffer583 = sp + 1520 | 0;
 $vararg_buffer580 = sp + 1512 | 0;
 $vararg_buffer576 = sp + 1504 | 0;
 $vararg_buffer572 = sp + 1496 | 0;
 $vararg_buffer567 = sp + 1480 | 0;
 $vararg_buffer564 = sp + 1472 | 0;
 $vararg_buffer560 = sp + 1464 | 0;
 $vararg_buffer553 = sp + 1440 | 0;
 $vararg_buffer550 = sp + 1432 | 0;
 $vararg_buffer546 = sp + 1424 | 0;
 $vararg_buffer539 = sp + 1400 | 0;
 $vararg_buffer536 = sp + 1392 | 0;
 $vararg_buffer532 = sp + 1384 | 0;
 $vararg_buffer527 = sp + 1368 | 0;
 $vararg_buffer523 = sp + 1360 | 0;
 $vararg_buffer518 = sp + 1344 | 0;
 $vararg_buffer510 = sp + 1320 | 0;
 $vararg_buffer506 = sp + 1312 | 0;
 $vararg_buffer501 = sp + 1296 | 0;
 $vararg_buffer497 = sp + 1288 | 0;
 $vararg_buffer493 = sp + 1280 | 0;
 $vararg_buffer488 = sp + 1264 | 0;
 $vararg_buffer485 = sp + 1256 | 0;
 $vararg_buffer481 = sp + 1248 | 0;
 $vararg_buffer477 = sp + 1240 | 0;
 $vararg_buffer473 = sp + 1232 | 0;
 $vararg_buffer468 = sp + 1216 | 0;
 $vararg_buffer463 = sp + 1200 | 0;
 $vararg_buffer456 = sp + 1176 | 0;
 $vararg_buffer448 = sp + 1152 | 0;
 $vararg_buffer445 = sp + 1144 | 0;
 $vararg_buffer441 = sp + 1136 | 0;
 $vararg_buffer436 = sp + 1120 | 0;
 $vararg_buffer433 = sp + 1112 | 0;
 $vararg_buffer429 = sp + 1104 | 0;
 $vararg_buffer425 = sp + 1096 | 0;
 $vararg_buffer421 = sp + 1088 | 0;
 $vararg_buffer416 = sp + 1072 | 0;
 $vararg_buffer413 = sp + 1064 | 0;
 $vararg_buffer409 = sp + 1056 | 0;
 $vararg_buffer405 = sp + 1048 | 0;
 $vararg_buffer401 = sp + 1040 | 0;
 $vararg_buffer396 = sp + 1024 | 0;
 $vararg_buffer385 = sp + 984 | 0;
 $vararg_buffer381 = sp + 976 | 0;
 $vararg_buffer378 = sp + 968 | 0;
 $vararg_buffer374 = sp + 960 | 0;
 $vararg_buffer371 = sp + 952 | 0;
 $vararg_buffer366 = sp + 936 | 0;
 $vararg_buffer362 = sp + 928 | 0;
 $vararg_buffer357 = sp + 912 | 0;
 $vararg_buffer353 = sp + 904 | 0;
 $vararg_buffer349 = sp + 896 | 0;
 $vararg_buffer345 = sp + 888 | 0;
 $vararg_buffer340 = sp + 872 | 0;
 $vararg_buffer335 = sp + 856 | 0;
 $vararg_buffer331 = sp + 848 | 0;
 $vararg_buffer326 = sp + 832 | 0;
 $vararg_buffer322 = sp + 824 | 0;
 $vararg_buffer319 = sp + 816 | 0;
 $vararg_buffer315 = sp + 808 | 0;
 $vararg_buffer311 = sp + 800 | 0;
 $vararg_buffer307 = sp + 792 | 0;
 $vararg_buffer303 = sp + 784 | 0;
 $vararg_buffer298 = sp + 768 | 0;
 $vararg_buffer293 = sp + 752 | 0;
 $vararg_buffer289 = sp + 744 | 0;
 $vararg_buffer284 = sp + 728 | 0;
 $vararg_buffer281 = sp + 720 | 0;
 $vararg_buffer277 = sp + 712 | 0;
 $vararg_buffer274 = sp + 704 | 0;
 $vararg_buffer270 = sp + 696 | 0;
 $vararg_buffer267 = sp + 688 | 0;
 $vararg_buffer264 = sp + 680 | 0;
 $vararg_buffer260 = sp + 672 | 0;
 $vararg_buffer256 = sp + 664 | 0;
 $vararg_buffer252 = sp + 656 | 0;
 $vararg_buffer247 = sp + 640 | 0;
 $vararg_buffer243 = sp + 632 | 0;
 $vararg_buffer240 = sp + 624 | 0;
 $vararg_buffer236 = sp + 616 | 0;
 $vararg_buffer232 = sp + 608 | 0;
 $vararg_buffer228 = sp + 600 | 0;
 $vararg_buffer223 = sp + 584 | 0;
 $vararg_buffer219 = sp + 576 | 0;
 $vararg_buffer216 = sp + 568 | 0;
 $vararg_buffer212 = sp + 560 | 0;
 $vararg_buffer208 = sp + 552 | 0;
 $vararg_buffer205 = sp + 544 | 0;
 $vararg_buffer201 = sp + 536 | 0;
 $vararg_buffer198 = sp + 528 | 0;
 $vararg_buffer194 = sp + 520 | 0;
 $vararg_buffer190 = sp + 512 | 0;
 $vararg_buffer185 = sp + 496 | 0;
 $vararg_buffer182 = sp + 488 | 0;
 $vararg_buffer178 = sp + 480 | 0;
 $vararg_buffer174 = sp + 472 | 0;
 $vararg_buffer169 = sp + 456 | 0;
 $vararg_buffer165 = sp + 448 | 0;
 $vararg_buffer161 = sp + 440 | 0;
 $vararg_buffer156 = sp + 424 | 0;
 $vararg_buffer153 = sp + 416 | 0;
 $vararg_buffer148 = sp + 400 | 0;
 $vararg_buffer145 = sp + 392 | 0;
 $vararg_buffer141 = sp + 384 | 0;
 $vararg_buffer137 = sp + 376 | 0;
 $vararg_buffer134 = sp + 368 | 0;
 $vararg_buffer130 = sp + 360 | 0;
 $vararg_buffer126 = sp + 352 | 0;
 $vararg_buffer123 = sp + 344 | 0;
 $vararg_buffer119 = sp + 336 | 0;
 $vararg_buffer115 = sp + 328 | 0;
 $vararg_buffer111 = sp + 320 | 0;
 $vararg_buffer106 = sp + 304 | 0;
 $vararg_buffer102 = sp + 296 | 0;
 $vararg_buffer98 = sp + 288 | 0;
 $vararg_buffer93 = sp + 272 | 0;
 $vararg_buffer90 = sp + 264 | 0;
 $vararg_buffer86 = sp + 256 | 0;
 $vararg_buffer82 = sp + 248 | 0;
 $vararg_buffer77 = sp + 232 | 0;
 $vararg_buffer73 = sp + 224 | 0;
 $vararg_buffer69 = sp + 216 | 0;
 $vararg_buffer64 = sp + 200 | 0;
 $vararg_buffer61 = sp + 192 | 0;
 $vararg_buffer57 = sp + 184 | 0;
 $vararg_buffer52 = sp + 168 | 0;
 $vararg_buffer41 = sp + 128 | 0;
 $vararg_buffer37 = sp + 120 | 0;
 $vararg_buffer31 = sp + 104 | 0;
 $vararg_buffer24 = sp + 80 | 0;
 $vararg_buffer13 = sp + 40 | 0;
 $vararg_buffer9 = sp + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 do switch ($format | 0) {
 case 0:
  {
   $0 = $kpse + 132 | 0;
   HEAP32[$0 >> 2] = 6744;
   HEAP32[$vararg_buffer >> 2] = 6757;
   HEAP32[$vararg_buffer + 4 >> 2] = 6765;
   HEAP32[$vararg_buffer + 8 >> 2] = 6776;
   HEAP32[$vararg_buffer + 12 >> 2] = 0;
   _init_path($kpse, $0, 6747, $vararg_buffer);
   HEAP32[$vararg_buffer4 >> 2] = 6765;
   HEAP32[$vararg_buffer4 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer4 + 8 >> 2] = 0;
   $1 = _concatn_with_spaces(6757, $vararg_buffer4) | 0;
   HEAP32[$vararg_buffer9 >> 2] = 6744;
   HEAP32[$vararg_buffer9 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 0, 0, $vararg_buffer9);
   HEAP32[$kpse + 172 >> 2] = 1;
   HEAP32[$kpse + 196 >> 2] = 1;
   $envvar_list$0 = $1;
   break;
  }
 case 1:
  {
   HEAP32[$vararg_buffer13 >> 2] = 6888;
   HEAP32[$vararg_buffer13 + 4 >> 2] = 6897;
   HEAP32[$vararg_buffer13 + 8 >> 2] = 6911;
   HEAP32[$vararg_buffer13 + 12 >> 2] = 6918;
   HEAP32[$vararg_buffer13 + 16 >> 2] = 6936;
   HEAP32[$vararg_buffer13 + 20 >> 2] = 6942;
   HEAP32[$vararg_buffer13 + 24 >> 2] = 6955;
   HEAP32[$vararg_buffer13 + 28 >> 2] = 6961;
   HEAP32[$vararg_buffer13 + 32 >> 2] = 0;
   _init_maketex($kpse, 1, 6880, $vararg_buffer13);
   $4 = $kpse + 200 | 0;
   HEAP32[$4 >> 2] = 6718;
   HEAP32[$vararg_buffer24 >> 2] = 6975;
   HEAP32[$vararg_buffer24 + 4 >> 2] = 6983;
   HEAP32[$vararg_buffer24 + 8 >> 2] = 6765;
   HEAP32[$vararg_buffer24 + 12 >> 2] = 6776;
   HEAP32[$vararg_buffer24 + 16 >> 2] = 0;
   _init_path($kpse, $4, 6747, $vararg_buffer24);
   HEAP32[$vararg_buffer31 >> 2] = 6983;
   HEAP32[$vararg_buffer31 + 4 >> 2] = 6765;
   HEAP32[$vararg_buffer31 + 8 >> 2] = 6776;
   HEAP32[$vararg_buffer31 + 12 >> 2] = 0;
   $5 = _concatn_with_spaces(6975, $vararg_buffer31) | 0;
   HEAP32[$vararg_buffer37 >> 2] = 6718;
   HEAP32[$vararg_buffer37 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 1, 0, $vararg_buffer37);
   HEAP32[$kpse + 240 >> 2] = 1;
   HEAP32[$kpse + 264 >> 2] = 1;
   $envvar_list$0 = $5;
   break;
  }
 case 2:
  {
   HEAP32[$vararg_buffer41 >> 2] = 6888;
   HEAP32[$vararg_buffer41 + 4 >> 2] = 6897;
   HEAP32[$vararg_buffer41 + 8 >> 2] = 6911;
   HEAP32[$vararg_buffer41 + 12 >> 2] = 6918;
   HEAP32[$vararg_buffer41 + 16 >> 2] = 6936;
   HEAP32[$vararg_buffer41 + 20 >> 2] = 6942;
   HEAP32[$vararg_buffer41 + 24 >> 2] = 6955;
   HEAP32[$vararg_buffer41 + 28 >> 2] = 6961;
   HEAP32[$vararg_buffer41 + 32 >> 2] = 0;
   _init_maketex($kpse, 2, 6880, $vararg_buffer41);
   $8 = $kpse + 268 | 0;
   HEAP32[$8 >> 2] = 6990;
   HEAP32[$vararg_buffer52 >> 2] = 6765;
   HEAP32[$vararg_buffer52 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer52 + 8 >> 2] = 0;
   _init_path($kpse, $8, 6747, $vararg_buffer52);
   HEAP32[$vararg_buffer57 >> 2] = 6776;
   HEAP32[$vararg_buffer57 + 4 >> 2] = 0;
   $9 = _concatn_with_spaces(6765, $vararg_buffer57) | 0;
   HEAP32[$kpse + 308 >> 2] = 1;
   HEAP32[$kpse + 332 >> 2] = 1;
   $envvar_list$0 = $9;
   break;
  }
 case 3:
  {
   HEAP32[$vararg_buffer61 >> 2] = 0;
   _init_maketex($kpse, 3, 7002, $vararg_buffer61);
   $12 = $kpse + 336 | 0;
   HEAP32[$12 >> 2] = 6728;
   HEAP32[$vararg_buffer64 >> 2] = 7011;
   HEAP32[$vararg_buffer64 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer64 + 8 >> 2] = 0;
   _init_path($kpse, $12, 6747, $vararg_buffer64);
   HEAP32[$vararg_buffer69 >> 2] = 6776;
   HEAP32[$vararg_buffer69 + 4 >> 2] = 0;
   $13 = _concatn_with_spaces(7011, $vararg_buffer69) | 0;
   HEAP32[$vararg_buffer73 >> 2] = 7020;
   HEAP32[$vararg_buffer73 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 3, 0, $vararg_buffer73);
   HEAP32[$kpse + 376 >> 2] = 1;
   HEAP32[$kpse + 400 >> 2] = 1;
   $envvar_list$0 = $13;
   break;
  }
 case 4:
  {
   $16 = $kpse + 404 | 0;
   HEAP32[$16 >> 2] = 7025;
   HEAP32[$vararg_buffer77 >> 2] = 7029;
   HEAP32[$vararg_buffer77 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer77 + 8 >> 2] = 0;
   _init_path($kpse, $16, 6747, $vararg_buffer77);
   HEAP32[$vararg_buffer82 >> 2] = 6776;
   HEAP32[$vararg_buffer82 + 4 >> 2] = 0;
   $17 = _concatn_with_spaces(7029, $vararg_buffer82) | 0;
   HEAP32[$vararg_buffer86 >> 2] = 7038;
   HEAP32[$vararg_buffer86 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 4, 0, $vararg_buffer86);
   $envvar_list$0 = $17;
   break;
  }
 case 5:
  {
   HEAP32[$vararg_buffer90 >> 2] = 0;
   _init_maketex($kpse, 5, 7043, $vararg_buffer90);
   $18 = $kpse + 472 | 0;
   HEAP32[$18 >> 2] = 7052;
   HEAP32[$vararg_buffer93 >> 2] = 7057;
   HEAP32[$vararg_buffer93 + 4 >> 2] = 7065;
   HEAP32[$vararg_buffer93 + 8 >> 2] = 0;
   _init_path($kpse, $18, 6747, $vararg_buffer93);
   HEAP32[$vararg_buffer98 >> 2] = 7065;
   HEAP32[$vararg_buffer98 + 4 >> 2] = 0;
   $19 = _concatn_with_spaces(7057, $vararg_buffer98) | 0;
   HEAP32[$vararg_buffer102 >> 2] = 7074;
   HEAP32[$vararg_buffer102 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 5, 0, $vararg_buffer102);
   HEAP32[$kpse + 536 >> 2] = 1;
   $envvar_list$0 = $19;
   break;
  }
 case 6:
  {
   $21 = $kpse + 540 | 0;
   HEAP32[$21 >> 2] = 7080;
   HEAP32[$vararg_buffer106 >> 2] = 7084;
   HEAP32[$vararg_buffer106 + 4 >> 2] = 7094;
   HEAP32[$vararg_buffer106 + 8 >> 2] = 0;
   _init_path($kpse, $21, 6747, $vararg_buffer106);
   HEAP32[$vararg_buffer111 >> 2] = 7094;
   HEAP32[$vararg_buffer111 + 4 >> 2] = 0;
   $22 = _concatn_with_spaces(7084, $vararg_buffer111) | 0;
   HEAP32[$vararg_buffer115 >> 2] = 7101;
   HEAP32[$vararg_buffer115 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 6, 0, $vararg_buffer115);
   HEAP32[$kpse + 580 >> 2] = 1;
   $envvar_list$0 = $22;
   break;
  }
 case 7:
  {
   $24 = $kpse + 608 | 0;
   HEAP32[$24 >> 2] = 7106;
   HEAP32[$vararg_buffer119 >> 2] = 7110;
   HEAP32[$vararg_buffer119 + 4 >> 2] = 0;
   _init_path($kpse, $24, 6747, $vararg_buffer119);
   HEAP32[$vararg_buffer123 >> 2] = 0;
   $25 = _concatn_with_spaces(7110, $vararg_buffer123) | 0;
   HEAP32[$vararg_buffer126 >> 2] = 7120;
   HEAP32[$vararg_buffer126 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 7, 0, $vararg_buffer126);
   $envvar_list$0 = $25;
   break;
  }
 case 8:
  {
   $26 = $kpse + 676 | 0;
   HEAP32[$26 >> 2] = 7125;
   HEAP32[$vararg_buffer130 >> 2] = 7800;
   HEAP32[$vararg_buffer130 + 4 >> 2] = 0;
   _init_path($kpse, $26, 7129, $vararg_buffer130);
   HEAP32[$vararg_buffer134 >> 2] = 0;
   $27 = _concatn_with_spaces(7800, $vararg_buffer134) | 0;
   HEAP32[$vararg_buffer137 >> 2] = 7809;
   HEAP32[$vararg_buffer137 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 8, 0, $vararg_buffer137);
   $envvar_list$0 = $27;
   break;
  }
 case 9:
  {
   $28 = $kpse + 744 | 0;
   HEAP32[$28 >> 2] = 7814;
   HEAP32[$vararg_buffer141 >> 2] = 7819;
   HEAP32[$vararg_buffer141 + 4 >> 2] = 0;
   _init_path($kpse, $28, 6747, $vararg_buffer141);
   HEAP32[$vararg_buffer145 >> 2] = 0;
   $29 = _concatn_with_spaces(7819, $vararg_buffer145) | 0;
   HEAP32[$vararg_buffer148 >> 2] = 7814;
   HEAP32[$vararg_buffer148 + 4 >> 2] = 7828;
   HEAP32[$vararg_buffer148 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 9, 0, $vararg_buffer148);
   $30 = $kpse + 748 | 0;
   $31 = HEAP32[$30 >> 2] | 0;
   $34 = _xmalloc((_strlen($31) | 0) + 1 | 0) | 0;
   $35 = HEAP8[$31 >> 0] | 0;
   L13 : do if (!($35 << 24 >> 24)) $q$0$ph$lcssa$i = $34; else {
    $271 = $35;
    $new_elt$0$ph7$i = 1;
    $p$0$ph6$i = $31;
    $q$0$ph5$i = $34;
    while (1) {
     L16 : do if (!$new_elt$0$ph7$i) {
      $45 = $271;
      $p$0$lcssa2$i = $p$0$ph6$i;
     } else {
      $37 = $271;
      $p$03$us$i = $p$0$ph6$i;
      while (1) {
       if ($37 << 24 >> 24 != 33) {
        $45 = $37;
        $p$0$lcssa2$i = $p$03$us$i;
        break L16;
       }
       if ((HEAP8[$p$03$us$i + 1 >> 0] | 0) != 33) {
        $45 = 33;
        $p$0$lcssa2$i = $p$03$us$i;
        break L16;
       }
       $42 = $p$03$us$i + 2 | 0;
       $43 = HEAP8[$42 >> 0] | 0;
       if (!($43 << 24 >> 24)) {
        $q$0$ph$lcssa$i = $q$0$ph5$i;
        break L13;
       } else {
        $37 = $43;
        $p$03$us$i = $42;
       }
      }
     } while (0);
     $48 = $p$0$lcssa2$i + 1 | 0;
     $49 = $q$0$ph5$i + 1 | 0;
     HEAP8[$q$0$ph5$i >> 0] = $45;
     $50 = HEAP8[$48 >> 0] | 0;
     if (!($50 << 24 >> 24)) {
      $q$0$ph$lcssa$i = $49;
      break;
     } else {
      $271 = $50;
      $new_elt$0$ph7$i = $45 << 24 >> 24 == 58 & 1;
      $p$0$ph6$i = $48;
      $q$0$ph5$i = $49;
     }
    }
   } while (0);
   HEAP8[$q$0$ph$lcssa$i >> 0] = 0;
   HEAP32[$30 >> 2] = $34;
   $envvar_list$0 = $29;
   break;
  }
 case 10:
  {
   HEAP32[$vararg_buffer153 >> 2] = 0;
   _init_maketex($kpse, 10, 7043, $vararg_buffer153);
   $52 = $kpse + 812 | 0;
   HEAP32[$52 >> 2] = 6732;
   HEAP32[$vararg_buffer156 >> 2] = 7833;
   HEAP32[$vararg_buffer156 + 4 >> 2] = 7065;
   HEAP32[$vararg_buffer156 + 8 >> 2] = 0;
   _init_path($kpse, $52, 6747, $vararg_buffer156);
   HEAP32[$vararg_buffer161 >> 2] = 7065;
   HEAP32[$vararg_buffer161 + 4 >> 2] = 0;
   $53 = _concatn_with_spaces(7833, $vararg_buffer161) | 0;
   HEAP32[$vararg_buffer165 >> 2] = 7844;
   HEAP32[$vararg_buffer165 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 10, 0, $vararg_buffer165);
   HEAP32[$kpse + 876 >> 2] = 1;
   $envvar_list$0 = $53;
   break;
  }
 case 11:
  {
   $55 = $kpse + 880 | 0;
   HEAP32[$55 >> 2] = 7849;
   HEAP32[$vararg_buffer169 >> 2] = 7853;
   HEAP32[$vararg_buffer169 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer169 + 8 >> 2] = 0;
   _init_path($kpse, $55, 6747, $vararg_buffer169);
   HEAP32[$vararg_buffer174 >> 2] = 6776;
   HEAP32[$vararg_buffer174 + 4 >> 2] = 0;
   $56 = _concatn_with_spaces(7853, $vararg_buffer174) | 0;
   HEAP32[$vararg_buffer178 >> 2] = 7865;
   HEAP32[$vararg_buffer178 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 11, 0, $vararg_buffer178);
   $envvar_list$0 = $56;
   break;
  }
 case 12:
  {
   HEAP32[$vararg_buffer182 >> 2] = 0;
   _init_maketex($kpse, 12, 7043, $vararg_buffer182);
   $57 = $kpse + 948 | 0;
   HEAP32[$57 >> 2] = 7870;
   HEAP32[$vararg_buffer185 >> 2] = 7874;
   HEAP32[$vararg_buffer185 + 4 >> 2] = 7065;
   HEAP32[$vararg_buffer185 + 8 >> 2] = 0;
   _init_path($kpse, $57, 6747, $vararg_buffer185);
   HEAP32[$vararg_buffer190 >> 2] = 7065;
   HEAP32[$vararg_buffer190 + 4 >> 2] = 0;
   $58 = _concatn_with_spaces(7874, $vararg_buffer190) | 0;
   HEAP32[$vararg_buffer194 >> 2] = 7881;
   HEAP32[$vararg_buffer194 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 12, 0, $vararg_buffer194);
   HEAP32[$kpse + 1012 >> 2] = 1;
   $envvar_list$0 = $58;
   break;
  }
 case 13:
  {
   HEAP32[$vararg_buffer198 >> 2] = 0;
   _init_maketex($kpse, 13, 7886, $vararg_buffer198);
   $60 = $kpse + 1016 | 0;
   HEAP32[$60 >> 2] = 6721;
   HEAP32[$vararg_buffer201 >> 2] = 7894;
   HEAP32[$vararg_buffer201 + 4 >> 2] = 0;
   _init_path($kpse, $60, 6747, $vararg_buffer201);
   HEAP32[$vararg_buffer205 >> 2] = 0;
   $61 = _concatn_with_spaces(7894, $vararg_buffer205) | 0;
   HEAP32[$vararg_buffer208 >> 2] = 7903;
   HEAP32[$vararg_buffer208 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 13, 0, $vararg_buffer208);
   $envvar_list$0 = $61;
   break;
  }
 case 15:
  {
   $62 = $kpse + 1152 | 0;
   HEAP32[$62 >> 2] = 7907;
   HEAP32[$vararg_buffer212 >> 2] = 7911;
   HEAP32[$vararg_buffer212 + 4 >> 2] = 0;
   _init_path($kpse, $62, 6747, $vararg_buffer212);
   HEAP32[$vararg_buffer216 >> 2] = 0;
   $63 = _concatn_with_spaces(7911, $vararg_buffer216) | 0;
   HEAP32[$vararg_buffer219 >> 2] = 7921;
   HEAP32[$vararg_buffer219 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 15, 0, $vararg_buffer219);
   $envvar_list$0 = $63;
   break;
  }
 case 14:
  {
   $64 = $kpse + 1084 | 0;
   HEAP32[$64 >> 2] = 7926;
   HEAP32[$vararg_buffer223 >> 2] = 7933;
   HEAP32[$vararg_buffer223 + 4 >> 2] = 7065;
   HEAP32[$vararg_buffer223 + 8 >> 2] = 0;
   _init_path($kpse, $64, 6747, $vararg_buffer223);
   HEAP32[$vararg_buffer228 >> 2] = 7065;
   HEAP32[$vararg_buffer228 + 4 >> 2] = 0;
   $65 = _concatn_with_spaces(7933, $vararg_buffer228) | 0;
   HEAP32[$vararg_buffer232 >> 2] = 7940;
   HEAP32[$vararg_buffer232 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 14, 0, $vararg_buffer232);
   $envvar_list$0 = $65;
   break;
  }
 case 16:
  {
   $66 = $kpse + 1220 | 0;
   HEAP32[$66 >> 2] = 7946;
   HEAP32[$vararg_buffer236 >> 2] = 7949;
   HEAP32[$vararg_buffer236 + 4 >> 2] = 0;
   _init_path($kpse, $66, 6747, $vararg_buffer236);
   HEAP32[$vararg_buffer240 >> 2] = 0;
   $67 = _concatn_with_spaces(7949, $vararg_buffer240) | 0;
   HEAP32[$vararg_buffer243 >> 2] = 7958;
   HEAP32[$vararg_buffer243 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 16, 0, $vararg_buffer243);
   $envvar_list$0 = $67;
   break;
  }
 case 17:
  {
   $68 = $kpse + 1288 | 0;
   HEAP32[$68 >> 2] = 7962;
   HEAP32[$vararg_buffer247 >> 2] = 7969;
   HEAP32[$vararg_buffer247 + 4 >> 2] = 7065;
   HEAP32[$vararg_buffer247 + 8 >> 2] = 0;
   _init_path($kpse, $68, 6747, $vararg_buffer247);
   HEAP32[$vararg_buffer252 >> 2] = 7065;
   HEAP32[$vararg_buffer252 + 4 >> 2] = 0;
   $69 = _concatn_with_spaces(7969, $vararg_buffer252) | 0;
   HEAP32[$vararg_buffer256 >> 2] = 7940;
   HEAP32[$vararg_buffer256 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 17, 0, $vararg_buffer256);
   $envvar_list$0 = $69;
   break;
  }
 case 18:
  {
   $70 = $kpse + 1356 | 0;
   HEAP32[$70 >> 2] = 7976;
   HEAP32[$vararg_buffer260 >> 2] = 7993;
   HEAP32[$vararg_buffer260 + 4 >> 2] = 0;
   _init_path($kpse, $70, 6747, $vararg_buffer260);
   HEAP32[$vararg_buffer264 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(7993, $vararg_buffer264) | 0;
   break;
  }
 case 19:
  {
   HEAP32[$vararg_buffer267 >> 2] = 0;
   _init_maketex($kpse, 19, 8003, $vararg_buffer267);
   $72 = $kpse + 1424 | 0;
   HEAP32[$72 >> 2] = 6740;
   HEAP32[$vararg_buffer270 >> 2] = 8009;
   HEAP32[$vararg_buffer270 + 4 >> 2] = 0;
   _init_path($kpse, $72, 6747, $vararg_buffer270);
   HEAP32[$vararg_buffer274 >> 2] = 0;
   $73 = _concatn_with_spaces(8009, $vararg_buffer274) | 0;
   HEAP32[$vararg_buffer277 >> 2] = 8019;
   HEAP32[$vararg_buffer277 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 19, 0, $vararg_buffer277);
   HEAP32[$kpse + 1464 >> 2] = 1;
   HEAP32[$kpse + 1488 >> 2] = 1;
   $envvar_list$0 = $73;
   break;
  }
 case 20:
  {
   HEAP32[$vararg_buffer281 >> 2] = 0;
   _init_maketex($kpse, 20, 8024, $vararg_buffer281);
   $76 = $kpse + 1492 | 0;
   HEAP32[$76 >> 2] = 6736;
   HEAP32[$vararg_buffer284 >> 2] = 8030;
   HEAP32[$vararg_buffer284 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer284 + 8 >> 2] = 0;
   _init_path($kpse, $76, 6747, $vararg_buffer284);
   HEAP32[$vararg_buffer289 >> 2] = 6776;
   HEAP32[$vararg_buffer289 + 4 >> 2] = 0;
   $77 = _concatn_with_spaces(8030, $vararg_buffer289) | 0;
   HEAP32[$vararg_buffer293 >> 2] = 8039;
   HEAP32[$vararg_buffer293 + 4 >> 2] = 7020;
   HEAP32[$vararg_buffer293 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 20, 0, $vararg_buffer293);
   HEAP32[$kpse + 1532 >> 2] = 1;
   HEAP32[$kpse + 1556 >> 2] = 1;
   $envvar_list$0 = $77;
   break;
  }
 case 21:
  {
   $80 = $kpse + 1560 | 0;
   HEAP32[$80 >> 2] = 8044;
   HEAP32[$vararg_buffer298 >> 2] = 8048;
   HEAP32[$vararg_buffer298 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer298 + 8 >> 2] = 0;
   _init_path($kpse, $80, 6747, $vararg_buffer298);
   HEAP32[$vararg_buffer303 >> 2] = 6776;
   HEAP32[$vararg_buffer303 + 4 >> 2] = 0;
   $81 = _concatn_with_spaces(8048, $vararg_buffer303) | 0;
   HEAP32[$vararg_buffer307 >> 2] = 8057;
   HEAP32[$vararg_buffer307 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 21, 0, $vararg_buffer307);
   HEAP32[$vararg_buffer311 >> 2] = 8062;
   HEAP32[$vararg_buffer311 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 21, 1, $vararg_buffer311);
   HEAP32[$kpse + 1600 >> 2] = 1;
   $envvar_list$0 = $81;
   break;
  }
 case 22:
  {
   $83 = $kpse + 1628 | 0;
   HEAP32[$83 >> 2] = 8066;
   HEAP32[$vararg_buffer315 >> 2] = 8070;
   HEAP32[$vararg_buffer315 + 4 >> 2] = 0;
   _init_path($kpse, $83, 6747, $vararg_buffer315);
   HEAP32[$vararg_buffer319 >> 2] = 0;
   $84 = _concatn_with_spaces(8070, $vararg_buffer319) | 0;
   HEAP32[$vararg_buffer322 >> 2] = 8080;
   HEAP32[$vararg_buffer322 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 22, 0, $vararg_buffer322);
   HEAP32[$kpse + 1668 >> 2] = 1;
   $envvar_list$0 = $84;
   break;
  }
 case 23:
  {
   $86 = $kpse + 1696 | 0;
   HEAP32[$86 >> 2] = 8085;
   HEAP32[$vararg_buffer326 >> 2] = 8089;
   HEAP32[$vararg_buffer326 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer326 + 8 >> 2] = 0;
   _init_path($kpse, $86, 6747, $vararg_buffer326);
   HEAP32[$vararg_buffer331 >> 2] = 6776;
   HEAP32[$vararg_buffer331 + 4 >> 2] = 0;
   $87 = _concatn_with_spaces(8089, $vararg_buffer331) | 0;
   HEAP32[$vararg_buffer335 >> 2] = 8098;
   HEAP32[$vararg_buffer335 + 4 >> 2] = 8103;
   HEAP32[$vararg_buffer335 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 23, 0, $vararg_buffer335);
   HEAP32[$kpse + 1736 >> 2] = 1;
   HEAP32[$kpse + 1760 >> 2] = 1;
   $envvar_list$0 = $87;
   break;
  }
 case 24:
  {
   $90 = $kpse + 1764 | 0;
   HEAP32[$90 >> 2] = 8107;
   HEAP32[$vararg_buffer340 >> 2] = 8111;
   HEAP32[$vararg_buffer340 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer340 + 8 >> 2] = 0;
   _init_path($kpse, $90, 6747, $vararg_buffer340);
   HEAP32[$vararg_buffer345 >> 2] = 6776;
   HEAP32[$vararg_buffer345 + 4 >> 2] = 0;
   $91 = _concatn_with_spaces(8111, $vararg_buffer345) | 0;
   HEAP32[$vararg_buffer349 >> 2] = 8120;
   HEAP32[$vararg_buffer349 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 24, 0, $vararg_buffer349);
   HEAP32[$vararg_buffer353 >> 2] = 8125;
   HEAP32[$vararg_buffer353 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 24, 1, $vararg_buffer353);
   HEAP32[$kpse + 1804 >> 2] = 1;
   $envvar_list$0 = $91;
   break;
  }
 case 25:
  {
   $93 = $kpse + 1832 | 0;
   HEAP32[$93 >> 2] = 8130;
   HEAP32[$vararg_buffer357 >> 2] = 8145;
   HEAP32[$vararg_buffer357 + 4 >> 2] = 8154;
   HEAP32[$vararg_buffer357 + 8 >> 2] = 0;
   _init_path($kpse, $93, 6747, $vararg_buffer357);
   HEAP32[$vararg_buffer362 >> 2] = 8154;
   HEAP32[$vararg_buffer362 + 4 >> 2] = 0;
   $94 = _concatn_with_spaces(8145, $vararg_buffer362) | 0;
   HEAP32[$vararg_buffer366 >> 2] = 8164;
   HEAP32[$vararg_buffer366 + 4 >> 2] = 8169;
   HEAP32[$vararg_buffer366 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 25, 1, $vararg_buffer366);
   HEAP32[$kpse + 1896 >> 2] = 1;
   $envvar_list$0 = $94;
   break;
  }
 case 26:
  {
   HEAP32[$vararg_buffer371 >> 2] = 0;
   _init_maketex($kpse, 26, 8175, $vararg_buffer371);
   $96 = $kpse + 1900 | 0;
   HEAP32[$96 >> 2] = 6724;
   HEAP32[$vararg_buffer374 >> 2] = 8154;
   HEAP32[$vararg_buffer374 + 4 >> 2] = 0;
   _init_path($kpse, $96, 6747, $vararg_buffer374);
   HEAP32[$vararg_buffer378 >> 2] = 0;
   $97 = _concatn_with_spaces(8154, $vararg_buffer378) | 0;
   HEAP32[$vararg_buffer381 >> 2] = 8184;
   HEAP32[$vararg_buffer381 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 26, 0, $vararg_buffer381);
   HEAP32[$vararg_buffer385 >> 2] = 8189;
   HEAP32[$vararg_buffer385 + 4 >> 2] = 8194;
   HEAP32[$vararg_buffer385 + 8 >> 2] = 8199;
   HEAP32[$vararg_buffer385 + 12 >> 2] = 8203;
   HEAP32[$vararg_buffer385 + 16 >> 2] = 8208;
   HEAP32[$vararg_buffer385 + 20 >> 2] = 8213;
   HEAP32[$vararg_buffer385 + 24 >> 2] = 8218;
   HEAP32[$vararg_buffer385 + 28 >> 2] = 8223;
   HEAP32[$vararg_buffer385 + 32 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 26, 1, $vararg_buffer385);
   $envvar_list$0 = $97;
   break;
  }
 case 30:
  {
   $98 = $kpse + 2172 | 0;
   HEAP32[$98 >> 2] = 8228;
   HEAP32[$vararg_buffer396 >> 2] = 8246;
   HEAP32[$vararg_buffer396 + 4 >> 2] = 8259;
   HEAP32[$vararg_buffer396 + 8 >> 2] = 0;
   _init_path($kpse, $98, 6747, $vararg_buffer396);
   HEAP32[$vararg_buffer401 >> 2] = 8259;
   HEAP32[$vararg_buffer401 + 4 >> 2] = 0;
   $99 = _concatn_with_spaces(8246, $vararg_buffer401) | 0;
   HEAP32[$vararg_buffer405 >> 2] = 8269;
   HEAP32[$vararg_buffer405 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 30, 1, $vararg_buffer405);
   HEAP32[$kpse + 2236 >> 2] = 1;
   $envvar_list$0 = $99;
   break;
  }
 case 27:
  {
   $101 = $kpse + 1968 | 0;
   HEAP32[$101 >> 2] = 8274;
   HEAP32[$vararg_buffer409 >> 2] = 8299;
   HEAP32[$vararg_buffer409 + 4 >> 2] = 0;
   _init_path($kpse, $101, 6747, $vararg_buffer409);
   HEAP32[$vararg_buffer413 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(8299, $vararg_buffer413) | 0;
   break;
  }
 case 28:
  {
   $103 = $kpse + 2036 | 0;
   HEAP32[$103 >> 2] = 8307;
   HEAP32[$vararg_buffer416 >> 2] = 8315;
   HEAP32[$vararg_buffer416 + 4 >> 2] = 7065;
   HEAP32[$vararg_buffer416 + 8 >> 2] = 0;
   _init_path($kpse, $103, 6747, $vararg_buffer416);
   HEAP32[$vararg_buffer421 >> 2] = 7065;
   HEAP32[$vararg_buffer421 + 4 >> 2] = 0;
   $104 = _concatn_with_spaces(8315, $vararg_buffer421) | 0;
   HEAP32[$vararg_buffer425 >> 2] = 7940;
   HEAP32[$vararg_buffer425 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 28, 0, $vararg_buffer425);
   $envvar_list$0 = $104;
   break;
  }
 case 29:
  {
   $105 = $kpse + 2104 | 0;
   HEAP32[$105 >> 2] = 8323;
   HEAP32[$vararg_buffer429 >> 2] = 8342;
   HEAP32[$vararg_buffer429 + 4 >> 2] = 0;
   _init_path($kpse, $105, 6747, $vararg_buffer429);
   HEAP32[$vararg_buffer433 >> 2] = 0;
   $106 = _concatn_with_spaces(8342, $vararg_buffer433) | 0;
   HEAP32[$vararg_buffer436 >> 2] = 8353;
   HEAP32[$vararg_buffer436 + 4 >> 2] = 8358;
   HEAP32[$vararg_buffer436 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 29, 1, $vararg_buffer436);
   $envvar_list$0 = $106;
   break;
  }
 case 31:
  {
   $107 = $kpse + 2240 | 0;
   HEAP32[$107 >> 2] = 8363;
   HEAP32[$vararg_buffer441 >> 2] = 8432;
   HEAP32[$vararg_buffer441 + 4 >> 2] = 0;
   _init_path($kpse, $107, 8375, $vararg_buffer441);
   HEAP32[$vararg_buffer445 >> 2] = 0;
   $108 = _concatn_with_spaces(8432, $vararg_buffer445) | 0;
   HEAP32[$kpse + 2304 >> 2] = 1;
   $envvar_list$0 = $108;
   break;
  }
 case 32:
  {
   $110 = $kpse + 2308 | 0;
   HEAP32[$110 >> 2] = 8440;
   HEAP32[$vararg_buffer448 >> 2] = 8452;
   HEAP32[$vararg_buffer448 + 4 >> 2] = 8460;
   HEAP32[$vararg_buffer448 + 8 >> 2] = 6776;
   HEAP32[$vararg_buffer448 + 12 >> 2] = 8246;
   HEAP32[$vararg_buffer448 + 16 >> 2] = 8259;
   HEAP32[$vararg_buffer448 + 20 >> 2] = 0;
   _init_path($kpse, $110, 6747, $vararg_buffer448);
   HEAP32[$vararg_buffer456 >> 2] = 8460;
   HEAP32[$vararg_buffer456 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer456 + 8 >> 2] = 8246;
   HEAP32[$vararg_buffer456 + 12 >> 2] = 8259;
   HEAP32[$vararg_buffer456 + 16 >> 2] = 0;
   $111 = _concatn_with_spaces(8452, $vararg_buffer456) | 0;
   HEAP32[$vararg_buffer463 >> 2] = 8469;
   HEAP32[$vararg_buffer463 + 4 >> 2] = 8474;
   HEAP32[$vararg_buffer463 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 32, 0, $vararg_buffer463);
   HEAP32[$kpse + 2372 >> 2] = 1;
   $envvar_list$0 = $111;
   break;
  }
 case 33:
  {
   $113 = $kpse + 2376 | 0;
   HEAP32[$113 >> 2] = 8479;
   HEAP32[$vararg_buffer468 >> 2] = 8482;
   HEAP32[$vararg_buffer468 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer468 + 8 >> 2] = 0;
   _init_path($kpse, $113, 6747, $vararg_buffer468);
   HEAP32[$vararg_buffer473 >> 2] = 6776;
   HEAP32[$vararg_buffer473 + 4 >> 2] = 0;
   $114 = _concatn_with_spaces(8482, $vararg_buffer473) | 0;
   HEAP32[$vararg_buffer477 >> 2] = 8103;
   HEAP32[$vararg_buffer477 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 33, 0, $vararg_buffer477);
   HEAP32[$kpse + 2416 >> 2] = 1;
   HEAP32[$kpse + 2440 >> 2] = 1;
   $envvar_list$0 = $114;
   break;
  }
 case 34:
  {
   $117 = $kpse + 2444 | 0;
   HEAP32[$117 >> 2] = 8490;
   HEAP32[$vararg_buffer481 >> 2] = 8503;
   HEAP32[$vararg_buffer481 + 4 >> 2] = 0;
   _init_path($kpse, $117, 6747, $vararg_buffer481);
   HEAP32[$vararg_buffer485 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(8503, $vararg_buffer485) | 0;
   break;
  }
 case 35:
  {
   $119 = $kpse + 2512 | 0;
   HEAP32[$119 >> 2] = 8513;
   HEAP32[$vararg_buffer488 >> 2] = 8517;
   HEAP32[$vararg_buffer488 + 4 >> 2] = 8531;
   HEAP32[$vararg_buffer488 + 8 >> 2] = 0;
   _init_path($kpse, $119, 6747, $vararg_buffer488);
   HEAP32[$vararg_buffer493 >> 2] = 8531;
   HEAP32[$vararg_buffer493 + 4 >> 2] = 0;
   $120 = _concatn_with_spaces(8517, $vararg_buffer493) | 0;
   HEAP32[$vararg_buffer497 >> 2] = 8542;
   HEAP32[$vararg_buffer497 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 35, 0, $vararg_buffer497);
   $envvar_list$0 = $120;
   break;
  }
 case 36:
  {
   $121 = $kpse + 2580 | 0;
   HEAP32[$121 >> 2] = 8547;
   HEAP32[$vararg_buffer501 >> 2] = 8562;
   HEAP32[$vararg_buffer501 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer501 + 8 >> 2] = 0;
   _init_path($kpse, $121, 6747, $vararg_buffer501);
   HEAP32[$vararg_buffer506 >> 2] = 6776;
   HEAP32[$vararg_buffer506 + 4 >> 2] = 0;
   $122 = _concatn_with_spaces(8562, $vararg_buffer506) | 0;
   HEAP32[$vararg_buffer510 >> 2] = 8570;
   HEAP32[$vararg_buffer510 + 4 >> 2] = 8575;
   HEAP32[$vararg_buffer510 + 8 >> 2] = 8580;
   HEAP32[$vararg_buffer510 + 12 >> 2] = 8585;
   HEAP32[$vararg_buffer510 + 16 >> 2] = 8590;
   HEAP32[$vararg_buffer510 + 20 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 36, 0, $vararg_buffer510);
   HEAP32[$kpse + 2620 >> 2] = 0;
   HEAP32[$kpse + 2644 >> 2] = 1;
   $envvar_list$0 = $122;
   break;
  }
 case 37:
  {
   $125 = $kpse + 2648 | 0;
   HEAP32[$125 >> 2] = 8597;
   HEAP32[$vararg_buffer518 >> 2] = 8610;
   HEAP32[$vararg_buffer518 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer518 + 8 >> 2] = 0;
   _init_path($kpse, $125, 6747, $vararg_buffer518);
   HEAP32[$vararg_buffer523 >> 2] = 6776;
   HEAP32[$vararg_buffer523 + 4 >> 2] = 0;
   $126 = _concatn_with_spaces(8610, $vararg_buffer523) | 0;
   HEAP32[$vararg_buffer527 >> 2] = 8619;
   HEAP32[$vararg_buffer527 + 4 >> 2] = 8624;
   HEAP32[$vararg_buffer527 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 37, 0, $vararg_buffer527);
   HEAP32[$kpse + 2712 >> 2] = 1;
   $envvar_list$0 = $126;
   break;
  }
 case 38:
  {
   $128 = $kpse + 2716 | 0;
   HEAP32[$128 >> 2] = 8629;
   HEAP32[$vararg_buffer532 >> 2] = 8641;
   HEAP32[$vararg_buffer532 + 4 >> 2] = 0;
   _init_path($kpse, $128, 6747, $vararg_buffer532);
   HEAP32[$vararg_buffer536 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(8641, $vararg_buffer536) | 0;
   break;
  }
 case 39:
  {
   $130 = $kpse + 2784 | 0;
   HEAP32[$130 >> 2] = 8647;
   $131 = $kpse + 112 | 0;
   $132 = HEAP32[$131 >> 2] | 0;
   HEAP32[$vararg_buffer539 >> 2] = 10587;
   HEAP32[$vararg_buffer539 + 4 >> 2] = 8664;
   HEAP32[$vararg_buffer539 + 8 >> 2] = $132;
   HEAP32[$vararg_buffer539 + 12 >> 2] = 8672;
   HEAP32[$vararg_buffer539 + 16 >> 2] = 0;
   $133 = _concatn(15912, $vararg_buffer539) | 0;
   HEAP32[$vararg_buffer546 >> 2] = _concat(_uppercasify(HEAP32[$131 >> 2] | 0) | 0, 8675) | 0;
   HEAP32[$vararg_buffer546 + 4 >> 2] = 0;
   _init_path($kpse, $130, $133, $vararg_buffer546);
   $139 = _concat(_uppercasify(HEAP32[$131 >> 2] | 0) | 0, 8675) | 0;
   HEAP32[$vararg_buffer550 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces($139, $vararg_buffer550) | 0;
   break;
  }
 case 40:
  {
   $141 = $kpse + 2852 | 0;
   HEAP32[$141 >> 2] = 8682;
   $142 = $kpse + 112 | 0;
   $143 = HEAP32[$142 >> 2] | 0;
   HEAP32[$vararg_buffer553 >> 2] = 10587;
   HEAP32[$vararg_buffer553 + 4 >> 2] = 8664;
   HEAP32[$vararg_buffer553 + 8 >> 2] = $143;
   HEAP32[$vararg_buffer553 + 12 >> 2] = 8672;
   HEAP32[$vararg_buffer553 + 16 >> 2] = 0;
   $144 = _concatn(15912, $vararg_buffer553) | 0;
   HEAP32[$vararg_buffer560 >> 2] = _concat(_uppercasify(HEAP32[$142 >> 2] | 0) | 0, 8675) | 0;
   HEAP32[$vararg_buffer560 + 4 >> 2] = 0;
   _init_path($kpse, $141, $144, $vararg_buffer560);
   $150 = _concat(_uppercasify(HEAP32[$142 >> 2] | 0) | 0, 8675) | 0;
   HEAP32[$vararg_buffer564 >> 2] = 0;
   $151 = _concatn_with_spaces($150, $vararg_buffer564) | 0;
   HEAP32[$kpse + 2916 >> 2] = 1;
   $envvar_list$0 = $151;
   break;
  }
 case 41:
  {
   $153 = $kpse + 2920 | 0;
   HEAP32[$153 >> 2] = 8701;
   HEAP32[$vararg_buffer567 >> 2] = 8712;
   HEAP32[$vararg_buffer567 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer567 + 8 >> 2] = 0;
   _init_path($kpse, $153, 6747, $vararg_buffer567);
   HEAP32[$vararg_buffer572 >> 2] = 6776;
   HEAP32[$vararg_buffer572 + 4 >> 2] = 0;
   $154 = _concatn_with_spaces(8712, $vararg_buffer572) | 0;
   HEAP32[$kpse + 2984 >> 2] = 1;
   $envvar_list$0 = $154;
   break;
  }
 case 42:
  {
   $156 = $kpse + 2988 | 0;
   HEAP32[$156 >> 2] = 8722;
   HEAP32[$vararg_buffer576 >> 2] = 8726;
   HEAP32[$vararg_buffer576 + 4 >> 2] = 0;
   _init_path($kpse, $156, 6747, $vararg_buffer576);
   HEAP32[$vararg_buffer580 >> 2] = 0;
   $157 = _concatn_with_spaces(8726, $vararg_buffer580) | 0;
   HEAP32[$vararg_buffer583 >> 2] = 8736;
   HEAP32[$vararg_buffer583 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 42, 0, $vararg_buffer583);
   HEAP32[$vararg_buffer587 >> 2] = 8741;
   HEAP32[$vararg_buffer587 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 42, 1, $vararg_buffer587);
   $envvar_list$0 = $157;
   break;
  }
 case 43:
  {
   $158 = $kpse + 3056 | 0;
   HEAP32[$158 >> 2] = 8745;
   HEAP32[$vararg_buffer591 >> 2] = 8750;
   HEAP32[$vararg_buffer591 + 4 >> 2] = 0;
   _init_path($kpse, $158, 6747, $vararg_buffer591);
   HEAP32[$vararg_buffer595 >> 2] = 0;
   $159 = _concatn_with_spaces(8750, $vararg_buffer595) | 0;
   HEAP32[$vararg_buffer598 >> 2] = 8761;
   HEAP32[$vararg_buffer598 + 4 >> 2] = 8736;
   HEAP32[$vararg_buffer598 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 43, 0, $vararg_buffer598);
   HEAP32[$vararg_buffer603 >> 2] = 8741;
   HEAP32[$vararg_buffer603 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 43, 1, $vararg_buffer603);
   $envvar_list$0 = $159;
   break;
  }
 case 44:
  {
   $160 = $kpse + 3124 | 0;
   HEAP32[$160 >> 2] = 8764;
   HEAP32[$vararg_buffer607 >> 2] = 8774;
   HEAP32[$vararg_buffer607 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer607 + 8 >> 2] = 0;
   _init_path($kpse, $160, 6747, $vararg_buffer607);
   HEAP32[$vararg_buffer612 >> 2] = 6776;
   HEAP32[$vararg_buffer612 + 4 >> 2] = 0;
   $161 = _concatn_with_spaces(8774, $vararg_buffer612) | 0;
   HEAP32[$vararg_buffer616 >> 2] = 8783;
   HEAP32[$vararg_buffer616 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 44, 0, $vararg_buffer616);
   HEAP32[$kpse + 3164 >> 2] = 1;
   $envvar_list$0 = $161;
   break;
  }
 case 45:
  {
   $163 = $kpse + 3192 | 0;
   HEAP32[$163 >> 2] = 8788;
   HEAP32[$vararg_buffer620 >> 2] = 8799;
   HEAP32[$vararg_buffer620 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer620 + 8 >> 2] = 0;
   _init_path($kpse, $163, 6747, $vararg_buffer620);
   HEAP32[$vararg_buffer625 >> 2] = 6776;
   HEAP32[$vararg_buffer625 + 4 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(8799, $vararg_buffer625) | 0;
   break;
  }
 case 46:
  {
   $165 = $kpse + 3260 | 0;
   HEAP32[$165 >> 2] = 8809;
   HEAP32[$vararg_buffer629 >> 2] = 8834;
   HEAP32[$vararg_buffer629 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer629 + 8 >> 2] = 0;
   _init_path($kpse, $165, 6747, $vararg_buffer629);
   HEAP32[$vararg_buffer634 >> 2] = 6776;
   HEAP32[$vararg_buffer634 + 4 >> 2] = 0;
   $166 = _concatn_with_spaces(8834, $vararg_buffer634) | 0;
   HEAP32[$vararg_buffer638 >> 2] = 8843;
   HEAP32[$vararg_buffer638 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 46, 0, $vararg_buffer638);
   HEAP32[$kpse + 3300 >> 2] = 1;
   $envvar_list$0 = $166;
   break;
  }
 case 47:
  {
   $168 = $kpse + 3328 | 0;
   HEAP32[$168 >> 2] = 8848;
   HEAP32[$vararg_buffer642 >> 2] = 8863;
   HEAP32[$vararg_buffer642 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer642 + 8 >> 2] = 0;
   _init_path($kpse, $168, 6747, $vararg_buffer642);
   HEAP32[$vararg_buffer647 >> 2] = 6776;
   HEAP32[$vararg_buffer647 + 4 >> 2] = 0;
   $169 = _concatn_with_spaces(8863, $vararg_buffer647) | 0;
   HEAP32[$vararg_buffer651 >> 2] = 8877;
   HEAP32[$vararg_buffer651 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 47, 0, $vararg_buffer651);
   HEAP32[$kpse + 3368 >> 2] = 1;
   HEAP32[$kpse + 3392 >> 2] = 1;
   $envvar_list$0 = $169;
   break;
  }
 case 48:
  {
   $172 = $kpse + 3396 | 0;
   HEAP32[$172 >> 2] = 8882;
   HEAP32[$vararg_buffer655 >> 2] = 8896;
   HEAP32[$vararg_buffer655 + 4 >> 2] = 0;
   _init_path($kpse, $172, 6747, $vararg_buffer655);
   HEAP32[$vararg_buffer659 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(8896, $vararg_buffer659) | 0;
   break;
  }
 case 49:
  {
   $174 = $kpse + 3464 | 0;
   HEAP32[$174 >> 2] = 8909;
   HEAP32[$vararg_buffer662 >> 2] = 8919;
   HEAP32[$vararg_buffer662 + 4 >> 2] = 6776;
   HEAP32[$vararg_buffer662 + 8 >> 2] = 0;
   _init_path($kpse, $174, 6747, $vararg_buffer662);
   HEAP32[$vararg_buffer667 >> 2] = 6776;
   HEAP32[$vararg_buffer667 + 4 >> 2] = 0;
   $175 = _concatn_with_spaces(8919, $vararg_buffer667) | 0;
   HEAP32[$vararg_buffer671 >> 2] = 8928;
   HEAP32[$vararg_buffer671 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 49, 0, $vararg_buffer671);
   HEAP32[$kpse + 3504 >> 2] = 1;
   $envvar_list$0 = $175;
   break;
  }
 case 50:
  {
   $177 = $kpse + 3532 | 0;
   HEAP32[$177 >> 2] = 8933;
   HEAP32[$vararg_buffer675 >> 2] = 8946;
   HEAP32[$vararg_buffer675 + 4 >> 2] = 0;
   _init_path($kpse, $177, 6747, $vararg_buffer675);
   HEAP32[$vararg_buffer679 >> 2] = 0;
   $envvar_list$0 = _concatn_with_spaces(8946, $vararg_buffer679) | 0;
   break;
  }
 case 51:
  {
   $179 = $kpse + 3600 | 0;
   HEAP32[$179 >> 2] = 8959;
   HEAP32[$vararg_buffer682 >> 2] = 8963;
   HEAP32[$vararg_buffer682 + 4 >> 2] = 0;
   _init_path($kpse, $179, 6747, $vararg_buffer682);
   HEAP32[$vararg_buffer686 >> 2] = 0;
   $180 = _concatn_with_spaces(8963, $vararg_buffer686) | 0;
   HEAP32[$vararg_buffer689 >> 2] = 8973;
   HEAP32[$vararg_buffer689 + 4 >> 2] = 8978;
   HEAP32[$vararg_buffer689 + 8 >> 2] = 8986;
   HEAP32[$vararg_buffer689 + 12 >> 2] = 8991;
   HEAP32[$vararg_buffer689 + 16 >> 2] = 8999;
   HEAP32[$vararg_buffer689 + 20 >> 2] = 9007;
   HEAP32[$vararg_buffer689 + 24 >> 2] = 9015;
   HEAP32[$vararg_buffer689 + 28 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 51, 0, $vararg_buffer689);
   HEAP32[$kpse + 3640 >> 2] = 1;
   $envvar_list$0 = $180;
   break;
  }
 case 52:
  {
   $182 = $kpse + 3668 | 0;
   HEAP32[$182 >> 2] = 9020;
   HEAP32[$vararg_buffer699 >> 2] = 9039;
   HEAP32[$vararg_buffer699 + 4 >> 2] = 0;
   _init_path($kpse, $182, 6747, $vararg_buffer699);
   HEAP32[$vararg_buffer703 >> 2] = 0;
   $183 = _concatn_with_spaces(9039, $vararg_buffer703) | 0;
   HEAP32[$vararg_buffer706 >> 2] = 9052;
   HEAP32[$vararg_buffer706 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 52, 0, $vararg_buffer706);
   HEAP32[$kpse + 3708 >> 2] = 1;
   $envvar_list$0 = $183;
   break;
  }
 case 53:
  {
   $185 = $kpse + 3736 | 0;
   HEAP32[$185 >> 2] = 9057;
   HEAP32[$vararg_buffer710 >> 2] = 9066;
   HEAP32[$vararg_buffer710 + 4 >> 2] = 0;
   _init_path($kpse, $185, 6747, $vararg_buffer710);
   HEAP32[$vararg_buffer714 >> 2] = 0;
   $186 = _concatn_with_spaces(9066, $vararg_buffer714) | 0;
   HEAP32[$vararg_buffer717 >> 2] = 9078;
   HEAP32[$vararg_buffer717 + 4 >> 2] = 9083;
   HEAP32[$vararg_buffer717 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 53, 0, $vararg_buffer717);
   HEAP32[$kpse + 3776 >> 2] = 1;
   $envvar_list$0 = $186;
   break;
  }
 case 54:
  {
   $188 = $kpse + 3804 | 0;
   HEAP32[$188 >> 2] = 9091;
   HEAP32[$vararg_buffer722 >> 2] = 9097;
   HEAP32[$vararg_buffer722 + 4 >> 2] = 7084;
   HEAP32[$vararg_buffer722 + 8 >> 2] = 7094;
   HEAP32[$vararg_buffer722 + 12 >> 2] = 0;
   _init_path($kpse, $188, 6747, $vararg_buffer722);
   HEAP32[$vararg_buffer728 >> 2] = 7084;
   HEAP32[$vararg_buffer728 + 4 >> 2] = 7094;
   HEAP32[$vararg_buffer728 + 8 >> 2] = 0;
   $189 = _concatn_with_spaces(9097, $vararg_buffer728) | 0;
   HEAP32[$vararg_buffer733 >> 2] = 9109;
   HEAP32[$vararg_buffer733 + 4 >> 2] = 7101;
   HEAP32[$vararg_buffer733 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 54, 0, $vararg_buffer733);
   HEAP32[$kpse + 3844 >> 2] = 1;
   $envvar_list$0 = $189;
   break;
  }
 case 55:
  {
   $191 = $kpse + 3872 | 0;
   HEAP32[$191 >> 2] = 9116;
   HEAP32[$vararg_buffer738 >> 2] = 9122;
   HEAP32[$vararg_buffer738 + 4 >> 2] = 7110;
   HEAP32[$vararg_buffer738 + 8 >> 2] = 0;
   _init_path($kpse, $191, 6747, $vararg_buffer738);
   HEAP32[$vararg_buffer743 >> 2] = 7110;
   HEAP32[$vararg_buffer743 + 4 >> 2] = 0;
   $192 = _concatn_with_spaces(9122, $vararg_buffer743) | 0;
   HEAP32[$vararg_buffer747 >> 2] = 9134;
   HEAP32[$vararg_buffer747 + 4 >> 2] = 7120;
   HEAP32[$vararg_buffer747 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 55, 0, $vararg_buffer747);
   HEAP32[$kpse + 3912 >> 2] = 1;
   $envvar_list$0 = $192;
   break;
  }
 case 56:
  {
   $194 = $kpse + 3940 | 0;
   HEAP32[$194 >> 2] = 9141;
   HEAP32[$vararg_buffer752 >> 2] = 9192;
   HEAP32[$vararg_buffer752 + 4 >> 2] = 0;
   _init_path($kpse, $194, 9146, $vararg_buffer752);
   HEAP32[$vararg_buffer756 >> 2] = 0;
   $195 = _concatn_with_spaces(9192, $vararg_buffer756) | 0;
   HEAP32[$vararg_buffer759 >> 2] = 9203;
   HEAP32[$vararg_buffer759 + 4 >> 2] = 9208;
   HEAP32[$vararg_buffer759 + 8 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 56, 0, $vararg_buffer759);
   HEAP32[$kpse + 3980 >> 2] = 1;
   $envvar_list$0 = $195;
   break;
  }
 case 57:
  {
   $197 = $kpse + 4008 | 0;
   HEAP32[$197 >> 2] = 9212;
   HEAP32[$vararg_buffer764 >> 2] = 9216;
   HEAP32[$vararg_buffer764 + 4 >> 2] = 0;
   _init_path($kpse, $197, 6747, $vararg_buffer764);
   HEAP32[$vararg_buffer768 >> 2] = 0;
   $198 = _concatn_with_spaces(9216, $vararg_buffer768) | 0;
   HEAP32[$vararg_buffer771 >> 2] = 9226;
   HEAP32[$vararg_buffer771 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 57, 0, $vararg_buffer771);
   HEAP32[$kpse + 4048 >> 2] = 1;
   $envvar_list$0 = $198;
   break;
  }
 case 58:
  {
   $200 = $kpse + 4076 | 0;
   HEAP32[$200 >> 2] = 9231;
   HEAP32[$vararg_buffer775 >> 2] = 9238;
   HEAP32[$vararg_buffer775 + 4 >> 2] = 0;
   _init_path($kpse, $200, 6747, $vararg_buffer775);
   HEAP32[$vararg_buffer779 >> 2] = 0;
   $201 = _concatn_with_spaces(9238, $vararg_buffer779) | 0;
   HEAP32[$vararg_buffer782 >> 2] = 9251;
   HEAP32[$vararg_buffer782 + 4 >> 2] = 0;
   _kpathsea_set_suffixes($kpse, 58, 0, $vararg_buffer782);
   HEAP32[$kpse + 4116 >> 2] = 1;
   $envvar_list$0 = $201;
   break;
  }
 default:
  {
   $203 = HEAP32[21] | 0;
   HEAP32[$vararg_buffer786 >> 2] = HEAP32[$kpse + 104 >> 2];
   _fprintf($203, 12703, $vararg_buffer786) | 0;
   HEAP32[$vararg_buffer789 >> 2] = $format;
   _fprintf($203, 9259, $vararg_buffer789) | 0;
   _fwrite(12726, 2, 1, $203) | 0;
   _exit(1);
  }
 } while (0);
 if (!(HEAP32[$kpse + 44 >> 2] & 8)) {
  STACKTOP = sp;
  return $envvar_list$0 | 0;
 }
 $210 = HEAP32[21] | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 $214 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 12 >> 2] | 0;
 HEAP32[$vararg_buffer792 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) >> 2];
 HEAP32[$vararg_buffer792 + 4 >> 2] = $214;
 _fprintf($210, 9295, $vararg_buffer792) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer796 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) + 4 >> 2];
 _fprintf($210, 9331, $vararg_buffer796) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer799 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) + 8 >> 2];
 _fprintf($210, 9339, $vararg_buffer799) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 $220 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 16 >> 2] | 0;
 HEAP32[$vararg_buffer802 >> 2] = ($220 | 0) == 0 ? 9364 : $220;
 _fprintf($210, 9371, $vararg_buffer802) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 $223 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 20 >> 2] | 0;
 HEAP32[$vararg_buffer805 >> 2] = ($223 | 0) == 0 ? 9364 : $223;
 _fprintf($210, 9405, $vararg_buffer805) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 $227 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 24 >> 2] | 0;
 HEAP32[$vararg_buffer808 >> 2] = ($227 | 0) == 0 ? 9364 : $227;
 _fprintf($210, 9442, $vararg_buffer808) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 $230 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 28 >> 2] | 0;
 HEAP32[$vararg_buffer811 >> 2] = ($230 | 0) == 0 ? 9364 : $230;
 _fprintf($210, 9465, $vararg_buffer811) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer814 >> 2] = $envvar_list$0;
 _fprintf($210, 9491, $vararg_buffer814) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 _fwrite(9521, 20, 1, $210) | 0;
 _fflush($210) | 0;
 $234 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 32 >> 2] | 0;
 if (!$234) _fwrite(9542, 8, 1, $210) | 0; else {
  $236 = HEAP32[$234 >> 2] | 0;
  if ($236 | 0) {
   $238 = $236;
   $ext$01630 = $234;
   while (1) {
    HEAP32[$vararg_buffer817 >> 2] = $238;
    _fprintf($210, 13361, $vararg_buffer817) | 0;
    $239 = $ext$01630 + 4 | 0;
    $240 = HEAP32[$239 >> 2] | 0;
    if (!$240) break; else {
     $238 = $240;
     $ext$01630 = $239;
    }
   }
  }
  _putc(10, $210) | 0;
 }
 _fwrite(13458, 7, 1, $210) | 0;
 _fwrite(9551, 18, 1, $210) | 0;
 _fflush($210) | 0;
 $243 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 36 >> 2] | 0;
 if (!$243) _fwrite(9542, 8, 1, $210) | 0; else {
  $245 = HEAP32[$243 >> 2] | 0;
  if ($245 | 0) {
   $247 = $245;
   $alt$01428 = $243;
   while (1) {
    HEAP32[$vararg_buffer820 >> 2] = $247;
    _fprintf($210, 13361, $vararg_buffer820) | 0;
    $248 = $alt$01428 + 4 | 0;
    $249 = HEAP32[$248 >> 2] | 0;
    if (!$249) break; else {
     $247 = $249;
     $alt$01428 = $248;
    }
   }
  }
  _putc(10, $210) | 0;
 }
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer823 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) + 40 >> 2];
 _fprintf($210, 9570, $vararg_buffer823) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 $254 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 44 >> 2] | 0;
 HEAP32[$vararg_buffer826 >> 2] = ($254 | 0) == 0 ? 9364 : $254;
 _fprintf($210, 9602, $vararg_buffer826) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 _fwrite(9637, 30, 1, $210) | 0;
 _fflush($210) | 0;
 $257 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 52 >> 2] | 0;
 if (!$257) _fwrite(9542, 8, 1, $210) | 0; else {
  $259 = HEAP32[$257 >> 2] | 0;
  if ($259 | 0) {
   $261 = $259;
   $arg$013 = $257;
   while (1) {
    HEAP32[$vararg_buffer829 >> 2] = $261;
    _fprintf($210, 13361, $vararg_buffer829) | 0;
    $262 = $arg$013 + 4 | 0;
    $263 = HEAP32[$262 >> 2] | 0;
    if (!$263) break; else {
     $261 = $263;
     $arg$013 = $262;
    }
   }
  }
  _putc(10, $210) | 0;
 }
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer832 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) + 56 >> 2];
 _fprintf($210, 9668, $vararg_buffer832) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer835 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) + 60 >> 2];
 _fprintf($210, 9692, $vararg_buffer835) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer838 >> 2] = HEAP32[$kpse + 132 + ($format * 68 | 0) + 64 >> 2];
 _fprintf($210, 9721, $vararg_buffer838) | 0;
 _fflush($210) | 0;
 _fwrite(13458, 7, 1, $210) | 0;
 HEAP32[$vararg_buffer841 >> 2] = $format;
 _fprintf($210, 9755, $vararg_buffer841) | 0;
 _fflush($210) | 0;
 STACKTOP = sp;
 return $envvar_list$0 | 0;
}

function _printf_core($f, $fmt, $ap, $nl_arg, $nl_type) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 $nl_arg = $nl_arg | 0;
 $nl_type = $nl_type | 0;
 var $$0 = 0, $$0$i = 0, $$0$lcssa$i = 0, $$012$i = 0, $$013$i = 0, $$03$i33 = 0, $$07$i = 0.0, $$1$i = 0.0, $$114$i = 0, $$2$i = 0.0, $$20$i = 0.0, $$210$i = 0, $$23$i = 0, $$25$i = 0, $$3$i = 0.0, $$311$i = 0, $$33$i = 0, $$4$i = 0.0, $$412$lcssa$i = 0, $$41278$i = 0, $$43 = 0, $$5$lcssa$i = 0, $$589$i = 0, $$a$3$i = 0, $$a$3192$i = 0, $$fl$4 = 0, $$lcssa = 0, $$lcssa162$i = 0, $$lcssa295 = 0, $$lcssa300 = 0, $$lcssa301 = 0, $$lcssa302 = 0, $$lcssa303 = 0, $$lcssa304 = 0, $$lcssa306 = 0, $$lcssa316 = 0, $$lcssa319 = 0.0, $$lcssa321 = 0, $$p$$i = 0, $$p$5 = 0, $$p$i = 0, $$pn$i = 0, $$pr$i = 0, $$pr50$i = 0, $$pre$phi190$iZ2D = 0, $$pre171 = 0, $$pre188$i = 0, $$z$4$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $107 = 0, $108 = 0, $11 = 0, $110 = 0, $12 = 0, $13 = 0, $134 = 0, $135 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $145 = 0, $147 = 0, $149 = 0, $15 = 0, $150 = 0, $155 = 0, $158 = 0, $16 = 0, $163 = 0, $164 = 0, $169 = 0, $176 = 0, $177 = 0, $188 = 0, $2 = 0, $200 = 0, $207 = 0, $209 = 0, $212 = 0, $213 = 0, $218 = 0, $22 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $231 = 0, $24 = 0, $244 = 0, $246 = 0, $249 = 0, $25 = 0, $254 = 0, $257 = 0, $258 = 0, $259 = 0, $260 = 0, $267 = 0, $270 = 0, $272 = 0, $275 = 0, $277 = 0, $278 = 0, $279 = 0, $285 = 0, $287 = 0, $288 = 0, $29 = 0, $292 = 0, $3 = 0, $30 = 0, $300 = 0, $306 = 0, $318 = 0, $321 = 0, $322 = 0, $334 = 0, $336 = 0, $341 = 0, $345 = 0, $348 = 0, $349 = 0, $35 = 0, $358 = 0.0, $365 = 0, $369 = 0, $376 = 0, $378 = 0, $380 = 0, $381 = 0, $385 = 0, $391 = 0.0, $392 = 0, $395 = 0, $397 = 0, $4 = 0, $40 = 0, $400 = 0, $402 = 0, $405 = 0, $406 = 0.0, $41 = 0, $416 = 0, $419 = 0, $422 = 0, $431 = 0, $433 = 0, $434 = 0, $440 = 0, $443 = 0.0, $45 = 0, $452 = 0, $457 = 0, $462 = 0, $466 = 0, $47 = 0, $476 = 0, $477 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $484 = 0.0, $487 = 0, $489 = 0, $492 = 0, $494 = 0, $495 = 0, $496 = 0, $498 = 0, $5 = 0, $502 = 0, $504 = 0, $508 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $518 = 0, $52 = 0, $524 = 0, $525 = 0, $526 = 0, $530 = 0, $531 = 0, $538 = 0, $546 = 0, $552 = 0, $553 = 0, $555 = 0, $556 = 0, $561 = 0, $562 = 0, $564 = 0, $57 = 0, $572 = 0, $575 = 0, $578 = 0, $579 = 0, $580 = 0, $583 = 0, $587 = 0, $595 = 0, $598 = 0, $6 = 0, $60 = 0, $600 = 0, $602 = 0, $604 = 0, $609 = 0, $61 = 0, $610 = 0, $612 = 0, $613 = 0, $615 = 0, $617 = 0, $619 = 0, $62 = 0, $63 = 0, $630 = 0, $633 = 0, $637 = 0, $638 = 0, $647 = 0, $648 = 0, $652 = 0, $655 = 0, $657 = 0, $659 = 0, $66 = 0, $663 = 0, $666 = 0, $670 = 0, $68 = 0, $680 = 0, $685 = 0, $692 = 0, $697 = 0, $7 = 0, $705 = 0, $715 = 0, $719 = 0, $726 = 0, $727 = 0, $734 = 0, $736 = 0, $740 = 0, $742 = 0, $751 = 0, $757 = 0, $758 = 0, $772 = 0, $774 = 0, $787 = 0, $791 = 0, $793 = 0, $798 = 0, $8 = 0, $9 = 0, $92 = 0, $93 = 0, $99 = 0, $a$0 = 0, $a$1 = 0, $a$1$lcssa$i = 0, $a$1149$i = 0, $a$2 = 0, $a$2$ph$i = 0, $a$3$lcssa$i = 0, $a$3136$i = 0, $a$5$lcssa$i = 0, $a$5111$i = 0, $a$6$i = 0, $a$8$i = 0, $a$9$ph$i = 0, $arg = 0, $argpos$0 = 0, $big$i = 0, $buf = 0, $buf$i = 0, $carry$0142$i = 0, $carry3$0130$i = 0, $cnt$0 = 0, $cnt$1 = 0, $cnt$1$lcssa = 0, $d$0$i = 0, $d$0141$i = 0, $d$0143$i = 0, $d$1129$i = 0, $d$2$lcssa$i = 0, $d$2110$i = 0, $d$4$i = 0, $d$584$i = 0, $d$677$i = 0, $d$788$i = 0, $e$0125$i = 0, $e$1$i = 0, $e$2106$i = 0, $e$4$i = 0, $e$5$ph$i = 0, $e2$i = 0, $ebuf0$i = 0, $estr$0$i = 0, $estr$1$lcssa$i = 0, $estr$195$i = 0, $estr$2$i = 0, $fl$0100 = 0, $fl$053 = 0, $fl$1 = 0, $fl$1$ = 0, $fl$3 = 0, $fl$4 = 0, $fl$6 = 0, $i$0$lcssa = 0, $i$0$lcssa178 = 0, $i$0105 = 0, $i$0124$i = 0, $i$03$i = 0, $i$03$i25 = 0, $i$1$lcssa$i = 0, $i$1116 = 0, $i$1118$i = 0, $i$2105$i = 0, $i$291 = 0, $i$291$lcssa = 0, $i$3101$i = 0, $i$389 = 0, $isdigittmp = 0, $isdigittmp$i = 0, $isdigittmp$i26 = 0, $isdigittmp1$i = 0, $isdigittmp1$i22 = 0, $isdigittmp11 = 0, $isdigittmp4$i = 0, $isdigittmp4$i24 = 0, $isdigittmp9 = 0, $j$0$i = 0, $j$0117$i = 0, $j$0119$i = 0, $j$1102$i = 0, $j$2$i = 0, $l$0 = 0, $l$0$i = 0, $l$1104 = 0, $l$2 = 0, $l10n$0 = 0, $l10n$0$lcssa = 0, $l10n$1 = 0, $l10n$2 = 0, $l10n$3 = 0, $mb = 0, $notrhs$i = 0, $p$0 = 0, $p$1 = 0, $p$2 = 0, $p$4176 = 0, $p$5 = 0, $pl$0 = 0, $pl$0$i = 0, $pl$1 = 0, $pl$1$i = 0, $pl$2 = 0, $prefix$0 = 0, $prefix$0$$i = 0, $prefix$0$i = 0, $prefix$1 = 0, $prefix$2 = 0, $r$0$a$9$i = 0, $re$171$i = 0, $round$070$i = 0.0, $round6$1$i = 0.0, $s$0 = 0, $s$0$i = 0, $s$1 = 0, $s$1$i = 0, $s$1$i$lcssa = 0, $s$2$lcssa = 0, $s$292 = 0, $s$4 = 0, $s$6 = 0, $s$7 = 0, $s$7$lcssa298 = 0, $s7$081$i = 0, $s7$1$i = 0, $s8$0$lcssa$i = 0, $s8$072$i = 0, $s9$0$i = 0, $s9$185$i = 0, $s9$2$i = 0, $small$0$i = 0.0, $small$1$i = 0.0, $st$0 = 0, $st$0$lcssa299 = 0, $storemerge = 0, $storemerge13 = 0, $storemerge851 = 0, $storemerge899 = 0, $t$0 = 0, $t$1 = 0, $w$0 = 0, $w$1 = 0, $w$2 = 0, $wc = 0, $ws$0106 = 0, $ws$1117 = 0, $z$0$i = 0, $z$0$lcssa = 0, $z$093 = 0, $z$1$lcssa$i = 0, $z$1148$i = 0, $z$2 = 0, $z$2$i = 0, $z$2$i$lcssa = 0, $z$3$lcssa$i = 0, $z$3135$i = 0, $z$4$i = 0, $z$7$$i = 0, $z$7$i = 0, $z$7$i$lcssa = 0, $z$7$ph$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 624 | 0;
 $big$i = sp + 24 | 0;
 $e2$i = sp + 16 | 0;
 $buf$i = sp + 588 | 0;
 $ebuf0$i = sp + 576 | 0;
 $arg = sp;
 $buf = sp + 536 | 0;
 $wc = sp + 8 | 0;
 $mb = sp + 528 | 0;
 $0 = ($f | 0) != 0;
 $1 = $buf + 40 | 0;
 $2 = $1;
 $3 = $buf + 39 | 0;
 $4 = $wc + 4 | 0;
 $5 = $buf$i;
 $6 = 0 - $5 | 0;
 $7 = $ebuf0$i + 12 | 0;
 $8 = $ebuf0$i + 11 | 0;
 $9 = $7;
 $10 = $9 - $5 | 0;
 $11 = -2 - $5 | 0;
 $12 = $9 + 2 | 0;
 $13 = $big$i + 288 | 0;
 $14 = $buf$i + 9 | 0;
 $15 = $14;
 $16 = $buf$i + 8 | 0;
 $cnt$0 = 0;
 $l$0 = 0;
 $l10n$0 = 0;
 $s$0 = $fmt;
 L1 : while (1) {
  do if (($cnt$0 | 0) > -1) if (($l$0 | 0) > (2147483647 - $cnt$0 | 0)) {
   HEAP32[(___errno_location() | 0) >> 2] = 75;
   $cnt$1 = -1;
   break;
  } else {
   $cnt$1 = $l$0 + $cnt$0 | 0;
   break;
  } else $cnt$1 = $cnt$0; while (0);
  $22 = HEAP8[$s$0 >> 0] | 0;
  if (!($22 << 24 >> 24)) {
   $cnt$1$lcssa = $cnt$1;
   $l10n$0$lcssa = $l10n$0;
   label = 244;
   break;
  } else {
   $24 = $22;
   $s$1 = $s$0;
  }
  L9 : while (1) {
   switch ($24 << 24 >> 24) {
   case 37:
    {
     $s$292 = $s$1;
     $z$093 = $s$1;
     label = 9;
     break L9;
     break;
    }
   case 0:
    {
     $s$2$lcssa = $s$1;
     $z$0$lcssa = $s$1;
     break L9;
     break;
    }
   default:
    {}
   }
   $25 = $s$1 + 1 | 0;
   $24 = HEAP8[$25 >> 0] | 0;
   $s$1 = $25;
  }
  L12 : do if ((label | 0) == 9) while (1) {
   label = 0;
   if ((HEAP8[$s$292 + 1 >> 0] | 0) != 37) {
    $s$2$lcssa = $s$292;
    $z$0$lcssa = $z$093;
    break L12;
   }
   $29 = $z$093 + 1 | 0;
   $30 = $s$292 + 2 | 0;
   if ((HEAP8[$30 >> 0] | 0) == 37) {
    $s$292 = $30;
    $z$093 = $29;
    label = 9;
   } else {
    $s$2$lcssa = $30;
    $z$0$lcssa = $29;
    break;
   }
  } while (0);
  $35 = $z$0$lcssa - $s$0 | 0;
  if ($0) if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s$0, $35, $f) | 0;
  if (($z$0$lcssa | 0) != ($s$0 | 0)) {
   $cnt$0 = $cnt$1;
   $l$0 = $35;
   $s$0 = $s$2$lcssa;
   continue;
  }
  $40 = $s$2$lcssa + 1 | 0;
  $41 = HEAP8[$40 >> 0] | 0;
  $isdigittmp = ($41 << 24 >> 24) + -48 | 0;
  if ($isdigittmp >>> 0 < 10) {
   $45 = (HEAP8[$s$2$lcssa + 2 >> 0] | 0) == 36;
   $$43 = $45 ? $s$2$lcssa + 3 | 0 : $40;
   $48 = HEAP8[$$43 >> 0] | 0;
   $argpos$0 = $45 ? $isdigittmp : -1;
   $l10n$1 = $45 ? 1 : $l10n$0;
   $storemerge = $$43;
  } else {
   $48 = $41;
   $argpos$0 = -1;
   $l10n$1 = $l10n$0;
   $storemerge = $40;
  }
  $47 = $48 << 24 >> 24;
  L25 : do if (($47 & -32 | 0) == 32) {
   $52 = $47;
   $57 = $48;
   $fl$0100 = 0;
   $storemerge899 = $storemerge;
   while (1) {
    if (!(1 << $52 + -32 & 75913)) {
     $66 = $57;
     $fl$053 = $fl$0100;
     $storemerge851 = $storemerge899;
     break L25;
    }
    $60 = 1 << ($57 << 24 >> 24) + -32 | $fl$0100;
    $61 = $storemerge899 + 1 | 0;
    $62 = HEAP8[$61 >> 0] | 0;
    $63 = $62 << 24 >> 24;
    if (($63 & -32 | 0) == 32) {
     $52 = $63;
     $57 = $62;
     $fl$0100 = $60;
     $storemerge899 = $61;
    } else {
     $66 = $62;
     $fl$053 = $60;
     $storemerge851 = $61;
     break;
    }
   }
  } else {
   $66 = $48;
   $fl$053 = 0;
   $storemerge851 = $storemerge;
  } while (0);
  do if ($66 << 24 >> 24 == 42) {
   $68 = $storemerge851 + 1 | 0;
   $isdigittmp11 = (HEAP8[$68 >> 0] | 0) + -48 | 0;
   if ($isdigittmp11 >>> 0 < 10) if ((HEAP8[$storemerge851 + 2 >> 0] | 0) == 36) {
    HEAP32[$nl_type + ($isdigittmp11 << 2) >> 2] = 10;
    $l10n$2 = 1;
    $storemerge13 = $storemerge851 + 3 | 0;
    $w$0 = HEAP32[$nl_arg + ((HEAP8[$68 >> 0] | 0) + -48 << 3) >> 2] | 0;
   } else label = 24; else label = 24;
   if ((label | 0) == 24) {
    label = 0;
    if ($l10n$1 | 0) {
     $$0 = -1;
     break L1;
    }
    if (!$0) {
     $fl$1 = $fl$053;
     $l10n$3 = 0;
     $s$4 = $68;
     $w$1 = 0;
     break;
    }
    $92 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
    $93 = HEAP32[$92 >> 2] | 0;
    HEAP32[$ap >> 2] = $92 + 4;
    $l10n$2 = 0;
    $storemerge13 = $68;
    $w$0 = $93;
   }
   if (($w$0 | 0) < 0) {
    $fl$1 = $fl$053 | 8192;
    $l10n$3 = $l10n$2;
    $s$4 = $storemerge13;
    $w$1 = 0 - $w$0 | 0;
   } else {
    $fl$1 = $fl$053;
    $l10n$3 = $l10n$2;
    $s$4 = $storemerge13;
    $w$1 = $w$0;
   }
  } else {
   $isdigittmp1$i = ($66 << 24 >> 24) + -48 | 0;
   if ($isdigittmp1$i >>> 0 < 10) {
    $101 = $storemerge851;
    $i$03$i = 0;
    $isdigittmp4$i = $isdigittmp1$i;
    while (1) {
     $99 = ($i$03$i * 10 | 0) + $isdigittmp4$i | 0;
     $100 = $101 + 1 | 0;
     $isdigittmp$i = (HEAP8[$100 >> 0] | 0) + -48 | 0;
     if ($isdigittmp$i >>> 0 < 10) {
      $101 = $100;
      $i$03$i = $99;
      $isdigittmp4$i = $isdigittmp$i;
     } else {
      $$lcssa = $99;
      $$lcssa295 = $100;
      break;
     }
    }
    if (($$lcssa | 0) < 0) {
     $$0 = -1;
     break L1;
    } else {
     $fl$1 = $fl$053;
     $l10n$3 = $l10n$1;
     $s$4 = $$lcssa295;
     $w$1 = $$lcssa;
    }
   } else {
    $fl$1 = $fl$053;
    $l10n$3 = $l10n$1;
    $s$4 = $storemerge851;
    $w$1 = 0;
   }
  } while (0);
  L46 : do if ((HEAP8[$s$4 >> 0] | 0) == 46) {
   $107 = $s$4 + 1 | 0;
   $108 = HEAP8[$107 >> 0] | 0;
   if ($108 << 24 >> 24 != 42) {
    $isdigittmp1$i22 = ($108 << 24 >> 24) + -48 | 0;
    if ($isdigittmp1$i22 >>> 0 < 10) {
     $140 = $107;
     $i$03$i25 = 0;
     $isdigittmp4$i24 = $isdigittmp1$i22;
    } else {
     $p$0 = 0;
     $s$6 = $107;
     break;
    }
    while (1) {
     $138 = ($i$03$i25 * 10 | 0) + $isdigittmp4$i24 | 0;
     $139 = $140 + 1 | 0;
     $isdigittmp$i26 = (HEAP8[$139 >> 0] | 0) + -48 | 0;
     if ($isdigittmp$i26 >>> 0 < 10) {
      $140 = $139;
      $i$03$i25 = $138;
      $isdigittmp4$i24 = $isdigittmp$i26;
     } else {
      $p$0 = $138;
      $s$6 = $139;
      break L46;
     }
    }
   }
   $110 = $s$4 + 2 | 0;
   $isdigittmp9 = (HEAP8[$110 >> 0] | 0) + -48 | 0;
   if ($isdigittmp9 >>> 0 < 10) if ((HEAP8[$s$4 + 3 >> 0] | 0) == 36) {
    HEAP32[$nl_type + ($isdigittmp9 << 2) >> 2] = 10;
    $p$0 = HEAP32[$nl_arg + ((HEAP8[$110 >> 0] | 0) + -48 << 3) >> 2] | 0;
    $s$6 = $s$4 + 4 | 0;
    break;
   }
   if ($l10n$3 | 0) {
    $$0 = -1;
    break L1;
   }
   if ($0) {
    $134 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
    $135 = HEAP32[$134 >> 2] | 0;
    HEAP32[$ap >> 2] = $134 + 4;
    $p$0 = $135;
    $s$6 = $110;
   } else {
    $p$0 = 0;
    $s$6 = $110;
   }
  } else {
   $p$0 = -1;
   $s$6 = $s$4;
  } while (0);
  $s$7 = $s$6;
  $st$0 = 0;
  while (1) {
   $145 = (HEAP8[$s$7 >> 0] | 0) + -65 | 0;
   if ($145 >>> 0 > 57) {
    $$0 = -1;
    break L1;
   }
   $147 = $s$7 + 1 | 0;
   $149 = HEAP8[15380 + ($st$0 * 58 | 0) + $145 >> 0] | 0;
   $150 = $149 & 255;
   if (($150 + -1 | 0) >>> 0 < 8) {
    $s$7 = $147;
    $st$0 = $150;
   } else {
    $$lcssa300 = $147;
    $$lcssa301 = $149;
    $$lcssa302 = $150;
    $s$7$lcssa298 = $s$7;
    $st$0$lcssa299 = $st$0;
    break;
   }
  }
  if (!($$lcssa301 << 24 >> 24)) {
   $$0 = -1;
   break;
  }
  $155 = ($argpos$0 | 0) > -1;
  do if ($$lcssa301 << 24 >> 24 == 19) if ($155) {
   $$0 = -1;
   break L1;
  } else label = 52; else {
   if ($155) {
    HEAP32[$nl_type + ($argpos$0 << 2) >> 2] = $$lcssa302;
    $158 = $nl_arg + ($argpos$0 << 3) | 0;
    $163 = HEAP32[$158 + 4 >> 2] | 0;
    $164 = $arg;
    HEAP32[$164 >> 2] = HEAP32[$158 >> 2];
    HEAP32[$164 + 4 >> 2] = $163;
    label = 52;
    break;
   }
   if (!$0) {
    $$0 = 0;
    break L1;
   }
   _pop_arg($arg, $$lcssa302, $ap);
  } while (0);
  if ((label | 0) == 52) {
   label = 0;
   if (!$0) {
    $cnt$0 = $cnt$1;
    $l$0 = $35;
    $l10n$0 = $l10n$3;
    $s$0 = $$lcssa300;
    continue;
   }
  }
  $169 = HEAP8[$s$7$lcssa298 >> 0] | 0;
  $t$0 = ($st$0$lcssa299 | 0) != 0 & ($169 & 15 | 0) == 3 ? $169 & -33 : $169;
  $176 = $fl$1 & -65537;
  $fl$1$ = ($fl$1 & 8192 | 0) == 0 ? $fl$1 : $176;
  L75 : do switch ($t$0 | 0) {
  case 110:
   {
    switch ($st$0$lcssa299 | 0) {
    case 0:
     {
      HEAP32[HEAP32[$arg >> 2] >> 2] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 1:
     {
      HEAP32[HEAP32[$arg >> 2] >> 2] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 2:
     {
      $188 = HEAP32[$arg >> 2] | 0;
      HEAP32[$188 >> 2] = $cnt$1;
      HEAP32[$188 + 4 >> 2] = (($cnt$1 | 0) < 0) << 31 >> 31;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 3:
     {
      HEAP16[HEAP32[$arg >> 2] >> 1] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 4:
     {
      HEAP8[HEAP32[$arg >> 2] >> 0] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 6:
     {
      HEAP32[HEAP32[$arg >> 2] >> 2] = $cnt$1;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    case 7:
     {
      $200 = HEAP32[$arg >> 2] | 0;
      HEAP32[$200 >> 2] = $cnt$1;
      HEAP32[$200 + 4 >> 2] = (($cnt$1 | 0) < 0) << 31 >> 31;
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
      break;
     }
    default:
     {
      $cnt$0 = $cnt$1;
      $l$0 = $35;
      $l10n$0 = $l10n$3;
      $s$0 = $$lcssa300;
      continue L1;
     }
    }
    break;
   }
  case 112:
   {
    $fl$3 = $fl$1$ | 8;
    $p$1 = $p$0 >>> 0 > 8 ? $p$0 : 8;
    $t$1 = 120;
    label = 64;
    break;
   }
  case 88:
  case 120:
   {
    $fl$3 = $fl$1$;
    $p$1 = $p$0;
    $t$1 = $t$0;
    label = 64;
    break;
   }
  case 111:
   {
    $244 = $arg;
    $246 = HEAP32[$244 >> 2] | 0;
    $249 = HEAP32[$244 + 4 >> 2] | 0;
    if (($246 | 0) == 0 & ($249 | 0) == 0) $$0$lcssa$i = $1; else {
     $$03$i33 = $1;
     $254 = $246;
     $258 = $249;
     while (1) {
      $257 = $$03$i33 + -1 | 0;
      HEAP8[$257 >> 0] = $254 & 7 | 48;
      $259 = _bitshift64Lshr($254 | 0, $258 | 0, 3) | 0;
      $260 = tempRet0;
      if (($259 | 0) == 0 & ($260 | 0) == 0) {
       $$0$lcssa$i = $257;
       break;
      } else {
       $$03$i33 = $257;
       $254 = $259;
       $258 = $260;
      }
     }
    }
    if (!($fl$1$ & 8)) {
     $a$0 = $$0$lcssa$i;
     $fl$4 = $fl$1$;
     $p$2 = $p$0;
     $pl$1 = 0;
     $prefix$1 = 15844;
     label = 77;
    } else {
     $267 = $2 - $$0$lcssa$i | 0;
     $a$0 = $$0$lcssa$i;
     $fl$4 = $fl$1$;
     $p$2 = ($p$0 | 0) > ($267 | 0) ? $p$0 : $267 + 1 | 0;
     $pl$1 = 0;
     $prefix$1 = 15844;
     label = 77;
    }
    break;
   }
  case 105:
  case 100:
   {
    $270 = $arg;
    $272 = HEAP32[$270 >> 2] | 0;
    $275 = HEAP32[$270 + 4 >> 2] | 0;
    if (($275 | 0) < 0) {
     $277 = _i64Subtract(0, 0, $272 | 0, $275 | 0) | 0;
     $278 = tempRet0;
     $279 = $arg;
     HEAP32[$279 >> 2] = $277;
     HEAP32[$279 + 4 >> 2] = $278;
     $287 = $277;
     $288 = $278;
     $pl$0 = 1;
     $prefix$0 = 15844;
     label = 76;
     break L75;
    }
    if (!($fl$1$ & 2048)) {
     $285 = $fl$1$ & 1;
     $287 = $272;
     $288 = $275;
     $pl$0 = $285;
     $prefix$0 = ($285 | 0) == 0 ? 15844 : 15846;
     label = 76;
    } else {
     $287 = $272;
     $288 = $275;
     $pl$0 = 1;
     $prefix$0 = 15845;
     label = 76;
    }
    break;
   }
  case 117:
   {
    $177 = $arg;
    $287 = HEAP32[$177 >> 2] | 0;
    $288 = HEAP32[$177 + 4 >> 2] | 0;
    $pl$0 = 0;
    $prefix$0 = 15844;
    label = 76;
    break;
   }
  case 99:
   {
    HEAP8[$3 >> 0] = HEAP32[$arg >> 2];
    $a$2 = $3;
    $fl$6 = $176;
    $p$5 = 1;
    $pl$2 = 0;
    $prefix$2 = 15844;
    $z$2 = $1;
    break;
   }
  case 109:
   {
    $a$1 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0;
    label = 82;
    break;
   }
  case 115:
   {
    $318 = HEAP32[$arg >> 2] | 0;
    $a$1 = $318 | 0 ? $318 : 15870;
    label = 82;
    break;
   }
  case 67:
   {
    HEAP32[$wc >> 2] = HEAP32[$arg >> 2];
    HEAP32[$4 >> 2] = 0;
    HEAP32[$arg >> 2] = $wc;
    $798 = $wc;
    $p$4176 = -1;
    label = 86;
    break;
   }
  case 83:
   {
    $$pre171 = HEAP32[$arg >> 2] | 0;
    if (!$p$0) {
     _pad($f, 32, $w$1, 0, $fl$1$);
     $i$0$lcssa178 = 0;
     label = 97;
    } else {
     $798 = $$pre171;
     $p$4176 = $p$0;
     label = 86;
    }
    break;
   }
  case 65:
  case 71:
  case 70:
  case 69:
  case 97:
  case 103:
  case 102:
  case 101:
   {
    $358 = +HEAPF64[$arg >> 3];
    HEAP32[$e2$i >> 2] = 0;
    HEAPF64[tempDoublePtr >> 3] = $358;
    if ((HEAP32[tempDoublePtr + 4 >> 2] | 0) < 0) {
     $$07$i = -$358;
     $pl$0$i = 1;
     $prefix$0$i = 15877;
    } else if (!($fl$1$ & 2048)) {
     $365 = $fl$1$ & 1;
     $$07$i = $358;
     $pl$0$i = $365;
     $prefix$0$i = ($365 | 0) == 0 ? 15878 : 15883;
    } else {
     $$07$i = $358;
     $pl$0$i = 1;
     $prefix$0$i = 15880;
    }
    HEAPF64[tempDoublePtr >> 3] = $$07$i;
    $369 = HEAP32[tempDoublePtr + 4 >> 2] & 2146435072;
    do if ($369 >>> 0 < 2146435072 | ($369 | 0) == 2146435072 & 0 < 0) {
     $391 = +_frexpl($$07$i, $e2$i) * 2.0;
     $392 = $391 != 0.0;
     if ($392) HEAP32[$e2$i >> 2] = (HEAP32[$e2$i >> 2] | 0) + -1;
     $395 = $t$0 | 32;
     if (($395 | 0) == 97) {
      $397 = $t$0 & 32;
      $prefix$0$$i = ($397 | 0) == 0 ? $prefix$0$i : $prefix$0$i + 9 | 0;
      $400 = $pl$0$i | 2;
      $402 = 12 - $p$0 | 0;
      do if ($p$0 >>> 0 > 11 | ($402 | 0) == 0) $$1$i = $391; else {
       $re$171$i = $402;
       $round$070$i = 8.0;
       while (1) {
        $405 = $re$171$i + -1 | 0;
        $406 = $round$070$i * 16.0;
        if (!$405) {
         $$lcssa319 = $406;
         break;
        } else {
         $re$171$i = $405;
         $round$070$i = $406;
        }
       }
       if ((HEAP8[$prefix$0$$i >> 0] | 0) == 45) {
        $$1$i = -($$lcssa319 + (-$391 - $$lcssa319));
        break;
       } else {
        $$1$i = $391 + $$lcssa319 - $$lcssa319;
        break;
       }
      } while (0);
      $416 = HEAP32[$e2$i >> 2] | 0;
      $419 = ($416 | 0) < 0 ? 0 - $416 | 0 : $416;
      $422 = _fmt_u($419, (($419 | 0) < 0) << 31 >> 31, $7) | 0;
      if (($422 | 0) == ($7 | 0)) {
       HEAP8[$8 >> 0] = 48;
       $estr$0$i = $8;
      } else $estr$0$i = $422;
      HEAP8[$estr$0$i + -1 >> 0] = ($416 >> 31 & 2) + 43;
      $431 = $estr$0$i + -2 | 0;
      HEAP8[$431 >> 0] = $t$0 + 15;
      $notrhs$i = ($p$0 | 0) < 1;
      $433 = ($fl$1$ & 8 | 0) == 0;
      $$2$i = $$1$i;
      $s$0$i = $buf$i;
      while (1) {
       $434 = ~~$$2$i;
       $440 = $s$0$i + 1 | 0;
       HEAP8[$s$0$i >> 0] = HEAPU8[15854 + $434 >> 0] | $397;
       $443 = ($$2$i - +($434 | 0)) * 16.0;
       do if (($440 - $5 | 0) == 1) {
        if ($433 & ($notrhs$i & $443 == 0.0)) {
         $s$1$i = $440;
         break;
        }
        HEAP8[$440 >> 0] = 46;
        $s$1$i = $s$0$i + 2 | 0;
       } else $s$1$i = $440; while (0);
       if ($443 != 0.0) {
        $$2$i = $443;
        $s$0$i = $s$1$i;
       } else {
        $s$1$i$lcssa = $s$1$i;
        break;
       }
      }
      $$pre188$i = $s$1$i$lcssa;
      $452 = $431;
      $l$0$i = ($p$0 | 0) != 0 & ($11 + $$pre188$i | 0) < ($p$0 | 0) ? $12 + $p$0 - $452 | 0 : $10 - $452 + $$pre188$i | 0;
      $457 = $l$0$i + $400 | 0;
      _pad($f, 32, $w$1, $457, $fl$1$);
      if (!(HEAP32[$f >> 2] & 32)) ___fwritex($prefix$0$$i, $400, $f) | 0;
      _pad($f, 48, $w$1, $457, $fl$1$ ^ 65536);
      $462 = $$pre188$i - $5 | 0;
      if (!(HEAP32[$f >> 2] & 32)) ___fwritex($buf$i, $462, $f) | 0;
      $466 = $9 - $452 | 0;
      _pad($f, 48, $l$0$i - ($462 + $466) | 0, 0, 0);
      if (!(HEAP32[$f >> 2] & 32)) ___fwritex($431, $466, $f) | 0;
      _pad($f, 32, $w$1, $457, $fl$1$ ^ 8192);
      $$0$i = ($457 | 0) < ($w$1 | 0) ? $w$1 : $457;
      break;
     }
     $$p$i = ($p$0 | 0) < 0 ? 6 : $p$0;
     if ($392) {
      $476 = (HEAP32[$e2$i >> 2] | 0) + -28 | 0;
      HEAP32[$e2$i >> 2] = $476;
      $$3$i = $391 * 268435456.0;
      $477 = $476;
     } else {
      $$3$i = $391;
      $477 = HEAP32[$e2$i >> 2] | 0;
     }
     $$33$i = ($477 | 0) < 0 ? $big$i : $13;
     $479 = $$33$i;
     $$4$i = $$3$i;
     $z$0$i = $$33$i;
     while (1) {
      $480 = ~~$$4$i >>> 0;
      HEAP32[$z$0$i >> 2] = $480;
      $481 = $z$0$i + 4 | 0;
      $484 = ($$4$i - +($480 >>> 0)) * 1.0e9;
      if ($484 != 0.0) {
       $$4$i = $484;
       $z$0$i = $481;
      } else {
       $$lcssa303 = $481;
       break;
      }
     }
     $$pr$i = HEAP32[$e2$i >> 2] | 0;
     if (($$pr$i | 0) > 0) {
      $487 = $$pr$i;
      $a$1149$i = $$33$i;
      $z$1148$i = $$lcssa303;
      while (1) {
       $489 = ($487 | 0) > 29 ? 29 : $487;
       $d$0141$i = $z$1148$i + -4 | 0;
       do if ($d$0141$i >>> 0 < $a$1149$i >>> 0) $a$2$ph$i = $a$1149$i; else {
        $carry$0142$i = 0;
        $d$0143$i = $d$0141$i;
        while (1) {
         $492 = _bitshift64Shl(HEAP32[$d$0143$i >> 2] | 0, 0, $489 | 0) | 0;
         $494 = _i64Add($492 | 0, tempRet0 | 0, $carry$0142$i | 0, 0) | 0;
         $495 = tempRet0;
         $496 = ___uremdi3($494 | 0, $495 | 0, 1e9, 0) | 0;
         HEAP32[$d$0143$i >> 2] = $496;
         $498 = ___udivdi3($494 | 0, $495 | 0, 1e9, 0) | 0;
         $d$0$i = $d$0143$i + -4 | 0;
         if ($d$0$i >>> 0 < $a$1149$i >>> 0) {
          $$lcssa304 = $498;
          break;
         } else {
          $carry$0142$i = $498;
          $d$0143$i = $d$0$i;
         }
        }
        if (!$$lcssa304) {
         $a$2$ph$i = $a$1149$i;
         break;
        }
        $502 = $a$1149$i + -4 | 0;
        HEAP32[$502 >> 2] = $$lcssa304;
        $a$2$ph$i = $502;
       } while (0);
       $z$2$i = $z$1148$i;
       while (1) {
        if ($z$2$i >>> 0 <= $a$2$ph$i >>> 0) {
         $z$2$i$lcssa = $z$2$i;
         break;
        }
        $504 = $z$2$i + -4 | 0;
        if (!(HEAP32[$504 >> 2] | 0)) $z$2$i = $504; else {
         $z$2$i$lcssa = $z$2$i;
         break;
        }
       }
       $508 = (HEAP32[$e2$i >> 2] | 0) - $489 | 0;
       HEAP32[$e2$i >> 2] = $508;
       if (($508 | 0) > 0) {
        $487 = $508;
        $a$1149$i = $a$2$ph$i;
        $z$1148$i = $z$2$i$lcssa;
       } else {
        $$pr50$i = $508;
        $a$1$lcssa$i = $a$2$ph$i;
        $z$1$lcssa$i = $z$2$i$lcssa;
        break;
       }
      }
     } else {
      $$pr50$i = $$pr$i;
      $a$1$lcssa$i = $$33$i;
      $z$1$lcssa$i = $$lcssa303;
     }
     if (($$pr50$i | 0) < 0) {
      $513 = (($$p$i + 25 | 0) / 9 | 0) + 1 | 0;
      $514 = ($395 | 0) == 102;
      $516 = $$pr50$i;
      $a$3136$i = $a$1$lcssa$i;
      $z$3135$i = $z$1$lcssa$i;
      while (1) {
       $515 = 0 - $516 | 0;
       $518 = ($515 | 0) > 9 ? 9 : $515;
       do if ($a$3136$i >>> 0 < $z$3135$i >>> 0) {
        $524 = (1 << $518) + -1 | 0;
        $525 = 1e9 >>> $518;
        $carry3$0130$i = 0;
        $d$1129$i = $a$3136$i;
        while (1) {
         $526 = HEAP32[$d$1129$i >> 2] | 0;
         HEAP32[$d$1129$i >> 2] = ($526 >>> $518) + $carry3$0130$i;
         $530 = Math_imul($526 & $524, $525) | 0;
         $531 = $d$1129$i + 4 | 0;
         if ($531 >>> 0 < $z$3135$i >>> 0) {
          $carry3$0130$i = $530;
          $d$1129$i = $531;
         } else {
          $$lcssa306 = $530;
          break;
         }
        }
        $$a$3$i = (HEAP32[$a$3136$i >> 2] | 0) == 0 ? $a$3136$i + 4 | 0 : $a$3136$i;
        if (!$$lcssa306) {
         $$a$3192$i = $$a$3$i;
         $z$4$i = $z$3135$i;
         break;
        }
        HEAP32[$z$3135$i >> 2] = $$lcssa306;
        $$a$3192$i = $$a$3$i;
        $z$4$i = $z$3135$i + 4 | 0;
       } else {
        $$a$3192$i = (HEAP32[$a$3136$i >> 2] | 0) == 0 ? $a$3136$i + 4 | 0 : $a$3136$i;
        $z$4$i = $z$3135$i;
       } while (0);
       $538 = $514 ? $$33$i : $$a$3192$i;
       $$z$4$i = ($z$4$i - $538 >> 2 | 0) > ($513 | 0) ? $538 + ($513 << 2) | 0 : $z$4$i;
       $546 = (HEAP32[$e2$i >> 2] | 0) + $518 | 0;
       HEAP32[$e2$i >> 2] = $546;
       if (($546 | 0) < 0) {
        $516 = $546;
        $a$3136$i = $$a$3192$i;
        $z$3135$i = $$z$4$i;
       } else {
        $a$3$lcssa$i = $$a$3192$i;
        $z$3$lcssa$i = $$z$4$i;
        break;
       }
      }
     } else {
      $a$3$lcssa$i = $a$1$lcssa$i;
      $z$3$lcssa$i = $z$1$lcssa$i;
     }
     do if ($a$3$lcssa$i >>> 0 < $z$3$lcssa$i >>> 0) {
      $552 = ($479 - $a$3$lcssa$i >> 2) * 9 | 0;
      $553 = HEAP32[$a$3$lcssa$i >> 2] | 0;
      if ($553 >>> 0 < 10) {
       $e$1$i = $552;
       break;
      } else {
       $e$0125$i = $552;
       $i$0124$i = 10;
      }
      while (1) {
       $555 = $i$0124$i * 10 | 0;
       $556 = $e$0125$i + 1 | 0;
       if ($553 >>> 0 < $555 >>> 0) {
        $e$1$i = $556;
        break;
       } else {
        $e$0125$i = $556;
        $i$0124$i = $555;
       }
      }
     } else $e$1$i = 0; while (0);
     $561 = ($395 | 0) == 103;
     $562 = ($$p$i | 0) != 0;
     $564 = $$p$i - (($395 | 0) != 102 ? $e$1$i : 0) + (($562 & $561) << 31 >> 31) | 0;
     if (($564 | 0) < ((($z$3$lcssa$i - $479 >> 2) * 9 | 0) + -9 | 0)) {
      $572 = $564 + 9216 | 0;
      $575 = $$33$i + 4 + ((($572 | 0) / 9 | 0) + -1024 << 2) | 0;
      $j$0117$i = (($572 | 0) % 9 | 0) + 1 | 0;
      if (($j$0117$i | 0) < 9) {
       $i$1118$i = 10;
       $j$0119$i = $j$0117$i;
       while (1) {
        $578 = $i$1118$i * 10 | 0;
        $j$0$i = $j$0119$i + 1 | 0;
        if (($j$0$i | 0) == 9) {
         $i$1$lcssa$i = $578;
         break;
        } else {
         $i$1118$i = $578;
         $j$0119$i = $j$0$i;
        }
       }
      } else $i$1$lcssa$i = 10;
      $579 = HEAP32[$575 >> 2] | 0;
      $580 = ($579 >>> 0) % ($i$1$lcssa$i >>> 0) | 0;
      $583 = ($575 + 4 | 0) == ($z$3$lcssa$i | 0);
      do if ($583 & ($580 | 0) == 0) {
       $a$8$i = $a$3$lcssa$i;
       $d$4$i = $575;
       $e$4$i = $e$1$i;
      } else {
       $$20$i = ((($579 >>> 0) / ($i$1$lcssa$i >>> 0) | 0) & 1 | 0) == 0 ? 9007199254740992.0 : 9007199254740994.0;
       $587 = ($i$1$lcssa$i | 0) / 2 | 0;
       if ($580 >>> 0 < $587 >>> 0) $small$0$i = .5; else $small$0$i = $583 & ($580 | 0) == ($587 | 0) ? 1.0 : 1.5;
       do if (!$pl$0$i) {
        $round6$1$i = $$20$i;
        $small$1$i = $small$0$i;
       } else {
        if ((HEAP8[$prefix$0$i >> 0] | 0) != 45) {
         $round6$1$i = $$20$i;
         $small$1$i = $small$0$i;
         break;
        }
        $round6$1$i = -$$20$i;
        $small$1$i = -$small$0$i;
       } while (0);
       $595 = $579 - $580 | 0;
       HEAP32[$575 >> 2] = $595;
       if (!($round6$1$i + $small$1$i != $round6$1$i)) {
        $a$8$i = $a$3$lcssa$i;
        $d$4$i = $575;
        $e$4$i = $e$1$i;
        break;
       }
       $598 = $595 + $i$1$lcssa$i | 0;
       HEAP32[$575 >> 2] = $598;
       if ($598 >>> 0 > 999999999) {
        $a$5111$i = $a$3$lcssa$i;
        $d$2110$i = $575;
        while (1) {
         $600 = $d$2110$i + -4 | 0;
         HEAP32[$d$2110$i >> 2] = 0;
         if ($600 >>> 0 < $a$5111$i >>> 0) {
          $602 = $a$5111$i + -4 | 0;
          HEAP32[$602 >> 2] = 0;
          $a$6$i = $602;
         } else $a$6$i = $a$5111$i;
         $604 = (HEAP32[$600 >> 2] | 0) + 1 | 0;
         HEAP32[$600 >> 2] = $604;
         if ($604 >>> 0 > 999999999) {
          $a$5111$i = $a$6$i;
          $d$2110$i = $600;
         } else {
          $a$5$lcssa$i = $a$6$i;
          $d$2$lcssa$i = $600;
          break;
         }
        }
       } else {
        $a$5$lcssa$i = $a$3$lcssa$i;
        $d$2$lcssa$i = $575;
       }
       $609 = ($479 - $a$5$lcssa$i >> 2) * 9 | 0;
       $610 = HEAP32[$a$5$lcssa$i >> 2] | 0;
       if ($610 >>> 0 < 10) {
        $a$8$i = $a$5$lcssa$i;
        $d$4$i = $d$2$lcssa$i;
        $e$4$i = $609;
        break;
       } else {
        $e$2106$i = $609;
        $i$2105$i = 10;
       }
       while (1) {
        $612 = $i$2105$i * 10 | 0;
        $613 = $e$2106$i + 1 | 0;
        if ($610 >>> 0 < $612 >>> 0) {
         $a$8$i = $a$5$lcssa$i;
         $d$4$i = $d$2$lcssa$i;
         $e$4$i = $613;
         break;
        } else {
         $e$2106$i = $613;
         $i$2105$i = $612;
        }
       }
      } while (0);
      $615 = $d$4$i + 4 | 0;
      $a$9$ph$i = $a$8$i;
      $e$5$ph$i = $e$4$i;
      $z$7$ph$i = $z$3$lcssa$i >>> 0 > $615 >>> 0 ? $615 : $z$3$lcssa$i;
     } else {
      $a$9$ph$i = $a$3$lcssa$i;
      $e$5$ph$i = $e$1$i;
      $z$7$ph$i = $z$3$lcssa$i;
     }
     $617 = 0 - $e$5$ph$i | 0;
     $z$7$i = $z$7$ph$i;
     while (1) {
      if ($z$7$i >>> 0 <= $a$9$ph$i >>> 0) {
       $$lcssa162$i = 0;
       $z$7$i$lcssa = $z$7$i;
       break;
      }
      $619 = $z$7$i + -4 | 0;
      if (!(HEAP32[$619 >> 2] | 0)) $z$7$i = $619; else {
       $$lcssa162$i = 1;
       $z$7$i$lcssa = $z$7$i;
       break;
      }
     }
     do if ($561) {
      $$p$$i = ($562 & 1 ^ 1) + $$p$i | 0;
      if (($$p$$i | 0) > ($e$5$ph$i | 0) & ($e$5$ph$i | 0) > -5) {
       $$013$i = $t$0 + -1 | 0;
       $$210$i = $$p$$i + -1 - $e$5$ph$i | 0;
      } else {
       $$013$i = $t$0 + -2 | 0;
       $$210$i = $$p$$i + -1 | 0;
      }
      $630 = $fl$1$ & 8;
      if ($630 | 0) {
       $$114$i = $$013$i;
       $$311$i = $$210$i;
       $$pre$phi190$iZ2D = $630;
       break;
      }
      do if ($$lcssa162$i) {
       $633 = HEAP32[$z$7$i$lcssa + -4 >> 2] | 0;
       if (!$633) {
        $j$2$i = 9;
        break;
       }
       if (!(($633 >>> 0) % 10 | 0)) {
        $i$3101$i = 10;
        $j$1102$i = 0;
       } else {
        $j$2$i = 0;
        break;
       }
       while (1) {
        $637 = $i$3101$i * 10 | 0;
        $638 = $j$1102$i + 1 | 0;
        if (!(($633 >>> 0) % ($637 >>> 0) | 0)) {
         $i$3101$i = $637;
         $j$1102$i = $638;
        } else {
         $j$2$i = $638;
         break;
        }
       }
      } else $j$2$i = 9; while (0);
      $647 = (($z$7$i$lcssa - $479 >> 2) * 9 | 0) + -9 | 0;
      if (($$013$i | 32 | 0) == 102) {
       $648 = $647 - $j$2$i | 0;
       $$23$i = ($648 | 0) < 0 ? 0 : $648;
       $$114$i = $$013$i;
       $$311$i = ($$210$i | 0) < ($$23$i | 0) ? $$210$i : $$23$i;
       $$pre$phi190$iZ2D = 0;
       break;
      } else {
       $652 = $647 + $e$5$ph$i - $j$2$i | 0;
       $$25$i = ($652 | 0) < 0 ? 0 : $652;
       $$114$i = $$013$i;
       $$311$i = ($$210$i | 0) < ($$25$i | 0) ? $$210$i : $$25$i;
       $$pre$phi190$iZ2D = 0;
       break;
      }
     } else {
      $$114$i = $t$0;
      $$311$i = $$p$i;
      $$pre$phi190$iZ2D = $fl$1$ & 8;
     } while (0);
     $655 = $$311$i | $$pre$phi190$iZ2D;
     $657 = ($655 | 0) != 0 & 1;
     $659 = ($$114$i | 32 | 0) == 102;
     if ($659) {
      $$pn$i = ($e$5$ph$i | 0) > 0 ? $e$5$ph$i : 0;
      $estr$2$i = 0;
     } else {
      $663 = ($e$5$ph$i | 0) < 0 ? $617 : $e$5$ph$i;
      $666 = _fmt_u($663, (($663 | 0) < 0) << 31 >> 31, $7) | 0;
      if (($9 - $666 | 0) < 2) {
       $estr$195$i = $666;
       while (1) {
        $670 = $estr$195$i + -1 | 0;
        HEAP8[$670 >> 0] = 48;
        if (($9 - $670 | 0) < 2) $estr$195$i = $670; else {
         $estr$1$lcssa$i = $670;
         break;
        }
       }
      } else $estr$1$lcssa$i = $666;
      HEAP8[$estr$1$lcssa$i + -1 >> 0] = ($e$5$ph$i >> 31 & 2) + 43;
      $680 = $estr$1$lcssa$i + -2 | 0;
      HEAP8[$680 >> 0] = $$114$i;
      $$pn$i = $9 - $680 | 0;
      $estr$2$i = $680;
     }
     $685 = $pl$0$i + 1 + $$311$i + $657 + $$pn$i | 0;
     _pad($f, 32, $w$1, $685, $fl$1$);
     if (!(HEAP32[$f >> 2] & 32)) ___fwritex($prefix$0$i, $pl$0$i, $f) | 0;
     _pad($f, 48, $w$1, $685, $fl$1$ ^ 65536);
     do if ($659) {
      $r$0$a$9$i = $a$9$ph$i >>> 0 > $$33$i >>> 0 ? $$33$i : $a$9$ph$i;
      $d$584$i = $r$0$a$9$i;
      while (1) {
       $692 = _fmt_u(HEAP32[$d$584$i >> 2] | 0, 0, $14) | 0;
       do if (($d$584$i | 0) == ($r$0$a$9$i | 0)) {
        if (($692 | 0) != ($14 | 0)) {
         $s7$1$i = $692;
         break;
        }
        HEAP8[$16 >> 0] = 48;
        $s7$1$i = $16;
       } else {
        if ($692 >>> 0 <= $buf$i >>> 0) {
         $s7$1$i = $692;
         break;
        }
        _memset($buf$i | 0, 48, $692 - $5 | 0) | 0;
        $s7$081$i = $692;
        while (1) {
         $697 = $s7$081$i + -1 | 0;
         if ($697 >>> 0 > $buf$i >>> 0) $s7$081$i = $697; else {
          $s7$1$i = $697;
          break;
         }
        }
       } while (0);
       if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s7$1$i, $15 - $s7$1$i | 0, $f) | 0;
       $705 = $d$584$i + 4 | 0;
       if ($705 >>> 0 > $$33$i >>> 0) {
        $$lcssa316 = $705;
        break;
       } else $d$584$i = $705;
      }
      do if ($655 | 0) {
       if (HEAP32[$f >> 2] & 32 | 0) break;
       ___fwritex(15912, 1, $f) | 0;
      } while (0);
      if (($$311$i | 0) > 0 & $$lcssa316 >>> 0 < $z$7$i$lcssa >>> 0) {
       $$41278$i = $$311$i;
       $d$677$i = $$lcssa316;
       while (1) {
        $715 = _fmt_u(HEAP32[$d$677$i >> 2] | 0, 0, $14) | 0;
        if ($715 >>> 0 > $buf$i >>> 0) {
         _memset($buf$i | 0, 48, $715 - $5 | 0) | 0;
         $s8$072$i = $715;
         while (1) {
          $719 = $s8$072$i + -1 | 0;
          if ($719 >>> 0 > $buf$i >>> 0) $s8$072$i = $719; else {
           $s8$0$lcssa$i = $719;
           break;
          }
         }
        } else $s8$0$lcssa$i = $715;
        if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s8$0$lcssa$i, ($$41278$i | 0) > 9 ? 9 : $$41278$i, $f) | 0;
        $726 = $d$677$i + 4 | 0;
        $727 = $$41278$i + -9 | 0;
        if (($$41278$i | 0) > 9 & $726 >>> 0 < $z$7$i$lcssa >>> 0) {
         $$41278$i = $727;
         $d$677$i = $726;
        } else {
         $$412$lcssa$i = $727;
         break;
        }
       }
      } else $$412$lcssa$i = $$311$i;
      _pad($f, 48, $$412$lcssa$i + 9 | 0, 9, 0);
     } else {
      $z$7$$i = $$lcssa162$i ? $z$7$i$lcssa : $a$9$ph$i + 4 | 0;
      if (($$311$i | 0) > -1) {
       $734 = ($$pre$phi190$iZ2D | 0) == 0;
       $$589$i = $$311$i;
       $d$788$i = $a$9$ph$i;
       while (1) {
        $736 = _fmt_u(HEAP32[$d$788$i >> 2] | 0, 0, $14) | 0;
        if (($736 | 0) == ($14 | 0)) {
         HEAP8[$16 >> 0] = 48;
         $s9$0$i = $16;
        } else $s9$0$i = $736;
        do if (($d$788$i | 0) == ($a$9$ph$i | 0)) {
         $742 = $s9$0$i + 1 | 0;
         if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s9$0$i, 1, $f) | 0;
         if ($734 & ($$589$i | 0) < 1) {
          $s9$2$i = $742;
          break;
         }
         if (HEAP32[$f >> 2] & 32 | 0) {
          $s9$2$i = $742;
          break;
         }
         ___fwritex(15912, 1, $f) | 0;
         $s9$2$i = $742;
        } else {
         if ($s9$0$i >>> 0 <= $buf$i >>> 0) {
          $s9$2$i = $s9$0$i;
          break;
         }
         _memset($buf$i | 0, 48, $s9$0$i + $6 | 0) | 0;
         $s9$185$i = $s9$0$i;
         while (1) {
          $740 = $s9$185$i + -1 | 0;
          if ($740 >>> 0 > $buf$i >>> 0) $s9$185$i = $740; else {
           $s9$2$i = $740;
           break;
          }
         }
        } while (0);
        $751 = $15 - $s9$2$i | 0;
        if (!(HEAP32[$f >> 2] & 32)) ___fwritex($s9$2$i, ($$589$i | 0) > ($751 | 0) ? $751 : $$589$i, $f) | 0;
        $757 = $$589$i - $751 | 0;
        $758 = $d$788$i + 4 | 0;
        if ($758 >>> 0 < $z$7$$i >>> 0 & ($757 | 0) > -1) {
         $$589$i = $757;
         $d$788$i = $758;
        } else {
         $$5$lcssa$i = $757;
         break;
        }
       }
      } else $$5$lcssa$i = $$311$i;
      _pad($f, 48, $$5$lcssa$i + 18 | 0, 18, 0);
      if (HEAP32[$f >> 2] & 32 | 0) break;
      ___fwritex($estr$2$i, $9 - $estr$2$i | 0, $f) | 0;
     } while (0);
     _pad($f, 32, $w$1, $685, $fl$1$ ^ 8192);
     $$0$i = ($685 | 0) < ($w$1 | 0) ? $w$1 : $685;
    } else {
     $376 = ($t$0 & 32 | 0) != 0;
     $378 = $$07$i != $$07$i | 0.0 != 0.0;
     $pl$1$i = $378 ? 0 : $pl$0$i;
     $380 = $pl$1$i + 3 | 0;
     _pad($f, 32, $w$1, $380, $176);
     $381 = HEAP32[$f >> 2] | 0;
     if (!($381 & 32)) {
      ___fwritex($prefix$0$i, $pl$1$i, $f) | 0;
      $385 = HEAP32[$f >> 2] | 0;
     } else $385 = $381;
     if (!($385 & 32)) ___fwritex($378 ? ($376 ? 15904 : 15908) : $376 ? 15896 : 15900, 3, $f) | 0;
     _pad($f, 32, $w$1, $380, $fl$1$ ^ 8192);
     $$0$i = ($380 | 0) < ($w$1 | 0) ? $w$1 : $380;
    } while (0);
    $cnt$0 = $cnt$1;
    $l$0 = $$0$i;
    $l10n$0 = $l10n$3;
    $s$0 = $$lcssa300;
    continue L1;
    break;
   }
  default:
   {
    $a$2 = $s$0;
    $fl$6 = $fl$1$;
    $p$5 = $p$0;
    $pl$2 = 0;
    $prefix$2 = 15844;
    $z$2 = $1;
   }
  } while (0);
  L311 : do if ((label | 0) == 64) {
   label = 0;
   $207 = $arg;
   $209 = HEAP32[$207 >> 2] | 0;
   $212 = HEAP32[$207 + 4 >> 2] | 0;
   $213 = $t$1 & 32;
   if (($209 | 0) == 0 & ($212 | 0) == 0) {
    $a$0 = $1;
    $fl$4 = $fl$3;
    $p$2 = $p$1;
    $pl$1 = 0;
    $prefix$1 = 15844;
    label = 77;
   } else {
    $$012$i = $1;
    $218 = $209;
    $225 = $212;
    while (1) {
     $224 = $$012$i + -1 | 0;
     HEAP8[$224 >> 0] = HEAPU8[15854 + ($218 & 15) >> 0] | $213;
     $226 = _bitshift64Lshr($218 | 0, $225 | 0, 4) | 0;
     $227 = tempRet0;
     if (($226 | 0) == 0 & ($227 | 0) == 0) {
      $$lcssa321 = $224;
      break;
     } else {
      $$012$i = $224;
      $218 = $226;
      $225 = $227;
     }
    }
    $231 = $arg;
    if (($fl$3 & 8 | 0) == 0 | (HEAP32[$231 >> 2] | 0) == 0 & (HEAP32[$231 + 4 >> 2] | 0) == 0) {
     $a$0 = $$lcssa321;
     $fl$4 = $fl$3;
     $p$2 = $p$1;
     $pl$1 = 0;
     $prefix$1 = 15844;
     label = 77;
    } else {
     $a$0 = $$lcssa321;
     $fl$4 = $fl$3;
     $p$2 = $p$1;
     $pl$1 = 2;
     $prefix$1 = 15844 + ($t$1 >> 4) | 0;
     label = 77;
    }
   }
  } else if ((label | 0) == 76) {
   label = 0;
   $a$0 = _fmt_u($287, $288, $1) | 0;
   $fl$4 = $fl$1$;
   $p$2 = $p$0;
   $pl$1 = $pl$0;
   $prefix$1 = $prefix$0;
   label = 77;
  } else if ((label | 0) == 82) {
   label = 0;
   $321 = _memchr($a$1, 0, $p$0) | 0;
   $322 = ($321 | 0) == 0;
   $a$2 = $a$1;
   $fl$6 = $176;
   $p$5 = $322 ? $p$0 : $321 - $a$1 | 0;
   $pl$2 = 0;
   $prefix$2 = 15844;
   $z$2 = $322 ? $a$1 + $p$0 | 0 : $321;
  } else if ((label | 0) == 86) {
   label = 0;
   $i$0105 = 0;
   $l$1104 = 0;
   $ws$0106 = $798;
   while (1) {
    $334 = HEAP32[$ws$0106 >> 2] | 0;
    if (!$334) {
     $i$0$lcssa = $i$0105;
     $l$2 = $l$1104;
     break;
    }
    $336 = _wctomb($mb, $334) | 0;
    if (($336 | 0) < 0 | $336 >>> 0 > ($p$4176 - $i$0105 | 0) >>> 0) {
     $i$0$lcssa = $i$0105;
     $l$2 = $336;
     break;
    }
    $341 = $336 + $i$0105 | 0;
    if ($p$4176 >>> 0 > $341 >>> 0) {
     $i$0105 = $341;
     $l$1104 = $336;
     $ws$0106 = $ws$0106 + 4 | 0;
    } else {
     $i$0$lcssa = $341;
     $l$2 = $336;
     break;
    }
   }
   if (($l$2 | 0) < 0) {
    $$0 = -1;
    break L1;
   }
   _pad($f, 32, $w$1, $i$0$lcssa, $fl$1$);
   if (!$i$0$lcssa) {
    $i$0$lcssa178 = 0;
    label = 97;
   } else {
    $i$1116 = 0;
    $ws$1117 = $798;
    while (1) {
     $345 = HEAP32[$ws$1117 >> 2] | 0;
     if (!$345) {
      $i$0$lcssa178 = $i$0$lcssa;
      label = 97;
      break L311;
     }
     $348 = _wctomb($mb, $345) | 0;
     $349 = $348 + $i$1116 | 0;
     if (($349 | 0) > ($i$0$lcssa | 0)) {
      $i$0$lcssa178 = $i$0$lcssa;
      label = 97;
      break L311;
     }
     if (!(HEAP32[$f >> 2] & 32)) ___fwritex($mb, $348, $f) | 0;
     if ($349 >>> 0 < $i$0$lcssa >>> 0) {
      $i$1116 = $349;
      $ws$1117 = $ws$1117 + 4 | 0;
     } else {
      $i$0$lcssa178 = $i$0$lcssa;
      label = 97;
      break;
     }
    }
   }
  } while (0);
  if ((label | 0) == 97) {
   label = 0;
   _pad($f, 32, $w$1, $i$0$lcssa178, $fl$1$ ^ 8192);
   $cnt$0 = $cnt$1;
   $l$0 = ($w$1 | 0) > ($i$0$lcssa178 | 0) ? $w$1 : $i$0$lcssa178;
   $l10n$0 = $l10n$3;
   $s$0 = $$lcssa300;
   continue;
  }
  if ((label | 0) == 77) {
   label = 0;
   $$fl$4 = ($p$2 | 0) > -1 ? $fl$4 & -65537 : $fl$4;
   $292 = $arg;
   $300 = (HEAP32[$292 >> 2] | 0) != 0 | (HEAP32[$292 + 4 >> 2] | 0) != 0;
   if (($p$2 | 0) != 0 | $300) {
    $306 = ($300 & 1 ^ 1) + ($2 - $a$0) | 0;
    $a$2 = $a$0;
    $fl$6 = $$fl$4;
    $p$5 = ($p$2 | 0) > ($306 | 0) ? $p$2 : $306;
    $pl$2 = $pl$1;
    $prefix$2 = $prefix$1;
    $z$2 = $1;
   } else {
    $a$2 = $1;
    $fl$6 = $$fl$4;
    $p$5 = 0;
    $pl$2 = $pl$1;
    $prefix$2 = $prefix$1;
    $z$2 = $1;
   }
  }
  $772 = $z$2 - $a$2 | 0;
  $$p$5 = ($p$5 | 0) < ($772 | 0) ? $772 : $p$5;
  $774 = $pl$2 + $$p$5 | 0;
  $w$2 = ($w$1 | 0) < ($774 | 0) ? $774 : $w$1;
  _pad($f, 32, $w$2, $774, $fl$6);
  if (!(HEAP32[$f >> 2] & 32)) ___fwritex($prefix$2, $pl$2, $f) | 0;
  _pad($f, 48, $w$2, $774, $fl$6 ^ 65536);
  _pad($f, 48, $$p$5, $772, 0);
  if (!(HEAP32[$f >> 2] & 32)) ___fwritex($a$2, $772, $f) | 0;
  _pad($f, 32, $w$2, $774, $fl$6 ^ 8192);
  $cnt$0 = $cnt$1;
  $l$0 = $w$2;
  $l10n$0 = $l10n$3;
  $s$0 = $$lcssa300;
 }
 L345 : do if ((label | 0) == 244) if (!$f) if (!$l10n$0$lcssa) $$0 = 0; else {
  $i$291 = 1;
  while (1) {
   $787 = HEAP32[$nl_type + ($i$291 << 2) >> 2] | 0;
   if (!$787) {
    $i$291$lcssa = $i$291;
    break;
   }
   _pop_arg($nl_arg + ($i$291 << 3) | 0, $787, $ap);
   $791 = $i$291 + 1 | 0;
   if (($791 | 0) < 10) $i$291 = $791; else {
    $$0 = 1;
    break L345;
   }
  }
  if (($i$291$lcssa | 0) < 10) {
   $i$389 = $i$291$lcssa;
   while (1) {
    $793 = $i$389 + 1 | 0;
    if (HEAP32[$nl_type + ($i$389 << 2) >> 2] | 0) {
     $$0 = -1;
     break L345;
    }
    if (($793 | 0) < 10) $i$389 = $793; else {
     $$0 = 1;
     break;
    }
   }
  } else $$0 = 1;
 } else $$0 = $cnt$1$lcssa; while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _predefcertainstrings() {
 var $1029 = 0, $1061 = 0, $1093 = 0, $1131 = 0, $1151 = 0, $116 = 0, $1186 = 0, $1215 = 0, $1241 = 0, $1264 = 0, $1290 = 0, $13 = 0, $1328 = 0, $1351 = 0, $1395 = 0, $142 = 0, $1439 = 0, $1459 = 0, $1482 = 0, $1514 = 0, $1540 = 0, $1566 = 0, $1592 = 0, $1600 = 0, $1643 = 0, $1654 = 0, $1661 = 0, $1671 = 0, $1681 = 0, $1691 = 0, $1701 = 0, $1711 = 0, $1721 = 0, $1728 = 0, $1735 = 0, $174 = 0, $1742 = 0, $1749 = 0, $1759 = 0, $1787 = 0, $1794 = 0, $1795 = 0, $1824 = 0, $1831 = 0, $1864 = 0, $1905 = 0, $202 = 0, $233 = 0, $258 = 0, $277 = 0, $30 = 0, $302 = 0, $330 = 0, $358 = 0, $383 = 0, $402 = 0, $418 = 0, $443 = 0, $459 = 0, $47 = 0, $484 = 0, $509 = 0, $537 = 0, $559 = 0, $566 = 0, $577 = 0, $588 = 0, $599 = 0, $610 = 0, $621 = 0, $635 = 0, $64 = 0, $676 = 0, $714 = 0, $758 = 0, $799 = 0, $81 = 0, $822 = 0, $860 = 0, $886 = 0, $930 = 0, $947 = 0, $988 = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25741] | 0;
 $13 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 7, 1) | 0;
 HEAP32[4246] = $13;
 HEAP32[4259] = HEAP32[(HEAP32[4145] | 0) + ($13 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25729] | 0;
 $30 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 7, 1) | 0;
 HEAP32[4246] = $30;
 HEAP32[4260] = HEAP32[(HEAP32[4145] | 0) + ($30 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25724] | 0;
 $47 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 7, 1) | 0;
 HEAP32[4246] = $47;
 HEAP32[4261] = HEAP32[(HEAP32[4145] | 0) + ($47 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 $64 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 7, 1) | 0;
 HEAP32[4246] = $64;
 HEAP32[4097] = HEAP32[(HEAP32[4145] | 0) + ($64 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25719] | 0;
 $81 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 7, 1) | 0;
 HEAP32[4246] = $81;
 HEAP32[4095] = HEAP32[(HEAP32[4145] | 0) + ($81 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25679] | 0;
 $116 = _zstrlookup(HEAP32[3993] | 0, 1, 10, 8, 1) | 0;
 HEAP32[4246] = $116;
 HEAP32[4262] = HEAP32[(HEAP32[4145] | 0) + ($116 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25679] | 0;
 $142 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 8, 1) | 0;
 HEAP32[4246] = $142;
 HEAP32[4263] = HEAP32[(HEAP32[4145] | 0) + ($142 << 2) >> 2];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25713] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25731] | 0;
 $174 = _zstrlookup(HEAP32[3993] | 0, 1, 9, 2, 1) | 0;
 HEAP32[4246] = $174;
 HEAP32[(HEAP32[4249] | 0) + ($174 << 2) >> 2] = 2;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25713] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25718] | 0;
 $202 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 2, 1) | 0;
 HEAP32[4246] = $202;
 HEAP32[(HEAP32[4249] | 0) + ($202 << 2) >> 2] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25713] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25722] | 0;
 $233 = _zstrlookup(HEAP32[3993] | 0, 1, 9, 2, 1) | 0;
 HEAP32[4246] = $233;
 HEAP32[(HEAP32[4249] | 0) + ($233 << 2) >> 2] = 1;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25713] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25685] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25737] | 0;
 $258 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 2, 1) | 0;
 HEAP32[4246] = $258;
 HEAP32[(HEAP32[4249] | 0) + ($258 << 2) >> 2] = 3;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25742] | 0;
 $277 = _zstrlookup(HEAP32[3993] | 0, 1, 5, 4, 1) | 0;
 HEAP32[4246] = $277;
 HEAP32[(HEAP32[4249] | 0) + ($277 << 2) >> 2] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 $302 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 4, 1) | 0;
 HEAP32[4246] = $302;
 HEAP32[(HEAP32[4249] | 0) + ($302 << 2) >> 2] = 1;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25723] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25731] | 0;
 $330 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 4, 1) | 0;
 HEAP32[4246] = $330;
 HEAP32[(HEAP32[4249] | 0) + ($330 << 2) >> 2] = 2;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25736] | 0;
 $358 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 4, 1) | 0;
 HEAP32[4246] = $358;
 HEAP32[(HEAP32[4249] | 0) + ($358 << 2) >> 2] = 3;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 $383 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 4, 1) | 0;
 HEAP32[4246] = $383;
 HEAP32[(HEAP32[4249] | 0) + ($383 << 2) >> 2] = 4;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25732] | 0;
 $402 = _zstrlookup(HEAP32[3993] | 0, 1, 5, 4, 1) | 0;
 HEAP32[4246] = $402;
 HEAP32[(HEAP32[4249] | 0) + ($402 << 2) >> 2] = 5;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25721] | 0;
 $418 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 4, 1) | 0;
 HEAP32[4246] = $418;
 HEAP32[(HEAP32[4249] | 0) + ($418 << 2) >> 2] = 6;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25739] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 $443 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 4, 1) | 0;
 HEAP32[4246] = $443;
 HEAP32[(HEAP32[4249] | 0) + ($443 << 2) >> 2] = 7;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 $459 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 4, 1) | 0;
 HEAP32[4246] = $459;
 HEAP32[(HEAP32[4249] | 0) + ($459 << 2) >> 2] = 8;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25736] | 0;
 $484 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 4, 1) | 0;
 HEAP32[4246] = $484;
 HEAP32[(HEAP32[4249] | 0) + ($484 << 2) >> 2] = 9;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25737] | 0;
 $509 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 12, 1) | 0;
 HEAP32[4246] = $509;
 HEAP32[(HEAP32[4249] | 0) + ($509 << 2) >> 2] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25722] | 0;
 $537 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 12, 1) | 0;
 HEAP32[4246] = $537;
 HEAP32[(HEAP32[4249] | 0) + ($537 << 2) >> 2] = 1;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25724] | 0;
 $559 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 12, 1) | 0;
 HEAP32[4246] = $559;
 HEAP32[(HEAP32[4249] | 0) + ($559 << 2) >> 2] = 2;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25682] | 0;
 $566 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 11, 1) | 0;
 HEAP32[4246] = $566;
 HEAP32[4264] = $566;
 HEAP8[(HEAP32[4144] | 0) + $566 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4264] << 2) >> 2] = 0;
 HEAP32[4199] = HEAP32[4264];
 HEAP32[4161] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25683] | 0;
 $577 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 11, 1) | 0;
 HEAP32[4246] = $577;
 HEAP32[4265] = $577;
 HEAP8[(HEAP32[4144] | 0) + $577 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4265] << 2) >> 2] = 1;
 HEAP32[4200] = HEAP32[4265];
 HEAP32[4162] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25681] | 0;
 $588 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 11, 1) | 0;
 HEAP32[4246] = $588;
 HEAP32[4266] = $588;
 HEAP8[(HEAP32[4144] | 0) + $588 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4266] << 2) >> 2] = 2;
 HEAP32[4201] = HEAP32[4266];
 HEAP32[4163] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25664] | 0;
 $599 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 11, 1) | 0;
 HEAP32[4246] = $599;
 HEAP32[4267] = $599;
 HEAP8[(HEAP32[4144] | 0) + $599 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4267] << 2) >> 2] = 3;
 HEAP32[4202] = HEAP32[4267];
 HEAP32[4164] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25666] | 0;
 $610 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 11, 1) | 0;
 HEAP32[4246] = $610;
 HEAP32[4268] = $610;
 HEAP8[(HEAP32[4144] | 0) + $610 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4268] << 2) >> 2] = 4;
 HEAP32[4203] = HEAP32[4268];
 HEAP32[4165] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25663] | 0;
 $621 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 11, 1) | 0;
 HEAP32[4246] = $621;
 HEAP32[4269] = $621;
 HEAP8[(HEAP32[4144] | 0) + $621 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4269] << 2) >> 2] = 5;
 HEAP32[4204] = HEAP32[4269];
 HEAP32[4166] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25679] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25682] | 0;
 $635 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 11, 1) | 0;
 HEAP32[4246] = $635;
 HEAP32[4270] = $635;
 HEAP8[(HEAP32[4144] | 0) + $635 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4270] << 2) >> 2] = 6;
 HEAP32[4205] = HEAP32[4270];
 HEAP32[4167] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25657] | 0;
 $676 = _zstrlookup(HEAP32[3993] | 0, 1, 11, 11, 1) | 0;
 HEAP32[4246] = $676;
 HEAP32[4271] = $676;
 HEAP8[(HEAP32[4144] | 0) + $676 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4271] << 2) >> 2] = 7;
 HEAP32[4206] = HEAP32[4271];
 HEAP32[4168] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25657] | 0;
 $714 = _zstrlookup(HEAP32[3993] | 0, 1, 10, 11, 1) | 0;
 HEAP32[4246] = $714;
 HEAP32[4272] = $714;
 HEAP8[(HEAP32[4144] | 0) + $714 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4272] << 2) >> 2] = 8;
 HEAP32[4207] = HEAP32[4272];
 HEAP32[4169] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25725] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 12 >> 0] = HEAP8[25657] | 0;
 $758 = _zstrlookup(HEAP32[3993] | 0, 1, 12, 11, 1) | 0;
 HEAP32[4246] = $758;
 HEAP32[4273] = $758;
 HEAP8[(HEAP32[4144] | 0) + $758 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4273] << 2) >> 2] = 9;
 HEAP32[4208] = HEAP32[4273];
 HEAP32[4170] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25725] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25657] | 0;
 $799 = _zstrlookup(HEAP32[3993] | 0, 1, 11, 11, 1) | 0;
 HEAP32[4246] = $799;
 HEAP32[4274] = $799;
 HEAP8[(HEAP32[4144] | 0) + $799 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4274] << 2) >> 2] = 10;
 HEAP32[4209] = HEAP32[4274];
 HEAP32[4171] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25657] | 0;
 $822 = _zstrlookup(HEAP32[3993] | 0, 1, 5, 11, 1) | 0;
 HEAP32[4246] = $822;
 HEAP32[4275] = $822;
 HEAP8[(HEAP32[4144] | 0) + $822 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4275] << 2) >> 2] = 11;
 HEAP32[4210] = HEAP32[4275];
 HEAP32[4172] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25657] | 0;
 $860 = _zstrlookup(HEAP32[3993] | 0, 1, 10, 11, 1) | 0;
 HEAP32[4246] = $860;
 HEAP32[4276] = $860;
 HEAP8[(HEAP32[4144] | 0) + $860 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4276] << 2) >> 2] = 12;
 HEAP32[4211] = HEAP32[4276];
 HEAP32[4173] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25657] | 0;
 $886 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 11, 1) | 0;
 HEAP32[4246] = $886;
 HEAP32[4277] = $886;
 HEAP8[(HEAP32[4144] | 0) + $886 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4277] << 2) >> 2] = 13;
 HEAP32[4212] = HEAP32[4277];
 HEAP32[4174] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25723] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 12 >> 0] = HEAP8[25657] | 0;
 $930 = _zstrlookup(HEAP32[3993] | 0, 1, 12, 11, 1) | 0;
 HEAP32[4246] = $930;
 HEAP32[4278] = $930;
 HEAP8[(HEAP32[4144] | 0) + $930 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4278] << 2) >> 2] = 14;
 HEAP32[4213] = HEAP32[4278];
 HEAP32[4175] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25723] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25657] | 0;
 $947 = _zstrlookup(HEAP32[3993] | 0, 1, 3, 11, 1) | 0;
 HEAP32[4246] = $947;
 HEAP32[4279] = $947;
 HEAP8[(HEAP32[4144] | 0) + $947 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4279] << 2) >> 2] = 15;
 HEAP32[4214] = HEAP32[4279];
 HEAP32[4176] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25725] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25657] | 0;
 $988 = _zstrlookup(HEAP32[3993] | 0, 1, 11, 11, 1) | 0;
 HEAP32[4246] = $988;
 HEAP32[4280] = $988;
 HEAP8[(HEAP32[4144] | 0) + $988 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4280] << 2) >> 2] = 16;
 HEAP32[4215] = HEAP32[4280];
 HEAP32[4177] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25657] | 0;
 $1029 = _zstrlookup(HEAP32[3993] | 0, 1, 11, 11, 1) | 0;
 HEAP32[4246] = $1029;
 HEAP32[4281] = $1029;
 HEAP8[(HEAP32[4144] | 0) + $1029 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4281] << 2) >> 2] = 17;
 HEAP32[4216] = HEAP32[4281];
 HEAP32[4178] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25657] | 0;
 $1061 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 11, 1) | 0;
 HEAP32[4246] = $1061;
 HEAP32[4282] = $1061;
 HEAP8[(HEAP32[4144] | 0) + $1061 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4282] << 2) >> 2] = 18;
 HEAP32[4217] = HEAP32[4282];
 HEAP32[4179] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25740] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25657] | 0;
 $1093 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 11, 1) | 0;
 HEAP32[4246] = $1093;
 HEAP32[4283] = $1093;
 HEAP8[(HEAP32[4144] | 0) + $1093 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4283] << 2) >> 2] = 19;
 HEAP32[4218] = HEAP32[4283];
 HEAP32[4180] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25657] | 0;
 $1131 = _zstrlookup(HEAP32[3993] | 0, 1, 10, 11, 1) | 0;
 HEAP32[4246] = $1131;
 HEAP32[4284] = $1131;
 HEAP8[(HEAP32[4144] | 0) + $1131 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4284] << 2) >> 2] = 20;
 HEAP32[4219] = HEAP32[4284];
 HEAP32[4181] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25657] | 0;
 $1151 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 11, 1) | 0;
 HEAP32[4246] = $1151;
 HEAP32[4285] = $1151;
 HEAP8[(HEAP32[4144] | 0) + $1151 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4285] << 2) >> 2] = 21;
 HEAP32[4220] = HEAP32[4285];
 HEAP32[4182] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25657] | 0;
 $1186 = _zstrlookup(HEAP32[3993] | 0, 1, 9, 11, 1) | 0;
 HEAP32[4246] = $1186;
 HEAP32[4286] = $1186;
 HEAP8[(HEAP32[4144] | 0) + $1186 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4286] << 2) >> 2] = 22;
 HEAP32[4221] = HEAP32[4286];
 HEAP32[4183] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25723] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25657] | 0;
 $1215 = _zstrlookup(HEAP32[3993] | 0, 1, 7, 11, 1) | 0;
 HEAP32[4246] = $1215;
 HEAP32[4287] = $1215;
 HEAP8[(HEAP32[4144] | 0) + $1215 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4287] << 2) >> 2] = 23;
 HEAP32[4222] = HEAP32[4287];
 HEAP32[4184] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25734] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25657] | 0;
 $1241 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 11, 1) | 0;
 HEAP32[4246] = $1241;
 HEAP32[4288] = $1241;
 HEAP8[(HEAP32[4144] | 0) + $1241 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4288] << 2) >> 2] = 24;
 HEAP32[4223] = HEAP32[4288];
 HEAP32[4185] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25728] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25657] | 0;
 $1264 = _zstrlookup(HEAP32[3993] | 0, 1, 5, 11, 1) | 0;
 HEAP32[4246] = $1264;
 HEAP32[4289] = $1264;
 HEAP8[(HEAP32[4144] | 0) + $1264 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4289] << 2) >> 2] = 25;
 HEAP32[4224] = HEAP32[4289];
 HEAP32[4186] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25728] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25657] | 0;
 $1290 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 11, 1) | 0;
 HEAP32[4246] = $1290;
 HEAP32[4290] = $1290;
 HEAP8[(HEAP32[4144] | 0) + $1290 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4290] << 2) >> 2] = 26;
 HEAP32[4225] = HEAP32[4290];
 HEAP32[4187] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25657] | 0;
 $1328 = _zstrlookup(HEAP32[3993] | 0, 1, 10, 11, 1) | 0;
 HEAP32[4246] = $1328;
 HEAP32[4291] = $1328;
 HEAP8[(HEAP32[4144] | 0) + $1328 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4291] << 2) >> 2] = 27;
 HEAP32[4226] = HEAP32[4291];
 HEAP32[4188] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25740] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25657] | 0;
 $1351 = _zstrlookup(HEAP32[3993] | 0, 1, 5, 11, 1) | 0;
 HEAP32[4246] = $1351;
 HEAP32[4292] = $1351;
 HEAP8[(HEAP32[4144] | 0) + $1351 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4292] << 2) >> 2] = 28;
 HEAP32[4227] = HEAP32[4292];
 HEAP32[4189] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25725] | 0;
 HEAP8[(HEAP32[3993] | 0) + 12 >> 0] = HEAP8[25657] | 0;
 $1395 = _zstrlookup(HEAP32[3993] | 0, 1, 12, 11, 1) | 0;
 HEAP32[4246] = $1395;
 HEAP32[4293] = $1395;
 HEAP8[(HEAP32[4144] | 0) + $1395 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4293] << 2) >> 2] = 29;
 HEAP32[4228] = HEAP32[4293];
 HEAP32[4190] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25723] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 12 >> 0] = HEAP8[25657] | 0;
 $1439 = _zstrlookup(HEAP32[3993] | 0, 1, 12, 11, 1) | 0;
 HEAP32[4246] = $1439;
 HEAP32[4294] = $1439;
 HEAP8[(HEAP32[4144] | 0) + $1439 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4294] << 2) >> 2] = 30;
 HEAP32[4229] = HEAP32[4294];
 HEAP32[4191] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25657] | 0;
 $1459 = _zstrlookup(HEAP32[3993] | 0, 1, 4, 11, 1) | 0;
 HEAP32[4246] = $1459;
 HEAP32[4295] = $1459;
 HEAP8[(HEAP32[4144] | 0) + $1459 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4295] << 2) >> 2] = 31;
 HEAP32[4230] = HEAP32[4295];
 HEAP32[4192] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25657] | 0;
 $1482 = _zstrlookup(HEAP32[3993] | 0, 1, 5, 11, 1) | 0;
 HEAP32[4246] = $1482;
 HEAP32[4296] = $1482;
 HEAP8[(HEAP32[4144] | 0) + $1482 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4296] << 2) >> 2] = 32;
 HEAP32[4231] = HEAP32[4296];
 HEAP32[4193] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25740] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25657] | 0;
 $1514 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 11, 1) | 0;
 HEAP32[4246] = $1514;
 HEAP32[4297] = $1514;
 HEAP8[(HEAP32[4144] | 0) + $1514 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4297] << 2) >> 2] = 33;
 HEAP32[4232] = HEAP32[4297];
 HEAP32[4194] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25740] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25725] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25657] | 0;
 $1540 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 11, 1) | 0;
 HEAP32[4246] = $1540;
 HEAP32[4298] = $1540;
 HEAP8[(HEAP32[4144] | 0) + $1540 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4298] << 2) >> 2] = 34;
 HEAP32[4233] = HEAP32[4298];
 HEAP32[4195] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25740] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25725] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25657] | 0;
 $1566 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 11, 1) | 0;
 HEAP32[4246] = $1566;
 HEAP32[4299] = $1566;
 HEAP8[(HEAP32[4144] | 0) + $1566 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4299] << 2) >> 2] = 35;
 HEAP32[4234] = HEAP32[4299];
 HEAP32[4196] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25740] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25726] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25657] | 0;
 $1592 = _zstrlookup(HEAP32[3993] | 0, 1, 6, 11, 1) | 0;
 HEAP32[4246] = $1592;
 HEAP32[4300] = $1592;
 HEAP8[(HEAP32[4144] | 0) + $1592 >> 0] = 0;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4300] << 2) >> 2] = 36;
 HEAP32[4235] = HEAP32[4300];
 HEAP32[4197] = 0;
 $1600 = _zstrlookup(HEAP32[3993] | 0, 1, 0, 0, 1) | 0;
 HEAP32[4246] = $1600;
 HEAP32[4301] = HEAP32[(HEAP32[4145] | 0) + ($1600 << 2) >> 2];
 HEAP8[(HEAP32[4144] | 0) + $1600 >> 0] = 3;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25721] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25723] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25738] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25733] | 0;
 HEAP8[(HEAP32[3993] | 0) + 12 >> 0] = HEAP8[25722] | 0;
 $1643 = _zstrlookup(HEAP32[3993] | 0, 1, 12, 0, 1) | 0;
 HEAP32[4246] = $1643;
 HEAP32[4302] = HEAP32[(HEAP32[4145] | 0) + ($1643 << 2) >> 2];
 HEAP8[(HEAP32[4144] | 0) + $1643 >> 0] = 3;
 HEAP32[4303] = HEAP32[4289];
 HEAP32[4304] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25726] | 0;
 $1654 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 14, 1) | 0;
 HEAP32[4246] = $1654;
 HEAP32[(HEAP32[4249] | 0) + ($1654 << 2) >> 2] = 0;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25727] | 0;
 $1661 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 14, 1) | 0;
 HEAP32[4246] = $1661;
 HEAP32[(HEAP32[4249] | 0) + ($1661 << 2) >> 2] = 1;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 $1671 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1671;
 HEAP32[(HEAP32[4249] | 0) + ($1671 << 2) >> 2] = 2;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25700] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25690] | 0;
 $1681 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1681;
 HEAP32[(HEAP32[4249] | 0) + ($1681 << 2) >> 2] = 3;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25722] | 0;
 $1691 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1691;
 HEAP32[(HEAP32[4249] | 0) + ($1691 << 2) >> 2] = 4;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25686] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25690] | 0;
 $1701 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1701;
 HEAP32[(HEAP32[4249] | 0) + ($1701 << 2) >> 2] = 5;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25718] | 0;
 $1711 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1711;
 HEAP32[(HEAP32[4249] | 0) + ($1711 << 2) >> 2] = 6;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25686] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25686] | 0;
 $1721 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1721;
 HEAP32[(HEAP32[4249] | 0) + ($1721 << 2) >> 2] = 7;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25732] | 0;
 $1728 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 14, 1) | 0;
 HEAP32[4246] = $1728;
 HEAP32[(HEAP32[4249] | 0) + ($1728 << 2) >> 2] = 8;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25700] | 0;
 $1735 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 14, 1) | 0;
 HEAP32[4246] = $1735;
 HEAP32[(HEAP32[4249] | 0) + ($1735 << 2) >> 2] = 9;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25729] | 0;
 $1742 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 14, 1) | 0;
 HEAP32[4246] = $1742;
 HEAP32[(HEAP32[4249] | 0) + ($1742 << 2) >> 2] = 10;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25697] | 0;
 $1749 = _zstrlookup(HEAP32[3993] | 0, 1, 1, 14, 1) | 0;
 HEAP32[4246] = $1749;
 HEAP32[(HEAP32[4249] | 0) + ($1749 << 2) >> 2] = 11;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25736] | 0;
 $1759 = _zstrlookup(HEAP32[3993] | 0, 1, 2, 14, 1) | 0;
 HEAP32[4246] = $1759;
 HEAP32[(HEAP32[4249] | 0) + ($1759 << 2) >> 2] = 12;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25720] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25723] | 0;
 $1787 = _zstrlookup(HEAP32[3993] | 0, 1, 8, 11, 1) | 0;
 HEAP32[4246] = $1787;
 HEAP8[(HEAP32[4144] | 0) + $1787 >> 0] = 4;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4246] << 2) >> 2] = HEAP32[4247];
 $1794 = HEAP32[4247] | 0;
 HEAP32[4305] = $1794;
 $1795 = $1794 + 1 | 0;
 HEAP32[4247] = $1795;
 HEAP32[4306] = $1795;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25736] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25728] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25657] | 0;
 $1824 = _zstrlookup(HEAP32[3993] | 0, 1, 9, 11, 1) | 0;
 HEAP32[4246] = $1824;
 HEAP8[(HEAP32[4144] | 0) + $1824 >> 0] = 6;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4246] << 2) >> 2] = HEAP32[4255];
 $1831 = HEAP32[4255] | 0;
 HEAP32[4256] = $1831;
 HEAP32[4255] = $1831 + 1;
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25722] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25731] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25737] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25735] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25742] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25657] | 0;
 $1864 = _zstrlookup(HEAP32[3993] | 0, 1, 10, 11, 1) | 0;
 HEAP32[4246] = $1864;
 HEAP8[(HEAP32[4144] | 0) + $1864 >> 0] = 7;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4246] << 2) >> 2] = HEAP32[4257];
 HEAP8[(HEAP32[3993] | 0) + 1 >> 0] = HEAP8[25724] | 0;
 HEAP8[(HEAP32[3993] | 0) + 2 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 3 >> 0] = HEAP8[25732] | 0;
 HEAP8[(HEAP32[3993] | 0) + 4 >> 0] = HEAP8[25719] | 0;
 HEAP8[(HEAP32[3993] | 0) + 5 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 6 >> 0] = HEAP8[25729] | 0;
 HEAP8[(HEAP32[3993] | 0) + 7 >> 0] = HEAP8[25667] | 0;
 HEAP8[(HEAP32[3993] | 0) + 8 >> 0] = HEAP8[25730] | 0;
 HEAP8[(HEAP32[3993] | 0) + 9 >> 0] = HEAP8[25718] | 0;
 HEAP8[(HEAP32[3993] | 0) + 10 >> 0] = HEAP8[25741] | 0;
 HEAP8[(HEAP32[3993] | 0) + 11 >> 0] = HEAP8[25657] | 0;
 $1905 = _zstrlookup(HEAP32[3993] | 0, 1, 11, 11, 1) | 0;
 HEAP32[4246] = $1905;
 HEAP8[(HEAP32[4144] | 0) + $1905 >> 0] = 7;
 HEAP32[(HEAP32[4249] | 0) + (HEAP32[4246] << 2) >> 2] = HEAP32[4307];
 return;
}

function _malloc($bytes) {
 $bytes = $bytes | 0;
 var $$0 = 0, $$lcssa = 0, $$lcssa141 = 0, $$lcssa142 = 0, $$lcssa144 = 0, $$lcssa147 = 0, $$lcssa149 = 0, $$lcssa151 = 0, $$lcssa153 = 0, $$lcssa155 = 0, $$lcssa157 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i14Z2D = 0, $$pre$phi$i17$iZ2D = 0, $$pre$phi$iZ2D = 0, $$pre$phi10$i$iZ2D = 0, $$pre$phiZ2D = 0, $$rsize$4$i = 0, $100 = 0, $1002 = 0, $1008 = 0, $101 = 0, $1011 = 0, $1012 = 0, $1030 = 0, $1032 = 0, $1039 = 0, $1040 = 0, $1041 = 0, $1049 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $107 = 0, $111 = 0, $113 = 0, $114 = 0, $116 = 0, $118 = 0, $12 = 0, $120 = 0, $122 = 0, $124 = 0, $126 = 0, $128 = 0, $133 = 0, $139 = 0, $14 = 0, $142 = 0, $145 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $152 = 0, $155 = 0, $157 = 0, $16 = 0, $160 = 0, $162 = 0, $165 = 0, $168 = 0, $169 = 0, $17 = 0, $171 = 0, $172 = 0, $174 = 0, $175 = 0, $177 = 0, $178 = 0, $18 = 0, $183 = 0, $184 = 0, $193 = 0, $198 = 0, $202 = 0, $208 = 0, $215 = 0, $219 = 0, $227 = 0, $229 = 0, $230 = 0, $232 = 0, $233 = 0, $234 = 0, $238 = 0, $239 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $251 = 0, $252 = 0, $257 = 0, $258 = 0, $261 = 0, $263 = 0, $266 = 0, $271 = 0, $278 = 0, $28 = 0, $287 = 0, $288 = 0, $292 = 0, $295 = 0, $298 = 0, $303 = 0, $306 = 0, $310 = 0, $312 = 0, $313 = 0, $315 = 0, $317 = 0, $319 = 0, $32 = 0, $321 = 0, $323 = 0, $325 = 0, $327 = 0, $337 = 0, $338 = 0, $340 = 0, $343 = 0, $349 = 0, $35 = 0, $351 = 0, $354 = 0, $356 = 0, $359 = 0, $361 = 0, $364 = 0, $367 = 0, $368 = 0, $370 = 0, $371 = 0, $373 = 0, $374 = 0, $376 = 0, $377 = 0, $382 = 0, $383 = 0, $39 = 0, $392 = 0, $397 = 0, $4 = 0, $401 = 0, $407 = 0, $414 = 0, $418 = 0, $42 = 0, $426 = 0, $429 = 0, $430 = 0, $431 = 0, $435 = 0, $436 = 0, $442 = 0, $447 = 0, $448 = 0, $45 = 0, $451 = 0, $453 = 0, $456 = 0, $461 = 0, $467 = 0, $469 = 0, $47 = 0, $471 = 0, $472 = 0, $48 = 0, $490 = 0, $492 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $509 = 0, $511 = 0, $512 = 0, $514 = 0, $52 = 0, $523 = 0, $527 = 0, $529 = 0, $530 = 0, $531 = 0, $54 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $549 = 0, $551 = 0, $552 = 0, $558 = 0, $56 = 0, $560 = 0, $562 = 0, $567 = 0, $569 = 0, $571 = 0, $572 = 0, $573 = 0, $58 = 0, $581 = 0, $582 = 0, $585 = 0, $589 = 0, $593 = 0, $595 = 0, $6 = 0, $60 = 0, $601 = 0, $605 = 0, $609 = 0, $618 = 0, $619 = 0, $62 = 0, $625 = 0, $628 = 0, $631 = 0, $633 = 0, $638 = 0, $641 = 0, $644 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $657 = 0, $658 = 0, $659 = 0, $663 = 0, $67 = 0, $674 = 0, $679 = 0, $68 = 0, $680 = 0, $682 = 0, $688 = 0, $69 = 0, $690 = 0, $694 = 0, $7 = 0, $70 = 0, $700 = 0, $704 = 0, $71 = 0, $710 = 0, $712 = 0, $718 = 0, $722 = 0, $723 = 0, $728 = 0, $734 = 0, $739 = 0, $742 = 0, $743 = 0, $746 = 0, $748 = 0, $750 = 0, $753 = 0, $764 = 0, $769 = 0, $771 = 0, $774 = 0, $776 = 0, $779 = 0, $78 = 0, $782 = 0, $783 = 0, $784 = 0, $786 = 0, $788 = 0, $789 = 0, $791 = 0, $792 = 0, $797 = 0, $798 = 0, $807 = 0, $812 = 0, $815 = 0, $816 = 0, $82 = 0, $822 = 0, $830 = 0, $836 = 0, $839 = 0, $840 = 0, $841 = 0, $845 = 0, $846 = 0, $85 = 0, $852 = 0, $857 = 0, $858 = 0, $861 = 0, $863 = 0, $866 = 0, $871 = 0, $877 = 0, $879 = 0, $881 = 0, $882 = 0, $89 = 0, $900 = 0, $902 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $918 = 0, $92 = 0, $922 = 0, $926 = 0, $928 = 0, $934 = 0, $935 = 0, $937 = 0, $938 = 0, $94 = 0, $942 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $955 = 0, $956 = 0, $96 = 0, $962 = 0, $967 = 0, $970 = 0, $971 = 0, $972 = 0, $976 = 0, $977 = 0, $983 = 0, $988 = 0, $989 = 0, $992 = 0, $994 = 0, $997 = 0, $F$0$i$i = 0, $F1$0$i = 0, $F4$0 = 0, $F4$0$i$i = 0, $F5$0$i = 0, $I1$0$i$i = 0, $I7$0$i = 0, $I7$0$i$i = 0, $K12$0$i = 0, $K2$0$i$i = 0, $K8$0$i$i = 0, $R$1$i = 0, $R$1$i$i = 0, $R$1$i$i$lcssa = 0, $R$1$i$lcssa = 0, $R$1$i9 = 0, $R$1$i9$lcssa = 0, $R$3$i = 0, $R$3$i$i = 0, $R$3$i11 = 0, $RP$1$i = 0, $RP$1$i$i = 0, $RP$1$i$i$lcssa = 0, $RP$1$i$lcssa = 0, $RP$1$i8 = 0, $RP$1$i8$lcssa = 0, $T$0$i = 0, $T$0$i$i = 0, $T$0$i$i$lcssa = 0, $T$0$i$i$lcssa140 = 0, $T$0$i$lcssa = 0, $T$0$i$lcssa156 = 0, $T$0$i18$i = 0, $T$0$i18$i$lcssa = 0, $T$0$i18$i$lcssa139 = 0, $br$2$ph$i = 0, $i$01$i$i = 0, $idx$0$i = 0, $magic$i$i = 0, $nb$0 = 0, $oldfirst$0$i$i = 0, $p$0$i$i = 0, $qsize$0$i$i = 0, $rsize$0$i = 0, $rsize$0$i$lcssa = 0, $rsize$0$i5 = 0, $rsize$1$i = 0, $rsize$3$i = 0, $rsize$4$lcssa$i = 0, $rsize$412$i = 0, $rst$0$i = 0, $rst$1$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$068$i = 0, $sp$068$i$lcssa = 0, $sp$167$i = 0, $sp$167$i$lcssa = 0, $ssize$0$i = 0, $ssize$2$ph$i = 0, $ssize$5$i = 0, $t$0$i = 0, $t$0$i4 = 0, $t$2$i = 0, $t$4$ph$i = 0, $t$4$v$4$i = 0, $t$411$i = 0, $tbase$746$i = 0, $tsize$745$i = 0, $v$0$i = 0, $v$0$i$lcssa = 0, $v$0$i6 = 0, $v$1$i = 0, $v$3$i = 0, $v$4$lcssa$i = 0, $v$413$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $magic$i$i = sp;
 do if ($bytes >>> 0 < 245) {
  $4 = $bytes >>> 0 < 11 ? 16 : $bytes + 11 & -8;
  $5 = $4 >>> 3;
  $6 = HEAP32[5769] | 0;
  $7 = $6 >>> $5;
  if ($7 & 3 | 0) {
   $12 = ($7 & 1 ^ 1) + $5 | 0;
   $14 = 23116 + ($12 << 1 << 2) | 0;
   $15 = $14 + 8 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $16 + 8 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   do if (($14 | 0) == ($18 | 0)) HEAP32[5769] = $6 & ~(1 << $12); else {
    if ($18 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    $25 = $18 + 12 | 0;
    if ((HEAP32[$25 >> 2] | 0) == ($16 | 0)) {
     HEAP32[$25 >> 2] = $14;
     HEAP32[$15 >> 2] = $18;
     break;
    } else _abort();
   } while (0);
   $28 = $12 << 3;
   HEAP32[$16 + 4 >> 2] = $28 | 3;
   $32 = $16 + $28 + 4 | 0;
   HEAP32[$32 >> 2] = HEAP32[$32 >> 2] | 1;
   $$0 = $17;
   STACKTOP = sp;
   return $$0 | 0;
  }
  $35 = HEAP32[5771] | 0;
  if ($4 >>> 0 > $35 >>> 0) {
   if ($7 | 0) {
    $39 = 2 << $5;
    $42 = $7 << $5 & ($39 | 0 - $39);
    $45 = ($42 & 0 - $42) + -1 | 0;
    $47 = $45 >>> 12 & 16;
    $48 = $45 >>> $47;
    $50 = $48 >>> 5 & 8;
    $52 = $48 >>> $50;
    $54 = $52 >>> 2 & 4;
    $56 = $52 >>> $54;
    $58 = $56 >>> 1 & 2;
    $60 = $56 >>> $58;
    $62 = $60 >>> 1 & 1;
    $65 = ($50 | $47 | $54 | $58 | $62) + ($60 >>> $62) | 0;
    $67 = 23116 + ($65 << 1 << 2) | 0;
    $68 = $67 + 8 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    $70 = $69 + 8 | 0;
    $71 = HEAP32[$70 >> 2] | 0;
    do if (($67 | 0) == ($71 | 0)) {
     HEAP32[5769] = $6 & ~(1 << $65);
     $89 = $35;
    } else {
     if ($71 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
     $78 = $71 + 12 | 0;
     if ((HEAP32[$78 >> 2] | 0) == ($69 | 0)) {
      HEAP32[$78 >> 2] = $67;
      HEAP32[$68 >> 2] = $71;
      $89 = HEAP32[5771] | 0;
      break;
     } else _abort();
    } while (0);
    $82 = ($65 << 3) - $4 | 0;
    HEAP32[$69 + 4 >> 2] = $4 | 3;
    $85 = $69 + $4 | 0;
    HEAP32[$85 + 4 >> 2] = $82 | 1;
    HEAP32[$85 + $82 >> 2] = $82;
    if ($89 | 0) {
     $91 = HEAP32[5774] | 0;
     $92 = $89 >>> 3;
     $94 = 23116 + ($92 << 1 << 2) | 0;
     $95 = HEAP32[5769] | 0;
     $96 = 1 << $92;
     if (!($95 & $96)) {
      HEAP32[5769] = $95 | $96;
      $$pre$phiZ2D = $94 + 8 | 0;
      $F4$0 = $94;
     } else {
      $100 = $94 + 8 | 0;
      $101 = HEAP32[$100 >> 2] | 0;
      if ($101 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
       $$pre$phiZ2D = $100;
       $F4$0 = $101;
      }
     }
     HEAP32[$$pre$phiZ2D >> 2] = $91;
     HEAP32[$F4$0 + 12 >> 2] = $91;
     HEAP32[$91 + 8 >> 2] = $F4$0;
     HEAP32[$91 + 12 >> 2] = $94;
    }
    HEAP32[5771] = $82;
    HEAP32[5774] = $85;
    $$0 = $70;
    STACKTOP = sp;
    return $$0 | 0;
   }
   $107 = HEAP32[5770] | 0;
   if (!$107) $nb$0 = $4; else {
    $111 = ($107 & 0 - $107) + -1 | 0;
    $113 = $111 >>> 12 & 16;
    $114 = $111 >>> $113;
    $116 = $114 >>> 5 & 8;
    $118 = $114 >>> $116;
    $120 = $118 >>> 2 & 4;
    $122 = $118 >>> $120;
    $124 = $122 >>> 1 & 2;
    $126 = $122 >>> $124;
    $128 = $126 >>> 1 & 1;
    $133 = HEAP32[23380 + (($116 | $113 | $120 | $124 | $128) + ($126 >>> $128) << 2) >> 2] | 0;
    $rsize$0$i = (HEAP32[$133 + 4 >> 2] & -8) - $4 | 0;
    $t$0$i = $133;
    $v$0$i = $133;
    while (1) {
     $139 = HEAP32[$t$0$i + 16 >> 2] | 0;
     if (!$139) {
      $142 = HEAP32[$t$0$i + 20 >> 2] | 0;
      if (!$142) {
       $rsize$0$i$lcssa = $rsize$0$i;
       $v$0$i$lcssa = $v$0$i;
       break;
      } else $145 = $142;
     } else $145 = $139;
     $148 = (HEAP32[$145 + 4 >> 2] & -8) - $4 | 0;
     $149 = $148 >>> 0 < $rsize$0$i >>> 0;
     $rsize$0$i = $149 ? $148 : $rsize$0$i;
     $t$0$i = $145;
     $v$0$i = $149 ? $145 : $v$0$i;
    }
    $150 = HEAP32[5773] | 0;
    if ($v$0$i$lcssa >>> 0 < $150 >>> 0) _abort();
    $152 = $v$0$i$lcssa + $4 | 0;
    if ($v$0$i$lcssa >>> 0 >= $152 >>> 0) _abort();
    $155 = HEAP32[$v$0$i$lcssa + 24 >> 2] | 0;
    $157 = HEAP32[$v$0$i$lcssa + 12 >> 2] | 0;
    do if (($157 | 0) == ($v$0$i$lcssa | 0)) {
     $168 = $v$0$i$lcssa + 20 | 0;
     $169 = HEAP32[$168 >> 2] | 0;
     if (!$169) {
      $171 = $v$0$i$lcssa + 16 | 0;
      $172 = HEAP32[$171 >> 2] | 0;
      if (!$172) {
       $R$3$i = 0;
       break;
      } else {
       $R$1$i = $172;
       $RP$1$i = $171;
      }
     } else {
      $R$1$i = $169;
      $RP$1$i = $168;
     }
     while (1) {
      $174 = $R$1$i + 20 | 0;
      $175 = HEAP32[$174 >> 2] | 0;
      if ($175 | 0) {
       $R$1$i = $175;
       $RP$1$i = $174;
       continue;
      }
      $177 = $R$1$i + 16 | 0;
      $178 = HEAP32[$177 >> 2] | 0;
      if (!$178) {
       $R$1$i$lcssa = $R$1$i;
       $RP$1$i$lcssa = $RP$1$i;
       break;
      } else {
       $R$1$i = $178;
       $RP$1$i = $177;
      }
     }
     if ($RP$1$i$lcssa >>> 0 < $150 >>> 0) _abort(); else {
      HEAP32[$RP$1$i$lcssa >> 2] = 0;
      $R$3$i = $R$1$i$lcssa;
      break;
     }
    } else {
     $160 = HEAP32[$v$0$i$lcssa + 8 >> 2] | 0;
     if ($160 >>> 0 < $150 >>> 0) _abort();
     $162 = $160 + 12 | 0;
     if ((HEAP32[$162 >> 2] | 0) != ($v$0$i$lcssa | 0)) _abort();
     $165 = $157 + 8 | 0;
     if ((HEAP32[$165 >> 2] | 0) == ($v$0$i$lcssa | 0)) {
      HEAP32[$162 >> 2] = $157;
      HEAP32[$165 >> 2] = $160;
      $R$3$i = $157;
      break;
     } else _abort();
    } while (0);
    do if ($155 | 0) {
     $183 = HEAP32[$v$0$i$lcssa + 28 >> 2] | 0;
     $184 = 23380 + ($183 << 2) | 0;
     if (($v$0$i$lcssa | 0) == (HEAP32[$184 >> 2] | 0)) {
      HEAP32[$184 >> 2] = $R$3$i;
      if (!$R$3$i) {
       HEAP32[5770] = HEAP32[5770] & ~(1 << $183);
       break;
      }
     } else {
      if ($155 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
      $193 = $155 + 16 | 0;
      if ((HEAP32[$193 >> 2] | 0) == ($v$0$i$lcssa | 0)) HEAP32[$193 >> 2] = $R$3$i; else HEAP32[$155 + 20 >> 2] = $R$3$i;
      if (!$R$3$i) break;
     }
     $198 = HEAP32[5773] | 0;
     if ($R$3$i >>> 0 < $198 >>> 0) _abort();
     HEAP32[$R$3$i + 24 >> 2] = $155;
     $202 = HEAP32[$v$0$i$lcssa + 16 >> 2] | 0;
     do if ($202 | 0) if ($202 >>> 0 < $198 >>> 0) _abort(); else {
      HEAP32[$R$3$i + 16 >> 2] = $202;
      HEAP32[$202 + 24 >> 2] = $R$3$i;
      break;
     } while (0);
     $208 = HEAP32[$v$0$i$lcssa + 20 >> 2] | 0;
     if ($208 | 0) if ($208 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
      HEAP32[$R$3$i + 20 >> 2] = $208;
      HEAP32[$208 + 24 >> 2] = $R$3$i;
      break;
     }
    } while (0);
    if ($rsize$0$i$lcssa >>> 0 < 16) {
     $215 = $rsize$0$i$lcssa + $4 | 0;
     HEAP32[$v$0$i$lcssa + 4 >> 2] = $215 | 3;
     $219 = $v$0$i$lcssa + $215 + 4 | 0;
     HEAP32[$219 >> 2] = HEAP32[$219 >> 2] | 1;
    } else {
     HEAP32[$v$0$i$lcssa + 4 >> 2] = $4 | 3;
     HEAP32[$152 + 4 >> 2] = $rsize$0$i$lcssa | 1;
     HEAP32[$152 + $rsize$0$i$lcssa >> 2] = $rsize$0$i$lcssa;
     $227 = HEAP32[5771] | 0;
     if ($227 | 0) {
      $229 = HEAP32[5774] | 0;
      $230 = $227 >>> 3;
      $232 = 23116 + ($230 << 1 << 2) | 0;
      $233 = HEAP32[5769] | 0;
      $234 = 1 << $230;
      if (!($233 & $234)) {
       HEAP32[5769] = $233 | $234;
       $$pre$phi$iZ2D = $232 + 8 | 0;
       $F1$0$i = $232;
      } else {
       $238 = $232 + 8 | 0;
       $239 = HEAP32[$238 >> 2] | 0;
       if ($239 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
        $$pre$phi$iZ2D = $238;
        $F1$0$i = $239;
       }
      }
      HEAP32[$$pre$phi$iZ2D >> 2] = $229;
      HEAP32[$F1$0$i + 12 >> 2] = $229;
      HEAP32[$229 + 8 >> 2] = $F1$0$i;
      HEAP32[$229 + 12 >> 2] = $232;
     }
     HEAP32[5771] = $rsize$0$i$lcssa;
     HEAP32[5774] = $152;
    }
    $$0 = $v$0$i$lcssa + 8 | 0;
    STACKTOP = sp;
    return $$0 | 0;
   }
  } else $nb$0 = $4;
 } else if ($bytes >>> 0 > 4294967231) $nb$0 = -1; else {
  $247 = $bytes + 11 | 0;
  $248 = $247 & -8;
  $249 = HEAP32[5770] | 0;
  if (!$249) $nb$0 = $248; else {
   $251 = 0 - $248 | 0;
   $252 = $247 >>> 8;
   if (!$252) $idx$0$i = 0; else if ($248 >>> 0 > 16777215) $idx$0$i = 31; else {
    $257 = ($252 + 1048320 | 0) >>> 16 & 8;
    $258 = $252 << $257;
    $261 = ($258 + 520192 | 0) >>> 16 & 4;
    $263 = $258 << $261;
    $266 = ($263 + 245760 | 0) >>> 16 & 2;
    $271 = 14 - ($261 | $257 | $266) + ($263 << $266 >>> 15) | 0;
    $idx$0$i = $248 >>> ($271 + 7 | 0) & 1 | $271 << 1;
   }
   $278 = HEAP32[23380 + ($idx$0$i << 2) >> 2] | 0;
   L123 : do if (!$278) {
    $rsize$3$i = $251;
    $t$2$i = 0;
    $v$3$i = 0;
    label = 86;
   } else {
    $rsize$0$i5 = $251;
    $rst$0$i = 0;
    $sizebits$0$i = $248 << (($idx$0$i | 0) == 31 ? 0 : 25 - ($idx$0$i >>> 1) | 0);
    $t$0$i4 = $278;
    $v$0$i6 = 0;
    while (1) {
     $287 = HEAP32[$t$0$i4 + 4 >> 2] & -8;
     $288 = $287 - $248 | 0;
     if ($288 >>> 0 < $rsize$0$i5 >>> 0) if (($287 | 0) == ($248 | 0)) {
      $rsize$412$i = $288;
      $t$411$i = $t$0$i4;
      $v$413$i = $t$0$i4;
      label = 90;
      break L123;
     } else {
      $rsize$1$i = $288;
      $v$1$i = $t$0$i4;
     } else {
      $rsize$1$i = $rsize$0$i5;
      $v$1$i = $v$0$i6;
     }
     $292 = HEAP32[$t$0$i4 + 20 >> 2] | 0;
     $295 = HEAP32[$t$0$i4 + 16 + ($sizebits$0$i >>> 31 << 2) >> 2] | 0;
     $rst$1$i = ($292 | 0) == 0 | ($292 | 0) == ($295 | 0) ? $rst$0$i : $292;
     $298 = ($295 | 0) == 0;
     if ($298) {
      $rsize$3$i = $rsize$1$i;
      $t$2$i = $rst$1$i;
      $v$3$i = $v$1$i;
      label = 86;
      break;
     } else {
      $rsize$0$i5 = $rsize$1$i;
      $rst$0$i = $rst$1$i;
      $sizebits$0$i = $sizebits$0$i << ($298 & 1 ^ 1);
      $t$0$i4 = $295;
      $v$0$i6 = $v$1$i;
     }
    }
   } while (0);
   if ((label | 0) == 86) {
    if (($t$2$i | 0) == 0 & ($v$3$i | 0) == 0) {
     $303 = 2 << $idx$0$i;
     $306 = $249 & ($303 | 0 - $303);
     if (!$306) {
      $nb$0 = $248;
      break;
     }
     $310 = ($306 & 0 - $306) + -1 | 0;
     $312 = $310 >>> 12 & 16;
     $313 = $310 >>> $312;
     $315 = $313 >>> 5 & 8;
     $317 = $313 >>> $315;
     $319 = $317 >>> 2 & 4;
     $321 = $317 >>> $319;
     $323 = $321 >>> 1 & 2;
     $325 = $321 >>> $323;
     $327 = $325 >>> 1 & 1;
     $t$4$ph$i = HEAP32[23380 + (($315 | $312 | $319 | $323 | $327) + ($325 >>> $327) << 2) >> 2] | 0;
    } else $t$4$ph$i = $t$2$i;
    if (!$t$4$ph$i) {
     $rsize$4$lcssa$i = $rsize$3$i;
     $v$4$lcssa$i = $v$3$i;
    } else {
     $rsize$412$i = $rsize$3$i;
     $t$411$i = $t$4$ph$i;
     $v$413$i = $v$3$i;
     label = 90;
    }
   }
   if ((label | 0) == 90) while (1) {
    label = 0;
    $337 = (HEAP32[$t$411$i + 4 >> 2] & -8) - $248 | 0;
    $338 = $337 >>> 0 < $rsize$412$i >>> 0;
    $$rsize$4$i = $338 ? $337 : $rsize$412$i;
    $t$4$v$4$i = $338 ? $t$411$i : $v$413$i;
    $340 = HEAP32[$t$411$i + 16 >> 2] | 0;
    if ($340 | 0) {
     $rsize$412$i = $$rsize$4$i;
     $t$411$i = $340;
     $v$413$i = $t$4$v$4$i;
     label = 90;
     continue;
    }
    $343 = HEAP32[$t$411$i + 20 >> 2] | 0;
    if (!$343) {
     $rsize$4$lcssa$i = $$rsize$4$i;
     $v$4$lcssa$i = $t$4$v$4$i;
     break;
    } else {
     $rsize$412$i = $$rsize$4$i;
     $t$411$i = $343;
     $v$413$i = $t$4$v$4$i;
     label = 90;
    }
   }
   if (!$v$4$lcssa$i) $nb$0 = $248; else if ($rsize$4$lcssa$i >>> 0 < ((HEAP32[5771] | 0) - $248 | 0) >>> 0) {
    $349 = HEAP32[5773] | 0;
    if ($v$4$lcssa$i >>> 0 < $349 >>> 0) _abort();
    $351 = $v$4$lcssa$i + $248 | 0;
    if ($v$4$lcssa$i >>> 0 >= $351 >>> 0) _abort();
    $354 = HEAP32[$v$4$lcssa$i + 24 >> 2] | 0;
    $356 = HEAP32[$v$4$lcssa$i + 12 >> 2] | 0;
    do if (($356 | 0) == ($v$4$lcssa$i | 0)) {
     $367 = $v$4$lcssa$i + 20 | 0;
     $368 = HEAP32[$367 >> 2] | 0;
     if (!$368) {
      $370 = $v$4$lcssa$i + 16 | 0;
      $371 = HEAP32[$370 >> 2] | 0;
      if (!$371) {
       $R$3$i11 = 0;
       break;
      } else {
       $R$1$i9 = $371;
       $RP$1$i8 = $370;
      }
     } else {
      $R$1$i9 = $368;
      $RP$1$i8 = $367;
     }
     while (1) {
      $373 = $R$1$i9 + 20 | 0;
      $374 = HEAP32[$373 >> 2] | 0;
      if ($374 | 0) {
       $R$1$i9 = $374;
       $RP$1$i8 = $373;
       continue;
      }
      $376 = $R$1$i9 + 16 | 0;
      $377 = HEAP32[$376 >> 2] | 0;
      if (!$377) {
       $R$1$i9$lcssa = $R$1$i9;
       $RP$1$i8$lcssa = $RP$1$i8;
       break;
      } else {
       $R$1$i9 = $377;
       $RP$1$i8 = $376;
      }
     }
     if ($RP$1$i8$lcssa >>> 0 < $349 >>> 0) _abort(); else {
      HEAP32[$RP$1$i8$lcssa >> 2] = 0;
      $R$3$i11 = $R$1$i9$lcssa;
      break;
     }
    } else {
     $359 = HEAP32[$v$4$lcssa$i + 8 >> 2] | 0;
     if ($359 >>> 0 < $349 >>> 0) _abort();
     $361 = $359 + 12 | 0;
     if ((HEAP32[$361 >> 2] | 0) != ($v$4$lcssa$i | 0)) _abort();
     $364 = $356 + 8 | 0;
     if ((HEAP32[$364 >> 2] | 0) == ($v$4$lcssa$i | 0)) {
      HEAP32[$361 >> 2] = $356;
      HEAP32[$364 >> 2] = $359;
      $R$3$i11 = $356;
      break;
     } else _abort();
    } while (0);
    do if ($354 | 0) {
     $382 = HEAP32[$v$4$lcssa$i + 28 >> 2] | 0;
     $383 = 23380 + ($382 << 2) | 0;
     if (($v$4$lcssa$i | 0) == (HEAP32[$383 >> 2] | 0)) {
      HEAP32[$383 >> 2] = $R$3$i11;
      if (!$R$3$i11) {
       HEAP32[5770] = HEAP32[5770] & ~(1 << $382);
       break;
      }
     } else {
      if ($354 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
      $392 = $354 + 16 | 0;
      if ((HEAP32[$392 >> 2] | 0) == ($v$4$lcssa$i | 0)) HEAP32[$392 >> 2] = $R$3$i11; else HEAP32[$354 + 20 >> 2] = $R$3$i11;
      if (!$R$3$i11) break;
     }
     $397 = HEAP32[5773] | 0;
     if ($R$3$i11 >>> 0 < $397 >>> 0) _abort();
     HEAP32[$R$3$i11 + 24 >> 2] = $354;
     $401 = HEAP32[$v$4$lcssa$i + 16 >> 2] | 0;
     do if ($401 | 0) if ($401 >>> 0 < $397 >>> 0) _abort(); else {
      HEAP32[$R$3$i11 + 16 >> 2] = $401;
      HEAP32[$401 + 24 >> 2] = $R$3$i11;
      break;
     } while (0);
     $407 = HEAP32[$v$4$lcssa$i + 20 >> 2] | 0;
     if ($407 | 0) if ($407 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
      HEAP32[$R$3$i11 + 20 >> 2] = $407;
      HEAP32[$407 + 24 >> 2] = $R$3$i11;
      break;
     }
    } while (0);
    do if ($rsize$4$lcssa$i >>> 0 < 16) {
     $414 = $rsize$4$lcssa$i + $248 | 0;
     HEAP32[$v$4$lcssa$i + 4 >> 2] = $414 | 3;
     $418 = $v$4$lcssa$i + $414 + 4 | 0;
     HEAP32[$418 >> 2] = HEAP32[$418 >> 2] | 1;
    } else {
     HEAP32[$v$4$lcssa$i + 4 >> 2] = $248 | 3;
     HEAP32[$351 + 4 >> 2] = $rsize$4$lcssa$i | 1;
     HEAP32[$351 + $rsize$4$lcssa$i >> 2] = $rsize$4$lcssa$i;
     $426 = $rsize$4$lcssa$i >>> 3;
     if ($rsize$4$lcssa$i >>> 0 < 256) {
      $429 = 23116 + ($426 << 1 << 2) | 0;
      $430 = HEAP32[5769] | 0;
      $431 = 1 << $426;
      if (!($430 & $431)) {
       HEAP32[5769] = $430 | $431;
       $$pre$phi$i14Z2D = $429 + 8 | 0;
       $F5$0$i = $429;
      } else {
       $435 = $429 + 8 | 0;
       $436 = HEAP32[$435 >> 2] | 0;
       if ($436 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
        $$pre$phi$i14Z2D = $435;
        $F5$0$i = $436;
       }
      }
      HEAP32[$$pre$phi$i14Z2D >> 2] = $351;
      HEAP32[$F5$0$i + 12 >> 2] = $351;
      HEAP32[$351 + 8 >> 2] = $F5$0$i;
      HEAP32[$351 + 12 >> 2] = $429;
      break;
     }
     $442 = $rsize$4$lcssa$i >>> 8;
     if (!$442) $I7$0$i = 0; else if ($rsize$4$lcssa$i >>> 0 > 16777215) $I7$0$i = 31; else {
      $447 = ($442 + 1048320 | 0) >>> 16 & 8;
      $448 = $442 << $447;
      $451 = ($448 + 520192 | 0) >>> 16 & 4;
      $453 = $448 << $451;
      $456 = ($453 + 245760 | 0) >>> 16 & 2;
      $461 = 14 - ($451 | $447 | $456) + ($453 << $456 >>> 15) | 0;
      $I7$0$i = $rsize$4$lcssa$i >>> ($461 + 7 | 0) & 1 | $461 << 1;
     }
     $467 = 23380 + ($I7$0$i << 2) | 0;
     HEAP32[$351 + 28 >> 2] = $I7$0$i;
     $469 = $351 + 16 | 0;
     HEAP32[$469 + 4 >> 2] = 0;
     HEAP32[$469 >> 2] = 0;
     $471 = HEAP32[5770] | 0;
     $472 = 1 << $I7$0$i;
     if (!($471 & $472)) {
      HEAP32[5770] = $471 | $472;
      HEAP32[$467 >> 2] = $351;
      HEAP32[$351 + 24 >> 2] = $467;
      HEAP32[$351 + 12 >> 2] = $351;
      HEAP32[$351 + 8 >> 2] = $351;
      break;
     }
     $K12$0$i = $rsize$4$lcssa$i << (($I7$0$i | 0) == 31 ? 0 : 25 - ($I7$0$i >>> 1) | 0);
     $T$0$i = HEAP32[$467 >> 2] | 0;
     while (1) {
      if ((HEAP32[$T$0$i + 4 >> 2] & -8 | 0) == ($rsize$4$lcssa$i | 0)) {
       $T$0$i$lcssa = $T$0$i;
       label = 148;
       break;
      }
      $490 = $T$0$i + 16 + ($K12$0$i >>> 31 << 2) | 0;
      $492 = HEAP32[$490 >> 2] | 0;
      if (!$492) {
       $$lcssa157 = $490;
       $T$0$i$lcssa156 = $T$0$i;
       label = 145;
       break;
      } else {
       $K12$0$i = $K12$0$i << 1;
       $T$0$i = $492;
      }
     }
     if ((label | 0) == 145) if ($$lcssa157 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
      HEAP32[$$lcssa157 >> 2] = $351;
      HEAP32[$351 + 24 >> 2] = $T$0$i$lcssa156;
      HEAP32[$351 + 12 >> 2] = $351;
      HEAP32[$351 + 8 >> 2] = $351;
      break;
     } else if ((label | 0) == 148) {
      $499 = $T$0$i$lcssa + 8 | 0;
      $500 = HEAP32[$499 >> 2] | 0;
      $501 = HEAP32[5773] | 0;
      if ($500 >>> 0 >= $501 >>> 0 & $T$0$i$lcssa >>> 0 >= $501 >>> 0) {
       HEAP32[$500 + 12 >> 2] = $351;
       HEAP32[$499 >> 2] = $351;
       HEAP32[$351 + 8 >> 2] = $500;
       HEAP32[$351 + 12 >> 2] = $T$0$i$lcssa;
       HEAP32[$351 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } while (0);
    $$0 = $v$4$lcssa$i + 8 | 0;
    STACKTOP = sp;
    return $$0 | 0;
   } else $nb$0 = $248;
  }
 } while (0);
 $509 = HEAP32[5771] | 0;
 if ($509 >>> 0 >= $nb$0 >>> 0) {
  $511 = $509 - $nb$0 | 0;
  $512 = HEAP32[5774] | 0;
  if ($511 >>> 0 > 15) {
   $514 = $512 + $nb$0 | 0;
   HEAP32[5774] = $514;
   HEAP32[5771] = $511;
   HEAP32[$514 + 4 >> 2] = $511 | 1;
   HEAP32[$514 + $511 >> 2] = $511;
   HEAP32[$512 + 4 >> 2] = $nb$0 | 3;
  } else {
   HEAP32[5771] = 0;
   HEAP32[5774] = 0;
   HEAP32[$512 + 4 >> 2] = $509 | 3;
   $523 = $512 + $509 + 4 | 0;
   HEAP32[$523 >> 2] = HEAP32[$523 >> 2] | 1;
  }
  $$0 = $512 + 8 | 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $527 = HEAP32[5772] | 0;
 if ($527 >>> 0 > $nb$0 >>> 0) {
  $529 = $527 - $nb$0 | 0;
  HEAP32[5772] = $529;
  $530 = HEAP32[5775] | 0;
  $531 = $530 + $nb$0 | 0;
  HEAP32[5775] = $531;
  HEAP32[$531 + 4 >> 2] = $529 | 1;
  HEAP32[$530 + 4 >> 2] = $nb$0 | 3;
  $$0 = $530 + 8 | 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 if (!(HEAP32[5887] | 0)) {
  HEAP32[5889] = 4096;
  HEAP32[5888] = 4096;
  HEAP32[5890] = -1;
  HEAP32[5891] = -1;
  HEAP32[5892] = 0;
  HEAP32[5880] = 0;
  $541 = $magic$i$i & -16 ^ 1431655768;
  HEAP32[$magic$i$i >> 2] = $541;
  HEAP32[5887] = $541;
 }
 $542 = $nb$0 + 48 | 0;
 $543 = HEAP32[5889] | 0;
 $544 = $nb$0 + 47 | 0;
 $545 = $543 + $544 | 0;
 $546 = 0 - $543 | 0;
 $547 = $545 & $546;
 if ($547 >>> 0 <= $nb$0 >>> 0) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $549 = HEAP32[5879] | 0;
 if ($549 | 0) {
  $551 = HEAP32[5877] | 0;
  $552 = $551 + $547 | 0;
  if ($552 >>> 0 <= $551 >>> 0 | $552 >>> 0 > $549 >>> 0) {
   $$0 = 0;
   STACKTOP = sp;
   return $$0 | 0;
  }
 }
 L254 : do if (!(HEAP32[5880] & 4)) {
  $558 = HEAP32[5775] | 0;
  L256 : do if (!$558) label = 171; else {
   $sp$0$i$i = 23524;
   while (1) {
    $560 = HEAP32[$sp$0$i$i >> 2] | 0;
    if ($560 >>> 0 <= $558 >>> 0) {
     $562 = $sp$0$i$i + 4 | 0;
     if (($560 + (HEAP32[$562 >> 2] | 0) | 0) >>> 0 > $558 >>> 0) {
      $$lcssa153 = $sp$0$i$i;
      $$lcssa155 = $562;
      break;
     }
    }
    $567 = HEAP32[$sp$0$i$i + 8 >> 2] | 0;
    if (!$567) {
     label = 171;
     break L256;
    } else $sp$0$i$i = $567;
   }
   $593 = $545 - (HEAP32[5772] | 0) & $546;
   if ($593 >>> 0 < 2147483647) {
    $595 = _sbrk($593 | 0) | 0;
    if (($595 | 0) == ((HEAP32[$$lcssa153 >> 2] | 0) + (HEAP32[$$lcssa155 >> 2] | 0) | 0)) {
     if (($595 | 0) != (-1 | 0)) {
      $tbase$746$i = $595;
      $tsize$745$i = $593;
      label = 191;
      break L254;
     }
    } else {
     $br$2$ph$i = $595;
     $ssize$2$ph$i = $593;
     label = 181;
    }
   }
  } while (0);
  do if ((label | 0) == 171) {
   $569 = _sbrk(0) | 0;
   if (($569 | 0) != (-1 | 0)) {
    $571 = $569;
    $572 = HEAP32[5888] | 0;
    $573 = $572 + -1 | 0;
    if (!($573 & $571)) $ssize$0$i = $547; else $ssize$0$i = $547 - $571 + ($573 + $571 & 0 - $572) | 0;
    $581 = HEAP32[5877] | 0;
    $582 = $581 + $ssize$0$i | 0;
    if ($ssize$0$i >>> 0 > $nb$0 >>> 0 & $ssize$0$i >>> 0 < 2147483647) {
     $585 = HEAP32[5879] | 0;
     if ($585 | 0) if ($582 >>> 0 <= $581 >>> 0 | $582 >>> 0 > $585 >>> 0) break;
     $589 = _sbrk($ssize$0$i | 0) | 0;
     if (($589 | 0) == ($569 | 0)) {
      $tbase$746$i = $569;
      $tsize$745$i = $ssize$0$i;
      label = 191;
      break L254;
     } else {
      $br$2$ph$i = $589;
      $ssize$2$ph$i = $ssize$0$i;
      label = 181;
     }
    }
   }
  } while (0);
  L276 : do if ((label | 0) == 181) {
   $601 = 0 - $ssize$2$ph$i | 0;
   do if ($542 >>> 0 > $ssize$2$ph$i >>> 0 & ($ssize$2$ph$i >>> 0 < 2147483647 & ($br$2$ph$i | 0) != (-1 | 0))) {
    $605 = HEAP32[5889] | 0;
    $609 = $544 - $ssize$2$ph$i + $605 & 0 - $605;
    if ($609 >>> 0 < 2147483647) if ((_sbrk($609 | 0) | 0) == (-1 | 0)) {
     _sbrk($601 | 0) | 0;
     break L276;
    } else {
     $ssize$5$i = $609 + $ssize$2$ph$i | 0;
     break;
    } else $ssize$5$i = $ssize$2$ph$i;
   } else $ssize$5$i = $ssize$2$ph$i; while (0);
   if (($br$2$ph$i | 0) != (-1 | 0)) {
    $tbase$746$i = $br$2$ph$i;
    $tsize$745$i = $ssize$5$i;
    label = 191;
    break L254;
   }
  } while (0);
  HEAP32[5880] = HEAP32[5880] | 4;
  label = 188;
 } else label = 188; while (0);
 if ((label | 0) == 188) if ($547 >>> 0 < 2147483647) {
  $618 = _sbrk($547 | 0) | 0;
  $619 = _sbrk(0) | 0;
  if ($618 >>> 0 < $619 >>> 0 & (($618 | 0) != (-1 | 0) & ($619 | 0) != (-1 | 0))) {
   $625 = $619 - $618 | 0;
   if ($625 >>> 0 > ($nb$0 + 40 | 0) >>> 0) {
    $tbase$746$i = $618;
    $tsize$745$i = $625;
    label = 191;
   }
  }
 }
 if ((label | 0) == 191) {
  $628 = (HEAP32[5877] | 0) + $tsize$745$i | 0;
  HEAP32[5877] = $628;
  if ($628 >>> 0 > (HEAP32[5878] | 0) >>> 0) HEAP32[5878] = $628;
  $631 = HEAP32[5775] | 0;
  do if (!$631) {
   $633 = HEAP32[5773] | 0;
   if (($633 | 0) == 0 | $tbase$746$i >>> 0 < $633 >>> 0) HEAP32[5773] = $tbase$746$i;
   HEAP32[5881] = $tbase$746$i;
   HEAP32[5882] = $tsize$745$i;
   HEAP32[5884] = 0;
   HEAP32[5778] = HEAP32[5887];
   HEAP32[5777] = -1;
   $i$01$i$i = 0;
   while (1) {
    $638 = 23116 + ($i$01$i$i << 1 << 2) | 0;
    HEAP32[$638 + 12 >> 2] = $638;
    HEAP32[$638 + 8 >> 2] = $638;
    $641 = $i$01$i$i + 1 | 0;
    if (($641 | 0) == 32) break; else $i$01$i$i = $641;
   }
   $644 = $tbase$746$i + 8 | 0;
   $649 = ($644 & 7 | 0) == 0 ? 0 : 0 - $644 & 7;
   $650 = $tbase$746$i + $649 | 0;
   $651 = $tsize$745$i + -40 - $649 | 0;
   HEAP32[5775] = $650;
   HEAP32[5772] = $651;
   HEAP32[$650 + 4 >> 2] = $651 | 1;
   HEAP32[$650 + $651 + 4 >> 2] = 40;
   HEAP32[5776] = HEAP32[5891];
  } else {
   $sp$068$i = 23524;
   while (1) {
    $657 = HEAP32[$sp$068$i >> 2] | 0;
    $658 = $sp$068$i + 4 | 0;
    $659 = HEAP32[$658 >> 2] | 0;
    if (($tbase$746$i | 0) == ($657 + $659 | 0)) {
     $$lcssa147 = $657;
     $$lcssa149 = $658;
     $$lcssa151 = $659;
     $sp$068$i$lcssa = $sp$068$i;
     label = 201;
     break;
    }
    $663 = HEAP32[$sp$068$i + 8 >> 2] | 0;
    if (!$663) break; else $sp$068$i = $663;
   }
   if ((label | 0) == 201) if (!(HEAP32[$sp$068$i$lcssa + 12 >> 2] & 8)) if ($631 >>> 0 < $tbase$746$i >>> 0 & $631 >>> 0 >= $$lcssa147 >>> 0) {
    HEAP32[$$lcssa149 >> 2] = $$lcssa151 + $tsize$745$i;
    $674 = $631 + 8 | 0;
    $679 = ($674 & 7 | 0) == 0 ? 0 : 0 - $674 & 7;
    $680 = $631 + $679 | 0;
    $682 = $tsize$745$i - $679 + (HEAP32[5772] | 0) | 0;
    HEAP32[5775] = $680;
    HEAP32[5772] = $682;
    HEAP32[$680 + 4 >> 2] = $682 | 1;
    HEAP32[$680 + $682 + 4 >> 2] = 40;
    HEAP32[5776] = HEAP32[5891];
    break;
   }
   $688 = HEAP32[5773] | 0;
   if ($tbase$746$i >>> 0 < $688 >>> 0) {
    HEAP32[5773] = $tbase$746$i;
    $753 = $tbase$746$i;
   } else $753 = $688;
   $690 = $tbase$746$i + $tsize$745$i | 0;
   $sp$167$i = 23524;
   while (1) {
    if ((HEAP32[$sp$167$i >> 2] | 0) == ($690 | 0)) {
     $$lcssa144 = $sp$167$i;
     $sp$167$i$lcssa = $sp$167$i;
     label = 209;
     break;
    }
    $694 = HEAP32[$sp$167$i + 8 >> 2] | 0;
    if (!$694) {
     $sp$0$i$i$i = 23524;
     break;
    } else $sp$167$i = $694;
   }
   if ((label | 0) == 209) if (!(HEAP32[$sp$167$i$lcssa + 12 >> 2] & 8)) {
    HEAP32[$$lcssa144 >> 2] = $tbase$746$i;
    $700 = $sp$167$i$lcssa + 4 | 0;
    HEAP32[$700 >> 2] = (HEAP32[$700 >> 2] | 0) + $tsize$745$i;
    $704 = $tbase$746$i + 8 | 0;
    $710 = $tbase$746$i + (($704 & 7 | 0) == 0 ? 0 : 0 - $704 & 7) | 0;
    $712 = $690 + 8 | 0;
    $718 = $690 + (($712 & 7 | 0) == 0 ? 0 : 0 - $712 & 7) | 0;
    $722 = $710 + $nb$0 | 0;
    $723 = $718 - $710 - $nb$0 | 0;
    HEAP32[$710 + 4 >> 2] = $nb$0 | 3;
    do if (($718 | 0) == ($631 | 0)) {
     $728 = (HEAP32[5772] | 0) + $723 | 0;
     HEAP32[5772] = $728;
     HEAP32[5775] = $722;
     HEAP32[$722 + 4 >> 2] = $728 | 1;
    } else {
     if (($718 | 0) == (HEAP32[5774] | 0)) {
      $734 = (HEAP32[5771] | 0) + $723 | 0;
      HEAP32[5771] = $734;
      HEAP32[5774] = $722;
      HEAP32[$722 + 4 >> 2] = $734 | 1;
      HEAP32[$722 + $734 >> 2] = $734;
      break;
     }
     $739 = HEAP32[$718 + 4 >> 2] | 0;
     if (($739 & 3 | 0) == 1) {
      $742 = $739 & -8;
      $743 = $739 >>> 3;
      L328 : do if ($739 >>> 0 < 256) {
       $746 = HEAP32[$718 + 8 >> 2] | 0;
       $748 = HEAP32[$718 + 12 >> 2] | 0;
       $750 = 23116 + ($743 << 1 << 2) | 0;
       do if (($746 | 0) != ($750 | 0)) {
        if ($746 >>> 0 < $753 >>> 0) _abort();
        if ((HEAP32[$746 + 12 >> 2] | 0) == ($718 | 0)) break;
        _abort();
       } while (0);
       if (($748 | 0) == ($746 | 0)) {
        HEAP32[5769] = HEAP32[5769] & ~(1 << $743);
        break;
       }
       do if (($748 | 0) == ($750 | 0)) $$pre$phi10$i$iZ2D = $748 + 8 | 0; else {
        if ($748 >>> 0 < $753 >>> 0) _abort();
        $764 = $748 + 8 | 0;
        if ((HEAP32[$764 >> 2] | 0) == ($718 | 0)) {
         $$pre$phi10$i$iZ2D = $764;
         break;
        }
        _abort();
       } while (0);
       HEAP32[$746 + 12 >> 2] = $748;
       HEAP32[$$pre$phi10$i$iZ2D >> 2] = $746;
      } else {
       $769 = HEAP32[$718 + 24 >> 2] | 0;
       $771 = HEAP32[$718 + 12 >> 2] | 0;
       do if (($771 | 0) == ($718 | 0)) {
        $782 = $718 + 16 | 0;
        $783 = $782 + 4 | 0;
        $784 = HEAP32[$783 >> 2] | 0;
        if (!$784) {
         $786 = HEAP32[$782 >> 2] | 0;
         if (!$786) {
          $R$3$i$i = 0;
          break;
         } else {
          $R$1$i$i = $786;
          $RP$1$i$i = $782;
         }
        } else {
         $R$1$i$i = $784;
         $RP$1$i$i = $783;
        }
        while (1) {
         $788 = $R$1$i$i + 20 | 0;
         $789 = HEAP32[$788 >> 2] | 0;
         if ($789 | 0) {
          $R$1$i$i = $789;
          $RP$1$i$i = $788;
          continue;
         }
         $791 = $R$1$i$i + 16 | 0;
         $792 = HEAP32[$791 >> 2] | 0;
         if (!$792) {
          $R$1$i$i$lcssa = $R$1$i$i;
          $RP$1$i$i$lcssa = $RP$1$i$i;
          break;
         } else {
          $R$1$i$i = $792;
          $RP$1$i$i = $791;
         }
        }
        if ($RP$1$i$i$lcssa >>> 0 < $753 >>> 0) _abort(); else {
         HEAP32[$RP$1$i$i$lcssa >> 2] = 0;
         $R$3$i$i = $R$1$i$i$lcssa;
         break;
        }
       } else {
        $774 = HEAP32[$718 + 8 >> 2] | 0;
        if ($774 >>> 0 < $753 >>> 0) _abort();
        $776 = $774 + 12 | 0;
        if ((HEAP32[$776 >> 2] | 0) != ($718 | 0)) _abort();
        $779 = $771 + 8 | 0;
        if ((HEAP32[$779 >> 2] | 0) == ($718 | 0)) {
         HEAP32[$776 >> 2] = $771;
         HEAP32[$779 >> 2] = $774;
         $R$3$i$i = $771;
         break;
        } else _abort();
       } while (0);
       if (!$769) break;
       $797 = HEAP32[$718 + 28 >> 2] | 0;
       $798 = 23380 + ($797 << 2) | 0;
       do if (($718 | 0) == (HEAP32[$798 >> 2] | 0)) {
        HEAP32[$798 >> 2] = $R$3$i$i;
        if ($R$3$i$i | 0) break;
        HEAP32[5770] = HEAP32[5770] & ~(1 << $797);
        break L328;
       } else {
        if ($769 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
        $807 = $769 + 16 | 0;
        if ((HEAP32[$807 >> 2] | 0) == ($718 | 0)) HEAP32[$807 >> 2] = $R$3$i$i; else HEAP32[$769 + 20 >> 2] = $R$3$i$i;
        if (!$R$3$i$i) break L328;
       } while (0);
       $812 = HEAP32[5773] | 0;
       if ($R$3$i$i >>> 0 < $812 >>> 0) _abort();
       HEAP32[$R$3$i$i + 24 >> 2] = $769;
       $815 = $718 + 16 | 0;
       $816 = HEAP32[$815 >> 2] | 0;
       do if ($816 | 0) if ($816 >>> 0 < $812 >>> 0) _abort(); else {
        HEAP32[$R$3$i$i + 16 >> 2] = $816;
        HEAP32[$816 + 24 >> 2] = $R$3$i$i;
        break;
       } while (0);
       $822 = HEAP32[$815 + 4 >> 2] | 0;
       if (!$822) break;
       if ($822 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
        HEAP32[$R$3$i$i + 20 >> 2] = $822;
        HEAP32[$822 + 24 >> 2] = $R$3$i$i;
        break;
       }
      } while (0);
      $oldfirst$0$i$i = $718 + $742 | 0;
      $qsize$0$i$i = $742 + $723 | 0;
     } else {
      $oldfirst$0$i$i = $718;
      $qsize$0$i$i = $723;
     }
     $830 = $oldfirst$0$i$i + 4 | 0;
     HEAP32[$830 >> 2] = HEAP32[$830 >> 2] & -2;
     HEAP32[$722 + 4 >> 2] = $qsize$0$i$i | 1;
     HEAP32[$722 + $qsize$0$i$i >> 2] = $qsize$0$i$i;
     $836 = $qsize$0$i$i >>> 3;
     if ($qsize$0$i$i >>> 0 < 256) {
      $839 = 23116 + ($836 << 1 << 2) | 0;
      $840 = HEAP32[5769] | 0;
      $841 = 1 << $836;
      do if (!($840 & $841)) {
       HEAP32[5769] = $840 | $841;
       $$pre$phi$i17$iZ2D = $839 + 8 | 0;
       $F4$0$i$i = $839;
      } else {
       $845 = $839 + 8 | 0;
       $846 = HEAP32[$845 >> 2] | 0;
       if ($846 >>> 0 >= (HEAP32[5773] | 0) >>> 0) {
        $$pre$phi$i17$iZ2D = $845;
        $F4$0$i$i = $846;
        break;
       }
       _abort();
      } while (0);
      HEAP32[$$pre$phi$i17$iZ2D >> 2] = $722;
      HEAP32[$F4$0$i$i + 12 >> 2] = $722;
      HEAP32[$722 + 8 >> 2] = $F4$0$i$i;
      HEAP32[$722 + 12 >> 2] = $839;
      break;
     }
     $852 = $qsize$0$i$i >>> 8;
     do if (!$852) $I7$0$i$i = 0; else {
      if ($qsize$0$i$i >>> 0 > 16777215) {
       $I7$0$i$i = 31;
       break;
      }
      $857 = ($852 + 1048320 | 0) >>> 16 & 8;
      $858 = $852 << $857;
      $861 = ($858 + 520192 | 0) >>> 16 & 4;
      $863 = $858 << $861;
      $866 = ($863 + 245760 | 0) >>> 16 & 2;
      $871 = 14 - ($861 | $857 | $866) + ($863 << $866 >>> 15) | 0;
      $I7$0$i$i = $qsize$0$i$i >>> ($871 + 7 | 0) & 1 | $871 << 1;
     } while (0);
     $877 = 23380 + ($I7$0$i$i << 2) | 0;
     HEAP32[$722 + 28 >> 2] = $I7$0$i$i;
     $879 = $722 + 16 | 0;
     HEAP32[$879 + 4 >> 2] = 0;
     HEAP32[$879 >> 2] = 0;
     $881 = HEAP32[5770] | 0;
     $882 = 1 << $I7$0$i$i;
     if (!($881 & $882)) {
      HEAP32[5770] = $881 | $882;
      HEAP32[$877 >> 2] = $722;
      HEAP32[$722 + 24 >> 2] = $877;
      HEAP32[$722 + 12 >> 2] = $722;
      HEAP32[$722 + 8 >> 2] = $722;
      break;
     }
     $K8$0$i$i = $qsize$0$i$i << (($I7$0$i$i | 0) == 31 ? 0 : 25 - ($I7$0$i$i >>> 1) | 0);
     $T$0$i18$i = HEAP32[$877 >> 2] | 0;
     while (1) {
      if ((HEAP32[$T$0$i18$i + 4 >> 2] & -8 | 0) == ($qsize$0$i$i | 0)) {
       $T$0$i18$i$lcssa = $T$0$i18$i;
       label = 279;
       break;
      }
      $900 = $T$0$i18$i + 16 + ($K8$0$i$i >>> 31 << 2) | 0;
      $902 = HEAP32[$900 >> 2] | 0;
      if (!$902) {
       $$lcssa = $900;
       $T$0$i18$i$lcssa139 = $T$0$i18$i;
       label = 276;
       break;
      } else {
       $K8$0$i$i = $K8$0$i$i << 1;
       $T$0$i18$i = $902;
      }
     }
     if ((label | 0) == 276) if ($$lcssa >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
      HEAP32[$$lcssa >> 2] = $722;
      HEAP32[$722 + 24 >> 2] = $T$0$i18$i$lcssa139;
      HEAP32[$722 + 12 >> 2] = $722;
      HEAP32[$722 + 8 >> 2] = $722;
      break;
     } else if ((label | 0) == 279) {
      $909 = $T$0$i18$i$lcssa + 8 | 0;
      $910 = HEAP32[$909 >> 2] | 0;
      $911 = HEAP32[5773] | 0;
      if ($910 >>> 0 >= $911 >>> 0 & $T$0$i18$i$lcssa >>> 0 >= $911 >>> 0) {
       HEAP32[$910 + 12 >> 2] = $722;
       HEAP32[$909 >> 2] = $722;
       HEAP32[$722 + 8 >> 2] = $910;
       HEAP32[$722 + 12 >> 2] = $T$0$i18$i$lcssa;
       HEAP32[$722 + 24 >> 2] = 0;
       break;
      } else _abort();
     }
    } while (0);
    $$0 = $710 + 8 | 0;
    STACKTOP = sp;
    return $$0 | 0;
   } else $sp$0$i$i$i = 23524;
   while (1) {
    $918 = HEAP32[$sp$0$i$i$i >> 2] | 0;
    if ($918 >>> 0 <= $631 >>> 0) {
     $922 = $918 + (HEAP32[$sp$0$i$i$i + 4 >> 2] | 0) | 0;
     if ($922 >>> 0 > $631 >>> 0) {
      $$lcssa142 = $922;
      break;
     }
    }
    $sp$0$i$i$i = HEAP32[$sp$0$i$i$i + 8 >> 2] | 0;
   }
   $926 = $$lcssa142 + -47 | 0;
   $928 = $926 + 8 | 0;
   $934 = $926 + (($928 & 7 | 0) == 0 ? 0 : 0 - $928 & 7) | 0;
   $935 = $631 + 16 | 0;
   $937 = $934 >>> 0 < $935 >>> 0 ? $631 : $934;
   $938 = $937 + 8 | 0;
   $942 = $tbase$746$i + 8 | 0;
   $947 = ($942 & 7 | 0) == 0 ? 0 : 0 - $942 & 7;
   $948 = $tbase$746$i + $947 | 0;
   $949 = $tsize$745$i + -40 - $947 | 0;
   HEAP32[5775] = $948;
   HEAP32[5772] = $949;
   HEAP32[$948 + 4 >> 2] = $949 | 1;
   HEAP32[$948 + $949 + 4 >> 2] = 40;
   HEAP32[5776] = HEAP32[5891];
   $955 = $937 + 4 | 0;
   HEAP32[$955 >> 2] = 27;
   HEAP32[$938 >> 2] = HEAP32[5881];
   HEAP32[$938 + 4 >> 2] = HEAP32[5882];
   HEAP32[$938 + 8 >> 2] = HEAP32[5883];
   HEAP32[$938 + 12 >> 2] = HEAP32[5884];
   HEAP32[5881] = $tbase$746$i;
   HEAP32[5882] = $tsize$745$i;
   HEAP32[5884] = 0;
   HEAP32[5883] = $938;
   $p$0$i$i = $937 + 24 | 0;
   while (1) {
    $956 = $p$0$i$i + 4 | 0;
    HEAP32[$956 >> 2] = 7;
    if (($956 + 4 | 0) >>> 0 < $$lcssa142 >>> 0) $p$0$i$i = $956; else break;
   }
   if (($937 | 0) != ($631 | 0)) {
    $962 = $937 - $631 | 0;
    HEAP32[$955 >> 2] = HEAP32[$955 >> 2] & -2;
    HEAP32[$631 + 4 >> 2] = $962 | 1;
    HEAP32[$937 >> 2] = $962;
    $967 = $962 >>> 3;
    if ($962 >>> 0 < 256) {
     $970 = 23116 + ($967 << 1 << 2) | 0;
     $971 = HEAP32[5769] | 0;
     $972 = 1 << $967;
     if (!($971 & $972)) {
      HEAP32[5769] = $971 | $972;
      $$pre$phi$i$iZ2D = $970 + 8 | 0;
      $F$0$i$i = $970;
     } else {
      $976 = $970 + 8 | 0;
      $977 = HEAP32[$976 >> 2] | 0;
      if ($977 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
       $$pre$phi$i$iZ2D = $976;
       $F$0$i$i = $977;
      }
     }
     HEAP32[$$pre$phi$i$iZ2D >> 2] = $631;
     HEAP32[$F$0$i$i + 12 >> 2] = $631;
     HEAP32[$631 + 8 >> 2] = $F$0$i$i;
     HEAP32[$631 + 12 >> 2] = $970;
     break;
    }
    $983 = $962 >>> 8;
    if (!$983) $I1$0$i$i = 0; else if ($962 >>> 0 > 16777215) $I1$0$i$i = 31; else {
     $988 = ($983 + 1048320 | 0) >>> 16 & 8;
     $989 = $983 << $988;
     $992 = ($989 + 520192 | 0) >>> 16 & 4;
     $994 = $989 << $992;
     $997 = ($994 + 245760 | 0) >>> 16 & 2;
     $1002 = 14 - ($992 | $988 | $997) + ($994 << $997 >>> 15) | 0;
     $I1$0$i$i = $962 >>> ($1002 + 7 | 0) & 1 | $1002 << 1;
    }
    $1008 = 23380 + ($I1$0$i$i << 2) | 0;
    HEAP32[$631 + 28 >> 2] = $I1$0$i$i;
    HEAP32[$631 + 20 >> 2] = 0;
    HEAP32[$935 >> 2] = 0;
    $1011 = HEAP32[5770] | 0;
    $1012 = 1 << $I1$0$i$i;
    if (!($1011 & $1012)) {
     HEAP32[5770] = $1011 | $1012;
     HEAP32[$1008 >> 2] = $631;
     HEAP32[$631 + 24 >> 2] = $1008;
     HEAP32[$631 + 12 >> 2] = $631;
     HEAP32[$631 + 8 >> 2] = $631;
     break;
    }
    $K2$0$i$i = $962 << (($I1$0$i$i | 0) == 31 ? 0 : 25 - ($I1$0$i$i >>> 1) | 0);
    $T$0$i$i = HEAP32[$1008 >> 2] | 0;
    while (1) {
     if ((HEAP32[$T$0$i$i + 4 >> 2] & -8 | 0) == ($962 | 0)) {
      $T$0$i$i$lcssa = $T$0$i$i;
      label = 305;
      break;
     }
     $1030 = $T$0$i$i + 16 + ($K2$0$i$i >>> 31 << 2) | 0;
     $1032 = HEAP32[$1030 >> 2] | 0;
     if (!$1032) {
      $$lcssa141 = $1030;
      $T$0$i$i$lcssa140 = $T$0$i$i;
      label = 302;
      break;
     } else {
      $K2$0$i$i = $K2$0$i$i << 1;
      $T$0$i$i = $1032;
     }
    }
    if ((label | 0) == 302) if ($$lcssa141 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
     HEAP32[$$lcssa141 >> 2] = $631;
     HEAP32[$631 + 24 >> 2] = $T$0$i$i$lcssa140;
     HEAP32[$631 + 12 >> 2] = $631;
     HEAP32[$631 + 8 >> 2] = $631;
     break;
    } else if ((label | 0) == 305) {
     $1039 = $T$0$i$i$lcssa + 8 | 0;
     $1040 = HEAP32[$1039 >> 2] | 0;
     $1041 = HEAP32[5773] | 0;
     if ($1040 >>> 0 >= $1041 >>> 0 & $T$0$i$i$lcssa >>> 0 >= $1041 >>> 0) {
      HEAP32[$1040 + 12 >> 2] = $631;
      HEAP32[$1039 >> 2] = $631;
      HEAP32[$631 + 8 >> 2] = $1040;
      HEAP32[$631 + 12 >> 2] = $T$0$i$i$lcssa;
      HEAP32[$631 + 24 >> 2] = 0;
      break;
     } else _abort();
    }
   }
  } while (0);
  $1049 = HEAP32[5772] | 0;
  if ($1049 >>> 0 > $nb$0 >>> 0) {
   $1051 = $1049 - $nb$0 | 0;
   HEAP32[5772] = $1051;
   $1052 = HEAP32[5775] | 0;
   $1053 = $1052 + $nb$0 | 0;
   HEAP32[5775] = $1053;
   HEAP32[$1053 + 4 >> 2] = $1051 | 1;
   HEAP32[$1052 + 4 >> 2] = $nb$0 | 3;
   $$0 = $1052 + 8 | 0;
   STACKTOP = sp;
   return $$0 | 0;
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12;
 $$0 = 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _zscanfndef($fnhashloc) {
 $fnhashloc = $fnhashloc | 0;
 var $$0$i = 0, $$1$i = 0, $$lcssa = 0, $$lcssa$i = 0, $$lcssa$i$i = 0, $$lcssa$i$i47 = 0, $$lcssa218 = 0, $$lcssa219 = 0, $$lcssa229 = 0, $$lcssa231 = 0, $$lcssa233 = 0, $$lcssa235 = 0, $$lcssa243 = 0, $$lcssa245 = 0, $$lcssa247 = 0, $$lcssa249 = 0, $0 = 0, $1 = 0, $10 = 0, $104 = 0, $108 = 0, $109 = 0, $114 = 0, $117 = 0, $119 = 0, $12 = 0, $120 = 0, $123 = 0, $125 = 0, $127 = 0, $128 = 0, $13 = 0, $130 = 0, $132 = 0, $133 = 0, $137 = 0, $140 = 0, $141 = 0, $145 = 0, $148 = 0, $149 = 0, $15 = 0, $157 = 0, $161 = 0, $162 = 0, $167 = 0, $169 = 0, $171 = 0, $175 = 0, $177 = 0, $179 = 0, $180 = 0, $182 = 0, $183 = 0, $184 = 0, $191 = 0, $192 = 0, $193 = 0, $195 = 0, $198 = 0, $20 = 0, $204 = 0, $207 = 0, $208 = 0, $209 = 0, $210 = 0, $211 = 0, $213 = 0, $217 = 0, $219 = 0, $22 = 0, $229 = 0, $235 = 0, $241 = 0, $242 = 0, $246 = 0, $250 = 0, $251 = 0, $257 = 0, $258 = 0, $268 = 0, $270 = 0, $274 = 0, $275 = 0, $277 = 0, $278 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $285 = 0, $286 = 0, $289 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $3 = 0, $304 = 0, $305 = 0, $309 = 0, $312 = 0, $313 = 0, $321 = 0, $323 = 0, $327 = 0, $329 = 0, $331 = 0, $332 = 0, $334 = 0, $335 = 0, $336 = 0, $343 = 0, $344 = 0, $345 = 0, $347 = 0, $350 = 0, $356 = 0, $359 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $365 = 0, $369 = 0, $37 = 0, $371 = 0, $38 = 0, $381 = 0, $387 = 0, $39 = 0, $393 = 0, $394 = 0, $399 = 0, $4 = 0, $401 = 0, $402 = 0, $407 = 0, $408 = 0, $41 = 0, $410 = 0, $411 = 0, $413 = 0, $418 = 0, $420 = 0, $434 = 0, $439 = 0, $44 = 0, $440 = 0, $442 = 0, $444 = 0, $446 = 0, $453 = 0, $454 = 0, $46 = 0, $460 = 0, $464 = 0, $465 = 0, $467 = 0, $470 = 0, $471 = 0, $48 = 0, $53 = 0, $55 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $63 = 0, $70 = 0, $71 = 0, $72 = 0, $75 = 0, $84 = 0, $87 = 0, $88 = 0, $9 = 0, $92 = 0, $95 = 0, $96 = 0, $copyptr$077 = 0, $h$0$lcssa$i = 0, $h$0$lcssa$i33 = 0, $h$06$i = 0, $h$06$i31 = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $h$1$i32 = 0, $h$1$i32$lcssa = 0, $i$0$i = 0, $i$0$i26 = 0, $i$01$i$i = 0, $i$01$i$i39 = 0, $intptr$0$i = 0, $intptr$1$i = 0, $intptr$1$i$lcssa = 0, $j$02$i$i = 0, $j$02$i$i38 = 0, $k$07$i = 0, $k$07$i30 = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa220 = 0, $p$0$i35 = 0, $p$0$i35$lcssa = 0, $p$0$i35$lcssa225 = 0, $signlength$0$i = 0, $singlefnspace$081 = 0, $singlefnspace$1 = 0, $singlefnspace$2 = 0, $singlefnspace$3 = 0, $singlefnspace$4 = 0, $singlefnspace$5 = 0, $singlefnspace$6 = 0, $singlefnspace$7 = 0, $singlefnspace$8 = 0, $singlefnspace$8$lcssa = 0, $singleptr$0$lcssa114 = 0, $singleptr$082 = 0, $singleptr$1 = 0, $singleptr$1$lcssa = 0, $singlfunction$084 = 0, $singlfunction$1 = 0, $singlfunction$10 = 0, $singlfunction$2 = 0, $singlfunction$3 = 0, $singlfunction$4 = 0, $singlfunction$5 = 0, $singlfunction$6 = 0, $singlfunction$7 = 0, $singlfunction$8 = 0, $singlfunction$8$lcssa = 0, $singlfunction$8$lcssa239 = 0, $singlfunction$9 = 0, $vararg_buffer = 0, $vararg_buffer14 = 0, $vararg_buffer19 = 0, $vararg_buffer24 = 0, $vararg_buffer29 = 0, $vararg_buffer3 = 0, $vararg_buffer34 = 0, $vararg_buffer40 = 0, $vararg_buffer46 = 0, $vararg_buffer52 = 0, $vararg_buffer55 = 0, $vararg_buffer58 = 0, $vararg_buffer61 = 0, $vararg_buffer64 = 0, $vararg_buffer70 = 0, $vararg_buffer76 = 0, $vararg_buffer8 = 0, $vararg_buffer82 = 0, $vararg_buffer88 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 272 | 0;
 $vararg_buffer88 = sp + 256 | 0;
 $vararg_buffer82 = sp + 240 | 0;
 $vararg_buffer76 = sp + 224 | 0;
 $vararg_buffer70 = sp + 208 | 0;
 $vararg_buffer64 = sp + 192 | 0;
 $vararg_buffer61 = sp + 184 | 0;
 $vararg_buffer58 = sp + 176 | 0;
 $vararg_buffer55 = sp + 168 | 0;
 $vararg_buffer52 = sp + 160 | 0;
 $vararg_buffer46 = sp + 144 | 0;
 $vararg_buffer40 = sp + 128 | 0;
 $vararg_buffer34 = sp + 112 | 0;
 $vararg_buffer29 = sp + 96 | 0;
 $vararg_buffer24 = sp + 80 | 0;
 $vararg_buffer19 = sp + 64 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = _xmalloc(204) | 0;
 $3 = HEAP32[4045] | 0;
 while (1) {
  $1 = HEAP32[3993] | 0;
  $4 = HEAP8[$1 + $3 >> 0] | 0;
  $9 = HEAP32[3999] | 0;
  $10 = ($3 | 0) < ($9 | 0);
  if ((HEAP8[25877 + ($4 & 255) >> 0] | 0) == 1 & $10) {
   $13 = $3;
   while (1) {
    $12 = $13 + 1 | 0;
    HEAP32[4045] = $12;
    $15 = HEAP8[$1 + $12 >> 0] | 0;
    $20 = ($12 | 0) < ($9 | 0);
    if ($20 & (HEAP8[25877 + ($15 & 255) >> 0] | 0) == 1) $13 = $12; else {
     $$lcssa$i$i = $20;
     $22 = $15;
     $470 = $12;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $10;
   $22 = $4;
   $470 = $3;
  }
  if (!($22 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa243 = $1;
   $$lcssa245 = $9;
   $$lcssa247 = $470;
   $$lcssa249 = $22;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 9;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $3 = 0;
 }
 if ((label | 0) == 9) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  $singlfunction$10 = $0;
  _free($singlfunction$10);
  STACKTOP = sp;
  return;
 }
 do if ($$lcssa249 << 24 >> 24 == 125) {
  HEAP32[$0 >> 2] = HEAP32[4313];
  $singleptr$0$lcssa114 = 0;
  $singlfunction$9 = $0;
 } else {
  $37 = $$lcssa249;
  $39 = $$lcssa247;
  $41 = $$lcssa243;
  $53 = $$lcssa245;
  $singlefnspace$081 = 50;
  $singleptr$082 = 0;
  $singlfunction$084 = $0;
  L15 : while (1) {
   L17 : do switch ($37 & 255 | 0) {
   case 35:
    {
     $38 = $39 + 1 | 0;
     HEAP32[4045] = $38;
     HEAP32[4044] = $38;
     if ((HEAP8[$41 + $38 >> 0] | 0) == 45) {
      $44 = $39 + 2 | 0;
      HEAP32[4045] = $44;
      $46 = $44;
      $signlength$0$i = 1;
     } else {
      $46 = $38;
      $signlength$0$i = 0;
     }
     HEAP32[4308] = 0;
     $48 = HEAPU8[$41 + $46 >> 0] | 0;
     if ((HEAP8[25877 + $48 >> 0] | 0) == 3 & ($46 | 0) < ($53 | 0)) {
      $55 = 0;
      $57 = $48;
      $60 = $46;
      while (1) {
       $58 = $57 + -48 + ($55 * 10 | 0) | 0;
       HEAP32[4308] = $58;
       $59 = $60 + 1 | 0;
       HEAP32[4045] = $59;
       $63 = HEAPU8[$41 + $59 >> 0] | 0;
       if (($59 | 0) < ($53 | 0) & (HEAP8[25877 + $63 >> 0] | 0) == 3) {
        $55 = $58;
        $57 = $63;
        $60 = $59;
       } else {
        $70 = $58;
        $72 = $59;
        break;
       }
      }
     } else {
      $70 = 0;
      $72 = $46;
     }
     if (($signlength$0$i | 0) == 1) HEAP32[4308] = 0 - $70;
     $71 = $72 - $38 | 0;
     if (($71 | 0) == ($signlength$0$i | 0)) {
      _fwrite(3059, 34, 1, HEAP32[3989] | 0) | 0;
      _fwrite(3059, 34, 1, HEAP32[3990] | 0) | 0;
      _skiptokenprint();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     }
     $75 = _zstrlookup($41, $38, $71, 1, 1) | 0;
     HEAP32[4309] = $75;
     if (!(HEAP32[4241] | 0)) {
      HEAP8[(HEAP32[4144] | 0) + $75 >> 0] = 2;
      HEAP32[(HEAP32[4249] | 0) + (HEAP32[4309] << 2) >> 2] = HEAP32[4308];
     }
     $84 = HEAP32[4045] | 0;
     $87 = HEAP8[(HEAP32[3993] | 0) + $84 >> 0] | 0;
     $88 = $87 & 255;
     L77 : do if (!((HEAP8[25877 + $88 >> 0] | 0) == 1 | ($84 | 0) >= (HEAP32[3999] | 0))) {
      switch ($87 << 24 >> 24) {
      case 37:
      case 125:
       {
        break L77;
        break;
       }
      default:
       {}
      }
      $92 = HEAP32[3989] | 0;
      $95 = HEAPU8[26133 + $88 >> 0] | 0;
      HEAP32[$vararg_buffer >> 2] = 34;
      HEAP32[$vararg_buffer + 4 >> 2] = $95;
      HEAP32[$vararg_buffer + 8 >> 2] = 3025;
      _fprintf($92, 1750, $vararg_buffer) | 0;
      $96 = HEAP32[3990] | 0;
      $104 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
      HEAP32[$vararg_buffer3 >> 2] = 34;
      HEAP32[$vararg_buffer3 + 4 >> 2] = $104;
      HEAP32[$vararg_buffer3 + 8 >> 2] = 3025;
      _fprintf($96, 1750, $vararg_buffer3) | 0;
      _skiptokenprint();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     } while (0);
     HEAP32[$singlfunction$084 + ($singleptr$082 << 2) >> 2] = HEAP32[4309];
     if (($singleptr$082 | 0) == ($singlefnspace$081 | 0)) {
      $108 = HEAP32[3989] | 0;
      $109 = $singleptr$082 + 50 | 0;
      HEAP32[$vararg_buffer8 >> 2] = 3094;
      HEAP32[$vararg_buffer8 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer8 + 8 >> 2] = $109;
      HEAP32[$vararg_buffer8 + 12 >> 2] = $singleptr$082;
      _fprintf($108, 1023, $vararg_buffer8) | 0;
      $singlefnspace$1 = $109;
      $singlfunction$1 = _xrealloc($singlfunction$084, ($singleptr$082 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$1 = $singlefnspace$081;
      $singlfunction$1 = $singlfunction$084;
     }
     $singlefnspace$8 = $singlefnspace$1;
     $singleptr$1 = $singleptr$082 + 1 | 0;
     $singlfunction$8 = $singlfunction$1;
     break;
    }
   case 34:
    {
     $114 = $39 + 1 | 0;
     HEAP32[4045] = $114;
     HEAP32[4044] = $114;
     $117 = ($114 | 0) < ($53 | 0);
     if ((HEAP8[$41 + $114 >> 0] | 0) != 34 & $117) {
      $120 = $114;
      while (1) {
       $119 = $120 + 1 | 0;
       HEAP32[4045] = $119;
       $123 = ($119 | 0) < ($53 | 0);
       if ($123 & (HEAP8[$41 + $119 >> 0] | 0) != 34) $120 = $119; else {
        $$lcssa$i = $123;
        $132 = $119;
        break;
       }
      }
     } else {
      $$lcssa$i = $117;
      $132 = $114;
     }
     if (!$$lcssa$i) {
      $125 = HEAP32[3989] | 0;
      $127 = HEAPU8[26167] | 0;
      HEAP32[$vararg_buffer14 >> 2] = 3116;
      HEAP32[$vararg_buffer14 + 4 >> 2] = $127;
      HEAP32[$vararg_buffer14 + 8 >> 2] = 3121;
      _fprintf($125, 3109, $vararg_buffer14) | 0;
      $128 = HEAP32[3990] | 0;
      $130 = HEAPU8[26167] | 0;
      HEAP32[$vararg_buffer19 >> 2] = 3116;
      HEAP32[$vararg_buffer19 + 4 >> 2] = $130;
      HEAP32[$vararg_buffer19 + 8 >> 2] = 3121;
      _fprintf($128, 3109, $vararg_buffer19) | 0;
      _skiptokenprint();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     }
     $133 = _zstrlookup($41, $114, $132 - $114 | 0, 0, 1) | 0;
     HEAP32[4309] = $133;
     HEAP8[(HEAP32[4144] | 0) + $133 >> 0] = 3;
     $137 = (HEAP32[4045] | 0) + 1 | 0;
     HEAP32[4045] = $137;
     $140 = HEAP8[(HEAP32[3993] | 0) + $137 >> 0] | 0;
     $141 = $140 & 255;
     L92 : do if (!((HEAP8[25877 + $141 >> 0] | 0) == 1 | ($137 | 0) >= (HEAP32[3999] | 0))) {
      switch ($140 << 24 >> 24) {
      case 37:
      case 125:
       {
        break L92;
        break;
       }
      default:
       {}
      }
      $145 = HEAP32[3989] | 0;
      $148 = HEAPU8[26133 + $141 >> 0] | 0;
      HEAP32[$vararg_buffer24 >> 2] = 34;
      HEAP32[$vararg_buffer24 + 4 >> 2] = $148;
      HEAP32[$vararg_buffer24 + 8 >> 2] = 3025;
      _fprintf($145, 1750, $vararg_buffer24) | 0;
      $149 = HEAP32[3990] | 0;
      $157 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
      HEAP32[$vararg_buffer29 >> 2] = 34;
      HEAP32[$vararg_buffer29 + 4 >> 2] = $157;
      HEAP32[$vararg_buffer29 + 8 >> 2] = 3025;
      _fprintf($149, 1750, $vararg_buffer29) | 0;
      _skiptokenprint();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     } while (0);
     HEAP32[$singlfunction$084 + ($singleptr$082 << 2) >> 2] = HEAP32[4309];
     if (($singleptr$082 | 0) == ($singlefnspace$081 | 0)) {
      $161 = HEAP32[3989] | 0;
      $162 = $singleptr$082 + 50 | 0;
      HEAP32[$vararg_buffer34 >> 2] = 3094;
      HEAP32[$vararg_buffer34 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer34 + 8 >> 2] = $162;
      HEAP32[$vararg_buffer34 + 12 >> 2] = $singleptr$082;
      _fprintf($161, 1023, $vararg_buffer34) | 0;
      $singlefnspace$2 = $162;
      $singlfunction$2 = _xrealloc($singlfunction$084, ($singleptr$082 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$2 = $singlefnspace$081;
      $singlfunction$2 = $singlfunction$084;
     }
     $singlefnspace$8 = $singlefnspace$2;
     $singleptr$1 = $singleptr$082 + 1 | 0;
     $singlfunction$8 = $singlfunction$2;
     break;
    }
   case 39:
    {
     $167 = $39 + 1 | 0;
     HEAP32[4045] = $167;
     HEAP32[4044] = $167;
     $169 = HEAP8[$41 + $167 >> 0] | 0;
     switch ($169 << 24 >> 24) {
     case 37:
     case 125:
      {
       $192 = $167;
       $193 = $167;
       $198 = $41;
       break;
      }
     default:
      {
       $171 = $169;
       $175 = $167;
       L101 : while (1) {
        if (!(($175 | 0) < ($53 | 0) ? (HEAP8[25877 + ($171 & 255) >> 0] | 0) != 1 : 0)) {
         $180 = $175;
         break;
        }
        $177 = $175 + 1 | 0;
        HEAP32[4045] = $177;
        $179 = HEAP8[$41 + $177 >> 0] | 0;
        switch ($179 << 24 >> 24) {
        case 37:
        case 125:
         {
          $180 = $177;
          break L101;
          break;
         }
        default:
         {
          $171 = $179;
          $175 = $177;
         }
        }
       }
       if (($180 | 0) > ($167 | 0)) {
        $182 = $180 + -1 | 0;
        $i$0$i = $167;
        while (1) {
         $183 = $41 + $i$0$i | 0;
         $184 = HEAP8[$183 >> 0] | 0;
         if (($184 + -65 & 255) < 26) HEAP8[$183 >> 0] = ($184 & 255) + 32;
         if (($i$0$i | 0) < ($182 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
        }
        $192 = HEAP32[4044] | 0;
        $193 = HEAP32[4045] | 0;
        $198 = HEAP32[3993] | 0;
       } else {
        $192 = $167;
        $193 = $180;
        $198 = $41;
       }
      }
     }
     $191 = $193 - $192 | 0;
     if (($191 | 0) > 0) {
      $195 = HEAP32[4240] | 0;
      $h$06$i = 0;
      $k$07$i = $192;
      while (1) {
       $h$1$i = (HEAPU8[$198 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
       while (1) if (($h$1$i | 0) < ($195 | 0)) {
        $h$1$i$lcssa = $h$1$i;
        break;
       } else $h$1$i = $h$1$i - $195 | 0;
       $204 = $k$07$i + 1 | 0;
       if (($204 | 0) < ($193 | 0)) {
        $h$06$i = $h$1$i$lcssa;
        $k$07$i = $204;
       } else {
        $h$0$lcssa$i = $h$1$i$lcssa;
        break;
       }
      }
     } else $h$0$lcssa$i = 0;
     HEAP32[4241] = 0;
     $207 = HEAP32[4145] | 0;
     $208 = HEAP32[4041] | 0;
     $209 = HEAP32[4042] | 0;
     $210 = HEAP32[4242] | 0;
     $211 = HEAP32[4243] | 0;
     $p$0$i = $h$0$lcssa$i + 1 | 0;
     L121 : while (1) {
      $213 = HEAP32[$207 + ($p$0$i << 2) >> 2] | 0;
      L123 : do if (($213 | 0) > 0) {
       $217 = HEAP32[$208 + ($213 + 1 << 2) >> 2] | 0;
       $219 = HEAP32[$208 + ($213 << 2) >> 2] | 0;
       if (($217 - $219 | 0) == ($191 | 0)) {
        if (($217 | 0) > ($219 | 0)) {
         $i$01$i$i = $192;
         $j$02$i$i = $219;
         while (1) {
          if ((HEAP8[$209 + $j$02$i$i >> 0] | 0) != (HEAP8[$198 + $i$01$i$i >> 0] | 0)) break L123;
          $229 = $j$02$i$i + 1 | 0;
          if (($229 | 0) < ($217 | 0)) {
           $i$01$i$i = $i$01$i$i + 1 | 0;
           $j$02$i$i = $229;
          } else break;
         }
        }
        if ((HEAP8[$210 + $p$0$i >> 0] | 0) == 11) {
         $p$0$i$lcssa = $p$0$i;
         break L121;
        }
       }
      } while (0);
      $235 = HEAP32[$211 + ($p$0$i << 2) >> 2] | 0;
      if (!$235) {
       $p$0$i$lcssa220 = $p$0$i;
       label = 60;
       break;
      } else $p$0$i = $235;
     }
     if ((label | 0) == 60) {
      label = 0;
      HEAP32[4310] = $p$0$i$lcssa220;
      _skptokenunknownfunctionprint();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     }
     HEAP32[4241] = 1;
     HEAP32[4310] = $p$0$i$lcssa;
     if (($p$0$i$lcssa | 0) == (HEAP32[4311] | 0)) {
      _printrecursionillegal();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     }
     HEAP32[$singlfunction$084 + ($singleptr$082 << 2) >> 2] = 0;
     if (($singleptr$082 | 0) == ($singlefnspace$081 | 0)) {
      $241 = HEAP32[3989] | 0;
      $242 = $singleptr$082 + 50 | 0;
      HEAP32[$vararg_buffer40 >> 2] = 3094;
      HEAP32[$vararg_buffer40 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer40 + 8 >> 2] = $242;
      HEAP32[$vararg_buffer40 + 12 >> 2] = $singleptr$082;
      _fprintf($241, 1023, $vararg_buffer40) | 0;
      $singlefnspace$3 = $242;
      $singlfunction$3 = _xrealloc($singlfunction$084, ($singleptr$082 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$3 = $singlefnspace$081;
      $singlfunction$3 = $singlfunction$084;
     }
     $246 = $singleptr$082 + 1 | 0;
     HEAP32[$singlfunction$3 + ($246 << 2) >> 2] = HEAP32[4310];
     if (($246 | 0) == ($singlefnspace$3 | 0)) {
      $250 = HEAP32[3989] | 0;
      $251 = $singleptr$082 + 51 | 0;
      HEAP32[$vararg_buffer46 >> 2] = 3094;
      HEAP32[$vararg_buffer46 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer46 + 8 >> 2] = $251;
      HEAP32[$vararg_buffer46 + 12 >> 2] = $246;
      _fprintf($250, 1023, $vararg_buffer46) | 0;
      $singlefnspace$4 = $251;
      $singlfunction$4 = _xrealloc($singlfunction$3, ($246 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$4 = $singlefnspace$3;
      $singlfunction$4 = $singlfunction$3;
     }
     $singlefnspace$8 = $singlefnspace$4;
     $singleptr$1 = $singleptr$082 + 2 | 0;
     $singlfunction$8 = $singlfunction$4;
     break;
    }
   case 123:
    {
     HEAP8[HEAP32[3995] >> 0] = 39;
     $257 = HEAP32[4312] | 0;
     $258 = HEAP32[3995] | 0;
     if (($257 | 0) < 0) {
      if ((HEAP32[3992] | 0) == 1) _bufferoverflow();
      HEAP8[$258 + 1 >> 0] = 45;
      $$0$i = 0 - $257 | 0;
      $intptr$0$i = 2;
     } else {
      $$0$i = $257;
      $intptr$0$i = 1;
     }
     $$1$i = $$0$i;
     $intptr$1$i = $intptr$0$i;
     while (1) {
      if (($intptr$1$i | 0) == (HEAP32[3992] | 0)) _bufferoverflow();
      $268 = (($$1$i | 0) % 10 | 0) + 48 & 255;
      HEAP8[$258 + $intptr$1$i >> 0] = $268;
      $270 = $intptr$1$i + 1 | 0;
      if (($$1$i + 9 | 0) >>> 0 > 18) {
       $$1$i = ($$1$i | 0) / 10 | 0;
       $intptr$1$i = $270;
      } else {
       $$lcssa218 = $268;
       $$lcssa219 = $270;
       $intptr$1$i$lcssa = $intptr$1$i;
       break;
      }
     }
     if (($intptr$0$i | 0) < ($intptr$1$i$lcssa | 0)) {
      $274 = $258 + $intptr$0$i | 0;
      $275 = HEAP8[$274 >> 0] | 0;
      HEAP8[$274 >> 0] = $$lcssa218;
      HEAP8[$258 + $intptr$1$i$lcssa >> 0] = $275;
      $277 = $intptr$1$i$lcssa + -1 | 0;
      $278 = $intptr$0$i + 1 | 0;
      if (($278 | 0) < ($277 | 0)) {
       $280 = $277;
       $282 = $278;
       while (1) {
        $281 = $258 + $282 | 0;
        $283 = HEAP8[$281 >> 0] | 0;
        HEAP8[$281 >> 0] = HEAP8[$258 + $280 >> 0] | 0;
        HEAP8[$258 + $280 >> 0] = $283;
        $285 = $280 + -1 | 0;
        $286 = $282 + 1 | 0;
        if (($286 | 0) < ($285 | 0)) {
         $280 = $285;
         $282 = $286;
        } else break;
       }
      }
     }
     $289 = _zstrlookup(HEAP32[3995] | 0, 0, $$lcssa219, 11, 1) | 0;
     if (HEAP32[4241] | 0) {
      label = 80;
      break L15;
     }
     HEAP32[4312] = (HEAP32[4312] | 0) + 1;
     HEAP8[(HEAP32[4144] | 0) + $289 >> 0] = 1;
     HEAP32[$singlfunction$084 + ($singleptr$082 << 2) >> 2] = 0;
     if (($singleptr$082 | 0) == ($singlefnspace$081 | 0)) {
      $304 = HEAP32[3989] | 0;
      $305 = $singleptr$082 + 50 | 0;
      HEAP32[$vararg_buffer64 >> 2] = 3094;
      HEAP32[$vararg_buffer64 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer64 + 8 >> 2] = $305;
      HEAP32[$vararg_buffer64 + 12 >> 2] = $singleptr$082;
      _fprintf($304, 1023, $vararg_buffer64) | 0;
      $singlefnspace$5 = $305;
      $singlfunction$5 = _xrealloc($singlfunction$084, ($singleptr$082 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$5 = $singlefnspace$081;
      $singlfunction$5 = $singlfunction$084;
     }
     $309 = $singleptr$082 + 1 | 0;
     HEAP32[$singlfunction$5 + ($309 << 2) >> 2] = $289;
     if (($309 | 0) == ($singlefnspace$5 | 0)) {
      $312 = HEAP32[3989] | 0;
      $313 = $singlefnspace$5 + 50 | 0;
      HEAP32[$vararg_buffer70 >> 2] = 3094;
      HEAP32[$vararg_buffer70 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer70 + 8 >> 2] = $313;
      HEAP32[$vararg_buffer70 + 12 >> 2] = $singlefnspace$5;
      _fprintf($312, 1023, $vararg_buffer70) | 0;
      $singlefnspace$6 = $313;
      $singlfunction$6 = _xrealloc($singlfunction$5, ($singlefnspace$5 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$6 = $singlefnspace$5;
      $singlfunction$6 = $singlfunction$5;
     }
     HEAP32[4045] = (HEAP32[4045] | 0) + 1;
     _zscanfndef($289);
     $singlefnspace$8 = $singlefnspace$6;
     $singleptr$1 = $singleptr$082 + 2 | 0;
     $singlfunction$8 = $singlfunction$6;
     break;
    }
   default:
    {
     HEAP32[4044] = $39;
     $321 = HEAP8[$41 + $39 >> 0] | 0;
     switch ($321 << 24 >> 24) {
     case 37:
     case 125:
      {
       $344 = $39;
       $345 = $39;
       $350 = $41;
       break;
      }
     default:
      {
       $323 = $321;
       $327 = $39;
       L20 : while (1) {
        if (!(($327 | 0) < ($53 | 0) ? (HEAP8[25877 + ($323 & 255) >> 0] | 0) != 1 : 0)) {
         $332 = $327;
         break;
        }
        $329 = $327 + 1 | 0;
        HEAP32[4045] = $329;
        $331 = HEAP8[$41 + $329 >> 0] | 0;
        switch ($331 << 24 >> 24) {
        case 37:
        case 125:
         {
          $332 = $329;
          break L20;
          break;
         }
        default:
         {
          $323 = $331;
          $327 = $329;
         }
        }
       }
       if (($332 | 0) > ($39 | 0)) {
        $334 = $332 + -1 | 0;
        $i$0$i26 = $39;
        while (1) {
         $335 = $41 + $i$0$i26 | 0;
         $336 = HEAP8[$335 >> 0] | 0;
         if (($336 + -65 & 255) < 26) HEAP8[$335 >> 0] = ($336 & 255) + 32;
         if (($i$0$i26 | 0) < ($334 | 0)) $i$0$i26 = $i$0$i26 + 1 | 0; else break;
        }
        $344 = HEAP32[4044] | 0;
        $345 = HEAP32[4045] | 0;
        $350 = HEAP32[3993] | 0;
       } else {
        $344 = $39;
        $345 = $332;
        $350 = $41;
       }
      }
     }
     $343 = $345 - $344 | 0;
     if (($343 | 0) > 0) {
      $347 = HEAP32[4240] | 0;
      $h$06$i31 = 0;
      $k$07$i30 = $344;
      while (1) {
       $h$1$i32 = (HEAPU8[$350 + $k$07$i30 >> 0] | 0) + ($h$06$i31 << 1) | 0;
       while (1) if (($h$1$i32 | 0) < ($347 | 0)) {
        $h$1$i32$lcssa = $h$1$i32;
        break;
       } else $h$1$i32 = $h$1$i32 - $347 | 0;
       $356 = $k$07$i30 + 1 | 0;
       if (($356 | 0) < ($345 | 0)) {
        $h$06$i31 = $h$1$i32$lcssa;
        $k$07$i30 = $356;
       } else {
        $h$0$lcssa$i33 = $h$1$i32$lcssa;
        break;
       }
      }
     } else $h$0$lcssa$i33 = 0;
     HEAP32[4241] = 0;
     $359 = HEAP32[4145] | 0;
     $360 = HEAP32[4041] | 0;
     $361 = HEAP32[4042] | 0;
     $362 = HEAP32[4242] | 0;
     $363 = HEAP32[4243] | 0;
     $p$0$i35 = $h$0$lcssa$i33 + 1 | 0;
     L40 : while (1) {
      $365 = HEAP32[$359 + ($p$0$i35 << 2) >> 2] | 0;
      L42 : do if (($365 | 0) > 0) {
       $369 = HEAP32[$360 + ($365 + 1 << 2) >> 2] | 0;
       $371 = HEAP32[$360 + ($365 << 2) >> 2] | 0;
       if (($369 - $371 | 0) == ($343 | 0)) {
        if (($369 | 0) > ($371 | 0)) {
         $i$01$i$i39 = $344;
         $j$02$i$i38 = $371;
         while (1) {
          if ((HEAP8[$361 + $j$02$i$i38 >> 0] | 0) != (HEAP8[$350 + $i$01$i$i39 >> 0] | 0)) break L42;
          $381 = $j$02$i$i38 + 1 | 0;
          if (($381 | 0) < ($369 | 0)) {
           $i$01$i$i39 = $i$01$i$i39 + 1 | 0;
           $j$02$i$i38 = $381;
          } else break;
         }
        }
        if ((HEAP8[$362 + $p$0$i35 >> 0] | 0) == 11) {
         $p$0$i35$lcssa = $p$0$i35;
         break L40;
        }
       }
      } while (0);
      $387 = HEAP32[$363 + ($p$0$i35 << 2) >> 2] | 0;
      if (!$387) {
       $p$0$i35$lcssa225 = $p$0$i35;
       label = 108;
       break;
      } else $p$0$i35 = $387;
     }
     if ((label | 0) == 108) {
      label = 0;
      HEAP32[4310] = $p$0$i35$lcssa225;
      _skptokenunknownfunctionprint();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     }
     HEAP32[4241] = 1;
     HEAP32[4310] = $p$0$i35$lcssa;
     if (($p$0$i35$lcssa | 0) == (HEAP32[4311] | 0)) {
      _printrecursionillegal();
      $singlefnspace$8 = $singlefnspace$081;
      $singleptr$1 = $singleptr$082;
      $singlfunction$8 = $singlfunction$084;
      break L17;
     }
     HEAP32[$singlfunction$084 + ($singleptr$082 << 2) >> 2] = $p$0$i35$lcssa;
     if (($singleptr$082 | 0) == ($singlefnspace$081 | 0)) {
      $393 = HEAP32[3989] | 0;
      $394 = $singleptr$082 + 50 | 0;
      HEAP32[$vararg_buffer76 >> 2] = 3094;
      HEAP32[$vararg_buffer76 + 4 >> 2] = 4;
      HEAP32[$vararg_buffer76 + 8 >> 2] = $394;
      HEAP32[$vararg_buffer76 + 12 >> 2] = $singleptr$082;
      _fprintf($393, 1023, $vararg_buffer76) | 0;
      $singlefnspace$7 = $394;
      $singlfunction$7 = _xrealloc($singlfunction$084, ($singleptr$082 << 2) + 204 | 0) | 0;
     } else {
      $singlefnspace$7 = $singlefnspace$081;
      $singlfunction$7 = $singlfunction$084;
     }
     $singlefnspace$8 = $singlefnspace$7;
     $singleptr$1 = $singleptr$082 + 1 | 0;
     $singlfunction$8 = $singlfunction$7;
    }
   } while (0);
   $401 = HEAP32[4045] | 0;
   while (1) {
    $399 = HEAP32[3993] | 0;
    $402 = HEAP8[$399 + $401 >> 0] | 0;
    $407 = HEAP32[3999] | 0;
    $408 = ($401 | 0) < ($407 | 0);
    if ((HEAP8[25877 + ($402 & 255) >> 0] | 0) == 1 & $408) {
     $411 = $401;
     while (1) {
      $410 = $411 + 1 | 0;
      HEAP32[4045] = $410;
      $413 = HEAP8[$399 + $410 >> 0] | 0;
      $418 = ($410 | 0) < ($407 | 0);
      if ($418 & (HEAP8[25877 + ($413 & 255) >> 0] | 0) == 1) $411 = $410; else {
       $$lcssa$i$i47 = $418;
       $420 = $413;
       $471 = $410;
       break;
      }
     }
    } else {
     $$lcssa$i$i47 = $408;
     $420 = $402;
     $471 = $401;
    }
    if (!($420 << 24 >> 24 == 37 | $$lcssa$i$i47 ^ 1)) {
     $$lcssa229 = $399;
     $$lcssa231 = $407;
     $$lcssa233 = $471;
     $$lcssa235 = $420;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     $singlfunction$8$lcssa239 = $singlfunction$8;
     label = 120;
     break L15;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $401 = 0;
   }
   if ($$lcssa235 << 24 >> 24 == 125) {
    $singlefnspace$8$lcssa = $singlefnspace$8;
    $singleptr$1$lcssa = $singleptr$1;
    $singlfunction$8$lcssa = $singlfunction$8;
    label = 121;
    break;
   } else {
    $37 = $$lcssa235;
    $39 = $$lcssa233;
    $41 = $$lcssa229;
    $53 = $$lcssa231;
    $singlefnspace$081 = $singlefnspace$8;
    $singleptr$082 = $singleptr$1;
    $singlfunction$084 = $singlfunction$8;
   }
  }
  if ((label | 0) == 80) {
   _fwrite(3145, 37, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3145, 37, 1, HEAP32[3990] | 0) | 0;
   $294 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer52 >> 2] = 964;
   _fprintf($294, 960, $vararg_buffer52) | 0;
   $295 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer55 >> 2] = 964;
   _fprintf($295, 960, $vararg_buffer55) | 0;
   $296 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer58 >> 2] = 985;
   _fprintf($296, 960, $vararg_buffer58) | 0;
   $297 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer61 >> 2] = 985;
   _fprintf($297, 960, $vararg_buffer61) | 0;
   HEAP8[25620] = 3;
   _longjmp(16008, 1);
  } else if ((label | 0) == 120) {
   _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
   _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   $singlfunction$10 = $singlfunction$8$lcssa239;
   _free($singlfunction$10);
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 121) {
   HEAP32[$singlfunction$8$lcssa + ($singleptr$1$lcssa << 2) >> 2] = HEAP32[4313];
   if (($singleptr$1$lcssa | 0) != ($singlefnspace$8$lcssa | 0)) {
    $singleptr$0$lcssa114 = $singleptr$1$lcssa;
    $singlfunction$9 = $singlfunction$8$lcssa;
    break;
   }
   $434 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer82 >> 2] = 3094;
   HEAP32[$vararg_buffer82 + 4 >> 2] = 4;
   HEAP32[$vararg_buffer82 + 8 >> 2] = $singleptr$1$lcssa + 50;
   HEAP32[$vararg_buffer82 + 12 >> 2] = $singleptr$1$lcssa;
   _fprintf($434, 1023, $vararg_buffer82) | 0;
   $singleptr$0$lcssa114 = $singleptr$1$lcssa;
   $singlfunction$9 = _xrealloc($singlfunction$8$lcssa, ($singleptr$1$lcssa << 2) + 204 | 0) | 0;
   break;
  }
 } while (0);
 $439 = $singleptr$0$lcssa114 + 1 | 0;
 $440 = HEAP32[4158] | 0;
 $442 = HEAP32[4314] | 0;
 if (($439 + $440 | 0) > ($442 | 0)) {
  $446 = $442;
  while (1) {
   $444 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer88 >> 2] = 3183;
   HEAP32[$vararg_buffer88 + 4 >> 2] = 4;
   HEAP32[$vararg_buffer88 + 8 >> 2] = $446 + 3e3;
   HEAP32[$vararg_buffer88 + 12 >> 2] = $446;
   _fprintf($444, 1023, $vararg_buffer88) | 0;
   HEAP32[4315] = _xrealloc(HEAP32[4315] | 0, (HEAP32[4314] << 2) + 12004 | 0) | 0;
   $453 = (HEAP32[4314] | 0) + 3e3 | 0;
   HEAP32[4314] = $453;
   $454 = HEAP32[4158] | 0;
   if (($439 + $454 | 0) > ($453 | 0)) $446 = $453; else {
    $$lcssa = $454;
    break;
   }
  }
 } else $$lcssa = $440;
 HEAP32[(HEAP32[4249] | 0) + ($fnhashloc << 2) >> 2] = $$lcssa;
 if (($singleptr$0$lcssa114 | 0) >= 0) {
  $460 = HEAP32[4315] | 0;
  $464 = HEAP32[4158] | 0;
  $copyptr$077 = 0;
  while (1) {
   HEAP32[$460 + ($464 << 2) >> 2] = HEAP32[$singlfunction$9 + ($copyptr$077 << 2) >> 2];
   $465 = $copyptr$077 + 1 | 0;
   $467 = (HEAP32[4158] | 0) + 1 | 0;
   HEAP32[4158] = $467;
   if (($465 | 0) == ($439 | 0)) break; else {
    $464 = $467;
    $copyptr$077 = $465;
   }
  }
 }
 HEAP32[4045] = (HEAP32[4045] | 0) + 1;
 $singlfunction$10 = $singlfunction$9;
 _free($singlfunction$10);
 STACKTOP = sp;
 return;
}

function _figureouttheformattedname() {
 var $$be = 0, $$lcssa = 0, $$lcssa192 = 0, $$lcssa194 = 0, $$lcssa196 = 0, $$lcssa198 = 0, $$lcssa199 = 0, $$lcssa202 = 0, $$ph$i = 0, $$ph$i7 = 0, $$ph3$i = 0, $$ph3$i8 = 0, $$pr$pre = 0, $$pre = 0, $$pre$i14 = 0, $$pre2$i165 = 0, $$pre2$i5 = 0, $$pre73 = 0, $$pre88 = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $104 = 0, $105 = 0, $107 = 0, $108 = 0, $11 = 0, $112 = 0, $115 = 0, $117 = 0, $121 = 0, $122 = 0, $125 = 0, $126 = 0, $129 = 0, $131 = 0, $133 = 0, $134 = 0, $137 = 0, $14 = 0, $144 = 0, $146 = 0, $149 = 0, $153 = 0, $155 = 0, $157 = 0, $16 = 0, $161 = 0, $162 = 0, $167 = 0, $17 = 0, $172 = 0, $173 = 0, $177 = 0, $18 = 0, $182 = 0, $188 = 0, $19 = 0, $190 = 0, $194 = 0, $196 = 0, $199 = 0, $20 = 0, $201 = 0, $204 = 0, $207 = 0, $210 = 0, $211 = 0, $215 = 0, $217 = 0, $219 = 0, $222 = 0, $227 = 0, $234 = 0, $239 = 0, $244 = 0, $245 = 0, $25 = 0, $250 = 0, $255 = 0, $256 = 0, $26 = 0, $262 = 0, $263 = 0, $265 = 0, $266 = 0, $269 = 0, $270 = 0, $278 = 0, $280 = 0, $281 = 0, $282 = 0, $284 = 0, $289 = 0, $290 = 0, $291 = 0, $293 = 0, $295 = 0, $299 = 0, $3 = 0, $30 = 0, $302 = 0, $308 = 0, $309 = 0, $313 = 0, $314 = 0, $319 = 0, $321 = 0, $327 = 0, $329 = 0, $331 = 0, $334 = 0, $338 = 0, $342 = 0, $347 = 0, $352 = 0, $357 = 0, $360 = 0, $365 = 0, $366 = 0, $37 = 0, $371 = 0, $373 = 0, $374 = 0, $375 = 0, $38 = 0, $382 = 0, $384 = 0, $385 = 0, $388 = 0, $389 = 0, $397 = 0, $399 = 0, $400 = 0, $401 = 0, $403 = 0, $408 = 0, $409 = 0, $410 = 0, $412 = 0, $415 = 0, $42 = 0, $424 = 0, $425 = 0, $427 = 0, $43 = 0, $432 = 0, $433 = 0, $438 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $47 = 0, $48 = 0, $52 = 0, $53 = 0, $59 = 0, $6 = 0, $66 = 0, $72 = 0, $73 = 0, $74 = 0, $78 = 0, $80 = 0, $84 = 0, $85 = 0, $88 = 0, $90 = 0, $93 = 0, $94 = 0, $96 = 0, $97 = 0, $storemerge$i = 0, $storemerge$i12 = 0, $storemerge$i16 = 0, $storemerge$i24 = 0, $storemerge2$i = 0, $storemerge2$i21 = 0, $storemerge56 = 0, label = 0;
 HEAP32[4251] = 0;
 HEAP32[4342] = 0;
 $0 = HEAP32[4345] | 0;
 $1 = HEAP32[4041] | 0;
 $3 = HEAP32[$1 + ($0 << 2) >> 2] | 0;
 HEAP32[4343] = $3;
 $6 = HEAP32[$1 + ($0 + 1 << 2) >> 2] | 0;
 HEAP32[4344] = $6;
 if (($3 | 0) < ($6 | 0)) {
  $10 = $3;
  $16 = $6;
 } else {
  $445 = HEAP32[4251] | 0;
  HEAP32[4333] = $445;
  return;
 }
 while (1) {
  $11 = HEAP8[(HEAP32[4042] | 0) + $10 >> 0] | 0;
  L5 : do switch ($11 << 24 >> 24) {
  case 123:
   {
    HEAP32[4342] = (HEAP32[4342] | 0) + 1;
    $14 = $10 + 1 | 0;
    HEAP32[4343] = $14;
    HEAP32[4348] = $14;
    HEAP32[4349] = 0;
    HEAP32[4350] = 0;
    HEAP32[4351] = 0;
    HEAP32[4352] = 1;
    L11 : do if (($14 | 0) < ($16 | 0)) {
     $$pre2$i165 = $16;
     $19 = $14;
     $26 = 0;
     $446 = 1;
     L12 : while (1) {
      $17 = HEAP32[4042] | 0;
      $18 = $17 + $19 | 0;
      $20 = HEAP8[$18 >> 0] | 0;
      L14 : do if ((HEAP8[25877 + ($20 & 255) >> 0] | 0) == 2) {
       $25 = $19 + 1 | 0;
       HEAP32[4343] = $25;
       do if (!$26) {
        L18 : do switch (HEAPU8[$18 >> 0] | 0) {
        case 70:
        case 102:
         {
          $37 = HEAP32[4353] | 0;
          HEAP32[4354] = $37;
          $38 = HEAP32[4355] | 0;
          HEAP32[4356] = $38;
          if (($37 | 0) == ($38 | 0)) {
           HEAP32[4352] = 0;
           $448 = 0;
          } else $448 = $446;
          switch (HEAP8[$17 + $25 >> 0] | 0) {
          case 70:
          case 102:
           break;
          default:
           {
            $449 = $448;
            label = 25;
            break L18;
           }
          }
          HEAP32[4350] = 1;
          $450 = $448;
          $66 = $25;
          break;
         }
        case 86:
        case 118:
         {
          $42 = HEAP32[4341] | 0;
          HEAP32[4354] = $42;
          $43 = HEAP32[4340] | 0;
          HEAP32[4356] = $43;
          if (($42 | 0) == ($43 | 0)) {
           HEAP32[4352] = 0;
           $451 = 0;
          } else $451 = $446;
          switch (HEAP8[$17 + $25 >> 0] | 0) {
          case 86:
          case 118:
           break;
          default:
           {
            $449 = $451;
            label = 25;
            break L18;
           }
          }
          HEAP32[4350] = 1;
          $450 = $451;
          $66 = $25;
          break;
         }
        case 76:
        case 108:
         {
          $47 = HEAP32[4340] | 0;
          HEAP32[4354] = $47;
          $48 = HEAP32[4339] | 0;
          HEAP32[4356] = $48;
          if (($47 | 0) == ($48 | 0)) {
           HEAP32[4352] = 0;
           $452 = 0;
          } else $452 = $446;
          switch (HEAP8[$17 + $25 >> 0] | 0) {
          case 76:
          case 108:
           break;
          default:
           {
            $449 = $452;
            label = 25;
            break L18;
           }
          }
          HEAP32[4350] = 1;
          $450 = $452;
          $66 = $25;
          break;
         }
        case 74:
        case 106:
         {
          $52 = HEAP32[4339] | 0;
          HEAP32[4354] = $52;
          $53 = HEAP32[4357] | 0;
          HEAP32[4356] = $53;
          if (($52 | 0) == ($53 | 0)) {
           HEAP32[4352] = 0;
           $453 = 0;
          } else $453 = $446;
          switch (HEAP8[$17 + $25 >> 0] | 0) {
          case 74:
          case 106:
           break;
          default:
           {
            $449 = $453;
            label = 25;
            break L18;
           }
          }
          HEAP32[4350] = 1;
          $450 = $453;
          $66 = $25;
          break;
         }
        default:
         {
          _fwrite(3370, 19, 1, HEAP32[3989] | 0) | 0;
          _fwrite(3370, 19, 1, HEAP32[3990] | 0) | 0;
          $59 = HEAP32[4345] | 0;
          _zoutpoolstr(HEAP32[3990] | 0, $59);
          _zoutpoolstr(HEAP32[3989] | 0, $59);
          _fwrite(3390, 37, 1, HEAP32[3989] | 0) | 0;
          _fwrite(3390, 37, 1, HEAP32[3990] | 0) | 0;
          _bstexwarnprint();
          HEAP32[4352] = 0;
          $449 = 0;
          label = 25;
         }
        } while (0);
        if ((label | 0) == 25) {
         label = 0;
         if (!(HEAP32[4350] | 0)) {
          $447 = $449;
          break;
         }
         $450 = $449;
         $66 = HEAP32[4343] | 0;
        }
        HEAP32[4343] = $66 + 1;
        $447 = $450;
       } else {
        _fwrite(3370, 19, 1, HEAP32[3989] | 0) | 0;
        _fwrite(3370, 19, 1, HEAP32[3990] | 0) | 0;
        $30 = HEAP32[4345] | 0;
        _zoutpoolstr(HEAP32[3990] | 0, $30);
        _zoutpoolstr(HEAP32[3989] | 0, $30);
        _fwrite(3390, 37, 1, HEAP32[3989] | 0) | 0;
        _fwrite(3390, 37, 1, HEAP32[3990] | 0) | 0;
        _bstexwarnprint();
        HEAP32[4352] = 0;
        $447 = 0;
       } while (0);
       HEAP32[4349] = 1;
       $$pr$pre = HEAP32[4351] | 0;
       if (!$$pr$pre) {
        $454 = 1;
        $455 = $447;
       } else {
        $88 = $$pr$pre;
        $90 = $447;
        break L11;
       }
      } else {
       switch ($20 << 24 >> 24) {
       case 125:
        {
         $$lcssa194 = $19;
         $$lcssa196 = $446;
         break L12;
         break;
        }
       case 123:
        break;
       default:
        {
         HEAP32[4343] = $19 + 1;
         $454 = $26;
         $455 = $446;
         break L14;
        }
       }
       $72 = HEAP32[4342] | 0;
       $73 = $72 + 1 | 0;
       HEAP32[4342] = $73;
       $74 = $19 + 1 | 0;
       HEAP32[4343] = $74;
       if (($72 | 0) > 0) {
        $$ph$i = $74;
        $$ph3$i = $73;
        while (1) {
         if (($$ph$i | 0) < ($$pre2$i165 | 0)) $78 = $$ph$i; else {
          $454 = $26;
          $455 = $446;
          break L14;
         }
         L52 : while (1) {
          switch (HEAP8[$17 + $78 >> 0] | 0) {
          case 125:
           {
            $$lcssa = $78;
            label = 36;
            break L52;
            break;
           }
          case 123:
           {
            $$lcssa192 = $78;
            label = 37;
            break L52;
            break;
           }
          default:
           {}
          }
          $80 = $78 + 1 | 0;
          HEAP32[4343] = $80;
          if (($80 | 0) < ($$pre2$i165 | 0)) $78 = $80; else {
           $454 = $26;
           $455 = $446;
           break L14;
          }
         }
         if ((label | 0) == 36) {
          label = 0;
          $85 = $$lcssa;
          $storemerge$i = $$ph3$i + -1 | 0;
         } else if ((label | 0) == 37) {
          label = 0;
          $85 = $$lcssa192;
          $storemerge$i = $$ph3$i + 1 | 0;
         }
         HEAP32[4342] = $storemerge$i;
         $84 = $85 + 1 | 0;
         HEAP32[4343] = $84;
         if (($storemerge$i | 0) > 1) {
          $$ph$i = $84;
          $$ph3$i = $storemerge$i;
         } else {
          $454 = $26;
          $455 = $446;
          break;
         }
        }
       } else {
        $454 = $26;
        $455 = $446;
       }
      } while (0);
      $$pre = HEAP32[4343] | 0;
      $$pre73 = HEAP32[4344] | 0;
      if (($$pre | 0) < ($$pre73 | 0)) {
       $$pre2$i165 = $$pre73;
       $19 = $$pre;
       $26 = $454;
       $446 = $455;
      } else {
       $88 = 0;
       $90 = $455;
       break L11;
      }
     }
     HEAP32[4342] = (HEAP32[4342] | 0) + -1;
     HEAP32[4343] = $$lcssa194 + 1;
     HEAP32[4351] = 1;
     $88 = 1;
     $90 = $$lcssa196;
    } else {
     $88 = 0;
     $90 = 1;
    } while (0);
    if (($88 | 0) != 0 & ($90 | 0) != 0) {
     HEAP32[4323] = HEAP32[4251];
     $93 = HEAP32[4348] | 0;
     HEAP32[4343] = $93;
     HEAP32[4342] = 1;
     $102 = 1;
     $96 = $93;
     while (1) {
      $94 = HEAP32[4042] | 0;
      $97 = HEAP8[$94 + $96 >> 0] | 0;
      L65 : do if (($102 | 0) == 1 ? (HEAP8[25877 + ($97 & 255) >> 0] | 0) == 2 : 0) {
       $104 = $96 + 1 | 0;
       HEAP32[4343] = $104;
       $105 = HEAP32[4350] | 0;
       if (!$105) $108 = $104; else {
        $107 = $96 + 2 | 0;
        HEAP32[4343] = $107;
        $108 = $107;
       }
       HEAP32[4358] = 1;
       HEAP32[4359] = $108;
       if ((HEAP8[$94 + $108 >> 0] | 0) == 123) {
        HEAP32[4358] = 0;
        HEAP32[4342] = 2;
        $112 = $108 + 1 | 0;
        HEAP32[4343] = $112;
        HEAP32[4348] = $112;
        $$pre2$i5 = HEAP32[4344] | 0;
        $$ph$i7 = $112;
        $$ph3$i8 = 2;
        L72 : while (1) {
         if (($$ph$i7 | 0) < ($$pre2$i5 | 0)) $115 = $$ph$i7; else {
          $125 = $$ph$i7;
          break;
         }
         L74 : while (1) {
          switch (HEAP8[$94 + $115 >> 0] | 0) {
          case 125:
           {
            $$lcssa198 = $115;
            label = 51;
            break L74;
            break;
           }
          case 123:
           {
            $$lcssa199 = $115;
            label = 52;
            break L74;
            break;
           }
          default:
           {}
          }
          $117 = $115 + 1 | 0;
          HEAP32[4343] = $117;
          if (($117 | 0) < ($$pre2$i5 | 0)) $115 = $117; else {
           $125 = $117;
           break L72;
          }
         }
         if ((label | 0) == 51) {
          label = 0;
          $122 = $$lcssa198;
          $storemerge$i12 = $$ph3$i8 + -1 | 0;
         } else if ((label | 0) == 52) {
          label = 0;
          $122 = $$lcssa199;
          $storemerge$i12 = $$ph3$i8 + 1 | 0;
         }
         HEAP32[4342] = $storemerge$i12;
         $121 = $122 + 1 | 0;
         HEAP32[4343] = $121;
         if (($storemerge$i12 | 0) > 1) {
          $$ph$i7 = $121;
          $$ph3$i8 = $storemerge$i12;
         } else {
          $125 = $121;
          break;
         }
        }
        HEAP32[4359] = $125 + -1;
        $456 = 0;
       } else $456 = 1;
       $126 = HEAP32[4354] | 0;
       if (($126 | 0) < (HEAP32[4356] | 0)) {
        $129 = $105;
        $133 = $126;
        while (1) {
         $131 = HEAP32[3997] | 0;
         $134 = HEAP32[$131 + ($133 << 2) >> 2] | 0;
         HEAP32[4335] = $134;
         $137 = HEAP32[$131 + ($133 + 1 << 2) >> 2] | 0;
         HEAP32[4336] = $137;
         L86 : do if (!$129) {
          if (($134 | 0) < ($137 | 0)) {
           $$pre88 = HEAP32[3994] | 0;
           $161 = $134;
           while (1) {
            $162 = HEAP8[$$pre88 + $161 >> 0] | 0;
            if ((HEAP8[25877 + ($162 & 255) >> 0] | 0) == 2) {
             $$lcssa202 = $162;
             label = 65;
             break;
            }
            $177 = $161 + 1 | 0;
            if ($162 << 24 >> 24 == 123 & ($177 | 0) < ($137 | 0)) if ((HEAP8[$$pre88 + $177 >> 0] | 0) == 92) break;
            HEAP32[4335] = $177;
            if (($177 | 0) < ($137 | 0)) $161 = $177; else break L86;
           }
           if ((label | 0) == 65) {
            label = 0;
            $167 = HEAP32[4251] | 0;
            if (($167 | 0) == (HEAP32[3992] | 0)) {
             _bufferoverflow();
             $172 = HEAP32[4251] | 0;
             $173 = HEAP8[(HEAP32[3994] | 0) + (HEAP32[4335] | 0) >> 0] | 0;
            } else {
             $172 = $167;
             $173 = $$lcssa202;
            }
            HEAP8[(HEAP32[3995] | 0) + $172 >> 0] = $173;
            HEAP32[4251] = (HEAP32[4251] | 0) + 1;
            break;
           }
           $182 = HEAP32[4251] | 0;
           if (($182 + 2 | 0) > (HEAP32[3992] | 0)) {
            _bufferoverflow();
            $188 = HEAP32[4251] | 0;
           } else $188 = $182;
           HEAP8[(HEAP32[3995] | 0) + $188 >> 0] = 123;
           $190 = (HEAP32[4251] | 0) + 1 | 0;
           HEAP32[4251] = $190;
           HEAP8[(HEAP32[3995] | 0) + $190 >> 0] = 92;
           $194 = (HEAP32[4251] | 0) + 1 | 0;
           HEAP32[4251] = $194;
           $196 = (HEAP32[4335] | 0) + 2 | 0;
           HEAP32[4335] = $196;
           HEAP32[4334] = 1;
           if (($196 | 0) < (HEAP32[4336] | 0)) {
            $201 = $196;
            $204 = 1;
            $207 = $194;
            while (1) {
             $199 = HEAP32[3994] | 0;
             switch (HEAP8[$199 + $201 >> 0] | 0) {
             case 125:
              {
               HEAP32[4334] = $204 + -1;
               break;
              }
             case 123:
              {
               HEAP32[4334] = $204 + 1;
               break;
              }
             default:
              {}
             }
             if (($207 | 0) == (HEAP32[3992] | 0)) {
              _bufferoverflow();
              $210 = HEAP32[3994] | 0;
              $211 = HEAP32[4335] | 0;
              $215 = HEAP32[4251] | 0;
             } else {
              $210 = $199;
              $211 = $201;
              $215 = $207;
             }
             HEAP8[(HEAP32[3995] | 0) + $215 >> 0] = HEAP8[$210 + $211 >> 0] | 0;
             $217 = (HEAP32[4251] | 0) + 1 | 0;
             HEAP32[4251] = $217;
             $219 = (HEAP32[4335] | 0) + 1 | 0;
             HEAP32[4335] = $219;
             $222 = HEAP32[4334] | 0;
             if (($219 | 0) < (HEAP32[4336] | 0) & ($222 | 0) > 0) {
              $201 = $219;
              $204 = $222;
              $207 = $217;
             } else break L86;
            }
           }
          }
         } else {
          if (((HEAP32[4333] | 0) + $137 - $134 | 0) > (HEAP32[3992] | 0)) {
           _bufferoverflow();
           $144 = HEAP32[4335] | 0;
           $146 = HEAP32[4336] | 0;
          } else {
           $144 = $134;
           $146 = $137;
          }
          if (($144 | 0) < ($146 | 0)) {
           $149 = $144;
           $153 = HEAP32[4251] | 0;
           while (1) {
            HEAP8[(HEAP32[3995] | 0) + $153 >> 0] = HEAP8[(HEAP32[3994] | 0) + $149 >> 0] | 0;
            $155 = (HEAP32[4251] | 0) + 1 | 0;
            HEAP32[4251] = $155;
            $157 = (HEAP32[4335] | 0) + 1 | 0;
            HEAP32[4335] = $157;
            if (($157 | 0) < (HEAP32[4336] | 0)) {
             $149 = $157;
             $153 = $155;
            } else break;
           }
          }
         } while (0);
         $227 = (HEAP32[4354] | 0) + 1 | 0;
         HEAP32[4354] = $227;
         L121 : do if (($227 | 0) < (HEAP32[4356] | 0)) {
          if (!(HEAP32[4358] | 0)) {
           $313 = HEAP32[4359] | 0;
           $314 = HEAP32[4348] | 0;
           if (($313 + (HEAP32[4333] | 0) - $314 | 0) > (HEAP32[3992] | 0)) {
            _bufferoverflow();
            $319 = HEAP32[4348] | 0;
            $321 = HEAP32[4359] | 0;
           } else {
            $319 = $314;
            $321 = $313;
           }
           HEAP32[4343] = $319;
           if (($319 | 0) >= ($321 | 0)) break;
           $327 = HEAP32[4251] | 0;
           $storemerge56 = $319;
           while (1) {
            HEAP8[(HEAP32[3995] | 0) + $327 >> 0] = HEAP8[(HEAP32[4042] | 0) + $storemerge56 >> 0] | 0;
            $329 = (HEAP32[4251] | 0) + 1 | 0;
            HEAP32[4251] = $329;
            $331 = (HEAP32[4343] | 0) + 1 | 0;
            HEAP32[4343] = $331;
            if (($331 | 0) < (HEAP32[4359] | 0)) {
             $327 = $329;
             $storemerge56 = $331;
            } else break L121;
           }
          }
          if (!(HEAP32[4350] | 0)) {
           $234 = HEAP32[4251] | 0;
           if (($234 | 0) == (HEAP32[3992] | 0)) {
            _bufferoverflow();
            $239 = HEAP32[4251] | 0;
           } else $239 = $234;
           HEAP8[(HEAP32[3995] | 0) + $239 >> 0] = 46;
           HEAP32[4251] = (HEAP32[4251] | 0) + 1;
           $244 = HEAP32[4354] | 0;
          } else $244 = $227;
          $245 = HEAP8[(HEAP32[3998] | 0) + $244 >> 0] | 0;
          if ((HEAP8[25877 + ($245 & 255) >> 0] | 0) == 4) {
           $250 = HEAP32[4251] | 0;
           if (($250 | 0) == (HEAP32[3992] | 0)) {
            _bufferoverflow();
            $255 = HEAP32[4251] | 0;
            $256 = HEAP8[(HEAP32[3998] | 0) + (HEAP32[4354] | 0) >> 0] | 0;
           } else {
            $255 = $250;
            $256 = $245;
           }
           HEAP8[(HEAP32[3995] | 0) + $255 >> 0] = $256;
           HEAP32[4251] = (HEAP32[4251] | 0) + 1;
           break;
          }
          do if (($244 | 0) == ((HEAP32[4356] | 0) + -1 | 0)) $295 = HEAP32[4251] | 0; else {
           HEAP32[4346] = 0;
           $262 = HEAP32[4323] | 0;
           HEAP32[4347] = $262;
           $263 = HEAP32[4251] | 0;
           if (($262 | 0) >= ($263 | 0)) {
            $295 = $263;
            break;
           }
           $$pre$i14 = HEAP32[3995] | 0;
           $266 = $262;
           $290 = 0;
           while (1) {
            $265 = $266 + 1 | 0;
            HEAP32[4347] = $265;
            L150 : do switch (HEAP8[$$pre$i14 + $266 >> 0] | 0) {
            case 123:
             {
              $269 = HEAP32[4330] | 0;
              $270 = $269 + 1 | 0;
              HEAP32[4330] = $270;
              if (!(($265 | 0) < ($263 | 0) & ($269 | 0) == 0)) {
               $291 = $265;
               break L150;
              }
              if ((HEAP8[$$pre$i14 + $265 >> 0] | 0) != 92) {
               $291 = $265;
               break L150;
              }
              $storemerge2$i = $266 + 2 | 0;
              HEAP32[4347] = $storemerge2$i;
              if (($storemerge2$i | 0) < ($263 | 0)) {
               $278 = $storemerge2$i;
               $281 = $270;
              } else {
               $291 = $storemerge2$i;
               break L150;
              }
              while (1) {
               switch (HEAP8[$$pre$i14 + $278 >> 0] | 0) {
               case 125:
                {
                 $280 = $281 + -1 | 0;
                 HEAP32[4330] = $280;
                 $284 = $280;
                 break;
                }
               case 123:
                {
                 $282 = $281 + 1 | 0;
                 HEAP32[4330] = $282;
                 $284 = $282;
                 break;
                }
               default:
                $284 = $281;
               }
               $storemerge$i16 = $278 + 1 | 0;
               HEAP32[4347] = $storemerge$i16;
               if (($storemerge$i16 | 0) < ($263 | 0) & ($284 | 0) > 0) {
                $278 = $storemerge$i16;
                $281 = $284;
               } else {
                $291 = $storemerge$i16;
                break L150;
               }
              }
              break;
             }
            case 125:
             {
              HEAP32[4330] = (HEAP32[4330] | 0) + -1;
              $291 = $265;
              break;
             }
            default:
             $291 = $265;
            } while (0);
            $289 = $290 + 1 | 0;
            HEAP32[4346] = $289;
            $293 = ($289 | 0) < 3;
            if ($293 & ($291 | 0) < ($263 | 0)) {
             $266 = $291;
             $290 = $289;
            } else break;
           }
           if ($293) {
            $295 = $263;
            break;
           }
           if (($263 | 0) == (HEAP32[3992] | 0)) {
            _bufferoverflow();
            $308 = HEAP32[3995] | 0;
            $309 = HEAP32[4251] | 0;
           } else {
            $308 = $$pre$i14;
            $309 = $263;
           }
           HEAP8[$308 + $309 >> 0] = 32;
           HEAP32[4251] = (HEAP32[4251] | 0) + 1;
           break L121;
          } while (0);
          if (($295 | 0) == (HEAP32[3992] | 0)) {
           _bufferoverflow();
           $299 = HEAP32[4251] | 0;
          } else $299 = $295;
          HEAP8[(HEAP32[3995] | 0) + $299 >> 0] = 126;
          HEAP32[4251] = (HEAP32[4251] | 0) + 1;
         } while (0);
         $302 = HEAP32[4354] | 0;
         if (($302 | 0) >= (HEAP32[4356] | 0)) break;
         $129 = HEAP32[4350] | 0;
         $133 = $302;
        }
        $334 = HEAP32[4358] | 0;
       } else $334 = $456;
       if (!$334) {
        HEAP32[4343] = (HEAP32[4359] | 0) + 1;
        label = 42;
       } else label = 42;
      } else switch ($97 << 24 >> 24) {
      case 125:
       {
        $338 = $102 + -1 | 0;
        HEAP32[4342] = $338;
        HEAP32[4343] = $96 + 1;
        if (($102 | 0) <= 1) {
         $$be = $338;
         break L65;
        }
        $342 = HEAP32[4251] | 0;
        if (($342 | 0) == (HEAP32[3992] | 0)) {
         _bufferoverflow();
         $347 = HEAP32[4251] | 0;
        } else $347 = $342;
        HEAP8[(HEAP32[3995] | 0) + $347 >> 0] = 125;
        HEAP32[4251] = (HEAP32[4251] | 0) + 1;
        label = 42;
        break L65;
        break;
       }
      case 123:
       {
        HEAP32[4342] = $102 + 1;
        HEAP32[4343] = $96 + 1;
        $352 = HEAP32[4251] | 0;
        if (($352 | 0) == (HEAP32[3992] | 0)) {
         _bufferoverflow();
         $357 = HEAP32[4251] | 0;
        } else $357 = $352;
        HEAP8[(HEAP32[3995] | 0) + $357 >> 0] = 123;
        HEAP32[4251] = (HEAP32[4251] | 0) + 1;
        label = 42;
        break L65;
        break;
       }
      default:
       {
        $360 = HEAP32[4251] | 0;
        if (($360 | 0) == (HEAP32[3992] | 0)) {
         _bufferoverflow();
         $365 = HEAP32[4251] | 0;
         $366 = HEAP8[(HEAP32[4042] | 0) + (HEAP32[4343] | 0) >> 0] | 0;
        } else {
         $365 = $360;
         $366 = $97;
        }
        HEAP8[(HEAP32[3995] | 0) + $365 >> 0] = $366;
        HEAP32[4251] = (HEAP32[4251] | 0) + 1;
        HEAP32[4343] = (HEAP32[4343] | 0) + 1;
        label = 42;
        break L65;
       }
      } while (0);
      if ((label | 0) == 42) {
       label = 0;
       $$be = HEAP32[4342] | 0;
      }
      if (($$be | 0) <= 0) break;
      $102 = $$be;
      $96 = HEAP32[4343] | 0;
     }
     $371 = HEAP32[4251] | 0;
     if (($371 | 0) > 0) {
      $373 = $371 + -1 | 0;
      $374 = HEAP32[3995] | 0;
      $375 = $374 + $373 | 0;
      if ((HEAP8[$375 >> 0] | 0) == 126) {
       HEAP32[4251] = $373;
       if ((HEAP8[$374 + ($371 + -2) >> 0] | 0) != 126) {
        HEAP32[4346] = 0;
        $382 = HEAP32[4323] | 0;
        HEAP32[4347] = $382;
        if (($382 | 0) < ($373 | 0)) {
         $385 = $382;
         $409 = 0;
         while (1) {
          $384 = $385 + 1 | 0;
          HEAP32[4347] = $384;
          L202 : do switch (HEAP8[$374 + $385 >> 0] | 0) {
          case 123:
           {
            $388 = HEAP32[4330] | 0;
            $389 = $388 + 1 | 0;
            HEAP32[4330] = $389;
            if (($384 | 0) < ($373 | 0) & ($388 | 0) == 0) if ((HEAP8[$374 + $384 >> 0] | 0) == 92) {
             $storemerge2$i21 = $385 + 2 | 0;
             HEAP32[4347] = $storemerge2$i21;
             if (($storemerge2$i21 | 0) < ($373 | 0)) {
              $397 = $storemerge2$i21;
              $400 = $389;
              while (1) {
               switch (HEAP8[$374 + $397 >> 0] | 0) {
               case 125:
                {
                 $399 = $400 + -1 | 0;
                 HEAP32[4330] = $399;
                 $403 = $399;
                 break;
                }
               case 123:
                {
                 $401 = $400 + 1 | 0;
                 HEAP32[4330] = $401;
                 $403 = $401;
                 break;
                }
               default:
                $403 = $400;
               }
               $storemerge$i24 = $397 + 1 | 0;
               HEAP32[4347] = $storemerge$i24;
               if (($storemerge$i24 | 0) < ($373 | 0) & ($403 | 0) > 0) {
                $397 = $storemerge$i24;
                $400 = $403;
               } else {
                $410 = $storemerge$i24;
                break L202;
               }
              }
             } else $410 = $storemerge2$i21;
            } else $410 = $384; else $410 = $384;
            break;
           }
          case 125:
           {
            HEAP32[4330] = (HEAP32[4330] | 0) + -1;
            $410 = $384;
            break;
           }
          default:
           $410 = $384;
          } while (0);
          $408 = $409 + 1 | 0;
          HEAP32[4346] = $408;
          $412 = ($408 | 0) < 3;
          if ($412 & ($410 | 0) < ($373 | 0)) {
           $385 = $410;
           $409 = $408;
          } else break;
         }
         if (!$412) {
          HEAP8[$375 >> 0] = 32;
          HEAP32[4251] = (HEAP32[4251] | 0) + 1;
          break L5;
         }
        }
        HEAP32[4251] = $371;
       }
      }
     }
    }
    break;
   }
  case 125:
   {
    $415 = HEAP32[4345] | 0;
    _fwrite(2597, 10, 1, HEAP32[3989] | 0) | 0;
    _fwrite(2597, 10, 1, HEAP32[3990] | 0) | 0;
    _zoutpoolstr(HEAP32[3990] | 0, $415);
    _zoutpoolstr(HEAP32[3989] | 0, $415);
    _fwrite(2608, 31, 1, HEAP32[3989] | 0) | 0;
    _fwrite(2608, 31, 1, HEAP32[3990] | 0) | 0;
    _bstmildexwarnprint();
    HEAP32[4343] = (HEAP32[4343] | 0) + 1;
    break;
   }
  default:
   {
    $427 = HEAP32[4251] | 0;
    if (($427 | 0) == (HEAP32[3992] | 0)) {
     _bufferoverflow();
     $432 = HEAP32[4251] | 0;
     $433 = HEAP8[(HEAP32[4042] | 0) + (HEAP32[4343] | 0) >> 0] | 0;
    } else {
     $432 = $427;
     $433 = $11;
    }
    HEAP8[(HEAP32[3995] | 0) + $432 >> 0] = $433;
    HEAP32[4251] = (HEAP32[4251] | 0) + 1;
    HEAP32[4343] = (HEAP32[4343] | 0) + 1;
   }
  } while (0);
  $424 = HEAP32[4343] | 0;
  $425 = HEAP32[4344] | 0;
  if (($424 | 0) < ($425 | 0)) {
   $10 = $424;
   $16 = $425;
  } else break;
 }
 if ((HEAP32[4342] | 0) <= 0) {
  $445 = HEAP32[4251] | 0;
  HEAP32[4333] = $445;
  return;
 }
 $438 = HEAP32[4345] | 0;
 _fwrite(2597, 10, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2597, 10, 1, HEAP32[3990] | 0) | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $438);
 _zoutpoolstr(HEAP32[3989] | 0, $438);
 _fwrite(2608, 31, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2608, 31, 1, HEAP32[3990] | 0) | 0;
 _bstmildexwarnprint();
 $445 = HEAP32[4251] | 0;
 HEAP32[4333] = $445;
 return;
}

function _bstentrycommand() {
 var $$lcssa = 0, $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i20 = 0, $$lcssa$i$i28 = 0, $$lcssa$i$i3 = 0, $$lcssa$i$i49 = 0, $$lcssa$i$i57 = 0, $$lcssa$i$i65 = 0, $$lcssa$i$i86 = 0, $$lcssa117 = 0, $$lcssa132 = 0, $$lcssa147 = 0, $$lcssa565 = 0, $$lcssa566 = 0, $$lcssa567 = 0, $$lcssa571 = 0, $$lcssa573 = 0, $$lcssa575 = 0, $$lcssa577 = 0, $$lcssa579 = 0, $$lcssa585 = 0, $$lcssa587 = 0, $$lcssa589 = 0, $$lcssa591 = 0, $$lcssa596 = 0, $$lcssa598 = 0, $$lcssa600 = 0, $$lcssa602 = 0, $$lcssa604 = 0, $$lcssa605 = 0, $$lcssa606 = 0, $$lcssa607 = 0, $$lcssa611 = 0, $$lcssa613 = 0, $$lcssa615 = 0, $$lcssa617 = 0, $$lcssa619 = 0, $$lcssa625 = 0, $$lcssa627 = 0, $$lcssa629 = 0, $$lcssa631 = 0, $$lcssa636 = 0, $$lcssa638 = 0, $$lcssa640 = 0, $$lcssa641 = 0, $$lcssa642 = 0, $$lcssa643 = 0, $$lcssa647 = 0, $$lcssa649 = 0, $$lcssa651 = 0, $$lcssa653 = 0, $$lcssa655 = 0, $$lcssa661 = 0, $$lcssa663 = 0, $$lcssa665 = 0, $$lcssa667 = 0, $$lcssa672 = 0, $$lcssa674 = 0, $$lcssa676 = 0, $$lcssa678 = 0, $109 = 0, $110 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $126 = 0, $13 = 0, $131 = 0, $132 = 0, $141 = 0, $143 = 0, $144 = 0, $149 = 0, $15 = 0, $150 = 0, $152 = 0, $153 = 0, $155 = 0, $16 = 0, $160 = 0, $162 = 0, $175 = 0, $176 = 0, $18 = 0, $181 = 0, $182 = 0, $184 = 0, $185 = 0, $187 = 0, $192 = 0, $194 = 0, $211 = 0, $212 = 0, $215 = 0, $217 = 0, $218 = 0, $220 = 0, $225 = 0, $226 = 0, $23 = 0, $231 = 0, $232 = 0, $234 = 0, $235 = 0, $237 = 0, $242 = 0, $244 = 0, $25 = 0, $257 = 0, $259 = 0, $261 = 0, $269 = 0, $270 = 0, $271 = 0, $273 = 0, $274 = 0, $287 = 0, $288 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $304 = 0, $309 = 0, $310 = 0, $319 = 0, $321 = 0, $322 = 0, $327 = 0, $328 = 0, $330 = 0, $331 = 0, $333 = 0, $338 = 0, $340 = 0, $353 = 0, $354 = 0, $359 = 0, $360 = 0, $362 = 0, $363 = 0, $365 = 0, $37 = 0, $370 = 0, $372 = 0, $384 = 0, $386 = 0, $387 = 0, $389 = 0, $39 = 0, $394 = 0, $395 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $403 = 0, $404 = 0, $406 = 0, $411 = 0, $413 = 0, $42 = 0, $426 = 0, $428 = 0, $430 = 0, $438 = 0, $439 = 0, $440 = 0, $442 = 0, $443 = 0, $456 = 0, $457 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $47 = 0, $473 = 0, $478 = 0, $479 = 0, $48 = 0, $488 = 0, $490 = 0, $491 = 0, $496 = 0, $497 = 0, $499 = 0, $500 = 0, $502 = 0, $507 = 0, $509 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $64 = 0, $66 = 0, $7 = 0, $79 = 0, $81 = 0, $83 = 0, $91 = 0, $92 = 0, $93 = 0, $95 = 0, $96 = 0, $i$0$i = 0, $i$0$i44 = 0, $i$0$i81 = 0, $storemerge = 0, $storemerge103 = 0, $storemerge104 = 0, $storemerge105 = 0, $storemerge106 = 0, $storemerge107 = 0, $storemerge108 = 0, $storemerge109 = 0, $storemerge110 = 0, $storemerge111 = 0, $storemerge112 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer14 = 0, $vararg_buffer19 = 0, $vararg_buffer24 = 0, $vararg_buffer27 = 0, $vararg_buffer3 = 0, $vararg_buffer30 = 0, $vararg_buffer35 = 0, $vararg_buffer40 = 0, $vararg_buffer43 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $vararg_buffer43 = sp + 136 | 0;
 $vararg_buffer40 = sp + 128 | 0;
 $vararg_buffer35 = sp + 112 | 0;
 $vararg_buffer30 = sp + 96 | 0;
 $vararg_buffer27 = sp + 88 | 0;
 $vararg_buffer24 = sp + 80 | 0;
 $vararg_buffer19 = sp + 64 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (HEAP32[4674] | 0) {
  _fwrite(4683, 30, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4683, 30, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4674] = 1;
 $6 = HEAP32[4045] | 0;
 while (1) {
  $4 = HEAP32[3993] | 0;
  $7 = HEAP8[$4 + $6 >> 0] | 0;
  $12 = HEAP32[3999] | 0;
  $13 = ($6 | 0) < ($12 | 0);
  if ((HEAP8[25877 + ($7 & 255) >> 0] | 0) == 1 & $13) {
   $16 = $6;
   while (1) {
    $15 = $16 + 1 | 0;
    HEAP32[4045] = $15;
    $18 = HEAP8[$4 + $15 >> 0] | 0;
    $23 = ($15 | 0) < ($12 | 0);
    if ($23 & (HEAP8[25877 + ($18 & 255) >> 0] | 0) == 1) $16 = $15; else {
     $$lcssa$i$i = $23;
     $25 = $18;
     $521 = $15;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $13;
   $25 = $7;
   $521 = $6;
  }
  if (!($25 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa672 = $4;
   $$lcssa674 = $12;
   $$lcssa676 = $521;
   $$lcssa678 = $25;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 9;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $6 = 0;
 }
 if ((label | 0) == 9) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa678 << 24 >> 24 != 123) {
  $37 = HEAP32[3989] | 0;
  $39 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $39;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($37, 1750, $vararg_buffer) | 0;
  $40 = HEAP32[3990] | 0;
  $42 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $42;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($40, 1750, $vararg_buffer3) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $47 = $$lcssa672;
 $54 = $$lcssa674;
 $storemerge = $$lcssa676 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge;
  $48 = HEAP8[$47 + $storemerge >> 0] | 0;
  $53 = ($storemerge | 0) < ($54 | 0);
  if ((HEAP8[25877 + ($48 & 255) >> 0] | 0) == 1 & $53) {
   $57 = $storemerge;
   while (1) {
    $56 = $57 + 1 | 0;
    HEAP32[4045] = $56;
    $59 = HEAP8[$47 + $56 >> 0] | 0;
    $64 = ($56 | 0) < ($54 | 0);
    if ($64 & (HEAP8[25877 + ($59 & 255) >> 0] | 0) == 1) $57 = $56; else {
     $$lcssa$i$i3 = $64;
     $522 = $56;
     $66 = $59;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $53;
   $522 = $storemerge;
   $66 = $48;
  }
  if (!($66 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa661 = $54;
   $$lcssa663 = $47;
   $$lcssa665 = $522;
   $$lcssa667 = $66;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 19;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $47 = HEAP32[3993] | 0;
  $54 = HEAP32[3999] | 0;
  $storemerge = 0;
 }
 if ((label | 0) == 19) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 L33 : do if ($$lcssa667 << 24 >> 24 == 125) {
  $$lcssa147 = $$lcssa665;
  $523 = $$lcssa661;
  $524 = $$lcssa663;
 } else {
  $79 = $$lcssa665;
  $81 = $$lcssa663;
  $91 = $$lcssa661;
  L34 : while (1) {
   HEAP32[4044] = $79;
   $83 = HEAPU8[$81 + $79 >> 0] | 0;
   if ((HEAP8[25877 + $83 >> 0] | 0) == 3) {
    $storemerge103 = 0;
    label = 27;
    break;
   }
   if ((HEAP8[26390 + $83 >> 0] | 0) == 1 & ($79 | 0) < ($91 | 0)) $93 = $79; else {
    $storemerge103 = 0;
    label = 27;
    break;
   }
   while (1) {
    $92 = $93 + 1 | 0;
    HEAP32[4045] = $92;
    $95 = HEAP8[$81 + $92 >> 0] | 0;
    $96 = $95 & 255;
    if (($92 | 0) < ($91 | 0) & (HEAP8[26390 + $96 >> 0] | 0) == 1) $93 = $92; else {
     $$lcssa640 = $93;
     $$lcssa641 = $92;
     $$lcssa642 = $95;
     $$lcssa643 = $96;
     break;
    }
   }
   if (($$lcssa641 | 0) == ($79 | 0)) {
    $storemerge103 = 0;
    label = 27;
    break;
   }
   if ((HEAP8[25877 + $$lcssa643 >> 0] | 0) == 1 | ($$lcssa641 | 0) == ($91 | 0)) $storemerge104 = 3; else switch ($$lcssa642 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge104 = 1;
     break;
    }
   default:
    {
     $storemerge103 = 2;
     label = 27;
     break L34;
    }
   }
   HEAP8[26389] = $storemerge104;
   if (($$lcssa640 | 0) < ($79 | 0)) {
    $118 = $79;
    $119 = $$lcssa641;
    $120 = $81;
   } else {
    $i$0$i = $79;
    while (1) {
     $109 = $81 + $i$0$i | 0;
     $110 = HEAP8[$109 >> 0] | 0;
     if (($110 + -65 & 255) < 26) HEAP8[$109 >> 0] = ($110 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa640 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $118 = HEAP32[4044] | 0;
    $119 = HEAP32[4045] | 0;
    $120 = HEAP32[3993] | 0;
   }
   $121 = _zstrlookup($120, $118, $119 - $118 | 0, 11, 1) | 0;
   HEAP32[4310] = $121;
   if (HEAP32[4241] | 0) {
    $$lcssa655 = $121;
    label = 34;
    break;
   }
   HEAP8[(HEAP32[4144] | 0) + $121 >> 0] = 4;
   HEAP32[(HEAP32[4249] | 0) + (HEAP32[4310] << 2) >> 2] = HEAP32[4247];
   HEAP32[4247] = (HEAP32[4247] | 0) + 1;
   $143 = HEAP32[4045] | 0;
   while (1) {
    $141 = HEAP32[3993] | 0;
    $144 = HEAP8[$141 + $143 >> 0] | 0;
    $149 = HEAP32[3999] | 0;
    $150 = ($143 | 0) < ($149 | 0);
    if ((HEAP8[25877 + ($144 & 255) >> 0] | 0) == 1 & $150) {
     $153 = $143;
     while (1) {
      $152 = $153 + 1 | 0;
      HEAP32[4045] = $152;
      $155 = HEAP8[$141 + $152 >> 0] | 0;
      $160 = ($152 | 0) < ($149 | 0);
      if ($160 & (HEAP8[25877 + ($155 & 255) >> 0] | 0) == 1) $153 = $152; else {
       $$lcssa$i$i12 = $160;
       $162 = $155;
       $525 = $152;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $150;
     $162 = $144;
     $525 = $143;
    }
    if (!($162 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa647 = $141;
     $$lcssa649 = $149;
     $$lcssa651 = $525;
     $$lcssa653 = $162;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 41;
     break L34;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $143 = 0;
   }
   if ($$lcssa653 << 24 >> 24 == 125) {
    $$lcssa147 = $$lcssa651;
    $523 = $$lcssa649;
    $524 = $$lcssa647;
    break L33;
   } else {
    $79 = $$lcssa651;
    $81 = $$lcssa647;
    $91 = $$lcssa649;
   }
  }
  if ((label | 0) == 27) {
   HEAP8[26389] = $storemerge103;
   _bstidprint();
   _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 34) {
   $126 = HEAP32[(HEAP32[4145] | 0) + ($$lcssa655 << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $126);
   _zoutpoolstr(HEAP32[3989] | 0, $126);
   _fwrite(1858, 20, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1858, 20, 1, HEAP32[3990] | 0) | 0;
   _zprintfnclass($$lcssa655);
   $131 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer8 >> 2] = 1879;
   _fprintf($131, 960, $vararg_buffer8) | 0;
   $132 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer11 >> 2] = 1879;
   _fprintf($132, 960, $vararg_buffer11) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 41) {
   _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  }
 } while (0);
 $175 = $524;
 $182 = $523;
 $storemerge105 = $$lcssa147 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge105;
  $176 = HEAP8[$175 + $storemerge105 >> 0] | 0;
  $181 = ($storemerge105 | 0) < ($182 | 0);
  if ((HEAP8[25877 + ($176 & 255) >> 0] | 0) == 1 & $181) {
   $185 = $storemerge105;
   while (1) {
    $184 = $185 + 1 | 0;
    HEAP32[4045] = $184;
    $187 = HEAP8[$175 + $184 >> 0] | 0;
    $192 = ($184 | 0) < ($182 | 0);
    if ($192 & (HEAP8[25877 + ($187 & 255) >> 0] | 0) == 1) $185 = $184; else {
     $$lcssa$i$i20 = $192;
     $194 = $187;
     $526 = $184;
     break;
    }
   }
  } else {
   $$lcssa$i$i20 = $181;
   $194 = $176;
   $526 = $storemerge105;
  }
  if (!($194 << 24 >> 24 == 37 | $$lcssa$i$i20 ^ 1)) {
   $$lcssa636 = $175;
   $$lcssa638 = $526;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 48;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $175 = HEAP32[3993] | 0;
  $182 = HEAP32[3999] | 0;
  $storemerge105 = 0;
 }
 if ((label | 0) == 48) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ((HEAP32[4247] | 0) == (HEAP32[4306] | 0)) {
  _fwrite(4714, 33, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4714, 33, 1, HEAP32[3990] | 0) | 0;
  _bstwarnprint();
  $211 = HEAP32[3993] | 0;
  $212 = HEAP32[4045] | 0;
 } else {
  $211 = $$lcssa636;
  $212 = $$lcssa638;
 }
 if ((HEAP8[$211 + $212 >> 0] | 0) != 123) {
  $215 = HEAP32[3989] | 0;
  $217 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer14 >> 2] = 34;
  HEAP32[$vararg_buffer14 + 4 >> 2] = $217;
  HEAP32[$vararg_buffer14 + 8 >> 2] = 1832;
  _fprintf($215, 1750, $vararg_buffer14) | 0;
  $218 = HEAP32[3990] | 0;
  $220 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer19 >> 2] = 34;
  HEAP32[$vararg_buffer19 + 4 >> 2] = $220;
  HEAP32[$vararg_buffer19 + 8 >> 2] = 1832;
  _fprintf($218, 1750, $vararg_buffer19) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $225 = $211;
 $storemerge106 = $212 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge106;
  $226 = HEAP8[$225 + $storemerge106 >> 0] | 0;
  $231 = HEAP32[3999] | 0;
  $232 = ($storemerge106 | 0) < ($231 | 0);
  if ((HEAP8[25877 + ($226 & 255) >> 0] | 0) == 1 & $232) {
   $235 = $storemerge106;
   while (1) {
    $234 = $235 + 1 | 0;
    HEAP32[4045] = $234;
    $237 = HEAP8[$225 + $234 >> 0] | 0;
    $242 = ($234 | 0) < ($231 | 0);
    if ($242 & (HEAP8[25877 + ($237 & 255) >> 0] | 0) == 1) $235 = $234; else {
     $$lcssa$i$i28 = $242;
     $244 = $237;
     $527 = $234;
     break;
    }
   }
  } else {
   $$lcssa$i$i28 = $232;
   $244 = $226;
   $527 = $storemerge106;
  }
  if (!($244 << 24 >> 24 == 37 | $$lcssa$i$i28 ^ 1)) {
   $$lcssa625 = $225;
   $$lcssa627 = $231;
   $$lcssa629 = $527;
   $$lcssa631 = $244;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 60;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $225 = HEAP32[3993] | 0;
  $storemerge106 = 0;
 }
 if ((label | 0) == 60) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 L101 : do if ($$lcssa631 << 24 >> 24 == 125) {
  $$lcssa132 = $$lcssa629;
  $528 = $$lcssa627;
  $529 = $$lcssa625;
 } else {
  $257 = $$lcssa629;
  $259 = $$lcssa625;
  $269 = $$lcssa627;
  L102 : while (1) {
   HEAP32[4044] = $257;
   $261 = HEAPU8[$259 + $257 >> 0] | 0;
   if ((HEAP8[25877 + $261 >> 0] | 0) == 3) {
    $storemerge107 = 0;
    label = 68;
    break;
   }
   if ((HEAP8[26390 + $261 >> 0] | 0) == 1 & ($257 | 0) < ($269 | 0)) $271 = $257; else {
    $storemerge107 = 0;
    label = 68;
    break;
   }
   while (1) {
    $270 = $271 + 1 | 0;
    HEAP32[4045] = $270;
    $273 = HEAP8[$259 + $270 >> 0] | 0;
    $274 = $273 & 255;
    if (($270 | 0) < ($269 | 0) & (HEAP8[26390 + $274 >> 0] | 0) == 1) $271 = $270; else {
     $$lcssa604 = $271;
     $$lcssa605 = $270;
     $$lcssa606 = $273;
     $$lcssa607 = $274;
     break;
    }
   }
   if (($$lcssa605 | 0) == ($257 | 0)) {
    $storemerge107 = 0;
    label = 68;
    break;
   }
   if ((HEAP8[25877 + $$lcssa607 >> 0] | 0) == 1 | ($$lcssa605 | 0) == ($269 | 0)) $storemerge108 = 3; else switch ($$lcssa606 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge108 = 1;
     break;
    }
   default:
    {
     $storemerge107 = 2;
     label = 68;
     break L102;
    }
   }
   HEAP8[26389] = $storemerge108;
   if (($$lcssa604 | 0) < ($257 | 0)) {
    $296 = $257;
    $297 = $$lcssa605;
    $298 = $259;
   } else {
    $i$0$i44 = $257;
    while (1) {
     $287 = $259 + $i$0$i44 | 0;
     $288 = HEAP8[$287 >> 0] | 0;
     if (($288 + -65 & 255) < 26) HEAP8[$287 >> 0] = ($288 & 255) + 32;
     if (($i$0$i44 | 0) < ($$lcssa604 | 0)) $i$0$i44 = $i$0$i44 + 1 | 0; else break;
    }
    $296 = HEAP32[4044] | 0;
    $297 = HEAP32[4045] | 0;
    $298 = HEAP32[3993] | 0;
   }
   $299 = _zstrlookup($298, $296, $297 - $296 | 0, 11, 1) | 0;
   HEAP32[4310] = $299;
   if (HEAP32[4241] | 0) {
    $$lcssa619 = $299;
    label = 75;
    break;
   }
   HEAP8[(HEAP32[4144] | 0) + $299 >> 0] = 5;
   HEAP32[(HEAP32[4249] | 0) + (HEAP32[4310] << 2) >> 2] = HEAP32[4368];
   HEAP32[4368] = (HEAP32[4368] | 0) + 1;
   $321 = HEAP32[4045] | 0;
   while (1) {
    $319 = HEAP32[3993] | 0;
    $322 = HEAP8[$319 + $321 >> 0] | 0;
    $327 = HEAP32[3999] | 0;
    $328 = ($321 | 0) < ($327 | 0);
    if ((HEAP8[25877 + ($322 & 255) >> 0] | 0) == 1 & $328) {
     $331 = $321;
     while (1) {
      $330 = $331 + 1 | 0;
      HEAP32[4045] = $330;
      $333 = HEAP8[$319 + $330 >> 0] | 0;
      $338 = ($330 | 0) < ($327 | 0);
      if ($338 & (HEAP8[25877 + ($333 & 255) >> 0] | 0) == 1) $331 = $330; else {
       $$lcssa$i$i49 = $338;
       $340 = $333;
       $530 = $330;
       break;
      }
     }
    } else {
     $$lcssa$i$i49 = $328;
     $340 = $322;
     $530 = $321;
    }
    if (!($340 << 24 >> 24 == 37 | $$lcssa$i$i49 ^ 1)) {
     $$lcssa611 = $319;
     $$lcssa613 = $327;
     $$lcssa615 = $530;
     $$lcssa617 = $340;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 82;
     break L102;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $321 = 0;
   }
   if ($$lcssa617 << 24 >> 24 == 125) {
    $$lcssa132 = $$lcssa615;
    $528 = $$lcssa613;
    $529 = $$lcssa611;
    break L101;
   } else {
    $257 = $$lcssa615;
    $259 = $$lcssa611;
    $269 = $$lcssa613;
   }
  }
  if ((label | 0) == 68) {
   HEAP8[26389] = $storemerge107;
   _bstidprint();
   _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 75) {
   $304 = HEAP32[(HEAP32[4145] | 0) + ($$lcssa619 << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $304);
   _zoutpoolstr(HEAP32[3989] | 0, $304);
   _fwrite(1858, 20, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1858, 20, 1, HEAP32[3990] | 0) | 0;
   _zprintfnclass($$lcssa619);
   $309 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer24 >> 2] = 1879;
   _fprintf($309, 960, $vararg_buffer24) | 0;
   $310 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer27 >> 2] = 1879;
   _fprintf($310, 960, $vararg_buffer27) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 82) {
   _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  }
 } while (0);
 $353 = $529;
 $360 = $528;
 $storemerge109 = $$lcssa132 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge109;
  $354 = HEAP8[$353 + $storemerge109 >> 0] | 0;
  $359 = ($storemerge109 | 0) < ($360 | 0);
  if ((HEAP8[25877 + ($354 & 255) >> 0] | 0) == 1 & $359) {
   $363 = $storemerge109;
   while (1) {
    $362 = $363 + 1 | 0;
    HEAP32[4045] = $362;
    $365 = HEAP8[$353 + $362 >> 0] | 0;
    $370 = ($362 | 0) < ($360 | 0);
    if ($370 & (HEAP8[25877 + ($365 & 255) >> 0] | 0) == 1) $363 = $362; else {
     $$lcssa$i$i57 = $370;
     $372 = $365;
     $531 = $362;
     break;
    }
   }
  } else {
   $$lcssa$i$i57 = $359;
   $372 = $354;
   $531 = $storemerge109;
  }
  if (!($372 << 24 >> 24 == 37 | $$lcssa$i$i57 ^ 1)) {
   $$lcssa596 = $360;
   $$lcssa598 = $353;
   $$lcssa600 = $531;
   $$lcssa602 = $372;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 89;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $353 = HEAP32[3993] | 0;
  $360 = HEAP32[3999] | 0;
  $storemerge109 = 0;
 }
 if ((label | 0) == 89) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa602 << 24 >> 24 != 123) {
  $384 = HEAP32[3989] | 0;
  $386 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer30 >> 2] = 34;
  HEAP32[$vararg_buffer30 + 4 >> 2] = $386;
  HEAP32[$vararg_buffer30 + 8 >> 2] = 1832;
  _fprintf($384, 1750, $vararg_buffer30) | 0;
  $387 = HEAP32[3990] | 0;
  $389 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer35 >> 2] = 34;
  HEAP32[$vararg_buffer35 + 4 >> 2] = $389;
  HEAP32[$vararg_buffer35 + 8 >> 2] = 1832;
  _fprintf($387, 1750, $vararg_buffer35) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $394 = $$lcssa598;
 $401 = $$lcssa596;
 $storemerge110 = $$lcssa600 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge110;
  $395 = HEAP8[$394 + $storemerge110 >> 0] | 0;
  $400 = ($storemerge110 | 0) < ($401 | 0);
  if ((HEAP8[25877 + ($395 & 255) >> 0] | 0) == 1 & $400) {
   $404 = $storemerge110;
   while (1) {
    $403 = $404 + 1 | 0;
    HEAP32[4045] = $403;
    $406 = HEAP8[$394 + $403 >> 0] | 0;
    $411 = ($403 | 0) < ($401 | 0);
    if ($411 & (HEAP8[25877 + ($406 & 255) >> 0] | 0) == 1) $404 = $403; else {
     $$lcssa$i$i65 = $411;
     $413 = $406;
     $532 = $403;
     break;
    }
   }
  } else {
   $$lcssa$i$i65 = $400;
   $413 = $395;
   $532 = $storemerge110;
  }
  if (!($413 << 24 >> 24 == 37 | $$lcssa$i$i65 ^ 1)) {
   $$lcssa585 = $401;
   $$lcssa587 = $394;
   $$lcssa589 = $532;
   $$lcssa591 = $413;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 99;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $394 = HEAP32[3993] | 0;
  $401 = HEAP32[3999] | 0;
  $storemerge110 = 0;
 }
 if ((label | 0) == 99) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 L166 : do if ($$lcssa591 << 24 >> 24 == 125) $$lcssa117 = $$lcssa589; else {
  $426 = $$lcssa589;
  $428 = $$lcssa587;
  $438 = $$lcssa585;
  L167 : while (1) {
   HEAP32[4044] = $426;
   $430 = HEAPU8[$428 + $426 >> 0] | 0;
   if ((HEAP8[25877 + $430 >> 0] | 0) == 3) {
    $storemerge111 = 0;
    label = 107;
    break;
   }
   if ((HEAP8[26390 + $430 >> 0] | 0) == 1 & ($426 | 0) < ($438 | 0)) $440 = $426; else {
    $storemerge111 = 0;
    label = 107;
    break;
   }
   while (1) {
    $439 = $440 + 1 | 0;
    HEAP32[4045] = $439;
    $442 = HEAP8[$428 + $439 >> 0] | 0;
    $443 = $442 & 255;
    if (($439 | 0) < ($438 | 0) & (HEAP8[26390 + $443 >> 0] | 0) == 1) $440 = $439; else {
     $$lcssa = $440;
     $$lcssa565 = $439;
     $$lcssa566 = $442;
     $$lcssa567 = $443;
     break;
    }
   }
   if (($$lcssa565 | 0) == ($426 | 0)) {
    $storemerge111 = 0;
    label = 107;
    break;
   }
   if ((HEAP8[25877 + $$lcssa567 >> 0] | 0) == 1 | ($$lcssa565 | 0) == ($438 | 0)) $storemerge112 = 3; else switch ($$lcssa566 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge112 = 1;
     break;
    }
   default:
    {
     $storemerge111 = 2;
     label = 107;
     break L167;
    }
   }
   HEAP8[26389] = $storemerge112;
   if (($$lcssa | 0) < ($426 | 0)) {
    $465 = $426;
    $466 = $$lcssa565;
    $467 = $428;
   } else {
    $i$0$i81 = $426;
    while (1) {
     $456 = $428 + $i$0$i81 | 0;
     $457 = HEAP8[$456 >> 0] | 0;
     if (($457 + -65 & 255) < 26) HEAP8[$456 >> 0] = ($457 & 255) + 32;
     if (($i$0$i81 | 0) < ($$lcssa | 0)) $i$0$i81 = $i$0$i81 + 1 | 0; else break;
    }
    $465 = HEAP32[4044] | 0;
    $466 = HEAP32[4045] | 0;
    $467 = HEAP32[3993] | 0;
   }
   $468 = _zstrlookup($467, $465, $466 - $465 | 0, 11, 1) | 0;
   HEAP32[4310] = $468;
   if (HEAP32[4241] | 0) {
    $$lcssa579 = $468;
    label = 114;
    break;
   }
   HEAP8[(HEAP32[4144] | 0) + $468 >> 0] = 6;
   HEAP32[(HEAP32[4249] | 0) + (HEAP32[4310] << 2) >> 2] = HEAP32[4255];
   HEAP32[4255] = (HEAP32[4255] | 0) + 1;
   $490 = HEAP32[4045] | 0;
   while (1) {
    $488 = HEAP32[3993] | 0;
    $491 = HEAP8[$488 + $490 >> 0] | 0;
    $496 = HEAP32[3999] | 0;
    $497 = ($490 | 0) < ($496 | 0);
    if ((HEAP8[25877 + ($491 & 255) >> 0] | 0) == 1 & $497) {
     $500 = $490;
     while (1) {
      $499 = $500 + 1 | 0;
      HEAP32[4045] = $499;
      $502 = HEAP8[$488 + $499 >> 0] | 0;
      $507 = ($499 | 0) < ($496 | 0);
      if ($507 & (HEAP8[25877 + ($502 & 255) >> 0] | 0) == 1) $500 = $499; else {
       $$lcssa$i$i86 = $507;
       $509 = $502;
       $533 = $499;
       break;
      }
     }
    } else {
     $$lcssa$i$i86 = $497;
     $509 = $491;
     $533 = $490;
    }
    if (!($509 << 24 >> 24 == 37 | $$lcssa$i$i86 ^ 1)) {
     $$lcssa571 = $488;
     $$lcssa573 = $496;
     $$lcssa575 = $533;
     $$lcssa577 = $509;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 121;
     break L167;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $490 = 0;
   }
   if ($$lcssa577 << 24 >> 24 == 125) {
    $$lcssa117 = $$lcssa575;
    break L166;
   } else {
    $426 = $$lcssa575;
    $428 = $$lcssa571;
    $438 = $$lcssa573;
   }
  }
  if ((label | 0) == 107) {
   HEAP8[26389] = $storemerge111;
   _bstidprint();
   _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 114) {
   $473 = HEAP32[(HEAP32[4145] | 0) + ($$lcssa579 << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $473);
   _zoutpoolstr(HEAP32[3989] | 0, $473);
   _fwrite(1858, 20, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1858, 20, 1, HEAP32[3990] | 0) | 0;
   _zprintfnclass($$lcssa579);
   $478 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer40 >> 2] = 1879;
   _fprintf($478, 960, $vararg_buffer40) | 0;
   $479 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer43 >> 2] = 1879;
   _fprintf($479, 960, $vararg_buffer43) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 121) {
   _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1895, 5, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  }
 } while (0);
 HEAP32[4045] = $$lcssa117 + 1;
 STACKTOP = sp;
 return;
}

function __getopt_internal($argc, $argv, $optstring, $longopts, $longind, $long_only) {
 $argc = $argc | 0;
 $argv = $argv | 0;
 $optstring = $optstring | 0;
 $longopts = $longopts | 0;
 $longind = $longind | 0;
 $long_only = $long_only | 0;
 var $$0$i = 0, $$0$i15 = 0, $$012$i = 0, $$012$i16 = 0, $$012$i16$lcssa = 0, $$012$i20 = 0, $$012$i20$lcssa = 0, $$08153 = 0, $$08154 = 0, $$3 = 0, $$lcssa$i = 0, $$lcssa$i38 = 0, $$lcssa238 = 0, $$pre = 0, $$pre140151 = 0, $100 = 0, $102 = 0, $104 = 0, $108 = 0, $110 = 0, $112 = 0, $114 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $125 = 0, $128 = 0, $129 = 0, $130 = 0, $131 = 0, $132 = 0, $137 = 0, $139 = 0, $14 = 0, $141 = 0, $142 = 0, $146 = 0, $149 = 0, $151 = 0, $153 = 0, $158 = 0, $159 = 0, $16 = 0, $161 = 0, $166 = 0, $168 = 0, $172 = 0, $174 = 0, $178 = 0, $18 = 0, $185 = 0, $186 = 0, $187 = 0, $189 = 0, $190 = 0, $2 = 0, $20 = 0, $202 = 0, $204 = 0, $21 = 0, $216 = 0, $219 = 0, $221 = 0, $222 = 0, $224 = 0, $226 = 0, $227 = 0, $232 = 0, $233 = 0, $235 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $243 = 0, $245 = 0, $246 = 0, $250 = 0, $257 = 0, $258 = 0, $26 = 0, $262 = 0, $266 = 0, $267 = 0, $271 = 0, $275 = 0, $277 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $285 = 0, $287 = 0, $292 = 0, $293 = 0, $295 = 0, $300 = 0, $303 = 0, $304 = 0, $305 = 0, $309 = 0, $31 = 0, $313 = 0, $318 = 0, $32 = 0, $320 = 0, $321 = 0, $331 = 0, $335 = 0, $336 = 0, $34 = 0, $346 = 0, $349 = 0, $355 = 0, $36 = 0, $361 = 0, $369 = 0, $37 = 0, $370 = 0, $39 = 0, $4 = 0, $42 = 0, $44 = 0, $45 = 0, $47 = 0, $49 = 0, $53 = 0, $56 = 0, $57 = 0, $63 = 0, $65 = 0, $66 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $79 = 0, $81 = 0, $83 = 0, $86 = 0, $87 = 0, $89 = 0, $91 = 0, $92 = 0, $94 = 0, $97 = 0, $99 = 0, $ambig$097 = 0, $ambig$1 = 0, $ambig$1$lcssa = 0, $ambig5$090 = 0, $ambig5$1 = 0, $ambig5$1$lcssa = 0, $bottom$0$lcssa3$i = 0, $bottom$0$lcssa3$i39 = 0, $bottom$0$ph14$i = 0, $bottom$0$ph14$i25 = 0, $bottom$06$us$i = 0, $bottom$06$us$i35 = 0, $bottom$06$us$us$i = 0, $bottom$06$us$us$i29 = 0, $c$1 = 0, $c$2 = 0, $i$09$i = 0, $i$09$i41 = 0, $i2$04$us$us$i = 0, $i2$04$us$us$i32 = 0, $indfound$098 = 0, $indfound$1 = 0, $indfound$1$lcssa = 0, $indfound$251 = 0, $indfound6$091 = 0, $indfound6$1 = 0, $indfound6$1$lcssa = 0, $indfound6$256 = 0, $nameend$0 = 0, $nameend$0$lcssa = 0, $nameend1$0 = 0, $nameend1$0$lcssa = 0, $option_index$099 = 0, $option_index7$092 = 0, $p$095 = 0, $p2$088 = 0, $pfound$096 = 0, $pfound$1 = 0, $pfound$1$lcssa = 0, $pfound$250 = 0, $pfound3$089 = 0, $pfound3$1 = 0, $pfound3$1$lcssa = 0, $pfound3$255 = 0, $top$0$ph13$i = 0, $top$0$ph13$i26 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer15 = 0, $vararg_buffer19 = 0, $vararg_buffer2 = 0, $vararg_buffer24 = 0, $vararg_buffer28 = 0, $vararg_buffer32 = 0, $vararg_buffer36 = 0, $vararg_buffer40 = 0, $vararg_buffer44 = 0, $vararg_buffer48 = 0, $vararg_buffer6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $vararg_buffer48 = sp + 112 | 0;
 $vararg_buffer44 = sp + 104 | 0;
 $vararg_buffer40 = sp + 96 | 0;
 $vararg_buffer36 = sp + 88 | 0;
 $vararg_buffer32 = sp + 80 | 0;
 $vararg_buffer28 = sp + 72 | 0;
 $vararg_buffer24 = sp + 64 | 0;
 $vararg_buffer19 = sp + 48 | 0;
 $vararg_buffer15 = sp + 40 | 0;
 $vararg_buffer11 = sp + 32 | 0;
 $vararg_buffer6 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 HEAP32[5750] = 0;
 $2 = HEAP32[18] | 0;
 if ((HEAP32[5751] | 0) == 0 | ($2 | 0) == 0) {
  HEAP32[18] = 1;
  HEAP32[5752] = 1;
  HEAP32[5753] = 1;
  HEAP32[5754] = 0;
  $4 = _getenv(12778) | 0;
  HEAP32[5755] = $4;
  L3 : do switch (HEAP8[$optstring >> 0] | 0) {
  case 45:
   {
    HEAP32[5756] = 2;
    $$0$i = $optstring + 1 | 0;
    break;
   }
  case 43:
   {
    HEAP32[5756] = 0;
    $$0$i = $optstring + 1 | 0;
    break;
   }
  default:
   if (!$4) {
    HEAP32[5756] = 1;
    $$0$i = $optstring;
    break L3;
   } else {
    HEAP32[5756] = 0;
    $$0$i = $optstring;
    break L3;
   }
  } while (0);
  HEAP32[18] = 1;
  HEAP32[5751] = 1;
  $$08154 = $$0$i;
  $$pre140151 = 1;
  label = 11;
 } else {
  $$pre = HEAP32[5754] | 0;
  if (!$$pre) {
   $$08154 = $optstring;
   $$pre140151 = $2;
   label = 11;
  } else if (!(HEAP8[$$pre >> 0] | 0)) {
   $$08154 = $optstring;
   $$pre140151 = $2;
   label = 11;
  } else {
   $$08153 = $optstring;
   $128 = $2;
   $149 = $$pre;
  }
 }
 L13 : do if ((label | 0) == 11) {
  $12 = HEAP32[5752] | 0;
  if (($12 | 0) > ($$pre140151 | 0)) {
   HEAP32[5752] = $$pre140151;
   $20 = $$pre140151;
  } else $20 = $12;
  $14 = HEAP32[5753] | 0;
  if (($14 | 0) > ($$pre140151 | 0)) {
   HEAP32[5753] = $$pre140151;
   $18 = $$pre140151;
  } else $18 = $14;
  $16 = HEAP32[5756] | 0;
  if (($16 | 0) == 1) {
   $21 = ($$pre140151 | 0) == ($20 | 0);
   if (($18 | 0) == ($20 | 0) | $21) if ($21) $369 = $18; else {
    HEAP32[5753] = $$pre140151;
    $369 = $$pre140151;
   } else {
    L27 : do if (($18 | 0) < ($20 | 0) & ($$pre140151 | 0) > ($20 | 0)) {
     $bottom$0$ph14$i = $18;
     $top$0$ph13$i = $$pre140151;
     while (1) {
      $24 = $top$0$ph13$i - $20 | 0;
      L30 : do if (($24 | 0) > 0) {
       $bottom$06$us$us$i = $bottom$0$ph14$i;
       while (1) {
        $26 = $20 - $bottom$06$us$us$i | 0;
        if (($24 | 0) > ($26 | 0)) {
         $$lcssa$i = $26;
         $bottom$0$lcssa3$i = $bottom$06$us$us$i;
         break L30;
        } else $i2$04$us$us$i = 0;
        while (1) {
         $31 = $argv + ($i2$04$us$us$i + $bottom$06$us$us$i << 2) | 0;
         $32 = HEAP32[$31 >> 2] | 0;
         $34 = $argv + ($i2$04$us$us$i + $20 << 2) | 0;
         HEAP32[$31 >> 2] = HEAP32[$34 >> 2];
         HEAP32[$34 >> 2] = $32;
         $36 = $i2$04$us$us$i + 1 | 0;
         if (($36 | 0) == ($24 | 0)) break; else $i2$04$us$us$i = $36;
        }
        $28 = $bottom$06$us$us$i + $24 | 0;
        if (($20 | 0) > ($28 | 0)) $bottom$06$us$us$i = $28; else break L27;
       }
      } else {
       $bottom$06$us$i = $bottom$0$ph14$i;
       while (1) {
        $37 = $20 - $bottom$06$us$i | 0;
        if (($24 | 0) > ($37 | 0)) {
         $$lcssa$i = $37;
         $bottom$0$lcssa3$i = $bottom$06$us$i;
         break L30;
        }
        $39 = $bottom$06$us$i + $24 | 0;
        if (($20 | 0) > ($39 | 0)) $bottom$06$us$i = $39; else break L27;
       }
      } while (0);
      $42 = $top$0$ph13$i - $$lcssa$i | 0;
      if (($$lcssa$i | 0) > 0) {
       $i$09$i = 0;
       while (1) {
        $44 = $argv + ($i$09$i + $bottom$0$lcssa3$i << 2) | 0;
        $45 = HEAP32[$44 >> 2] | 0;
        $47 = $argv + ($i$09$i + $42 << 2) | 0;
        HEAP32[$44 >> 2] = HEAP32[$47 >> 2];
        HEAP32[$47 >> 2] = $45;
        $49 = $i$09$i + 1 | 0;
        if (($49 | 0) == ($$lcssa$i | 0)) break; else $i$09$i = $49;
       }
      }
      if (($42 | 0) > ($20 | 0) & ($20 | 0) > ($bottom$0$lcssa3$i | 0)) {
       $bottom$0$ph14$i = $bottom$0$lcssa3$i;
       $top$0$ph13$i = $42;
      } else break;
     }
    } while (0);
    $53 = $18 - $20 + $$pre140151 | 0;
    HEAP32[5753] = $53;
    HEAP32[5752] = $$pre140151;
    $369 = $53;
   }
   L46 : do if (($$pre140151 | 0) < ($argc | 0)) {
    $56 = $$pre140151;
    while (1) {
     $57 = HEAP32[$argv + ($56 << 2) >> 2] | 0;
     if ((HEAP8[$57 >> 0] | 0) == 45) if (HEAP8[$57 + 1 >> 0] | 0) {
      $65 = $56;
      break L46;
     }
     $63 = $56 + 1 | 0;
     HEAP32[18] = $63;
     if (($63 | 0) < ($argc | 0)) $56 = $63; else {
      $65 = $63;
      break;
     }
    }
   } else $65 = $$pre140151; while (0);
   HEAP32[5752] = $65;
   $66 = $65;
   $73 = $369;
   $75 = $65;
  } else {
   $66 = $$pre140151;
   $73 = $18;
   $75 = $20;
  }
  do if (($66 | 0) == ($argc | 0)) {
   $110 = $73;
   $112 = $75;
  } else {
   if (_strcmp(HEAP32[$argv + ($66 << 2) >> 2] | 0, 12794) | 0) {
    if (($66 | 0) == ($argc | 0)) {
     $110 = $73;
     $112 = $75;
     break;
    }
    $114 = HEAP32[$argv + ($66 << 2) >> 2] | 0;
    $117 = $114;
    if ((HEAP8[$114 >> 0] | 0) == 45) {
     $118 = $114 + 1 | 0;
     $119 = HEAP8[$118 >> 0] | 0;
     if ($119 << 24 >> 24) {
      $125 = $118 + (($longopts | 0) != 0 & $119 << 24 >> 24 == 45 & 1) | 0;
      HEAP32[5754] = $125;
      $$08153 = $$08154;
      $128 = $66;
      $149 = $125;
      break L13;
     }
    }
    if (!$16) {
     $$3 = -1;
     STACKTOP = sp;
     return $$3 | 0;
    }
    HEAP32[18] = $66 + 1;
    HEAP32[5750] = $117;
    $$3 = 1;
    STACKTOP = sp;
    return $$3 | 0;
   }
   $72 = $66 + 1 | 0;
   HEAP32[18] = $72;
   $74 = ($73 | 0) == ($75 | 0);
   if ($74 | ($72 | 0) == ($75 | 0)) if ($74) {
    HEAP32[5753] = $72;
    $370 = $72;
   } else $370 = $73; else {
    L72 : do if (($66 | 0) >= ($75 | 0) & ($75 | 0) > ($73 | 0)) {
     $bottom$0$ph14$i25 = $73;
     $top$0$ph13$i26 = $72;
     while (1) {
      $79 = $top$0$ph13$i26 - $75 | 0;
      L75 : do if (($79 | 0) > 0) {
       $bottom$06$us$us$i29 = $bottom$0$ph14$i25;
       while (1) {
        $81 = $75 - $bottom$06$us$us$i29 | 0;
        if (($79 | 0) > ($81 | 0)) {
         $$lcssa$i38 = $81;
         $bottom$0$lcssa3$i39 = $bottom$06$us$us$i29;
         break L75;
        } else $i2$04$us$us$i32 = 0;
        while (1) {
         $86 = $argv + ($i2$04$us$us$i32 + $bottom$06$us$us$i29 << 2) | 0;
         $87 = HEAP32[$86 >> 2] | 0;
         $89 = $argv + ($i2$04$us$us$i32 + $75 << 2) | 0;
         HEAP32[$86 >> 2] = HEAP32[$89 >> 2];
         HEAP32[$89 >> 2] = $87;
         $91 = $i2$04$us$us$i32 + 1 | 0;
         if (($91 | 0) == ($79 | 0)) break; else $i2$04$us$us$i32 = $91;
        }
        $83 = $bottom$06$us$us$i29 + $79 | 0;
        if (($75 | 0) > ($83 | 0)) $bottom$06$us$us$i29 = $83; else break L72;
       }
      } else {
       $bottom$06$us$i35 = $bottom$0$ph14$i25;
       while (1) {
        $92 = $75 - $bottom$06$us$i35 | 0;
        if (($79 | 0) > ($92 | 0)) {
         $$lcssa$i38 = $92;
         $bottom$0$lcssa3$i39 = $bottom$06$us$i35;
         break L75;
        }
        $94 = $bottom$06$us$i35 + $79 | 0;
        if (($75 | 0) > ($94 | 0)) $bottom$06$us$i35 = $94; else break L72;
       }
      } while (0);
      $97 = $top$0$ph13$i26 - $$lcssa$i38 | 0;
      if (($$lcssa$i38 | 0) > 0) {
       $i$09$i41 = 0;
       while (1) {
        $99 = $argv + ($i$09$i41 + $bottom$0$lcssa3$i39 << 2) | 0;
        $100 = HEAP32[$99 >> 2] | 0;
        $102 = $argv + ($i$09$i41 + $97 << 2) | 0;
        HEAP32[$99 >> 2] = HEAP32[$102 >> 2];
        HEAP32[$102 >> 2] = $100;
        $104 = $i$09$i41 + 1 | 0;
        if (($104 | 0) == ($$lcssa$i38 | 0)) break; else $i$09$i41 = $104;
       }
      }
      if (($97 | 0) > ($75 | 0) & ($75 | 0) > ($bottom$0$lcssa3$i39 | 0)) {
       $bottom$0$ph14$i25 = $bottom$0$lcssa3$i39;
       $top$0$ph13$i26 = $97;
      } else break;
     }
    } while (0);
    $108 = $73 + $72 - $75 | 0;
    HEAP32[5753] = $108;
    HEAP32[5752] = $72;
    $370 = $108;
   }
   HEAP32[5752] = $argc;
   HEAP32[18] = $argc;
   $110 = $370;
   $112 = $argc;
  } while (0);
  if (($110 | 0) == ($112 | 0)) {
   $$3 = -1;
   STACKTOP = sp;
   return $$3 | 0;
  }
  HEAP32[18] = $110;
  $$3 = -1;
  STACKTOP = sp;
  return $$3 | 0;
 } while (0);
 L97 : do if ($longopts | 0) {
  $129 = HEAP32[$argv + ($128 << 2) >> 2] | 0;
  $130 = $129 + 1 | 0;
  $131 = HEAP8[$130 >> 0] | 0;
  $132 = $131 << 24 >> 24 == 45;
  L99 : do if ($132) $nameend$0 = $149; else {
   if (!$long_only) break L97;
   if (!(HEAP8[$129 + 2 >> 0] | 0)) {
    $137 = HEAP8[$$08153 >> 0] | 0;
    if (!($137 << 24 >> 24)) $nameend$0 = $149; else {
     $$012$i20 = $$08153;
     $139 = $137;
     while (1) {
      if ($139 << 24 >> 24 == $131 << 24 >> 24) {
       $$012$i20$lcssa = $$012$i20;
       break;
      }
      $141 = $$012$i20 + 1 | 0;
      $142 = HEAP8[$141 >> 0] | 0;
      if (!($142 << 24 >> 24)) {
       $nameend$0 = $149;
       break L99;
      } else {
       $$012$i20 = $141;
       $139 = $142;
      }
     }
     if (!$$012$i20$lcssa) $nameend$0 = $149; else break L97;
    }
   } else $nameend$0 = $149;
  } while (0);
  L107 : while (1) {
   switch (HEAP8[$nameend$0 >> 0] | 0) {
   case 61:
   case 0:
    {
     $nameend$0$lcssa = $nameend$0;
     break L107;
     break;
    }
   default:
    {}
   }
   $nameend$0 = $nameend$0 + 1 | 0;
  }
  $146 = HEAP32[$longopts >> 2] | 0;
  if ($146 | 0) {
   $151 = $nameend$0$lcssa - $149 | 0;
   $153 = $146;
   $ambig$097 = 0;
   $indfound$098 = -1;
   $option_index$099 = 0;
   $p$095 = $longopts;
   $pfound$096 = 0;
   while (1) {
    if (!(_strncmp($153, $149, $151) | 0)) {
     if (($151 | 0) == (_strlen($153) | 0)) {
      $indfound$251 = $option_index$099;
      $pfound$250 = $p$095;
      break;
     }
     $158 = ($pfound$096 | 0) == 0;
     $ambig$1 = $158 ? $ambig$097 : 1;
     $indfound$1 = $158 ? $option_index$099 : $indfound$098;
     $pfound$1 = $158 ? $p$095 : $pfound$096;
    } else {
     $ambig$1 = $ambig$097;
     $indfound$1 = $indfound$098;
     $pfound$1 = $pfound$096;
    }
    $159 = $p$095 + 16 | 0;
    $161 = HEAP32[$159 >> 2] | 0;
    if (!$161) {
     $ambig$1$lcssa = $ambig$1;
     $indfound$1$lcssa = $indfound$1;
     $pfound$1$lcssa = $pfound$1;
     label = 76;
     break;
    } else {
     $153 = $161;
     $ambig$097 = $ambig$1;
     $indfound$098 = $indfound$1;
     $option_index$099 = $option_index$099 + 1 | 0;
     $p$095 = $159;
     $pfound$096 = $pfound$1;
    }
   }
   if ((label | 0) == 76) if (!$ambig$1$lcssa) {
    $indfound$251 = $indfound$1$lcssa;
    $pfound$250 = $pfound$1$lcssa;
   } else {
    if (!(HEAP32[19] | 0)) {
     $168 = $149;
     $172 = $128;
    } else {
     $166 = HEAP32[21] | 0;
     HEAP32[$vararg_buffer >> 2] = HEAP32[$argv >> 2];
     HEAP32[$vararg_buffer + 4 >> 2] = $129;
     _fprintf($166, 12797, $vararg_buffer) | 0;
     $168 = HEAP32[5754] | 0;
     $172 = HEAP32[18] | 0;
    }
    HEAP32[5754] = $168 + (_strlen($168) | 0);
    HEAP32[18] = $172 + 1;
    HEAP32[20] = 0;
    $$3 = 63;
    STACKTOP = sp;
    return $$3 | 0;
   }
   if ($pfound$250 | 0) {
    $174 = $128 + 1 | 0;
    HEAP32[18] = $174;
    $178 = HEAP32[$pfound$250 + 4 >> 2] | 0;
    do if (!(HEAP8[$nameend$0$lcssa >> 0] | 0)) {
     if (($178 | 0) == 1) {
      if (($174 | 0) < ($argc | 0)) {
       HEAP32[18] = $128 + 2;
       HEAP32[5750] = HEAP32[$argv + ($174 << 2) >> 2];
       break;
      }
      if (!(HEAP32[19] | 0)) $204 = $149; else {
       $202 = HEAP32[21] | 0;
       HEAP32[$vararg_buffer11 >> 2] = HEAP32[$argv >> 2];
       HEAP32[$vararg_buffer11 + 4 >> 2] = $129;
       _fprintf($202, 12917, $vararg_buffer11) | 0;
       $204 = HEAP32[5754] | 0;
      }
      HEAP32[5754] = $204 + (_strlen($204) | 0);
      HEAP32[20] = HEAP32[$pfound$250 + 12 >> 2];
      $$3 = (HEAP8[$$08153 >> 0] | 0) == 58 ? 58 : 63;
      STACKTOP = sp;
      return $$3 | 0;
     }
    } else {
     if ($178 | 0) {
      HEAP32[5750] = $nameend$0$lcssa + 1;
      break;
     }
     do if (HEAP32[19] | 0) {
      $185 = HEAP32[21] | 0;
      $186 = HEAP32[$argv >> 2] | 0;
      $187 = HEAP32[$pfound$250 >> 2] | 0;
      if ((HEAP8[$130 >> 0] | 0) == 45) {
       HEAP32[$vararg_buffer2 >> 2] = $186;
       HEAP32[$vararg_buffer2 + 4 >> 2] = $187;
       _fprintf($185, 12827, $vararg_buffer2) | 0;
       break;
      } else {
       $189 = HEAP8[$129 >> 0] | 0;
       HEAP32[$vararg_buffer6 >> 2] = $186;
       HEAP32[$vararg_buffer6 + 4 >> 2] = $189;
       HEAP32[$vararg_buffer6 + 8 >> 2] = $187;
       _fprintf($185, 12872, $vararg_buffer6) | 0;
       break;
      }
     } while (0);
     $190 = HEAP32[5754] | 0;
     HEAP32[5754] = $190 + (_strlen($190) | 0);
     HEAP32[20] = HEAP32[$pfound$250 + 12 >> 2];
     $$3 = 63;
     STACKTOP = sp;
     return $$3 | 0;
    } while (0);
    HEAP32[5754] = $149 + (_strlen($149) | 0);
    if ($longind | 0) HEAP32[$longind >> 2] = $indfound$251;
    $216 = HEAP32[$pfound$250 + 8 >> 2] | 0;
    $219 = HEAP32[$pfound$250 + 12 >> 2] | 0;
    if (!$216) {
     $$3 = $219;
     STACKTOP = sp;
     return $$3 | 0;
    }
    HEAP32[$216 >> 2] = $219;
    $$3 = 0;
    STACKTOP = sp;
    return $$3 | 0;
   }
  }
  L158 : do if (!(($long_only | 0) == 0 | $132)) {
   $221 = HEAP8[$149 >> 0] | 0;
   $222 = HEAP8[$$08153 >> 0] | 0;
   if ($222 << 24 >> 24) {
    $$012$i16 = $$08153;
    $224 = $222;
    while (1) {
     if ($224 << 24 >> 24 == $221 << 24 >> 24) {
      $$012$i16$lcssa = $$012$i16;
      break;
     }
     $226 = $$012$i16 + 1 | 0;
     $227 = HEAP8[$226 >> 0] | 0;
     if (!($227 << 24 >> 24)) break L158; else {
      $$012$i16 = $226;
      $224 = $227;
     }
    }
    if ($$012$i16$lcssa | 0) break L97;
   }
  } while (0);
  do if (HEAP32[19] | 0) {
   $232 = HEAP32[21] | 0;
   $233 = HEAP32[$argv >> 2] | 0;
   if ($132) {
    HEAP32[$vararg_buffer15 >> 2] = $233;
    HEAP32[$vararg_buffer15 + 4 >> 2] = $149;
    _fprintf($232, 12955, $vararg_buffer15) | 0;
    break;
   } else {
    $235 = HEAP8[$129 >> 0] | 0;
    HEAP32[$vararg_buffer19 >> 2] = $233;
    HEAP32[$vararg_buffer19 + 4 >> 2] = $235;
    HEAP32[$vararg_buffer19 + 8 >> 2] = $149;
    _fprintf($232, 12987, $vararg_buffer19) | 0;
    break;
   }
  } while (0);
  HEAP32[5754] = 30748;
  HEAP32[18] = (HEAP32[18] | 0) + 1;
  HEAP32[20] = 0;
  $$3 = 63;
  STACKTOP = sp;
  return $$3 | 0;
 } while (0);
 $238 = $149 + 1 | 0;
 HEAP32[5754] = $238;
 $239 = HEAP8[$149 >> 0] | 0;
 $240 = $239 << 24 >> 24;
 $241 = HEAP8[$$08153 >> 0] | 0;
 L173 : do if (!($241 << 24 >> 24)) $$0$i15 = 0; else {
  $$012$i = $$08153;
  $243 = $241;
  while (1) {
   if ($243 << 24 >> 24 == $239 << 24 >> 24) {
    $$0$i15 = $$012$i;
    break L173;
   }
   $245 = $$012$i + 1 | 0;
   $246 = HEAP8[$245 >> 0] | 0;
   if (!($246 << 24 >> 24)) {
    $$0$i15 = 0;
    break;
   } else {
    $$012$i = $245;
    $243 = $246;
   }
  }
 } while (0);
 if (!(HEAP8[$238 >> 0] | 0)) {
  $250 = $128 + 1 | 0;
  HEAP32[18] = $250;
  $267 = $250;
 } else $267 = $128;
 if ($239 << 24 >> 24 == 58 | ($$0$i15 | 0) == 0) {
  do if (HEAP32[19] | 0) {
   $257 = HEAP32[21] | 0;
   $258 = HEAP32[$argv >> 2] | 0;
   if (!(HEAP32[5755] | 0)) {
    HEAP32[$vararg_buffer28 >> 2] = $258;
    HEAP32[$vararg_buffer28 + 4 >> 2] = $240;
    _fprintf($257, 13045, $vararg_buffer28) | 0;
    break;
   } else {
    HEAP32[$vararg_buffer24 >> 2] = $258;
    HEAP32[$vararg_buffer24 + 4 >> 2] = $240;
    _fprintf($257, 13019, $vararg_buffer24) | 0;
    break;
   }
  } while (0);
  HEAP32[20] = $240;
  $$3 = 63;
  STACKTOP = sp;
  return $$3 | 0;
 }
 $262 = HEAP8[$$0$i15 + 1 >> 0] | 0;
 if (!((HEAP8[$$0$i15 >> 0] | 0) == 87 & $262 << 24 >> 24 == 59)) {
  do if ($262 << 24 >> 24 == 58) {
   $355 = (HEAP8[$238 >> 0] | 0) != 0;
   if ((HEAP8[$$0$i15 + 2 >> 0] | 0) == 58) {
    if ($355) {
     HEAP32[5750] = $238;
     HEAP32[18] = $267 + 1;
    } else HEAP32[5750] = 0;
    HEAP32[5754] = 0;
    $c$2 = $239;
    break;
   }
   do if ($355) {
    HEAP32[5750] = $238;
    HEAP32[18] = $267 + 1;
    $c$1 = $239;
   } else {
    if (($267 | 0) != ($argc | 0)) {
     HEAP32[18] = $267 + 1;
     HEAP32[5750] = HEAP32[$argv + ($267 << 2) >> 2];
     $c$1 = $239;
     break;
    }
    if (HEAP32[19] | 0) {
     $361 = HEAP32[21] | 0;
     HEAP32[$vararg_buffer48 >> 2] = HEAP32[$argv >> 2];
     HEAP32[$vararg_buffer48 + 4 >> 2] = $240;
     _fprintf($361, 13071, $vararg_buffer48) | 0;
    }
    HEAP32[20] = $240;
    $c$1 = (HEAP8[$$08153 >> 0] | 0) == 58 ? 58 : 63;
   } while (0);
   HEAP32[5754] = 0;
   $c$2 = $c$1;
  } else $c$2 = $239; while (0);
  $$3 = $c$2 << 24 >> 24;
  STACKTOP = sp;
  return $$3 | 0;
 }
 do if (!(HEAP8[$238 >> 0] | 0)) {
  if (($267 | 0) != ($argc | 0)) {
   $275 = $267 + 1 | 0;
   HEAP32[18] = $275;
   $277 = HEAP32[$argv + ($267 << 2) >> 2] | 0;
   HEAP32[5750] = $277;
   $279 = $277;
   $303 = $275;
   break;
  }
  if (HEAP32[19] | 0) {
   $271 = HEAP32[21] | 0;
   HEAP32[$vararg_buffer32 >> 2] = HEAP32[$argv >> 2];
   HEAP32[$vararg_buffer32 + 4 >> 2] = $240;
   _fprintf($271, 13071, $vararg_buffer32) | 0;
  }
  HEAP32[20] = $240;
  $$3 = (HEAP8[$$08153 >> 0] | 0) == 58 ? 58 : 63;
  STACKTOP = sp;
  return $$3 | 0;
 } else {
  HEAP32[5750] = $238;
  $266 = $267 + 1 | 0;
  HEAP32[18] = $266;
  $279 = $238;
  $303 = $266;
 } while (0);
 HEAP32[5754] = $279;
 $nameend1$0 = $279;
 L226 : while (1) {
  $280 = HEAP8[$nameend1$0 >> 0] | 0;
  switch ($280 << 24 >> 24) {
  case 61:
  case 0:
   {
    $$lcssa238 = $280;
    $nameend1$0$lcssa = $nameend1$0;
    break L226;
    break;
   }
  default:
   {}
  }
  $nameend1$0 = $nameend1$0 + 1 | 0;
 }
 $281 = HEAP32[$longopts >> 2] | 0;
 if ($281 | 0) {
  $285 = $nameend1$0$lcssa - $279 | 0;
  $287 = $281;
  $ambig5$090 = 0;
  $indfound6$091 = 0;
  $option_index7$092 = 0;
  $p2$088 = $longopts;
  $pfound3$089 = 0;
  while (1) {
   if (!(_strncmp($287, $279, $285) | 0)) {
    if (($285 | 0) == (_strlen($287) | 0)) {
     $indfound6$256 = $option_index7$092;
     $pfound3$255 = $p2$088;
     break;
    }
    $292 = ($pfound3$089 | 0) == 0;
    $ambig5$1 = $292 ? $ambig5$090 : 1;
    $indfound6$1 = $292 ? $option_index7$092 : $indfound6$091;
    $pfound3$1 = $292 ? $p2$088 : $pfound3$089;
   } else {
    $ambig5$1 = $ambig5$090;
    $indfound6$1 = $indfound6$091;
    $pfound3$1 = $pfound3$089;
   }
   $293 = $p2$088 + 16 | 0;
   $295 = HEAP32[$293 >> 2] | 0;
   if (!$295) {
    $ambig5$1$lcssa = $ambig5$1;
    $indfound6$1$lcssa = $indfound6$1;
    $pfound3$1$lcssa = $pfound3$1;
    label = 137;
    break;
   } else {
    $287 = $295;
    $ambig5$090 = $ambig5$1;
    $indfound6$091 = $indfound6$1;
    $option_index7$092 = $option_index7$092 + 1 | 0;
    $p2$088 = $293;
    $pfound3$089 = $pfound3$1;
   }
  }
  if ((label | 0) == 137) if (!$ambig5$1$lcssa) {
   $indfound6$256 = $indfound6$1$lcssa;
   $pfound3$255 = $pfound3$1$lcssa;
  } else {
   if (!(HEAP32[19] | 0)) {
    $305 = $279;
    $309 = $303;
   } else {
    $300 = HEAP32[21] | 0;
    $304 = HEAP32[$argv + ($303 << 2) >> 2] | 0;
    HEAP32[$vararg_buffer36 >> 2] = HEAP32[$argv >> 2];
    HEAP32[$vararg_buffer36 + 4 >> 2] = $304;
    _fprintf($300, 13110, $vararg_buffer36) | 0;
    $305 = HEAP32[5754] | 0;
    $309 = HEAP32[18] | 0;
   }
   HEAP32[5754] = $305 + (_strlen($305) | 0);
   HEAP32[18] = $309 + 1;
   $$3 = 63;
   STACKTOP = sp;
   return $$3 | 0;
  }
  if ($pfound3$255 | 0) {
   $313 = HEAP32[$pfound3$255 + 4 >> 2] | 0;
   do if (!($$lcssa238 << 24 >> 24)) {
    if (($313 | 0) == 1) {
     if (($303 | 0) < ($argc | 0)) {
      HEAP32[18] = $303 + 1;
      HEAP32[5750] = HEAP32[$argv + ($303 << 2) >> 2];
      break;
     }
     if (!(HEAP32[19] | 0)) $336 = $279; else {
      $331 = HEAP32[21] | 0;
      $335 = HEAP32[$argv + ($303 + -1 << 2) >> 2] | 0;
      HEAP32[$vararg_buffer44 >> 2] = HEAP32[$argv >> 2];
      HEAP32[$vararg_buffer44 + 4 >> 2] = $335;
      _fprintf($331, 12917, $vararg_buffer44) | 0;
      $336 = HEAP32[5754] | 0;
     }
     HEAP32[5754] = $336 + (_strlen($336) | 0);
     $$3 = (HEAP8[$$08153 >> 0] | 0) == 58 ? 58 : 63;
     STACKTOP = sp;
     return $$3 | 0;
    }
   } else {
    if ($313 | 0) {
     HEAP32[5750] = $nameend1$0$lcssa + 1;
     break;
    }
    if (!(HEAP32[19] | 0)) $321 = $279; else {
     $318 = HEAP32[21] | 0;
     $320 = HEAP32[$pfound3$255 >> 2] | 0;
     HEAP32[$vararg_buffer40 >> 2] = HEAP32[$argv >> 2];
     HEAP32[$vararg_buffer40 + 4 >> 2] = $320;
     _fprintf($318, 13143, $vararg_buffer40) | 0;
     $321 = HEAP32[5754] | 0;
    }
    HEAP32[5754] = $321 + (_strlen($321) | 0);
    $$3 = 63;
    STACKTOP = sp;
    return $$3 | 0;
   } while (0);
   HEAP32[5754] = $279 + (_strlen($279) | 0);
   if ($longind | 0) HEAP32[$longind >> 2] = $indfound6$256;
   $346 = HEAP32[$pfound3$255 + 8 >> 2] | 0;
   $349 = HEAP32[$pfound3$255 + 12 >> 2] | 0;
   if (!$346) {
    $$3 = $349;
    STACKTOP = sp;
    return $$3 | 0;
   }
   HEAP32[$346 >> 2] = $349;
   $$3 = 0;
   STACKTOP = sp;
   return $$3 | 0;
  }
 }
 HEAP32[5754] = 0;
 $$3 = 87;
 STACKTOP = sp;
 return $$3 | 0;
}

function _xformatname() {
 var $$lcssa144 = 0, $$lcssa146 = 0, $$pre = 0, $$pre51 = 0, $$pre66 = 0, $$pre69 = 0, $$pre70 = 0, $$pre71 = 0, $0 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $116 = 0, $120 = 0, $123 = 0, $132 = 0, $137 = 0, $142 = 0, $143 = 0, $146 = 0, $15 = 0, $151 = 0, $152 = 0, $16 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $173 = 0, $18 = 0, $181 = 0, $182 = 0, $184 = 0, $190 = 0, $191 = 0, $202 = 0, $206 = 0, $207 = 0, $209 = 0, $21 = 0, $210 = 0, $212 = 0, $220 = 0, $223 = 0, $230 = 0, $231 = 0, $243 = 0, $244 = 0, $25 = 0, $250 = 0, $252 = 0, $253 = 0, $254 = 0, $258 = 0, $26 = 0, $266 = 0, $267 = 0, $271 = 0, $28 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $288 = 0, $291 = 0, $295 = 0, $296 = 0, $298 = 0, $301 = 0, $305 = 0, $307 = 0, $309 = 0, $31 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $35 = 0, $37 = 0, $39 = 0, $42 = 0, $43 = 0, $47 = 0, $48 = 0, $5 = 0, $50 = 0, $51 = 0, $54 = 0, $56 = 0, $57 = 0, $58 = 0, $60 = 0, $62 = 0, $64 = 0, $65 = 0, $66 = 0, $71 = 0, $72 = 0, $75 = 0, $78 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $94 = 0, $95 = 0, $97 = 0, $98 = 0, $storemerge = 0, $storemerge$i = 0, $storemerge$i12 = 0, $storemerge$i12118 = 0, $storemerge$i12120 = 0, $storemerge$i8 = 0, $storemerge$i8112 = 0, $storemerge$i8114 = 0, $storemerge$in = 0, $storemerge$in$i = 0, $storemerge$in$i11$pre = 0, $storemerge$in$i11119 = 0, $storemerge$in$i7$pre = 0, $storemerge$in$i7113 = 0, $storemerge$in$in$i = 0, $storemerge2 = 0, $storemerge235 = 0, $storemerge3 = 0, $storemerge333 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer23 = 0, $vararg_buffer28 = 0, $vararg_buffer3 = 0, $vararg_buffer33 = 0, $vararg_buffer38 = 0, $vararg_buffer41 = 0, $vararg_buffer44 = 0, $vararg_buffer47 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $vararg_buffer47 = sp + 152 | 0;
 $vararg_buffer44 = sp + 144 | 0;
 $vararg_buffer41 = sp + 136 | 0;
 $vararg_buffer38 = sp + 128 | 0;
 $vararg_buffer33 = sp + 112 | 0;
 $vararg_buffer28 = sp + 96 | 0;
 $vararg_buffer23 = sp + 80 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 _zzpoplitstk(17512, 26651);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   $5 = HEAP8[26649] | 0;
   switch ($5 << 24 >> 24) {
   case 0:
    {
     $10 = HEAP8[26651] | 0;
     switch ($10 << 24 >> 24) {
     case 1:
      {
       HEAP32[4333] = 0;
       $15 = HEAP32[4378] | 0;
       $16 = HEAP32[4041] | 0;
       $18 = HEAP32[$16 + ($15 << 2) >> 2] | 0;
       HEAP32[4238] = $18;
       $21 = HEAP32[$16 + ($15 + 1 << 2) >> 2] | 0;
       HEAP32[4239] = $21;
       if (($21 - $18 | 0) > (HEAP32[3992] | 0)) {
        _bufferoverflow();
        $25 = HEAP32[4333] | 0;
        $26 = HEAP32[4238] | 0;
        $28 = HEAP32[4239] | 0;
       } else {
        $25 = 0;
        $26 = $18;
        $28 = $21;
       }
       HEAP32[4251] = $25;
       if (($26 | 0) < ($28 | 0)) {
        $31 = $26;
        $35 = $25;
        while (1) {
         HEAP8[(HEAP32[3995] | 0) + $35 >> 0] = HEAP8[(HEAP32[4042] | 0) + $31 >> 0] | 0;
         $37 = (HEAP32[4251] | 0) + 1 | 0;
         HEAP32[4251] = $37;
         $39 = (HEAP32[4238] | 0) + 1 | 0;
         HEAP32[4238] = $39;
         if (($39 | 0) < (HEAP32[4239] | 0)) {
          $31 = $39;
          $35 = $37;
         } else {
          $42 = $37;
          break;
         }
        }
       } else $42 = $25;
       HEAP32[4333] = $42;
       HEAP32[4251] = 0;
       HEAP32[4379] = 0;
       $43 = HEAP32[4365] | 0;
       if (($43 | 0) > 0 & ($42 | 0) > 0) {
        $47 = 0;
        $48 = 0;
        while (1) {
         HEAP32[4379] = $47 + 1;
         HEAP32[4323] = $48;
         _znamescanforand(HEAP32[4378] | 0);
         $50 = HEAP32[4379] | 0;
         $51 = HEAP32[4365] | 0;
         $$pre = HEAP32[4251] | 0;
         $$pre51 = HEAP32[4333] | 0;
         if (($50 | 0) < ($51 | 0) & ($$pre | 0) < ($$pre51 | 0)) {
          $47 = $50;
          $48 = $$pre;
         } else {
          $54 = $$pre;
          $56 = $$pre51;
          $58 = $50;
          $60 = $51;
          break;
         }
        }
       } else {
        $54 = 0;
        $56 = $42;
        $58 = 0;
        $60 = $43;
       }
       if (($54 | 0) < ($56 | 0)) {
        $57 = $54 + -4 | 0;
        HEAP32[4251] = $57;
        $313 = $57;
       } else $313 = $54;
       if (($58 | 0) < ($60 | 0)) {
        $62 = HEAP32[3989] | 0;
        if (($60 | 0) == 1) {
         _fwrite(3907, 21, 1, $62) | 0;
         _fwrite(3907, 21, 1, HEAP32[3990] | 0) | 0;
        } else {
         HEAP32[$vararg_buffer >> 2] = 3929;
         HEAP32[$vararg_buffer + 4 >> 2] = $60;
         HEAP32[$vararg_buffer + 8 >> 2] = 3943;
         _fprintf($62, 1280, $vararg_buffer) | 0;
         $64 = HEAP32[3990] | 0;
         $65 = HEAP32[4365] | 0;
         HEAP32[$vararg_buffer3 >> 2] = 3929;
         HEAP32[$vararg_buffer3 + 4 >> 2] = $65;
         HEAP32[$vararg_buffer3 + 8 >> 2] = 3943;
         _fprintf($64, 1280, $vararg_buffer3) | 0;
        }
        $66 = HEAP32[4378] | 0;
        _zoutpoolstr(HEAP32[3990] | 0, $66);
        _zoutpoolstr(HEAP32[3989] | 0, $66);
        _putc(34, HEAP32[3989] | 0) | 0;
        _putc(34, HEAP32[3990] | 0) | 0;
        _bstexwarnprint();
        $72 = HEAP32[4251] | 0;
       } else $72 = $313;
       $71 = HEAP32[4323] | 0;
       L31 : do if (($72 | 0) > ($71 | 0)) {
        $314 = $71;
        $75 = $72;
        while (1) {
         $78 = HEAP8[(HEAP32[3995] | 0) + ($75 + -1) >> 0] | 0;
         switch (HEAPU8[25877 + ($78 & 255) >> 0] | 0) {
         case 4:
         case 1:
          {
           $94 = $314;
           $storemerge$in = $75;
           break;
          }
         default:
          {
           if ($78 << 24 >> 24 != 44) {
            $95 = $314;
            $97 = $75;
            break L31;
           }
           $84 = HEAP32[3989] | 0;
           $85 = HEAP32[4365] | 0;
           HEAP32[$vararg_buffer8 >> 2] = 3955;
           HEAP32[$vararg_buffer8 + 4 >> 2] = $85;
           HEAP32[$vararg_buffer8 + 8 >> 2] = 3961;
           _fprintf($84, 1280, $vararg_buffer8) | 0;
           $86 = HEAP32[3990] | 0;
           $87 = HEAP32[4365] | 0;
           HEAP32[$vararg_buffer13 >> 2] = 3955;
           HEAP32[$vararg_buffer13 + 4 >> 2] = $87;
           HEAP32[$vararg_buffer13 + 8 >> 2] = 3961;
           _fprintf($86, 1280, $vararg_buffer13) | 0;
           $88 = HEAP32[4378] | 0;
           _zoutpoolstr(HEAP32[3990] | 0, $88);
           _zoutpoolstr(HEAP32[3989] | 0, $88);
           _fwrite(3967, 24, 1, HEAP32[3989] | 0) | 0;
           _fwrite(3967, 24, 1, HEAP32[3990] | 0) | 0;
           _bstexwarnprint();
           $94 = HEAP32[4323] | 0;
           $storemerge$in = HEAP32[4251] | 0;
          }
         }
         $storemerge = $storemerge$in + -1 | 0;
         HEAP32[4251] = $storemerge;
         if (($storemerge | 0) > ($94 | 0)) {
          $314 = $94;
          $75 = $storemerge;
         } else {
          $95 = $94;
          $97 = $storemerge;
          break L31;
         }
        }
       } else {
        $95 = $71;
        $97 = $72;
       } while (0);
       HEAP32[4335] = 0;
       HEAP32[4380] = 0;
       HEAP32[4381] = 0;
       HEAP32[4382] = 1;
       if (($95 | 0) < ($97 | 0)) {
        $100 = $95;
        $123 = 1;
        while (1) {
         $98 = HEAP32[3995] | 0;
         $101 = HEAP8[$98 + $100 >> 0] | 0;
         $102 = $101 & 255;
         L42 : do switch ($102 | 0) {
         case 44:
          {
           $103 = HEAP32[4380] | 0;
           if (($103 | 0) == 2) {
            $105 = HEAP32[3989] | 0;
            $106 = HEAP32[4365] | 0;
            HEAP32[$vararg_buffer18 >> 2] = 3992;
            HEAP32[$vararg_buffer18 + 4 >> 2] = $106;
            HEAP32[$vararg_buffer18 + 8 >> 2] = 4017;
            _fprintf($105, 1280, $vararg_buffer18) | 0;
            $107 = HEAP32[3990] | 0;
            $108 = HEAP32[4365] | 0;
            HEAP32[$vararg_buffer23 >> 2] = 3992;
            HEAP32[$vararg_buffer23 + 4 >> 2] = $108;
            HEAP32[$vararg_buffer23 + 8 >> 2] = 4017;
            _fprintf($107, 1280, $vararg_buffer23) | 0;
            $109 = HEAP32[4378] | 0;
            _zoutpoolstr(HEAP32[3990] | 0, $109);
            _zoutpoolstr(HEAP32[3989] | 0, $109);
            _putc(34, HEAP32[3989] | 0) | 0;
            _putc(34, HEAP32[3990] | 0) | 0;
            _bstexwarnprint();
           } else {
            HEAP32[4380] = $103 + 1;
            $116 = HEAP32[4381] | 0;
            if (!$103) HEAP32[4383] = $116; else HEAP32[4384] = $116;
            HEAP8[(HEAP32[3998] | 0) + $116 >> 0] = 44;
           }
           $120 = (HEAP32[4323] | 0) + 1 | 0;
           HEAP32[4323] = $120;
           HEAP32[4382] = 1;
           $184 = $120;
           $315 = 1;
           break;
          }
         case 123:
          {
           HEAP32[4330] = (HEAP32[4330] | 0) + 1;
           if (!$123) $132 = $100; else {
            HEAP32[(HEAP32[3997] | 0) + (HEAP32[4381] << 2) >> 2] = HEAP32[4335];
            HEAP32[4381] = (HEAP32[4381] | 0) + 1;
            $132 = HEAP32[4323] | 0;
           }
           HEAP8[(HEAP32[3994] | 0) + (HEAP32[4335] | 0) >> 0] = HEAP8[$98 + $132 >> 0] | 0;
           $storemerge333 = (HEAP32[4335] | 0) + 1 | 0;
           HEAP32[4335] = $storemerge333;
           $storemerge235 = (HEAP32[4323] | 0) + 1 | 0;
           HEAP32[4323] = $storemerge235;
           $137 = HEAP32[4330] | 0;
           L70 : do if (($137 | 0) > 0 & ($storemerge235 | 0) < (HEAP32[4251] | 0)) {
            $143 = $storemerge235;
            $146 = $137;
            $151 = $storemerge333;
            while (1) {
             $142 = (HEAP32[3995] | 0) + $143 | 0;
             switch (HEAP8[$142 >> 0] | 0) {
             case 125:
              {
               HEAP32[4330] = $146 + -1;
               break;
              }
             case 123:
              {
               HEAP32[4330] = $146 + 1;
               break;
              }
             default:
              {}
             }
             HEAP8[(HEAP32[3994] | 0) + $151 >> 0] = HEAP8[$142 >> 0] | 0;
             $storemerge3 = (HEAP32[4335] | 0) + 1 | 0;
             HEAP32[4335] = $storemerge3;
             $storemerge2 = (HEAP32[4323] | 0) + 1 | 0;
             HEAP32[4323] = $storemerge2;
             $152 = HEAP32[4330] | 0;
             if (($152 | 0) > 0 & ($storemerge2 | 0) < (HEAP32[4251] | 0)) {
              $143 = $storemerge2;
              $146 = $152;
              $151 = $storemerge3;
             } else {
              $316 = $storemerge2;
              break L70;
             }
            }
           } else $316 = $storemerge235; while (0);
           HEAP32[4382] = 0;
           $184 = $316;
           $315 = 0;
           break;
          }
         case 125:
          {
           if ($123 | 0) {
            HEAP32[(HEAP32[3997] | 0) + (HEAP32[4381] << 2) >> 2] = HEAP32[4335];
            HEAP32[4381] = (HEAP32[4381] | 0) + 1;
           }
           $163 = HEAP32[3989] | 0;
           $164 = HEAP32[4365] | 0;
           HEAP32[$vararg_buffer28 >> 2] = 3955;
           HEAP32[$vararg_buffer28 + 4 >> 2] = $164;
           HEAP32[$vararg_buffer28 + 8 >> 2] = 4017;
           _fprintf($163, 1280, $vararg_buffer28) | 0;
           $165 = HEAP32[3990] | 0;
           $166 = HEAP32[4365] | 0;
           HEAP32[$vararg_buffer33 >> 2] = 3955;
           HEAP32[$vararg_buffer33 + 4 >> 2] = $166;
           HEAP32[$vararg_buffer33 + 8 >> 2] = 4017;
           _fprintf($165, 1280, $vararg_buffer33) | 0;
           $167 = HEAP32[4378] | 0;
           _zoutpoolstr(HEAP32[3990] | 0, $167);
           _zoutpoolstr(HEAP32[3989] | 0, $167);
           _fwrite(4023, 22, 1, HEAP32[3989] | 0) | 0;
           _fwrite(4023, 22, 1, HEAP32[3990] | 0) | 0;
           _bstexwarnprint();
           $173 = (HEAP32[4323] | 0) + 1 | 0;
           HEAP32[4323] = $173;
           HEAP32[4382] = 0;
           $184 = $173;
           $315 = 0;
           break;
          }
         default:
          switch (HEAPU8[25877 + $102 >> 0] | 0) {
          case 1:
           {
            if (!$123) {
             HEAP8[(HEAP32[3998] | 0) + (HEAP32[4381] | 0) >> 0] = 32;
             $182 = HEAP32[4323] | 0;
            } else $182 = $100;
            $181 = $182 + 1 | 0;
            HEAP32[4323] = $181;
            HEAP32[4382] = 1;
            $184 = $181;
            $315 = 1;
            break L42;
            break;
           }
          case 4:
           {
            if (!$123) {
             HEAP8[(HEAP32[3998] | 0) + (HEAP32[4381] | 0) >> 0] = $101;
             $191 = HEAP32[4323] | 0;
            } else $191 = $100;
            $190 = $191 + 1 | 0;
            HEAP32[4323] = $190;
            HEAP32[4382] = 1;
            $184 = $190;
            $315 = 1;
            break L42;
            break;
           }
          default:
           {
            if (!$123) $202 = $101; else {
             HEAP32[(HEAP32[3997] | 0) + (HEAP32[4381] << 2) >> 2] = HEAP32[4335];
             HEAP32[4381] = (HEAP32[4381] | 0) + 1;
             $202 = HEAP8[$98 + (HEAP32[4323] | 0) >> 0] | 0;
            }
            HEAP8[(HEAP32[3994] | 0) + (HEAP32[4335] | 0) >> 0] = $202;
            HEAP32[4335] = (HEAP32[4335] | 0) + 1;
            $206 = (HEAP32[4323] | 0) + 1 | 0;
            HEAP32[4323] = $206;
            HEAP32[4382] = 0;
            $184 = $206;
            $315 = 0;
            break L42;
           }
          }
         } while (0);
         if (($184 | 0) < (HEAP32[4251] | 0)) {
          $100 = $184;
          $123 = $315;
         } else break;
        }
        $209 = HEAP32[4381] | 0;
        $210 = HEAP32[4335] | 0;
       } else {
        $209 = 0;
        $210 = 0;
       }
       $207 = HEAP32[3997] | 0;
       HEAP32[$207 + ($209 << 2) >> 2] = $210;
       L85 : do switch (HEAP32[4380] | 0) {
       case 0:
        {
         HEAP32[4353] = 0;
         $212 = HEAP32[4381] | 0;
         HEAP32[4339] = $212;
         HEAP32[4357] = $212;
         HEAP32[4341] = 0;
         L88 : do if (($212 | 0) > 1) {
          HEAP32[4335] = HEAP32[$207 >> 2];
          HEAP32[4336] = HEAP32[$207 + 4 >> 2];
          L90 : do if (!(_vontokenfound() | 0)) {
           while (1) {
            $230 = HEAP32[4341] | 0;
            $231 = $230 + 1 | 0;
            HEAP32[4341] = $231;
            if (($231 | 0) >= ((HEAP32[4339] | 0) + -1 | 0)) {
             $$lcssa144 = $230;
             $$lcssa146 = $231;
             break;
            }
            $$pre70 = HEAP32[3997] | 0;
            HEAP32[4335] = HEAP32[$$pre70 + ($231 << 2) >> 2];
            HEAP32[4336] = HEAP32[$$pre70 + ($230 + 2 << 2) >> 2];
            if (_vontokenfound() | 0) {
             $storemerge$in$in$i = 17356;
             break L90;
            }
           }
           if (($$lcssa144 | 0) <= -1) {
            $252 = $$lcssa146;
            label = 72;
            break L88;
           }
           $$pre71 = HEAP32[3998] | 0;
           $243 = $$lcssa146;
           while (1) {
            $244 = HEAP8[$$pre71 + $243 >> 0] | 0;
            if ($244 << 24 >> 24 == 126 ? 1 : (HEAP8[25877 + ($244 & 255) >> 0] | 0) != 4) {
             $252 = $243;
             label = 72;
             break L88;
            }
            $250 = $243 + -1 | 0;
            HEAP32[4341] = $250;
            if (($243 | 0) > 1) $243 = $250; else {
             $252 = $250;
             label = 72;
             break L88;
            }
           }
          } else $storemerge$in$in$i = 17356; while (0);
          while (1) {
           $storemerge$in$i = HEAP32[$storemerge$in$in$i >> 2] | 0;
           $storemerge$i = $storemerge$in$i + -1 | 0;
           HEAP32[4340] = $storemerge$i;
           $220 = HEAP32[4341] | 0;
           if (($storemerge$i | 0) <= ($220 | 0)) {
            $253 = $220;
            break L88;
           }
           $223 = HEAP32[3997] | 0;
           HEAP32[4335] = HEAP32[$223 + ($storemerge$in$i + -2 << 2) >> 2];
           HEAP32[4336] = HEAP32[$223 + ($storemerge$i << 2) >> 2];
           if (!(_vontokenfound() | 0)) $storemerge$in$in$i = 17360; else break;
          }
          $253 = HEAP32[4341] | 0;
         } else {
          $252 = 0;
          label = 72;
         } while (0);
         if ((label | 0) == 72) {
          HEAP32[4340] = $252;
          $253 = $252;
         }
         HEAP32[4355] = $253;
         break;
        }
       case 1:
        {
         HEAP32[4341] = 0;
         $254 = HEAP32[4383] | 0;
         HEAP32[4339] = $254;
         HEAP32[4357] = $254;
         HEAP32[4353] = $254;
         HEAP32[4355] = HEAP32[4381];
         $storemerge$i8112 = $254 + -1 | 0;
         HEAP32[4340] = $storemerge$i8112;
         if (($254 | 0) > 1) {
          $storemerge$i8114 = $storemerge$i8112;
          $storemerge$in$i7113 = $254;
          while (1) {
           $258 = HEAP32[3997] | 0;
           HEAP32[4335] = HEAP32[$258 + ($storemerge$in$i7113 + -2 << 2) >> 2];
           HEAP32[4336] = HEAP32[$258 + ($storemerge$i8114 << 2) >> 2];
           if (_vontokenfound() | 0) break L85;
           $storemerge$in$i7$pre = HEAP32[4340] | 0;
           $$pre69 = HEAP32[4341] | 0;
           $storemerge$i8 = $storemerge$in$i7$pre + -1 | 0;
           HEAP32[4340] = $storemerge$i8;
           if (($storemerge$i8 | 0) > ($$pre69 | 0)) {
            $storemerge$i8114 = $storemerge$i8;
            $storemerge$in$i7113 = $storemerge$in$i7$pre;
           } else break;
          }
         }
         break;
        }
       case 2:
        {
         HEAP32[4341] = 0;
         $266 = HEAP32[4383] | 0;
         HEAP32[4339] = $266;
         $267 = HEAP32[4384] | 0;
         HEAP32[4357] = $267;
         HEAP32[4353] = $267;
         HEAP32[4355] = HEAP32[4381];
         $storemerge$i12118 = $266 + -1 | 0;
         HEAP32[4340] = $storemerge$i12118;
         if (($266 | 0) > 1) {
          $storemerge$i12120 = $storemerge$i12118;
          $storemerge$in$i11119 = $266;
          while (1) {
           $271 = HEAP32[3997] | 0;
           HEAP32[4335] = HEAP32[$271 + ($storemerge$in$i11119 + -2 << 2) >> 2];
           HEAP32[4336] = HEAP32[$271 + ($storemerge$i12120 << 2) >> 2];
           if (_vontokenfound() | 0) break L85;
           $storemerge$in$i11$pre = HEAP32[4340] | 0;
           $$pre66 = HEAP32[4341] | 0;
           $storemerge$i12 = $storemerge$in$i11$pre + -1 | 0;
           HEAP32[4340] = $storemerge$i12;
           if (($storemerge$i12 | 0) > ($$pre66 | 0)) {
            $storemerge$i12120 = $storemerge$i12;
            $storemerge$in$i11119 = $storemerge$in$i11$pre;
           } else break;
          }
         }
         break;
        }
       default:
        {
         _fwrite(4046, 25, 1, HEAP32[3989] | 0) | 0;
         _fwrite(4046, 25, 1, HEAP32[3990] | 0) | 0;
         $281 = HEAP32[3989] | 0;
         HEAP32[$vararg_buffer38 >> 2] = 964;
         _fprintf($281, 960, $vararg_buffer38) | 0;
         $282 = HEAP32[3990] | 0;
         HEAP32[$vararg_buffer41 >> 2] = 964;
         _fprintf($282, 960, $vararg_buffer41) | 0;
         $283 = HEAP32[3989] | 0;
         HEAP32[$vararg_buffer44 >> 2] = 985;
         _fprintf($283, 960, $vararg_buffer44) | 0;
         $284 = HEAP32[3990] | 0;
         HEAP32[$vararg_buffer47 >> 2] = 985;
         _fprintf($284, 960, $vararg_buffer47) | 0;
         HEAP8[25620] = 3;
         _longjmp(16008, 1);
        }
       } while (0);
       HEAP32[4333] = 0;
       $285 = HEAP32[4345] | 0;
       $286 = HEAP32[4041] | 0;
       $288 = HEAP32[$286 + ($285 << 2) >> 2] | 0;
       HEAP32[4238] = $288;
       $291 = HEAP32[$286 + ($285 + 1 << 2) >> 2] | 0;
       HEAP32[4239] = $291;
       if (($291 - $288 | 0) > (HEAP32[3992] | 0)) {
        _bufferoverflow();
        $295 = HEAP32[4333] | 0;
        $296 = HEAP32[4238] | 0;
        $298 = HEAP32[4239] | 0;
       } else {
        $295 = 0;
        $296 = $288;
        $298 = $291;
       }
       HEAP32[4251] = $295;
       if (($296 | 0) < ($298 | 0)) {
        $301 = $296;
        $305 = $295;
        while (1) {
         HEAP8[(HEAP32[3995] | 0) + $305 >> 0] = HEAP8[(HEAP32[4042] | 0) + $301 >> 0] | 0;
         $307 = (HEAP32[4251] | 0) + 1 | 0;
         HEAP32[4251] = $307;
         $309 = (HEAP32[4238] | 0) + 1 | 0;
         HEAP32[4238] = $309;
         if (($309 | 0) < (HEAP32[4239] | 0)) {
          $301 = $309;
          $305 = $307;
         } else {
          $312 = $307;
          break;
         }
        }
       } else $312 = $295;
       HEAP32[4333] = $312;
       _figureouttheformattedname();
       _addpoolbufandpush();
       STACKTOP = sp;
       return;
      }
     case 4:
      break;
     default:
      {
       _zprintstklit(HEAP32[4378] | 0, $10);
       _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
      }
     }
     _zpushlitstk(HEAP32[4301] | 0, 1);
     STACKTOP = sp;
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit(HEAP32[4365] | 0, $5);
     _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(HEAP32[4301] | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 STACKTOP = sp;
 return;
}

function _scanbalancedbraces() {
 var $$lcssa$i$i = 0, $$lcssa$i$i14 = 0, $$lcssa$i$i20 = 0, $$lcssa$i$i26 = 0, $$lcssa$i$i36 = 0, $$lcssa268 = 0, $$lcssa270 = 0, $$lcssa272 = 0, $$lcssa307 = 0, $$lcssa308 = 0, $$lcssa310 = 0, $$lcssa311 = 0, $$lcssa316 = 0, $$pre$i24 = 0, $$pre$i34 = 0, $$pre3$pre$i = 0, $$pre5$pre$i = 0, $1 = 0, $104 = 0, $116 = 0, $119 = 0, $120 = 0, $121 = 0, $127 = 0, $13 = 0, $141 = 0, $144 = 0, $145 = 0, $146 = 0, $15 = 0, $152 = 0, $16 = 0, $164 = 0, $167 = 0, $170 = 0, $174 = 0, $176 = 0, $182 = 0, $183 = 0, $185 = 0, $186 = 0, $193 = 0, $195 = 0, $208 = 0, $209 = 0, $212 = 0, $215 = 0, $221 = 0, $222 = 0, $224 = 0, $225 = 0, $232 = 0, $247 = 0, $253 = 0, $254 = 0, $256 = 0, $257 = 0, $26 = 0, $264 = 0, $27 = 0, $276 = 0, $279 = 0, $281 = 0, $285 = 0, $288 = 0, $289 = 0, $29 = 0, $295 = 0, $296 = 0, $298 = 0, $299 = 0, $30 = 0, $306 = 0, $31 = 0, $320 = 0, $322 = 0, $323 = 0, $325 = 0, $326 = 0, $328 = 0, $33 = 0, $330 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $340 = 0, $341 = 0, $347 = 0, $348 = 0, $350 = 0, $351 = 0, $358 = 0, $36 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $39 = 0, $40 = 0, $41 = 0, $47 = 0, $62 = 0, $66 = 0, $69 = 0, $70 = 0, $71 = 0, $77 = 0, $93 = 0, $96 = 0, $97 = 0, $98 = 0, $Result$0 = 0, $storemerge = 0, $storemerge41 = 0, $storemerge42 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer23 = 0, $vararg_buffer28 = 0, $vararg_buffer3 = 0, $vararg_buffer33 = 0, $vararg_buffer38 = 0, $vararg_buffer43 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $vararg_buffer43 = sp + 144 | 0;
 $vararg_buffer38 = sp + 128 | 0;
 $vararg_buffer33 = sp + 112 | 0;
 $vararg_buffer28 = sp + 96 | 0;
 $vararg_buffer23 = sp + 80 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $1 = (HEAP32[4045] | 0) + 1 | 0;
 HEAP32[4045] = $1;
 if (($1 | 0) == (HEAP32[3999] | 0) ? 1 : (HEAP8[25877 + (HEAPU8[(HEAP32[3993] | 0) + $1 >> 0] | 0) >> 0] | 0) == 1) if (!(_compressbibwhite() | 0)) {
  $Result$0 = 0;
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 $13 = HEAP32[4251] | 0;
 if (($13 | 0) > 1) {
  $15 = $13 + -1 | 0;
  $16 = HEAP32[3995] | 0;
  if ((HEAP8[$16 + $15 >> 0] | 0) == 32) if ((HEAP8[$16 + ($13 + -2) >> 0] | 0) == 32) HEAP32[4251] = $15;
 }
 HEAP32[4317] = 0;
 $26 = HEAP32[4045] | 0;
 $27 = HEAP32[3993] | 0;
 $29 = HEAP8[$27 + $26 >> 0] | 0;
 $30 = HEAP8[26646] | 0;
 $31 = $29 << 24 >> 24 == $30 << 24 >> 24;
 L10 : do if (!(HEAP32[4318] | 0)) if ($31) $371 = $26; else {
  $170 = $29;
  $174 = $26;
  $322 = $27;
  $325 = $30;
  L12 : while (1) {
   L14 : do switch ($170 << 24 >> 24) {
   case 125:
    {
     label = 70;
     break L12;
     break;
    }
   case 123:
    {
     HEAP32[4317] = (HEAP32[4317] | 0) + 1;
     $176 = $322;
     $storemerge = $174 + 1 | 0;
     while (1) {
      HEAP32[4045] = $storemerge;
      $182 = HEAP32[3999] | 0;
      $183 = ($storemerge | 0) < ($182 | 0);
      if ((HEAP8[25877 + (HEAPU8[$176 + $storemerge >> 0] | 0) >> 0] | 0) == 1 & $183) {
       $186 = $storemerge;
       while (1) {
        $185 = $186 + 1 | 0;
        HEAP32[4045] = $185;
        $193 = ($185 | 0) < ($182 | 0);
        if ($193 & (HEAP8[25877 + (HEAPU8[$176 + $185 >> 0] | 0) >> 0] | 0) == 1) $186 = $185; else {
         $$lcssa$i$i = $193;
         $372 = $185;
         break;
        }
       }
      } else {
       $$lcssa$i$i = $183;
       $372 = $storemerge;
      }
      if ($$lcssa$i$i) {
       $$lcssa268 = $176;
       $$lcssa270 = $182;
       $$lcssa272 = $372;
       break;
      }
      if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
       label = 43;
       break L12;
      }
      HEAP32[4146] = (HEAP32[4146] | 0) + 1;
      $176 = HEAP32[3993] | 0;
      $storemerge = 0;
     }
     $195 = HEAP32[4317] | 0;
     if (($195 | 0) > 0) {
      $$pre3$pre$i = $$lcssa270;
      $208 = $$lcssa268;
      $209 = $$lcssa272;
      $212 = $195;
      while (1) {
       L43 : do switch (HEAP8[$208 + $209 >> 0] | 0) {
       case 125:
        {
         HEAP32[4317] = $212 + -1;
         $215 = $208;
         $222 = $$pre3$pre$i;
         $storemerge42 = $209 + 1 | 0;
         while (1) {
          HEAP32[4045] = $storemerge42;
          $221 = ($storemerge42 | 0) < ($222 | 0);
          if ((HEAP8[25877 + (HEAPU8[$215 + $storemerge42 >> 0] | 0) >> 0] | 0) == 1 & $221) {
           $225 = $storemerge42;
           while (1) {
            $224 = $225 + 1 | 0;
            HEAP32[4045] = $224;
            $232 = ($224 | 0) < ($222 | 0);
            if ($232 & (HEAP8[25877 + (HEAPU8[$215 + $224 >> 0] | 0) >> 0] | 0) == 1) $225 = $224; else {
             $$lcssa$i$i14 = $232;
             $373 = $224;
             break;
            }
           }
          } else {
           $$lcssa$i$i14 = $221;
           $373 = $storemerge42;
          }
          if ($$lcssa$i$i14) {
           $374 = $222;
           $375 = $215;
           $376 = $373;
           break L43;
          }
          if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
           label = 51;
           break L12;
          }
          HEAP32[4146] = (HEAP32[4146] | 0) + 1;
          $215 = HEAP32[3993] | 0;
          $222 = HEAP32[3999] | 0;
          $storemerge42 = 0;
         }
         break;
        }
       case 123:
        {
         HEAP32[4317] = $212 + 1;
         $247 = $208;
         $254 = $$pre3$pre$i;
         $storemerge41 = $209 + 1 | 0;
         while (1) {
          HEAP32[4045] = $storemerge41;
          $253 = ($storemerge41 | 0) < ($254 | 0);
          if ((HEAP8[25877 + (HEAPU8[$247 + $storemerge41 >> 0] | 0) >> 0] | 0) == 1 & $253) {
           $257 = $storemerge41;
           while (1) {
            $256 = $257 + 1 | 0;
            HEAP32[4045] = $256;
            $264 = ($256 | 0) < ($254 | 0);
            if ($264 & (HEAP8[25877 + (HEAPU8[$247 + $256 >> 0] | 0) >> 0] | 0) == 1) $257 = $256; else {
             $$lcssa$i$i20 = $264;
             $377 = $256;
             break;
            }
           }
          } else {
           $$lcssa$i$i20 = $253;
           $377 = $storemerge41;
          }
          if ($$lcssa$i$i20) {
           $374 = $254;
           $375 = $247;
           $376 = $377;
           break L43;
          }
          if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
           label = 58;
           break L12;
          }
          HEAP32[4146] = (HEAP32[4146] | 0) + 1;
          $247 = HEAP32[3993] | 0;
          $254 = HEAP32[3999] | 0;
          $storemerge41 = 0;
         }
         break;
        }
       default:
        {
         $276 = $209 + 1 | 0;
         HEAP32[4045] = $276;
         HEAP32[4044] = $276;
         L45 : do switch (HEAP8[$208 + $276 >> 0] | 0) {
         case 123:
         case 125:
          {
           $$pre$i24 = $276;
           break;
          }
         default:
          {
           $279 = $276;
           while (1) {
            if (($279 | 0) >= ($$pre3$pre$i | 0)) {
             $$pre$i24 = $279;
             break L45;
            }
            $281 = $279 + 1 | 0;
            HEAP32[4045] = $281;
            switch (HEAP8[$208 + $281 >> 0] | 0) {
            case 123:
            case 125:
             {
              $$pre$i24 = $281;
              break L45;
              break;
             }
            default:
             $279 = $281;
            }
           }
          }
         } while (0);
         if (($$pre$i24 | 0) < ($$pre3$pre$i | 0)) {
          $374 = $$pre3$pre$i;
          $375 = $208;
          $376 = $$pre$i24;
         } else {
          $288 = $208;
          $289 = $$pre$i24;
          $296 = $$pre3$pre$i;
          while (1) {
           $295 = ($289 | 0) < ($296 | 0);
           if ((HEAP8[25877 + (HEAPU8[$288 + $289 >> 0] | 0) >> 0] | 0) == 1 & $295) {
            $299 = $289;
            while (1) {
             $298 = $299 + 1 | 0;
             HEAP32[4045] = $298;
             $306 = ($298 | 0) < ($296 | 0);
             if ($306 & (HEAP8[25877 + (HEAPU8[$288 + $298 >> 0] | 0) >> 0] | 0) == 1) $299 = $298; else {
              $$lcssa$i$i26 = $306;
              $378 = $298;
              break;
             }
            }
           } else {
            $$lcssa$i$i26 = $295;
            $378 = $289;
           }
           if ($$lcssa$i$i26) {
            $374 = $296;
            $375 = $288;
            $376 = $378;
            break L43;
           }
           if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
            label = 69;
            break L12;
           }
           HEAP32[4146] = (HEAP32[4146] | 0) + 1;
           HEAP32[4045] = 0;
           $288 = HEAP32[3993] | 0;
           $289 = 0;
           $296 = HEAP32[3999] | 0;
          }
         }
        }
       } while (0);
       $285 = HEAP32[4317] | 0;
       if (($285 | 0) > 0) {
        $$pre3$pre$i = $374;
        $208 = $375;
        $209 = $376;
        $212 = $285;
       } else {
        $334 = $375;
        $335 = $376;
        break L14;
       }
      }
     } else {
      $334 = $$lcssa268;
      $335 = $$lcssa272;
     }
     break;
    }
   default:
    {
     $320 = $174 + 1 | 0;
     HEAP32[4045] = $320;
     HEAP32[4044] = $320;
     $323 = HEAP8[$322 + $320 >> 0] | 0;
     $$pre5$pre$i = HEAP32[3999] | 0;
     L16 : do if ($323 << 24 >> 24 == $325 << 24 >> 24) $$pre$i34 = $320; else {
      switch ($323 << 24 >> 24) {
      case 123:
      case 125:
       {
        $$pre$i34 = $320;
        break L16;
        break;
       }
      default:
       $326 = $320;
      }
      while (1) {
       if (($326 | 0) >= ($$pre5$pre$i | 0)) {
        $$pre$i34 = $326;
        break L16;
       }
       $328 = $326 + 1 | 0;
       HEAP32[4045] = $328;
       $330 = HEAP8[$322 + $328 >> 0] | 0;
       if ($330 << 24 >> 24 == $325 << 24 >> 24) {
        $$pre$i34 = $328;
        break L16;
       }
       switch ($330 << 24 >> 24) {
       case 123:
       case 125:
        {
         $$pre$i34 = $328;
         break L16;
         break;
        }
       default:
        $326 = $328;
       }
      }
     } while (0);
     if (($$pre$i34 | 0) < ($$pre5$pre$i | 0)) {
      $334 = $322;
      $335 = $$pre$i34;
     } else {
      $340 = $322;
      $341 = $$pre$i34;
      $348 = $$pre5$pre$i;
      while (1) {
       $347 = ($341 | 0) < ($348 | 0);
       if ((HEAP8[25877 + (HEAPU8[$340 + $341 >> 0] | 0) >> 0] | 0) == 1 & $347) {
        $351 = $341;
        while (1) {
         $350 = $351 + 1 | 0;
         HEAP32[4045] = $350;
         $358 = ($350 | 0) < ($348 | 0);
         if ($358 & (HEAP8[25877 + (HEAPU8[$340 + $350 >> 0] | 0) >> 0] | 0) == 1) $351 = $350; else {
          $$lcssa$i$i36 = $358;
          $379 = $350;
          break;
         }
        }
       } else {
        $$lcssa$i$i36 = $347;
        $379 = $341;
       }
       if ($$lcssa$i$i36) {
        $334 = $340;
        $335 = $379;
        break L14;
       }
       if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
        label = 83;
        break L12;
       }
       HEAP32[4146] = (HEAP32[4146] | 0) + 1;
       HEAP32[4045] = 0;
       $340 = HEAP32[3993] | 0;
       $341 = 0;
       $348 = HEAP32[3999] | 0;
      }
     }
    }
   } while (0);
   $336 = HEAP8[$334 + $335 >> 0] | 0;
   $337 = HEAP8[26646] | 0;
   if ($336 << 24 >> 24 == $337 << 24 >> 24) {
    $371 = $335;
    break L10;
   } else {
    $170 = $336;
    $174 = $335;
    $322 = $334;
    $325 = $337;
   }
  }
  if ((label | 0) == 43) {
   _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 51) {
   _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 58) {
   _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 69) {
   _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 70) {
   _fwrite(2002, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(2002, 17, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 83) {
   _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  }
 } else if ($31) $371 = $26; else {
  $33 = $29;
  L92 : while (1) {
   L94 : do switch ($33 & 255 | 0) {
   case 125:
    {
     label = 29;
     break L92;
     break;
    }
   case 123:
    {
     HEAP32[4317] = (HEAP32[4317] | 0) + 1;
     $36 = HEAP32[4251] | 0;
     if (($36 | 0) == (HEAP32[3992] | 0)) {
      $$lcssa311 = $36;
      label = 12;
      break L92;
     }
     HEAP8[(HEAP32[3995] | 0) + $36 >> 0] = 123;
     HEAP32[4251] = (HEAP32[4251] | 0) + 1;
     $47 = (HEAP32[4045] | 0) + 1 | 0;
     HEAP32[4045] = $47;
     if (($47 | 0) == (HEAP32[3999] | 0) ? 1 : (HEAP8[25877 + (HEAPU8[(HEAP32[3993] | 0) + $47 >> 0] | 0) >> 0] | 0) == 1) if (!(_compressbibwhite() | 0)) {
      $Result$0 = 0;
      label = 85;
      break L92;
     }
     L102 : while (1) {
      $62 = HEAP8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0;
      switch ($62 & 255 | 0) {
      case 125:
       {
        HEAP32[4317] = (HEAP32[4317] | 0) + -1;
        $66 = HEAP32[4251] | 0;
        if (($66 | 0) == (HEAP32[3992] | 0)) {
         $$lcssa308 = $66;
         label = 17;
         break L92;
        }
        HEAP8[(HEAP32[3995] | 0) + $66 >> 0] = 125;
        HEAP32[4251] = (HEAP32[4251] | 0) + 1;
        $77 = (HEAP32[4045] | 0) + 1 | 0;
        HEAP32[4045] = $77;
        if (($77 | 0) == (HEAP32[3999] | 0) ? 1 : (HEAP8[25877 + (HEAPU8[(HEAP32[3993] | 0) + $77 >> 0] | 0) >> 0] | 0) == 1) if (!(_compressbibwhite() | 0)) {
         $Result$0 = 0;
         label = 85;
         break L92;
        }
        if (!(HEAP32[4317] | 0)) break L94; else continue L102;
        break;
       }
      case 123:
       {
        HEAP32[4317] = (HEAP32[4317] | 0) + 1;
        $93 = HEAP32[4251] | 0;
        if (($93 | 0) == (HEAP32[3992] | 0)) {
         $$lcssa307 = $93;
         label = 22;
         break L92;
        }
        HEAP8[(HEAP32[3995] | 0) + $93 >> 0] = 123;
        HEAP32[4251] = (HEAP32[4251] | 0) + 1;
        $104 = (HEAP32[4045] | 0) + 1 | 0;
        HEAP32[4045] = $104;
        if (!(($104 | 0) == (HEAP32[3999] | 0) ? 1 : (HEAP8[25877 + (HEAPU8[(HEAP32[3993] | 0) + $104 >> 0] | 0) >> 0] | 0) == 1)) continue L102;
        if (!(_compressbibwhite() | 0)) {
         $Result$0 = 0;
         label = 85;
         break L92;
        } else continue L102;
        break;
       }
      default:
       {
        $116 = HEAP32[4251] | 0;
        if (($116 | 0) == (HEAP32[3992] | 0)) {
         $$lcssa310 = $116;
         label = 26;
         break L92;
        }
        HEAP8[(HEAP32[3995] | 0) + $116 >> 0] = $62;
        HEAP32[4251] = (HEAP32[4251] | 0) + 1;
        $127 = (HEAP32[4045] | 0) + 1 | 0;
        HEAP32[4045] = $127;
        if (!(($127 | 0) == (HEAP32[3999] | 0) ? 1 : (HEAP8[25877 + (HEAPU8[(HEAP32[3993] | 0) + $127 >> 0] | 0) >> 0] | 0) == 1)) continue L102;
        if (!(_compressbibwhite() | 0)) {
         $Result$0 = 0;
         label = 85;
         break L92;
        } else continue L102;
       }
      }
     }
     break;
    }
   default:
    {
     $141 = HEAP32[4251] | 0;
     if (($141 | 0) == (HEAP32[3992] | 0)) {
      $$lcssa316 = $141;
      label = 31;
      break L92;
     }
     HEAP8[(HEAP32[3995] | 0) + $141 >> 0] = $33;
     HEAP32[4251] = (HEAP32[4251] | 0) + 1;
     $152 = (HEAP32[4045] | 0) + 1 | 0;
     HEAP32[4045] = $152;
     if (($152 | 0) == (HEAP32[3999] | 0) ? 1 : (HEAP8[25877 + (HEAPU8[(HEAP32[3993] | 0) + $152 >> 0] | 0) >> 0] | 0) == 1) if (!(_compressbibwhite() | 0)) {
      $Result$0 = 0;
      label = 85;
      break L92;
     }
    }
   } while (0);
   $164 = HEAP32[4045] | 0;
   $167 = HEAP8[(HEAP32[3993] | 0) + $164 >> 0] | 0;
   if ($167 << 24 >> 24 == (HEAP8[26646] | 0)) {
    $371 = $164;
    break L10;
   } else $33 = $167;
  }
  if ((label | 0) == 12) {
   $39 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = 2020;
   HEAP32[$vararg_buffer + 4 >> 2] = $$lcssa311;
   HEAP32[$vararg_buffer + 8 >> 2] = 2045;
   _fprintf($39, 1280, $vararg_buffer) | 0;
   $40 = HEAP32[3990] | 0;
   $41 = HEAP32[3992] | 0;
   HEAP32[$vararg_buffer3 >> 2] = 2020;
   HEAP32[$vararg_buffer3 + 4 >> 2] = $41;
   HEAP32[$vararg_buffer3 + 8 >> 2] = 2045;
   _fprintf($40, 1280, $vararg_buffer3) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 17) {
   $69 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer8 >> 2] = 2020;
   HEAP32[$vararg_buffer8 + 4 >> 2] = $$lcssa308;
   HEAP32[$vararg_buffer8 + 8 >> 2] = 2045;
   _fprintf($69, 1280, $vararg_buffer8) | 0;
   $70 = HEAP32[3990] | 0;
   $71 = HEAP32[3992] | 0;
   HEAP32[$vararg_buffer13 >> 2] = 2020;
   HEAP32[$vararg_buffer13 + 4 >> 2] = $71;
   HEAP32[$vararg_buffer13 + 8 >> 2] = 2045;
   _fprintf($70, 1280, $vararg_buffer13) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 22) {
   $96 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer18 >> 2] = 2020;
   HEAP32[$vararg_buffer18 + 4 >> 2] = $$lcssa307;
   HEAP32[$vararg_buffer18 + 8 >> 2] = 2045;
   _fprintf($96, 1280, $vararg_buffer18) | 0;
   $97 = HEAP32[3990] | 0;
   $98 = HEAP32[3992] | 0;
   HEAP32[$vararg_buffer23 >> 2] = 2020;
   HEAP32[$vararg_buffer23 + 4 >> 2] = $98;
   HEAP32[$vararg_buffer23 + 8 >> 2] = 2045;
   _fprintf($97, 1280, $vararg_buffer23) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 26) {
   $119 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer28 >> 2] = 2020;
   HEAP32[$vararg_buffer28 + 4 >> 2] = $$lcssa310;
   HEAP32[$vararg_buffer28 + 8 >> 2] = 2045;
   _fprintf($119, 1280, $vararg_buffer28) | 0;
   $120 = HEAP32[3990] | 0;
   $121 = HEAP32[3992] | 0;
   HEAP32[$vararg_buffer33 >> 2] = 2020;
   HEAP32[$vararg_buffer33 + 4 >> 2] = $121;
   HEAP32[$vararg_buffer33 + 8 >> 2] = 2045;
   _fprintf($120, 1280, $vararg_buffer33) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 29) {
   _fwrite(2002, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(2002, 17, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 31) {
   $144 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer38 >> 2] = 2020;
   HEAP32[$vararg_buffer38 + 4 >> 2] = $$lcssa316;
   HEAP32[$vararg_buffer38 + 8 >> 2] = 2045;
   _fprintf($144, 1280, $vararg_buffer38) | 0;
   $145 = HEAP32[3990] | 0;
   $146 = HEAP32[3992] | 0;
   HEAP32[$vararg_buffer43 >> 2] = 2020;
   HEAP32[$vararg_buffer43 + 4 >> 2] = $146;
   HEAP32[$vararg_buffer43 + 8 >> 2] = 2045;
   _fprintf($145, 1280, $vararg_buffer43) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else if ((label | 0) == 85) {
   STACKTOP = sp;
   return $Result$0 | 0;
  }
 } while (0);
 HEAP32[4045] = $371 + 1;
 $Result$0 = 1;
 STACKTOP = sp;
 return $Result$0 | 0;
}

function _bstreadcommand() {
 var $$lcssa = 0, $$lcssa105 = 0, $$lcssa106 = 0, $$pre76 = 0, $$pre76$lcssa = 0, $$pre77 = 0, $$pre77$lcssa = 0, $117 = 0, $120 = 0, $123 = 0, $124 = 0, $125 = 0, $127 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $137 = 0, $138 = 0, $139 = 0, $142 = 0, $147 = 0, $149 = 0, $158 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $166 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $180 = 0, $182 = 0, $183 = 0, $186 = 0, $188 = 0, $190 = 0, $192 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $202 = 0, $203 = 0, $204 = 0, $207 = 0, $216 = 0, $218 = 0, $22 = 0, $223 = 0, $23 = 0, $232 = 0, $234 = 0, $245 = 0, $246 = 0, $25 = 0, $252 = 0, $26 = 0, $264 = 0, $265 = 0, $267 = 0, $269 = 0, $284 = 0, $288 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $30 = 0, $313 = 0, $315 = 0, $321 = 0, $322 = 0, $323 = 0, $326 = 0, $328 = 0, $332 = 0, $334 = 0, $336 = 0, $340 = 0, $342 = 0, $345 = 0, $348 = 0, $349 = 0, $35 = 0, $358 = 0, $359 = 0, $361 = 0, $364 = 0, $368 = 0, $37 = 0, $370 = 0, $375 = 0, $377 = 0, $383 = 0, $387 = 0, $389 = 0, $393 = 0, $395 = 0, $398 = 0, $40 = 0, $400 = 0, $404 = 0, $407 = 0, $409 = 0, $41 = 0, $414 = 0, $417 = 0, $418 = 0, $426 = 0, $429 = 0, $430 = 0, $431 = 0, $44 = 0, $51 = 0, $54 = 0, $57 = 0, $59 = 0, $60 = 0, $61 = 0, $65 = 0, $67 = 0, $70 = 0, $74 = 0, $75 = 0, $77 = 0, $79 = 0, $8 = 0, $83 = 0, $86 = 0, $9 = 0, $storemerge1024 = 0, $storemerge1134 = 0, $storemerge1237 = 0, $storemerge1345 = 0, $storemerge1459 = 0, $storemerge166 = 0, $storemerge263 = 0, $storemerge355 = 0, $storemerge448 = 0, $storemerge543 = 0, $storemerge68 = 0, $storemerge730 = 0, $storemerge925 = 0, $vararg_buffer = 0, $vararg_buffer14 = 0, $vararg_buffer17 = 0, $vararg_buffer20 = 0, $vararg_buffer23 = 0, $vararg_buffer26 = 0, $vararg_buffer29 = 0, $vararg_buffer32 = 0, $vararg_buffer35 = 0, $vararg_buffer38 = 0, $vararg_buffer4 = 0, $vararg_buffer41 = 0, $vararg_buffer44 = 0, $vararg_buffer47 = 0, $vararg_buffer50 = 0, $vararg_buffer53 = 0, $vararg_buffer9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $vararg_buffer53 = sp + 152 | 0;
 $vararg_buffer50 = sp + 144 | 0;
 $vararg_buffer47 = sp + 136 | 0;
 $vararg_buffer44 = sp + 128 | 0;
 $vararg_buffer41 = sp + 120 | 0;
 $vararg_buffer38 = sp + 112 | 0;
 $vararg_buffer35 = sp + 104 | 0;
 $vararg_buffer32 = sp + 96 | 0;
 $vararg_buffer29 = sp + 88 | 0;
 $vararg_buffer26 = sp + 80 | 0;
 $vararg_buffer23 = sp + 72 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer17 = sp + 56 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer9 = sp + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (HEAP32[4675] | 0) {
  _fwrite(5251, 29, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5251, 29, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4675] = 1;
 if (!(HEAP32[4674] | 0)) {
  _fwrite(5281, 42, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5281, 42, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $8 = HEAP32[4045] | 0;
 HEAP32[4682] = $8;
 $9 = HEAP32[3999] | 0;
 HEAP32[4683] = $9;
 HEAP32[4252] = $8;
 if (($8 | 0) < ($9 | 0)) {
  $storemerge68 = $8;
  while (1) {
   HEAP8[(HEAP32[3994] | 0) + $storemerge68 >> 0] = HEAP8[(HEAP32[3993] | 0) + $storemerge68 >> 0] | 0;
   $17 = (HEAP32[4252] | 0) + 1 | 0;
   HEAP32[4252] = $17;
   if (($17 | 0) < (HEAP32[4683] | 0)) $storemerge68 = $17; else break;
  }
 }
 $22 = Math_imul(HEAP32[4157] | 0, HEAP32[4247] | 0) | 0;
 $23 = HEAP32[4148] | 0;
 if (($23 | 0) < ($22 | 0)) {
  $25 = HEAP32[3989] | 0;
  $26 = $22 + 5e3 | 0;
  HEAP32[$vararg_buffer >> 2] = 1901;
  HEAP32[$vararg_buffer + 4 >> 2] = 4;
  HEAP32[$vararg_buffer + 8 >> 2] = $26;
  HEAP32[$vararg_buffer + 12 >> 2] = $23;
  _fprintf($25, 1023, $vararg_buffer) | 0;
  $30 = _xrealloc(HEAP32[4149] | 0, ($22 << 2) + 20004 | 0) | 0;
  HEAP32[4149] = $30;
  HEAP32[4148] = $26;
  if (($23 | 0) > ($22 + 4999 | 0)) $35 = $26; else {
   _memset($30 + ($23 << 2) | 0, 0, $26 - $23 << 2 | 0) | 0;
   $35 = HEAP32[4148] | 0;
  }
 } else $35 = $23;
 HEAP32[4151] = 0;
 if (($35 | 0) > 0) {
  $37 = HEAP32[4149] | 0;
  $storemerge166 = 0;
  while (1) {
   HEAP32[$37 + ($storemerge166 << 2) >> 2] = 0;
   $44 = (HEAP32[4151] | 0) + 1 | 0;
   HEAP32[4151] = $44;
   if (($44 | 0) < (HEAP32[4148] | 0)) $storemerge166 = $44; else break;
  }
 }
 HEAP32[4150] = 0;
 if ((HEAP32[4098] | 0) > 0) {
  $40 = HEAP32[4100] | 0;
  $41 = HEAP32[4102] | 0;
  $storemerge263 = 0;
  while (1) {
   HEAP32[$40 + ($storemerge263 << 2) >> 2] = 0;
   HEAP32[$41 + (HEAP32[4150] << 2) >> 2] = 0;
   $51 = (HEAP32[4150] | 0) + 1 | 0;
   HEAP32[4150] = $51;
   if (($51 | 0) < (HEAP32[4098] | 0)) $storemerge263 = $51; else break;
  }
 }
 $54 = HEAP32[4157] | 0;
 HEAP32[4329] = $54;
 if (!(HEAP32[4328] | 0)) {
  HEAP32[4150] = $54;
  HEAP32[4671] = 0;
  $429 = $54;
 } else {
  $57 = HEAP32[4671] | 0;
  HEAP32[4150] = $57;
  if (($57 | 0) < ($54 | 0)) {
   $59 = HEAP32[4099] | 0;
   $60 = HEAP32[4102] | 0;
   $61 = HEAP32[4101] | 0;
   $storemerge1459 = $57;
   while (1) {
    HEAP32[$60 + ($storemerge1459 << 2) >> 2] = HEAP32[$59 + ($storemerge1459 << 2) >> 2];
    $65 = HEAP32[4150] | 0;
    HEAP32[$61 + ($65 << 2) >> 2] = 0;
    $67 = $65 + 1 | 0;
    HEAP32[4150] = $67;
    if (($67 | 0) < (HEAP32[4329] | 0)) $storemerge1459 = $67; else break;
   }
   $70 = HEAP32[4671] | 0;
  } else $70 = $57;
  HEAP32[4150] = $70;
  $429 = $70;
 }
 HEAP32[4684] = 1;
 HEAP32[4093] = 0;
 if ((HEAP32[4673] | 0) > 0) {
  $storemerge355 = 0;
  while (1) {
   $74 = (HEAP32[4669] | 0) == 0;
   $75 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer4 >> 2] = 5324;
   HEAP32[$vararg_buffer4 + 4 >> 2] = $storemerge355 + 1;
   HEAP32[$vararg_buffer4 + 8 >> 2] = 4429;
   _fprintf($75, 1280, $vararg_buffer4) | 0;
   if ($74) {
    _zoutpoolstr(HEAP32[3989] | 0, HEAP32[(HEAP32[4094] | 0) + (HEAP32[4093] << 2) >> 2] | 0);
    _zoutpoolstr(HEAP32[3989] | 0, HEAP32[4095] | 0);
    _putc(10, HEAP32[3989] | 0) | 0;
   } else {
    $77 = HEAP32[3990] | 0;
    $79 = (HEAP32[4093] | 0) + 1 | 0;
    HEAP32[$vararg_buffer9 >> 2] = 5324;
    HEAP32[$vararg_buffer9 + 4 >> 2] = $79;
    HEAP32[$vararg_buffer9 + 8 >> 2] = 4429;
    _fprintf($77, 1280, $vararg_buffer9) | 0;
    $83 = HEAP32[(HEAP32[4094] | 0) + (HEAP32[4093] << 2) >> 2] | 0;
    _zoutpoolstr(HEAP32[3990] | 0, $83);
    _zoutpoolstr(HEAP32[3989] | 0, $83);
    $86 = HEAP32[4095] | 0;
    _zoutpoolstr(HEAP32[3990] | 0, $86);
    _zoutpoolstr(HEAP32[3989] | 0, $86);
    _putc(10, HEAP32[3989] | 0) | 0;
    _putc(10, HEAP32[3990] | 0) | 0;
   }
   HEAP32[4146] = 0;
   HEAP32[4045] = HEAP32[3999];
   if (!(_eof(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) do _getbibcommandorentryandprocess(); while (!(_eof(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0));
   _close_file(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0);
   $117 = (HEAP32[4093] | 0) + 1 | 0;
   HEAP32[4093] = $117;
   if (($117 | 0) < (HEAP32[4673] | 0)) $storemerge355 = $117; else break;
  }
  $120 = HEAP32[4150] | 0;
 } else $120 = $429;
 HEAP32[4685] = 1;
 HEAP32[4157] = $120;
 HEAP32[4385] = HEAP32[4304];
 $123 = HEAP32[4247] | 0;
 $124 = Math_imul($123, $120 + -1 | 0) | 0;
 $125 = HEAP32[4305] | 0;
 $127 = HEAP32[4148] | 0;
 if (($124 + $125 | 0) >= ($127 | 0)) {
  _fwrite(3267, 32, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3267, 32, 1, HEAP32[3990] | 0) | 0;
  $132 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer14 >> 2] = 964;
  _fprintf($132, 960, $vararg_buffer14) | 0;
  $133 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer17 >> 2] = 964;
  _fprintf($133, 960, $vararg_buffer17) | 0;
  $134 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer20 >> 2] = 985;
  _fprintf($134, 960, $vararg_buffer20) | 0;
  $135 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer23 >> 2] = 985;
  _fprintf($135, 960, $vararg_buffer23) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
 HEAP32[4150] = 0;
 if (($120 | 0) > 0) {
  $137 = $123;
  $139 = $125;
  $storemerge448 = 0;
  while (1) {
   $138 = (Math_imul($137, $storemerge448) | 0) + $139 | 0;
   HEAP32[4151] = $138;
   $142 = HEAP32[(HEAP32[4149] | 0) + ($138 << 2) >> 2] | 0;
   if ($142 | 0) if (_zfindcitelocsforthiscitekey($142) | 0) {
    $147 = HEAP32[4249] | 0;
    $149 = HEAP32[$147 + (HEAP32[4250] << 2) >> 2] | 0;
    HEAP32[4248] = $149;
    HEAP32[(HEAP32[4149] | 0) + (HEAP32[4151] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + ($149 << 2) >> 2];
    $158 = HEAP32[$147 + (HEAP32[4248] << 2) >> 2] | 0;
    HEAP32[4686] = $158;
    $160 = HEAP32[4247] | 0;
    $161 = Math_imul($160, HEAP32[4150] | 0) | 0;
    $162 = HEAP32[4306] | 0;
    $163 = $161 + $162 | 0;
    HEAP32[4151] = $163;
    $164 = $161 + $160 | 0;
    HEAP32[4687] = $164;
    $166 = (Math_imul($160, $158) | 0) + $162 | 0;
    HEAP32[4688] = $166;
    if (($163 | 0) < ($164 | 0)) {
     $168 = HEAP32[4149] | 0;
     $170 = $163;
     $430 = $164;
     $storemerge1345 = $166;
     while (1) {
      $169 = $168 + ($170 << 2) | 0;
      if (!(HEAP32[$169 >> 2] | 0)) {
       HEAP32[$169 >> 2] = HEAP32[$168 + ($storemerge1345 << 2) >> 2];
       $176 = HEAP32[4151] | 0;
       $178 = HEAP32[4688] | 0;
       $180 = HEAP32[4687] | 0;
      } else {
       $176 = $170;
       $178 = $storemerge1345;
       $180 = $430;
      }
      $175 = $176 + 1 | 0;
      HEAP32[4151] = $175;
      $177 = $178 + 1 | 0;
      HEAP32[4688] = $177;
      if (($175 | 0) < ($180 | 0)) {
       $170 = $175;
       $430 = $180;
       $storemerge1345 = $177;
      } else break;
     }
    }
   }
   $182 = (HEAP32[4150] | 0) + 1 | 0;
   HEAP32[4150] = $182;
   $183 = HEAP32[4157] | 0;
   $$pre76 = HEAP32[4247] | 0;
   $$pre77 = HEAP32[4305] | 0;
   if (($182 | 0) < ($183 | 0)) {
    $137 = $$pre76;
    $139 = $$pre77;
    $storemerge448 = $182;
   } else {
    $$lcssa106 = $183;
    $$pre76$lcssa = $$pre76;
    $$pre77$lcssa = $$pre77;
    break;
   }
  }
  $186 = $$lcssa106;
  $188 = $$pre76$lcssa;
  $190 = $$pre77$lcssa;
  $192 = HEAP32[4148] | 0;
 } else {
  $186 = $120;
  $188 = $123;
  $190 = $125;
  $192 = $127;
 }
 if (((Math_imul($188, $186 + -1 | 0) | 0) + $190 | 0) >= ($192 | 0)) {
  _fwrite(3267, 32, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3267, 32, 1, HEAP32[3990] | 0) | 0;
  $196 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer26 >> 2] = 964;
  _fprintf($196, 960, $vararg_buffer26) | 0;
  $197 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer29 >> 2] = 964;
  _fprintf($197, 960, $vararg_buffer29) | 0;
  $198 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer32 >> 2] = 985;
  _fprintf($198, 960, $vararg_buffer32) | 0;
  $199 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer35 >> 2] = 985;
  _fprintf($199, 960, $vararg_buffer35) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
 HEAP32[4150] = 0;
 L71 : do if (($186 | 0) > 0) {
  $202 = $188;
  $204 = $190;
  $storemerge543 = 0;
  L72 : while (1) {
   $203 = (Math_imul($202, $storemerge543) | 0) + $204 | 0;
   HEAP32[4151] = $203;
   $207 = HEAP32[(HEAP32[4149] | 0) + ($203 << 2) >> 2] | 0;
   do if ($207 | 0) {
    if (!(_zfindcitelocsforthiscitekey($207) | 0)) {
     if (HEAP32[4254] | 0) {
      label = 51;
      break L72;
     }
     _nonexistentcrossreferenceerror();
     HEAP32[(HEAP32[4149] | 0) + (HEAP32[4151] << 2) >> 2] = 0;
     break;
    }
    $216 = HEAP32[4248] | 0;
    $218 = HEAP32[4249] | 0;
    if (($216 | 0) != (HEAP32[$218 + (HEAP32[4250] << 2) >> 2] | 0)) {
     label = 54;
     break L72;
    }
    $223 = HEAP32[$218 + ($216 << 2) >> 2] | 0;
    HEAP32[4686] = $223;
    if (!(HEAP32[(HEAP32[4100] | 0) + ($223 << 2) >> 2] | 0)) {
     _nonexistentcrossreferenceerror();
     HEAP32[(HEAP32[4149] | 0) + (HEAP32[4151] << 2) >> 2] = 0;
     break;
    }
    $232 = Math_imul(HEAP32[4247] | 0, $223) | 0;
    $234 = $232 + (HEAP32[4305] | 0) | 0;
    HEAP32[4688] = $234;
    L84 : do if (HEAP32[(HEAP32[4149] | 0) + ($234 << 2) >> 2] | 0) {
     _fwrite(5340, 39, 1, HEAP32[3989] | 0) | 0;
     _fwrite(5340, 39, 1, HEAP32[3990] | 0) | 0;
     _zbadcrossreferenceprint(HEAP32[(HEAP32[4099] | 0) + (HEAP32[4686] << 2) >> 2] | 0);
     $245 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer38 >> 2] = 5380;
     _fprintf($245, 960, $vararg_buffer38) | 0;
     $246 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer41 >> 2] = 5380;
     _fprintf($246, 960, $vararg_buffer41) | 0;
     switch (HEAP8[25620] | 0) {
     case 1:
      {
       HEAP32[3991] = (HEAP32[3991] | 0) + 1;
       break L84;
       break;
      }
     case 0:
      {
       HEAP8[25620] = 1;
       HEAP32[3991] = 1;
       break L84;
       break;
      }
     default:
      break L84;
     }
    } while (0);
    if (HEAP32[4328] | 0) break;
    $252 = HEAP32[4686] | 0;
    if (($252 | 0) < (HEAP32[4329] | 0)) break;
    if ((HEAP32[(HEAP32[4102] | 0) + ($252 << 2) >> 2] | 0) >= (HEAP32[4689] | 0)) break;
    HEAP32[(HEAP32[4149] | 0) + (HEAP32[4151] << 2) >> 2] = 0;
   } while (0);
   $264 = (HEAP32[4150] | 0) + 1 | 0;
   HEAP32[4150] = $264;
   $265 = HEAP32[4157] | 0;
   if (($264 | 0) >= ($265 | 0)) {
    $$lcssa105 = $265;
    label = 47;
    break;
   }
   $202 = HEAP32[4247] | 0;
   $204 = HEAP32[4305] | 0;
   $storemerge543 = $264;
  }
  if ((label | 0) == 47) {
   HEAP32[4150] = 0;
   if (($$lcssa105 | 0) > 0) $269 = 0; else break;
   L97 : while (1) {
    $267 = HEAP32[4100] | 0;
    do if (!(HEAP32[$267 + ($269 << 2) >> 2] | 0)) _zprintmissingentry(HEAP32[(HEAP32[4099] | 0) + ($269 << 2) >> 2] | 0); else {
     if (!((HEAP32[4328] | 0) != 0 | ($269 | 0) < (HEAP32[4329] | 0))) if ((HEAP32[(HEAP32[4102] | 0) + ($269 << 2) >> 2] | 0) < (HEAP32[4689] | 0)) break;
     $284 = HEAP32[4690] | 0;
     do if (($269 | 0) > ($284 | 0)) {
      $288 = Math_imul(HEAP32[4247] | 0, $284 + 1 | 0) | 0;
      if (($288 | 0) > (HEAP32[4148] | 0)) {
       label = 73;
       break L97;
      }
      $297 = HEAP32[4099] | 0;
      HEAP32[$297 + ($284 << 2) >> 2] = HEAP32[$297 + ($269 << 2) >> 2];
      HEAP32[$267 + (HEAP32[4690] << 2) >> 2] = HEAP32[$267 + (HEAP32[4150] << 2) >> 2];
      if (!(_zfindcitelocsforthiscitekey(HEAP32[$297 + (HEAP32[4150] << 2) >> 2] | 0) | 0)) {
       label = 75;
       break L97;
      }
      if (!(HEAP32[4254] | 0)) {
       label = 78;
       break L97;
      }
      $313 = HEAP32[4248] | 0;
      $315 = HEAP32[4249] | 0;
      if (($313 | 0) != (HEAP32[$315 + (HEAP32[4250] << 2) >> 2] | 0)) {
       label = 78;
       break L97;
      }
      HEAP32[$315 + ($313 << 2) >> 2] = HEAP32[4690];
      $321 = HEAP32[4690] | 0;
      $322 = HEAP32[4247] | 0;
      $323 = Math_imul($322, $321) | 0;
      HEAP32[4151] = $323;
      HEAP32[4687] = $323 + $322;
      $326 = Math_imul(HEAP32[4150] | 0, $322) | 0;
      HEAP32[4252] = $326;
      if (($322 | 0) <= 0) {
       $340 = $321;
       break;
      }
      $328 = HEAP32[4149] | 0;
      $332 = $323;
      $storemerge1237 = $326;
      while (1) {
       HEAP32[$328 + ($332 << 2) >> 2] = HEAP32[$328 + ($storemerge1237 << 2) >> 2];
       $334 = (HEAP32[4151] | 0) + 1 | 0;
       HEAP32[4151] = $334;
       $336 = (HEAP32[4252] | 0) + 1 | 0;
       HEAP32[4252] = $336;
       if (($334 | 0) < (HEAP32[4687] | 0)) {
        $332 = $334;
        $storemerge1237 = $336;
       } else break;
      }
      $340 = HEAP32[4690] | 0;
     } else $340 = $284; while (0);
     HEAP32[4690] = $340 + 1;
    } while (0);
    $342 = (HEAP32[4150] | 0) + 1 | 0;
    HEAP32[4150] = $342;
    if (($342 | 0) < (HEAP32[4157] | 0)) $269 = $342; else break L71;
   }
   if ((label | 0) == 73) {
    _fwrite(3267, 32, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3267, 32, 1, HEAP32[3990] | 0) | 0;
    $293 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer44 >> 2] = 964;
    _fprintf($293, 960, $vararg_buffer44) | 0;
    $294 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer47 >> 2] = 964;
    _fprintf($294, 960, $vararg_buffer47) | 0;
    $295 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer50 >> 2] = 985;
    _fprintf($295, 960, $vararg_buffer50) | 0;
    $296 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer53 >> 2] = 985;
    _fprintf($296, 960, $vararg_buffer53) | 0;
    HEAP8[25620] = 3;
    _longjmp(16008, 1);
   } else if ((label | 0) == 75) _citekeydisappearedconfusion(); else if ((label | 0) == 78) _hashciteconfusion();
  } else if ((label | 0) == 51) _hashciteconfusion(); else if ((label | 0) == 54) _hashciteconfusion();
 } else HEAP32[4150] = 0; while (0);
 $345 = HEAP32[4690] | 0;
 HEAP32[4157] = $345;
 if (!(HEAP32[4328] | 0)) $364 = $345; else {
  $348 = HEAP32[4671] | 0;
  HEAP32[4150] = $348;
  $349 = HEAP32[4329] | 0;
  if (($348 | 0) < ($349 | 0)) {
   $431 = $349;
   $storemerge1134 = $348;
   while (1) {
    if (!(HEAP32[(HEAP32[4101] | 0) + ($storemerge1134 << 2) >> 2] | 0)) {
     _zprintmissingentry(HEAP32[(HEAP32[4102] | 0) + ($storemerge1134 << 2) >> 2] | 0);
     $359 = HEAP32[4150] | 0;
     $361 = HEAP32[4329] | 0;
    } else {
     $359 = $storemerge1134;
     $361 = $431;
    }
    $358 = $359 + 1 | 0;
    HEAP32[4150] = $358;
    if (($358 | 0) < ($361 | 0)) {
     $431 = $361;
     $storemerge1134 = $358;
    } else break;
   }
   $364 = HEAP32[4157] | 0;
  } else $364 = $345;
 }
 $368 = _xmalloc(Math_imul((HEAP32[4368] << 2) + 4 | 0, $364 + 1 | 0) | 0) | 0;
 HEAP32[4369] = $368;
 HEAP32[4691] = 0;
 $370 = HEAP32[4157] | 0;
 if ((Math_imul($370, HEAP32[4368] | 0) | 0) > 0) {
  $storemerge730 = 0;
  while (1) {
   HEAP32[$368 + ($storemerge730 << 2) >> 2] = 0;
   $375 = (HEAP32[4691] | 0) + 1 | 0;
   HEAP32[4691] = $375;
   $377 = HEAP32[4157] | 0;
   if (($375 | 0) < (Math_imul($377, HEAP32[4368] | 0) | 0)) $storemerge730 = $375; else {
    $$lcssa = $377;
    break;
   }
  }
 } else $$lcssa = $370;
 $383 = Math_imul((HEAP32[4255] | 0) + 1 | 0, $$lcssa + 1 | 0) | 0;
 $387 = _xmalloc(Math_imul($383, (HEAP32[4257] | 0) + 1 | 0) | 0) | 0;
 HEAP32[4258] = $387;
 HEAP32[4370] = 0;
 $389 = HEAP32[4157] | 0;
 if ((Math_imul($389, HEAP32[4255] | 0) | 0) > 0) {
  HEAP8[$387 >> 0] = 127;
  $393 = (HEAP32[4370] | 0) + 1 | 0;
  HEAP32[4370] = $393;
  $395 = HEAP32[4157] | 0;
  if (($393 | 0) < (Math_imul($395, HEAP32[4255] | 0) | 0)) {
   $404 = $393;
   while (1) {
    HEAP8[(HEAP32[4258] | 0) + (Math_imul((HEAP32[4257] | 0) + 1 | 0, $404) | 0) >> 0] = 127;
    $407 = (HEAP32[4370] | 0) + 1 | 0;
    HEAP32[4370] = $407;
    $409 = HEAP32[4157] | 0;
    if (($407 | 0) < (Math_imul($409, HEAP32[4255] | 0) | 0)) $404 = $407; else {
     $398 = $409;
     break;
    }
   }
  } else $398 = $395;
 } else $398 = $389;
 HEAP32[4150] = 0;
 if (($398 | 0) > 0) {
  $400 = HEAP32[4102] | 0;
  $storemerge925 = 0;
  while (1) {
   HEAP32[$400 + ($storemerge925 << 2) >> 2] = $storemerge925;
   $414 = (HEAP32[4150] | 0) + 1 | 0;
   HEAP32[4150] = $414;
   if (($414 | 0) < (HEAP32[4157] | 0)) $storemerge925 = $414; else break;
  }
 }
 HEAP32[4692] = 1;
 $417 = HEAP32[4682] | 0;
 HEAP32[4045] = $417;
 $418 = HEAP32[4683] | 0;
 HEAP32[3999] = $418;
 HEAP32[4252] = $417;
 if (($417 | 0) < ($418 | 0)) $storemerge1024 = $417; else {
  STACKTOP = sp;
  return;
 }
 while (1) {
  HEAP8[(HEAP32[3993] | 0) + $storemerge1024 >> 0] = HEAP8[(HEAP32[3994] | 0) + $storemerge1024 >> 0] | 0;
  $426 = (HEAP32[4252] | 0) + 1 | 0;
  HEAP32[4252] = $426;
  if (($426 | 0) < (HEAP32[3999] | 0)) $storemerge1024 = $426; else break;
 }
 STACKTOP = sp;
 return;
}

function _xchangecase() {
 var $$lcssa = 0, $$lcssa108 = 0, $$lcssa37 = 0, $$pre71 = 0, $$pre75 = 0, $$pre80 = 0, $0 = 0, $10 = 0, $101 = 0, $109 = 0, $11 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $118 = 0, $12 = 0, $122 = 0, $124 = 0, $134 = 0, $140 = 0, $148 = 0, $149 = 0, $150 = 0, $161 = 0, $162 = 0, $163 = 0, $171 = 0, $172 = 0, $173 = 0, $180 = 0, $182 = 0, $183 = 0, $185 = 0, $190 = 0, $191 = 0, $193 = 0, $194 = 0, $195 = 0, $198 = 0, $204 = 0, $208 = 0, $214 = 0, $216 = 0, $218 = 0, $224 = 0, $228 = 0, $230 = 0, $231 = 0, $232 = 0, $234 = 0, $237 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $244 = 0, $248 = 0, $249 = 0, $254 = 0, $255 = 0, $257 = 0, $258 = 0, $259 = 0, $266 = 0, $268 = 0, $269 = 0, $270 = 0, $29 = 0, $299 = 0, $31 = 0, $312 = 0, $313 = 0, $32 = 0, $35 = 0, $39 = 0, $40 = 0, $42 = 0, $45 = 0, $49 = 0, $5 = 0, $51 = 0, $53 = 0, $56 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $67 = 0, $68 = 0, $85 = 0, $86 = 0, $88 = 0, $90 = 0, $96 = 0, $98 = 0, $99 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$0$i = 0, $i$0$i12 = 0, $i$0$i15 = 0, $i$0$i7 = 0, $i$0$i9 = 0, $i$01$i$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa121 = 0, $storemerge3$lcssa = 0, $storemerge3$ph = 0, label = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   $5 = HEAP8[26649] | 0;
   switch ($5 << 24 >> 24) {
   case 1:
    {
     $10 = HEAP32[4345] | 0;
     $11 = HEAP32[4041] | 0;
     $12 = $11 + ($10 << 2) | 0;
     switch (HEAPU8[(HEAP32[4042] | 0) + (HEAP32[$12 >> 2] | 0) >> 0] | 0) {
     case 84:
     case 116:
      {
       HEAP8[26650] = 0;
       $24 = 0;
       break;
      }
     case 76:
     case 108:
      {
       HEAP8[26650] = 1;
       $24 = 0;
       break;
      }
     case 85:
     case 117:
      {
       HEAP8[26650] = 2;
       $24 = 0;
       break;
      }
     default:
      {
       HEAP8[26650] = 3;
       $24 = 1;
      }
     }
     if (((HEAP32[$11 + ($10 + 1 << 2) >> 2] | 0) - (HEAP32[$12 >> 2] | 0) | 0) != 1 | $24) {
      HEAP8[26650] = 3;
      _zoutpoolstr(HEAP32[3990] | 0, $10);
      _zoutpoolstr(HEAP32[3989] | 0, $10);
      _fwrite(3809, 37, 1, HEAP32[3989] | 0) | 0;
      _fwrite(3809, 37, 1, HEAP32[3990] | 0) | 0;
      _bstexwarnprint();
      $31 = HEAP32[4041] | 0;
     } else $31 = $11;
     HEAP32[4333] = 0;
     $29 = HEAP32[4365] | 0;
     $32 = HEAP32[$31 + ($29 << 2) >> 2] | 0;
     HEAP32[4238] = $32;
     $35 = HEAP32[$31 + ($29 + 1 << 2) >> 2] | 0;
     HEAP32[4239] = $35;
     if (($35 - $32 | 0) > (HEAP32[3992] | 0)) {
      _bufferoverflow();
      $39 = HEAP32[4333] | 0;
      $40 = HEAP32[4238] | 0;
      $42 = HEAP32[4239] | 0;
     } else {
      $39 = 0;
      $40 = $32;
      $42 = $35;
     }
     HEAP32[4251] = $39;
     if (($40 | 0) < ($42 | 0)) {
      $45 = $40;
      $49 = $39;
      while (1) {
       HEAP8[(HEAP32[3995] | 0) + $49 >> 0] = HEAP8[(HEAP32[4042] | 0) + $45 >> 0] | 0;
       $51 = (HEAP32[4251] | 0) + 1 | 0;
       HEAP32[4251] = $51;
       $53 = (HEAP32[4238] | 0) + 1 | 0;
       HEAP32[4238] = $53;
       if (($53 | 0) < (HEAP32[4239] | 0)) {
        $45 = $53;
        $49 = $51;
       } else {
        $56 = $51;
        break;
       }
      }
     } else $56 = $39;
     HEAP32[4333] = $56;
     HEAP32[4330] = 0;
     HEAP32[4251] = 0;
     L23 : do if (($56 | 0) > 0) {
      $60 = 0;
      $67 = $56;
      L24 : while (1) {
       $58 = HEAP32[3995] | 0;
       $59 = $58 + $60 | 0;
       $61 = HEAP8[$59 >> 0] | 0;
       L26 : do switch ($61 << 24 >> 24) {
       case 123:
        {
         $62 = HEAP32[4330] | 0;
         HEAP32[4330] = $62 + 1;
         do if (!(($62 | 0) != 0 | ($60 + 4 | 0) > ($67 | 0))) {
          $68 = $60 + 1 | 0;
          if ((HEAP8[$58 + $68 >> 0] | 0) == 92) {
           if (!(HEAP8[26650] | 0)) {
            if (!$60) break;
            if (HEAP32[4377] | 0) if ((HEAP8[25877 + (HEAPU8[$58 + ($60 + -1) >> 0] | 0) >> 0] | 0) == 1) break;
           }
           HEAP32[4251] = $68;
           L55 : do if (($68 | 0) < ($67 | 0)) {
            $86 = $68;
            $88 = $67;
            while (1) {
             $85 = $86 + 1 | 0;
             HEAP32[4251] = $85;
             HEAP32[4323] = $85;
             $$pre71 = HEAP32[3995] | 0;
             L58 : do if (($85 | 0) < ($88 | 0)) {
              $90 = $85;
              while (1) {
               if ((HEAP8[25877 + (HEAPU8[$$pre71 + $90 >> 0] | 0) >> 0] | 0) != 2) {
                $99 = $90;
                break L58;
               }
               $96 = $90 + 1 | 0;
               HEAP32[4251] = $96;
               if (($96 | 0) < ($88 | 0)) $90 = $96; else {
                $99 = $96;
                break;
               }
              }
             } else $99 = $85; while (0);
             $98 = $99 - $85 | 0;
             if (($98 | 0) > 0) {
              $101 = HEAP32[4240] | 0;
              $h$06$i = 0;
              $k$07$i = $85;
              while (1) {
               $h$1$i = (HEAPU8[$$pre71 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
               while (1) if (($h$1$i | 0) < ($101 | 0)) {
                $h$1$i$lcssa = $h$1$i;
                break;
               } else $h$1$i = $h$1$i - $101 | 0;
               $109 = $k$07$i + 1 | 0;
               if (($109 | 0) < ($99 | 0)) {
                $h$06$i = $h$1$i$lcssa;
                $k$07$i = $109;
               } else {
                $h$0$lcssa$i = $h$1$i$lcssa;
                break;
               }
              }
             } else $h$0$lcssa$i = 0;
             HEAP32[4241] = 0;
             $112 = HEAP32[4145] | 0;
             $113 = HEAP32[4041] | 0;
             $114 = HEAP32[4042] | 0;
             $115 = HEAP32[4242] | 0;
             $116 = HEAP32[4243] | 0;
             $p$0$i = $h$0$lcssa$i + 1 | 0;
             L71 : while (1) {
              $118 = HEAP32[$112 + ($p$0$i << 2) >> 2] | 0;
              L73 : do if (($118 | 0) > 0) {
               $122 = HEAP32[$113 + ($118 + 1 << 2) >> 2] | 0;
               $124 = HEAP32[$113 + ($118 << 2) >> 2] | 0;
               if (($122 - $124 | 0) != ($98 | 0)) break;
               if (($122 | 0) > ($124 | 0)) {
                $i$01$i$i = $85;
                $j$02$i$i = $124;
                while (1) {
                 if ((HEAP8[$114 + $j$02$i$i >> 0] | 0) != (HEAP8[$$pre71 + $i$01$i$i >> 0] | 0)) break L73;
                 $134 = $j$02$i$i + 1 | 0;
                 if (($134 | 0) < ($122 | 0)) {
                  $i$01$i$i = $i$01$i$i + 1 | 0;
                  $j$02$i$i = $134;
                 } else break;
                }
               }
               if ((HEAP8[$115 + $p$0$i >> 0] | 0) == 14) {
                $p$0$i$lcssa = $p$0$i;
                label = 44;
                break L71;
               }
              } while (0);
              $140 = HEAP32[$116 + ($p$0$i << 2) >> 2] | 0;
              if (!$140) {
               $p$0$i$lcssa121 = $p$0$i;
               label = 43;
               break;
              } else $p$0$i = $140;
             }
             L82 : do if ((label | 0) == 43) {
              label = 0;
              HEAP32[4338] = $p$0$i$lcssa121;
             } else if ((label | 0) == 44) {
              label = 0;
              HEAP32[4241] = 1;
              HEAP32[4338] = $p$0$i$lcssa;
              switch (HEAPU8[26650] | 0) {
              case 3:
               {
                break L82;
                break;
               }
              case 1:
              case 0:
               {
                switch (HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0) {
                case 7:
                case 5:
                case 3:
                case 9:
                case 11:
                 break;
                default:
                 break L82;
                }
                if (($99 | 0) <= ($85 | 0)) break L82;
                $148 = $99 + -1 | 0;
                $i$0$i = $85;
                while (1) {
                 $149 = $$pre71 + $i$0$i | 0;
                 $150 = HEAP8[$149 >> 0] | 0;
                 if (($150 + -65 & 255) < 26) HEAP8[$149 >> 0] = ($150 & 255) + 32;
                 if (($i$0$i | 0) < ($148 | 0)) $i$0$i = $i$0$i + 1 | 0; else break L82;
                }
                break;
               }
              case 2:
               break;
              default:
               {
                label = 74;
                break L24;
               }
              }
              switch (HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0) {
              case 6:
              case 4:
              case 2:
              case 8:
              case 10:
               {
                if (($99 | 0) <= ($85 | 0)) break L82;
                $161 = $99 + -1 | 0;
                $i$0$i7 = $85;
                while (1) {
                 $162 = $$pre71 + $i$0$i7 | 0;
                 $163 = HEAP8[$162 >> 0] | 0;
                 if (($163 + -97 & 255) < 26) HEAP8[$162 >> 0] = ($163 & 255) + 224;
                 if (($i$0$i7 | 0) < ($161 | 0)) $i$0$i7 = $i$0$i7 + 1 | 0; else break L82;
                }
                break;
               }
              case 12:
              case 1:
              case 0:
               break;
              default:
               break L82;
              }
              if (($99 | 0) > ($85 | 0)) {
               $171 = $99 + -1 | 0;
               $i$0$i9 = $85;
               while (1) {
                $172 = $$pre71 + $i$0$i9 | 0;
                $173 = HEAP8[$172 >> 0] | 0;
                if (($173 + -97 & 255) < 26) HEAP8[$172 >> 0] = ($173 & 255) + 224;
                if (($i$0$i9 | 0) < ($171 | 0)) $i$0$i9 = $i$0$i9 + 1 | 0; else break;
               }
               $180 = HEAP32[4323] | 0;
               $182 = HEAP32[4251] | 0;
              } else {
               $180 = $85;
               $182 = $99;
              }
              if (($180 | 0) < ($182 | 0)) {
               $185 = $180;
               while (1) {
                $183 = HEAP32[3995] | 0;
                HEAP8[$183 + ($185 + -1) >> 0] = HEAP8[$183 + $185 >> 0] | 0;
                $190 = (HEAP32[4323] | 0) + 1 | 0;
                HEAP32[4323] = $190;
                $191 = HEAP32[4251] | 0;
                if (($190 | 0) < ($191 | 0)) $185 = $190; else {
                 $$lcssa = $190;
                 $195 = $191;
                 break;
                }
               }
              } else {
               $$lcssa = $180;
               $195 = $182;
              }
              $193 = $$lcssa + -1 | 0;
              HEAP32[4323] = $193;
              $194 = HEAP32[4333] | 0;
              L117 : do if (($195 | 0) < ($194 | 0)) {
               $$pre75 = HEAP32[3995] | 0;
               $208 = $195;
               while (1) {
                if ((HEAP8[25877 + (HEAPU8[$$pre75 + $208 >> 0] | 0) >> 0] | 0) != 1) {
                 $storemerge3$ph = $208;
                 break L117;
                }
                $214 = $208 + 1 | 0;
                HEAP32[4251] = $214;
                if (($214 | 0) < ($194 | 0)) $208 = $214; else {
                 $storemerge3$ph = $214;
                 break;
                }
               }
              } else $storemerge3$ph = $195; while (0);
              HEAP32[4252] = $storemerge3$ph;
              if (($storemerge3$ph | 0) < ($194 | 0)) {
               $198 = HEAP32[3995] | 0;
               HEAP8[$198 + ($$lcssa + -1) >> 0] = HEAP8[$198 + $storemerge3$ph >> 0] | 0;
               $204 = (HEAP32[4252] | 0) + 1 | 0;
               HEAP32[4252] = $204;
               if (($204 | 0) < (HEAP32[4333] | 0)) {
                $218 = $204;
                while (1) {
                 $216 = HEAP32[3995] | 0;
                 HEAP8[$216 + ($218 - (HEAP32[4251] | 0) + (HEAP32[4323] | 0)) >> 0] = HEAP8[$216 + $218 >> 0] | 0;
                 $224 = (HEAP32[4252] | 0) + 1 | 0;
                 HEAP32[4252] = $224;
                 if (($224 | 0) < (HEAP32[4333] | 0)) $218 = $224; else {
                  $$lcssa108 = $224;
                  break;
                 }
                }
               } else $$lcssa108 = $204;
               $228 = HEAP32[4251] | 0;
               $230 = HEAP32[4323] | 0;
               $storemerge3$lcssa = $$lcssa108;
              } else {
               $228 = $storemerge3$ph;
               $230 = $193;
               $storemerge3$lcssa = $storemerge3$ph;
              }
              HEAP32[4333] = $storemerge3$lcssa - $228 + $230;
              HEAP32[4251] = $230;
             } while (0);
             $231 = HEAP32[4251] | 0;
             HEAP32[4323] = $231;
             $232 = HEAP32[4333] | 0;
             $234 = HEAP32[4330] | 0;
             L131 : do if (($231 | 0) < ($232 | 0) & ($234 | 0) > 0) {
              $$pre80 = HEAP32[3995] | 0;
              $237 = $231;
              $240 = $234;
              while (1) {
               switch (HEAP8[$$pre80 + $237 >> 0] | 0) {
               case 92:
                {
                 $255 = $237;
                 break L131;
                 break;
                }
               case 125:
                {
                 $239 = $240 + -1 | 0;
                 HEAP32[4330] = $239;
                 $244 = $239;
                 break;
                }
               case 123:
                {
                 $241 = $240 + 1 | 0;
                 HEAP32[4330] = $241;
                 $244 = $241;
                 break;
                }
               default:
                $244 = $240;
               }
               $242 = $237 + 1 | 0;
               HEAP32[4251] = $242;
               if (($242 | 0) < ($232 | 0) & ($244 | 0) > 0) {
                $237 = $242;
                $240 = $244;
               } else {
                $255 = $242;
                break L131;
               }
              }
             } else $255 = $231; while (0);
             L140 : do switch (HEAPU8[26650] | 0) {
             case 1:
             case 0:
              {
               $254 = HEAP32[3995] | 0;
               if (($255 | 0) <= ($231 | 0)) break L140;
               $257 = $255 + -1 | 0;
               $i$0$i12 = $231;
               while (1) {
                $258 = $254 + $i$0$i12 | 0;
                $259 = HEAP8[$258 >> 0] | 0;
                if (($259 + -65 & 255) < 26) HEAP8[$258 >> 0] = ($259 & 255) + 32;
                if (($i$0$i12 | 0) < ($257 | 0)) $i$0$i12 = $i$0$i12 + 1 | 0; else break;
               }
               break;
              }
             case 2:
              {
               $266 = HEAP32[3995] | 0;
               if (($255 | 0) <= ($231 | 0)) break L140;
               $268 = $255 + -1 | 0;
               $i$0$i15 = $231;
               while (1) {
                $269 = $266 + $i$0$i15 | 0;
                $270 = HEAP8[$269 >> 0] | 0;
                if (($270 + -97 & 255) < 26) HEAP8[$269 >> 0] = ($270 & 255) + 224;
                if (($i$0$i15 | 0) < ($268 | 0)) $i$0$i15 = $i$0$i15 + 1 | 0; else break;
               }
               break;
              }
             case 3:
              break;
             default:
              {
               label = 93;
               break L24;
              }
             } while (0);
             $248 = HEAP32[4251] | 0;
             $249 = HEAP32[4333] | 0;
             if (($248 | 0) < ($249 | 0) & (HEAP32[4330] | 0) > 0) {
              $86 = $248;
              $88 = $249;
             } else {
              $$lcssa37 = $248;
              break L55;
             }
            }
           } else $$lcssa37 = $68; while (0);
           HEAP32[4251] = $$lcssa37 + -1;
          }
         } while (0);
         HEAP32[4377] = 0;
         break;
        }
       case 125:
        {
         _zdecrbracelevel(HEAP32[4365] | 0);
         HEAP32[4377] = 0;
         break;
        }
       default:
        if (!(HEAP32[4330] | 0)) switch (HEAPU8[26650] | 0) {
        case 3:
         {
          break L26;
          break;
         }
        case 0:
         {
          do if (!$60) $299 = $61; else {
           if (!(HEAP32[4377] | 0)) {
            if (($61 + -65 & 255) >= 26) {
             $299 = $61;
             break;
            }
           } else if (!(($61 + -65 & 255) < 26 ? (HEAP8[25877 + (HEAPU8[$58 + ($60 + -1) >> 0] | 0) >> 0] | 0) != 1 : 0)) {
            $299 = $61;
            break;
           }
           HEAP8[$59 >> 0] = ($61 & 255) + 32;
           $299 = HEAP8[(HEAP32[3995] | 0) + (HEAP32[4251] | 0) >> 0] | 0;
          } while (0);
          if ($299 << 24 >> 24 == 58) {
           HEAP32[4377] = 1;
           break L26;
          }
          if ((HEAP8[25877 + ($299 & 255) >> 0] | 0) == 1) break L26;
          HEAP32[4377] = 0;
          break L26;
          break;
         }
        case 1:
         {
          if (($61 + -65 & 255) >= 26) break L26;
          HEAP8[$59 >> 0] = ($61 & 255) + 32;
          break L26;
          break;
         }
        case 2:
         {
          if (($61 + -97 & 255) >= 26) break L26;
          HEAP8[$59 >> 0] = ($61 & 255) + 224;
          break L26;
          break;
         }
        default:
         {
          label = 112;
          break L24;
         }
        }
       } while (0);
       $312 = (HEAP32[4251] | 0) + 1 | 0;
       HEAP32[4251] = $312;
       $313 = HEAP32[4333] | 0;
       if (($312 | 0) < ($313 | 0)) {
        $60 = $312;
        $67 = $313;
       } else break L23;
      }
      if ((label | 0) == 74) _caseconversionconfusion(); else if ((label | 0) == 93) _caseconversionconfusion(); else if ((label | 0) == 112) _caseconversionconfusion();
     } while (0);
     _zcheckbracelevel(HEAP32[4365] | 0);
     _addpoolbufandpush();
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit(HEAP32[4365] | 0, $5);
     _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(HEAP32[4301] | 0, 1);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 return;
}

function _bstmacrocommand() {
 var $$lcssa$i = 0, $$lcssa$i$i = 0, $$lcssa$i$i14 = 0, $$lcssa$i$i22 = 0, $$lcssa$i$i3 = 0, $$lcssa$i$i30 = 0, $$lcssa$i$i39 = 0, $$lcssa294 = 0, $$lcssa296 = 0, $$lcssa303 = 0, $$lcssa305 = 0, $$lcssa307 = 0, $$lcssa309 = 0, $$lcssa314 = 0, $$lcssa316 = 0, $$lcssa318 = 0, $$lcssa320 = 0, $$lcssa325 = 0, $$lcssa327 = 0, $$lcssa329 = 0, $$lcssa331 = 0, $$lcssa333 = 0, $$lcssa334 = 0, $$lcssa335 = 0, $$lcssa336 = 0, $$lcssa337 = 0, $$lcssa341 = 0, $$lcssa343 = 0, $$lcssa345 = 0, $$lcssa350 = 0, $$lcssa352 = 0, $$lcssa354 = 0, $$lcssa356 = 0, $104 = 0, $105 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $13 = 0, $130 = 0, $131 = 0, $133 = 0, $134 = 0, $136 = 0, $144 = 0, $147 = 0, $15 = 0, $154 = 0, $156 = 0, $157 = 0, $16 = 0, $162 = 0, $163 = 0, $165 = 0, $166 = 0, $168 = 0, $173 = 0, $175 = 0, $18 = 0, $187 = 0, $189 = 0, $190 = 0, $192 = 0, $197 = 0, $198 = 0, $203 = 0, $204 = 0, $206 = 0, $207 = 0, $209 = 0, $214 = 0, $216 = 0, $228 = 0, $23 = 0, $230 = 0, $231 = 0, $233 = 0, $238 = 0, $239 = 0, $244 = 0, $245 = 0, $247 = 0, $248 = 0, $25 = 0, $250 = 0, $255 = 0, $257 = 0, $269 = 0, $271 = 0, $272 = 0, $274 = 0, $275 = 0, $278 = 0, $280 = 0, $281 = 0, $284 = 0, $286 = 0, $288 = 0, $289 = 0, $291 = 0, $293 = 0, $294 = 0, $306 = 0, $308 = 0, $313 = 0, $314 = 0, $316 = 0, $317 = 0, $319 = 0, $324 = 0, $326 = 0, $338 = 0, $340 = 0, $341 = 0, $343 = 0, $347 = 0, $348 = 0, $349 = 0, $350 = 0, $351 = 0, $352 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $42 = 0, $47 = 0, $48 = 0, $53 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $64 = 0, $66 = 0, $7 = 0, $79 = 0, $87 = 0, $88 = 0, $90 = 0, $91 = 0, $i$0$i = 0, $i$01$i$i = 0, $i$01$i1$i = 0, $storemerge = 0, $storemerge48 = 0, $storemerge49 = 0, $storemerge50 = 0, $storemerge51 = 0, $storemerge52 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer23 = 0, $vararg_buffer28 = 0, $vararg_buffer3 = 0, $vararg_buffer33 = 0, $vararg_buffer38 = 0, $vararg_buffer43 = 0, $vararg_buffer48 = 0, $vararg_buffer53 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 $vararg_buffer53 = sp + 176 | 0;
 $vararg_buffer48 = sp + 160 | 0;
 $vararg_buffer43 = sp + 144 | 0;
 $vararg_buffer38 = sp + 128 | 0;
 $vararg_buffer33 = sp + 112 | 0;
 $vararg_buffer28 = sp + 96 | 0;
 $vararg_buffer23 = sp + 80 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (HEAP32[4675] | 0) {
  _fwrite(4887, 41, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4887, 41, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $6 = HEAP32[4045] | 0;
 while (1) {
  $4 = HEAP32[3993] | 0;
  $7 = HEAP8[$4 + $6 >> 0] | 0;
  $12 = HEAP32[3999] | 0;
  $13 = ($6 | 0) < ($12 | 0);
  if ((HEAP8[25877 + ($7 & 255) >> 0] | 0) == 1 & $13) {
   $16 = $6;
   while (1) {
    $15 = $16 + 1 | 0;
    HEAP32[4045] = $15;
    $18 = HEAP8[$4 + $15 >> 0] | 0;
    $23 = ($15 | 0) < ($12 | 0);
    if ($23 & (HEAP8[25877 + ($18 & 255) >> 0] | 0) == 1) $16 = $15; else {
     $$lcssa$i$i = $23;
     $25 = $18;
     $347 = $15;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $13;
   $25 = $7;
   $347 = $6;
  }
  if (!($25 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa350 = $4;
   $$lcssa352 = $12;
   $$lcssa354 = $347;
   $$lcssa356 = $25;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 9;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $6 = 0;
 }
 if ((label | 0) == 9) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa356 << 24 >> 24 != 123) {
  $37 = HEAP32[3989] | 0;
  $39 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $39;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($37, 1750, $vararg_buffer) | 0;
  $40 = HEAP32[3990] | 0;
  $42 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $42;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($40, 1750, $vararg_buffer3) | 0;
  _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $47 = $$lcssa350;
 $54 = $$lcssa352;
 $storemerge = $$lcssa354 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge;
  $48 = HEAP8[$47 + $storemerge >> 0] | 0;
  $53 = ($storemerge | 0) < ($54 | 0);
  if ((HEAP8[25877 + ($48 & 255) >> 0] | 0) == 1 & $53) {
   $57 = $storemerge;
   while (1) {
    $56 = $57 + 1 | 0;
    HEAP32[4045] = $56;
    $59 = HEAP8[$47 + $56 >> 0] | 0;
    $64 = ($56 | 0) < ($54 | 0);
    if ($64 & (HEAP8[25877 + ($59 & 255) >> 0] | 0) == 1) $57 = $56; else {
     $$lcssa$i$i3 = $64;
     $348 = $56;
     $66 = $59;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $53;
   $348 = $storemerge;
   $66 = $48;
  }
  if (!($66 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa341 = $54;
   $$lcssa343 = $47;
   $$lcssa345 = $348;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 18;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $47 = HEAP32[3993] | 0;
  $54 = HEAP32[3999] | 0;
  $storemerge = 0;
 }
 if ((label | 0) == 18) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4044] = $$lcssa345;
 $79 = HEAPU8[$$lcssa343 + $$lcssa345 >> 0] | 0;
 L33 : do if ((HEAP8[25877 + $79 >> 0] | 0) == 3) $storemerge48 = 0; else if ((HEAP8[26390 + $79 >> 0] | 0) == 1 & ($$lcssa345 | 0) < ($$lcssa341 | 0)) {
  $88 = $$lcssa345;
  while (1) {
   $87 = $88 + 1 | 0;
   HEAP32[4045] = $87;
   $90 = HEAP8[$$lcssa343 + $87 >> 0] | 0;
   $91 = $90 & 255;
   if (($87 | 0) < ($$lcssa341 | 0) & (HEAP8[26390 + $91 >> 0] | 0) == 1) $88 = $87; else {
    $$lcssa334 = $88;
    $$lcssa335 = $87;
    $$lcssa336 = $90;
    $$lcssa337 = $91;
    break;
   }
  }
  if (($$lcssa335 | 0) == ($$lcssa345 | 0)) $storemerge48 = 0; else {
   if ((HEAP8[25877 + $$lcssa337 >> 0] | 0) == 1 | ($$lcssa335 | 0) == ($$lcssa341 | 0)) $storemerge49 = 3; else switch ($$lcssa336 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge49 = 1;
     break;
    }
   default:
    {
     $storemerge48 = 2;
     break L33;
    }
   }
   HEAP8[26389] = $storemerge49;
   if (($$lcssa334 | 0) < ($$lcssa345 | 0)) {
    $113 = $$lcssa345;
    $114 = $$lcssa335;
    $115 = $$lcssa343;
   } else {
    $i$0$i = $$lcssa345;
    while (1) {
     $104 = $$lcssa343 + $i$0$i | 0;
     $105 = HEAP8[$104 >> 0] | 0;
     if (($105 + -65 & 255) < 26) HEAP8[$104 >> 0] = ($105 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa334 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $113 = HEAP32[4044] | 0;
    $114 = HEAP32[4045] | 0;
    $115 = HEAP32[3993] | 0;
   }
   $116 = _zstrlookup($115, $113, $114 - $113 | 0, 13, 1) | 0;
   HEAP32[4319] = $116;
   if (HEAP32[4241] | 0) {
    $119 = HEAP32[3990] | 0;
    $120 = HEAP32[4044] | 0;
    $121 = HEAP32[4045] | 0;
    if (($120 | 0) < ($121 | 0)) {
     $i$01$i$i = $120;
     while (1) {
      _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i$i >> 0] | 0) >> 0] | 0, $119) | 0;
      $130 = $i$01$i$i + 1 | 0;
      $131 = HEAP32[4045] | 0;
      if (($130 | 0) < ($131 | 0)) $i$01$i$i = $130; else {
       $$lcssa333 = $131;
       break;
      }
     }
     $134 = HEAP32[4044] | 0;
     $136 = $$lcssa333;
    } else {
     $134 = $120;
     $136 = $121;
    }
    $133 = HEAP32[3989] | 0;
    if (($134 | 0) < ($136 | 0)) {
     $i$01$i1$i = $134;
     while (1) {
      _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $133) | 0;
      $144 = $i$01$i1$i + 1 | 0;
      if (($144 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $144; else break;
     }
     $147 = HEAP32[3989] | 0;
    } else $147 = $133;
    _fwrite(4935, 30, 1, $147) | 0;
    _fwrite(4935, 30, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   HEAP32[(HEAP32[4249] | 0) + ($116 << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + ($116 << 2) >> 2];
   $156 = HEAP32[4045] | 0;
   while (1) {
    $154 = HEAP32[3993] | 0;
    $157 = HEAP8[$154 + $156 >> 0] | 0;
    $162 = HEAP32[3999] | 0;
    $163 = ($156 | 0) < ($162 | 0);
    if ((HEAP8[25877 + ($157 & 255) >> 0] | 0) == 1 & $163) {
     $166 = $156;
     while (1) {
      $165 = $166 + 1 | 0;
      HEAP32[4045] = $165;
      $168 = HEAP8[$154 + $165 >> 0] | 0;
      $173 = ($165 | 0) < ($162 | 0);
      if ($173 & (HEAP8[25877 + ($168 & 255) >> 0] | 0) == 1) $166 = $165; else {
       $$lcssa$i$i14 = $173;
       $175 = $168;
       $349 = $165;
       break;
      }
     }
    } else {
     $$lcssa$i$i14 = $163;
     $175 = $157;
     $349 = $156;
    }
    if (!($175 << 24 >> 24 == 37 | $$lcssa$i$i14 ^ 1)) {
     $$lcssa325 = $154;
     $$lcssa327 = $162;
     $$lcssa329 = $349;
     $$lcssa331 = $175;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 45;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $156 = 0;
   }
   if ((label | 0) == 45) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa331 << 24 >> 24 != 125) {
    $187 = HEAP32[3989] | 0;
    $189 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer8 >> 2] = 34;
    HEAP32[$vararg_buffer8 + 4 >> 2] = $189;
    HEAP32[$vararg_buffer8 + 8 >> 2] = 1832;
    _fprintf($187, 1750, $vararg_buffer8) | 0;
    $190 = HEAP32[3990] | 0;
    $192 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer13 >> 2] = 34;
    HEAP32[$vararg_buffer13 + 4 >> 2] = $192;
    HEAP32[$vararg_buffer13 + 8 >> 2] = 1832;
    _fprintf($190, 1750, $vararg_buffer13) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   $197 = $$lcssa325;
   $204 = $$lcssa327;
   $storemerge50 = $$lcssa329 + 1 | 0;
   while (1) {
    HEAP32[4045] = $storemerge50;
    $198 = HEAP8[$197 + $storemerge50 >> 0] | 0;
    $203 = ($storemerge50 | 0) < ($204 | 0);
    if ((HEAP8[25877 + ($198 & 255) >> 0] | 0) == 1 & $203) {
     $207 = $storemerge50;
     while (1) {
      $206 = $207 + 1 | 0;
      HEAP32[4045] = $206;
      $209 = HEAP8[$197 + $206 >> 0] | 0;
      $214 = ($206 | 0) < ($204 | 0);
      if ($214 & (HEAP8[25877 + ($209 & 255) >> 0] | 0) == 1) $207 = $206; else {
       $$lcssa$i$i22 = $214;
       $216 = $209;
       $350 = $206;
       break;
      }
     }
    } else {
     $$lcssa$i$i22 = $203;
     $216 = $198;
     $350 = $storemerge50;
    }
    if (!($216 << 24 >> 24 == 37 | $$lcssa$i$i22 ^ 1)) {
     $$lcssa314 = $204;
     $$lcssa316 = $197;
     $$lcssa318 = $350;
     $$lcssa320 = $216;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 54;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    $197 = HEAP32[3993] | 0;
    $204 = HEAP32[3999] | 0;
    $storemerge50 = 0;
   }
   if ((label | 0) == 54) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa320 << 24 >> 24 != 123) {
    $228 = HEAP32[3989] | 0;
    $230 = HEAPU8[26256] | 0;
    HEAP32[$vararg_buffer18 >> 2] = 34;
    HEAP32[$vararg_buffer18 + 4 >> 2] = $230;
    HEAP32[$vararg_buffer18 + 8 >> 2] = 1832;
    _fprintf($228, 1750, $vararg_buffer18) | 0;
    $231 = HEAP32[3990] | 0;
    $233 = HEAPU8[26256] | 0;
    HEAP32[$vararg_buffer23 >> 2] = 34;
    HEAP32[$vararg_buffer23 + 4 >> 2] = $233;
    HEAP32[$vararg_buffer23 + 8 >> 2] = 1832;
    _fprintf($231, 1750, $vararg_buffer23) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   $238 = $$lcssa316;
   $245 = $$lcssa314;
   $storemerge51 = $$lcssa318 + 1 | 0;
   while (1) {
    HEAP32[4045] = $storemerge51;
    $239 = HEAP8[$238 + $storemerge51 >> 0] | 0;
    $244 = ($storemerge51 | 0) < ($245 | 0);
    if ((HEAP8[25877 + ($239 & 255) >> 0] | 0) == 1 & $244) {
     $248 = $storemerge51;
     while (1) {
      $247 = $248 + 1 | 0;
      HEAP32[4045] = $247;
      $250 = HEAP8[$238 + $247 >> 0] | 0;
      $255 = ($247 | 0) < ($245 | 0);
      if ($255 & (HEAP8[25877 + ($250 & 255) >> 0] | 0) == 1) $248 = $247; else {
       $$lcssa$i$i30 = $255;
       $257 = $250;
       $351 = $247;
       break;
      }
     }
    } else {
     $$lcssa$i$i30 = $244;
     $257 = $239;
     $351 = $storemerge51;
    }
    if (!($257 << 24 >> 24 == 37 | $$lcssa$i$i30 ^ 1)) {
     $$lcssa303 = $245;
     $$lcssa305 = $238;
     $$lcssa307 = $351;
     $$lcssa309 = $257;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 63;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    $238 = HEAP32[3993] | 0;
    $245 = HEAP32[3999] | 0;
    $storemerge51 = 0;
   }
   if ((label | 0) == 63) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa309 << 24 >> 24 != 34) {
    $269 = HEAP32[3989] | 0;
    $271 = HEAPU8[26167] | 0;
    HEAP32[$vararg_buffer28 >> 2] = 4966;
    HEAP32[$vararg_buffer28 + 4 >> 2] = $271;
    HEAP32[$vararg_buffer28 + 8 >> 2] = 4994;
    _fprintf($269, 3109, $vararg_buffer28) | 0;
    $272 = HEAP32[3990] | 0;
    $274 = HEAPU8[26167] | 0;
    HEAP32[$vararg_buffer33 >> 2] = 4966;
    HEAP32[$vararg_buffer33 + 4 >> 2] = $274;
    HEAP32[$vararg_buffer33 + 8 >> 2] = 4994;
    _fprintf($272, 3109, $vararg_buffer33) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   $275 = $$lcssa307 + 1 | 0;
   HEAP32[4045] = $275;
   HEAP32[4044] = $275;
   $278 = ($275 | 0) < ($$lcssa303 | 0);
   if ((HEAP8[$$lcssa305 + $275 >> 0] | 0) != 34 & $278) {
    $281 = $275;
    while (1) {
     $280 = $281 + 1 | 0;
     HEAP32[4045] = $280;
     $284 = ($280 | 0) < ($$lcssa303 | 0);
     if ($284 & (HEAP8[$$lcssa305 + $280 >> 0] | 0) != 34) $281 = $280; else {
      $$lcssa$i = $284;
      $293 = $280;
      break;
     }
    }
   } else {
    $$lcssa$i = $278;
    $293 = $275;
   }
   if (!$$lcssa$i) {
    $286 = HEAP32[3989] | 0;
    $288 = HEAPU8[26167] | 0;
    HEAP32[$vararg_buffer38 >> 2] = 5005;
    HEAP32[$vararg_buffer38 + 4 >> 2] = $288;
    HEAP32[$vararg_buffer38 + 8 >> 2] = 5018;
    _fprintf($286, 3109, $vararg_buffer38) | 0;
    $289 = HEAP32[3990] | 0;
    $291 = HEAPU8[26167] | 0;
    HEAP32[$vararg_buffer43 >> 2] = 5005;
    HEAP32[$vararg_buffer43 + 4 >> 2] = $291;
    HEAP32[$vararg_buffer43 + 8 >> 2] = 5018;
    _fprintf($289, 3109, $vararg_buffer43) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   $294 = _zstrlookup($$lcssa305, $275, $293 - $275 | 0, 0, 1) | 0;
   HEAP32[4677] = $294;
   HEAP8[(HEAP32[4144] | 0) + $294 >> 0] = 3;
   HEAP32[(HEAP32[4249] | 0) + (HEAP32[4319] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4677] << 2) >> 2];
   $storemerge52 = (HEAP32[4045] | 0) + 1 | 0;
   while (1) {
    HEAP32[4045] = $storemerge52;
    $306 = HEAP32[3993] | 0;
    $308 = HEAP8[$306 + $storemerge52 >> 0] | 0;
    $313 = HEAP32[3999] | 0;
    $314 = ($storemerge52 | 0) < ($313 | 0);
    if ((HEAP8[25877 + ($308 & 255) >> 0] | 0) == 1 & $314) {
     $317 = $storemerge52;
     while (1) {
      $316 = $317 + 1 | 0;
      HEAP32[4045] = $316;
      $319 = HEAP8[$306 + $316 >> 0] | 0;
      $324 = ($316 | 0) < ($313 | 0);
      if ($324 & (HEAP8[25877 + ($319 & 255) >> 0] | 0) == 1) $317 = $316; else {
       $$lcssa$i$i39 = $324;
       $326 = $319;
       $352 = $316;
       break;
      }
     }
    } else {
     $$lcssa$i$i39 = $314;
     $326 = $308;
     $352 = $storemerge52;
    }
    if (!($326 << 24 >> 24 == 37 | $$lcssa$i$i39 ^ 1)) {
     $$lcssa294 = $352;
     $$lcssa296 = $326;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 76;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    $storemerge52 = 0;
   }
   if ((label | 0) == 76) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa296 << 24 >> 24 == 125) {
    HEAP32[4045] = $$lcssa294 + 1;
    STACKTOP = sp;
    return;
   } else {
    $338 = HEAP32[3989] | 0;
    $340 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer48 >> 2] = 34;
    HEAP32[$vararg_buffer48 + 4 >> 2] = $340;
    HEAP32[$vararg_buffer48 + 8 >> 2] = 1832;
    _fprintf($338, 1750, $vararg_buffer48) | 0;
    $341 = HEAP32[3990] | 0;
    $343 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer53 >> 2] = 34;
    HEAP32[$vararg_buffer53 + 4 >> 2] = $343;
    HEAP32[$vararg_buffer53 + 8 >> 2] = 1832;
    _fprintf($341, 1750, $vararg_buffer53) | 0;
    _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
  }
 } else $storemerge48 = 0; while (0);
 HEAP8[26389] = $storemerge48;
 _bstidprint();
 _fwrite(4929, 5, 1, HEAP32[3989] | 0) | 0;
 _fwrite(4929, 5, 1, HEAP32[3990] | 0) | 0;
 _bsterrprintandlookforblankline();
 STACKTOP = sp;
 return;
}

function _zexecutefn($exfnloc) {
 $exfnloc = $exfnloc | 0;
 var $$lcssa = 0, $$lcssa55 = 0, $113 = 0, $117 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $128 = 0, $139 = 0, $153 = 0, $157 = 0, $160 = 0, $163 = 0, $167 = 0, $169 = 0, $174 = 0, $177 = 0, $18 = 0, $184 = 0, $187 = 0, $189 = 0, $190 = 0, $194 = 0, $197 = 0, $198 = 0, $201 = 0, $203 = 0, $209 = 0, $210 = 0, $211 = 0, $212 = 0, $220 = 0, $221 = 0, $227 = 0, $229 = 0, $231 = 0, $232 = 0, $238 = 0, $31 = 0, $35 = 0, $39 = 0, $40 = 0, $48 = 0, $5 = 0, $50 = 0, $51 = 0, $55 = 0, $57 = 0, $58 = 0, $60 = 0, $64 = 0, $65 = 0, $66 = 0, $7 = 0, $70 = 0, $71 = 0, $77 = 0, $78 = 0, $79 = 0, $80 = 0, $83 = 0, $84 = 0, $86 = 0, $89 = 0, $91 = 0, $93 = 0, $95 = 0, $96 = 0, $98 = 0, $rpoplt1 = 0, $rpoplt2 = 0, $rpoptp1 = 0, $rpoptp2 = 0, $stklt$i = 0, $stktp$i = 0, $storemerge1$lcssa = 0, $storemerge115 = 0, $storemerge17 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer10 = 0, $vararg_buffer13 = 0, $vararg_buffer16 = 0, $vararg_buffer19 = 0, $vararg_buffer22 = 0, $vararg_buffer25 = 0, $vararg_buffer28 = 0, $vararg_buffer31 = 0, $vararg_buffer34 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, $wizptr$014 = 0, $wizptr$1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $vararg_buffer34 = sp + 96 | 0;
 $vararg_buffer31 = sp + 88 | 0;
 $vararg_buffer28 = sp + 80 | 0;
 $vararg_buffer25 = sp + 72 | 0;
 $vararg_buffer22 = sp + 64 | 0;
 $vararg_buffer19 = sp + 56 | 0;
 $vararg_buffer16 = sp + 48 | 0;
 $vararg_buffer13 = sp + 40 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $stklt$i = sp + 120 | 0;
 $stktp$i = sp + 126 | 0;
 $rpoplt1 = sp + 116 | 0;
 $rpoplt2 = sp + 112 | 0;
 $rpoptp1 = sp + 125 | 0;
 $rpoptp2 = sp + 124 | 0;
 do switch (HEAPU8[(HEAP32[4144] | 0) + $exfnloc >> 0] | 0 | 0) {
 case 0:
  {
   $5 = (HEAP32[4249] | 0) + ($exfnloc << 2) | 0;
   $7 = 16644 + (HEAP32[$5 >> 2] << 2) | 0;
   HEAP32[$7 >> 2] = (HEAP32[$7 >> 2] | 0) + 1;
   do switch (HEAP32[$5 >> 2] | 0) {
   case 0:
    {
     _xequals();
     STACKTOP = sp;
     return;
    }
   case 1:
    {
     _xgreaterthan();
     STACKTOP = sp;
     return;
    }
   case 2:
    {
     _xlessthan();
     STACKTOP = sp;
     return;
    }
   case 3:
    {
     _xplus();
     STACKTOP = sp;
     return;
    }
   case 4:
    {
     _xminus();
     STACKTOP = sp;
     return;
    }
   case 5:
    {
     _xconcatenate();
     STACKTOP = sp;
     return;
    }
   case 6:
    {
     _xgets();
     STACKTOP = sp;
     return;
    }
   case 7:
    {
     _xaddperiod();
     STACKTOP = sp;
     return;
    }
   case 8:
    {
     if (!(HEAP32[4152] | 0)) {
      _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
      _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
      _bstexwarnprint();
      STACKTOP = sp;
      return;
     }
     $18 = HEAP32[(HEAP32[4100] | 0) + (HEAP32[4150] << 2) >> 2] | 0;
     if (($18 | 0) == (HEAP32[4386] | 0)) {
      _zexecutefn(HEAP32[4303] | 0);
      STACKTOP = sp;
      return;
     }
     if (!$18) {
      STACKTOP = sp;
      return;
     }
     _zexecutefn($18);
     STACKTOP = sp;
     return;
    }
   case 9:
    {
     _xchangecase();
     STACKTOP = sp;
     return;
    }
   case 10:
    {
     _xchrtoint();
     STACKTOP = sp;
     return;
    }
   case 11:
    {
     if (!(HEAP32[4152] | 0)) {
      _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
      _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
      _bstexwarnprint();
      STACKTOP = sp;
      return;
     } else {
      _zpushlitstk(HEAP32[(HEAP32[4099] | 0) + (HEAP32[4150] << 2) >> 2] | 0, 1);
      STACKTOP = sp;
      return;
     }
     break;
    }
   case 12:
    {
     _xduplicate();
     STACKTOP = sp;
     return;
    }
   case 13:
    {
     _xempty();
     STACKTOP = sp;
     return;
    }
   case 14:
    {
     _xformatname();
     STACKTOP = sp;
     return;
    }
   case 15:
    {
     _zzpoplitstk(17380, 26648);
     _zzpoplitstk(17460, 26649);
     _zzpoplitstk(17512, 26651);
     $31 = HEAP8[26648] | 0;
     switch ($31 << 24 >> 24) {
     case 2:
      {
       $35 = HEAP8[26649] | 0;
       switch ($35 << 24 >> 24) {
       case 2:
        {
         $39 = HEAP8[26651] | 0;
         $40 = HEAP32[4378] | 0;
         switch ($39 << 24 >> 24) {
         case 0:
          {
           if (($40 | 0) > 0) {
            _zexecutefn(HEAP32[4365] | 0);
            STACKTOP = sp;
            return;
           } else {
            _zexecutefn(HEAP32[4345] | 0);
            STACKTOP = sp;
            return;
           }
           break;
          }
         case 4:
          {
           STACKTOP = sp;
           return;
          }
         default:
          {
           _zprintstklit($40, $39);
           _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
           _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
           _bstexwarnprint();
           STACKTOP = sp;
           return;
          }
         }
         break;
        }
       case 4:
        {
         STACKTOP = sp;
         return;
        }
       default:
        {
         _zprintstklit(HEAP32[4365] | 0, $35);
         _fwrite(3549, 17, 1, HEAP32[3989] | 0) | 0;
         _fwrite(3549, 17, 1, HEAP32[3990] | 0) | 0;
         _bstexwarnprint();
         STACKTOP = sp;
         return;
        }
       }
       break;
      }
     case 4:
      {
       STACKTOP = sp;
       return;
      }
     default:
      {
       _zprintstklit(HEAP32[4345] | 0, $31);
       _fwrite(3549, 17, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3549, 17, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
       STACKTOP = sp;
       return;
      }
     }
     break;
    }
   case 16:
    {
     _xinttochr();
     STACKTOP = sp;
     return;
    }
   case 17:
    {
     _xinttostr();
     STACKTOP = sp;
     return;
    }
   case 18:
    {
     _xmissing();
     STACKTOP = sp;
     return;
    }
   case 19:
    {
     _outputbblline();
     STACKTOP = sp;
     return;
    }
   case 20:
    {
     _xnumnames();
     STACKTOP = sp;
     return;
    }
   case 21:
    {
     _zzpoplitstk(17380, 26648);
     STACKTOP = sp;
     return;
    }
   case 22:
    {
     _xpreamble();
     STACKTOP = sp;
     return;
    }
   case 23:
    {
     _xpurify();
     STACKTOP = sp;
     return;
    }
   case 24:
    {
     _xquote();
     STACKTOP = sp;
     return;
    }
   case 26:
    {
     if ((HEAP32[4360] | 0) <= 0) {
      STACKTOP = sp;
      return;
     }
     do {
      _zzpoplitstk($stklt$i, $stktp$i);
      $48 = HEAP8[$stktp$i >> 0] | 0;
      if ($48 << 24 >> 24 == 4) {
       $50 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer >> 2] = 3567;
       _fprintf($50, 960, $vararg_buffer) | 0;
       $51 = HEAP32[3990] | 0;
       HEAP32[$vararg_buffer1 >> 2] = 3567;
       _fprintf($51, 960, $vararg_buffer1) | 0;
      } else _zprintlit(HEAP32[$stklt$i >> 2] | 0, $48);
     } while ((HEAP32[4360] | 0) > 0);
     STACKTOP = sp;
     return;
    }
   case 27:
    {
     _xsubstring();
     STACKTOP = sp;
     return;
    }
   case 28:
    {
     _xswap();
     STACKTOP = sp;
     return;
    }
   case 29:
    {
     _xtextlength();
     STACKTOP = sp;
     return;
    }
   case 30:
    {
     _xtextprefix();
     STACKTOP = sp;
     return;
    }
   case 31:
    {
     _zzpoplitstk($stklt$i, $stktp$i);
     $55 = HEAP8[$stktp$i >> 0] | 0;
     if ($55 << 24 >> 24 == 4) {
      $57 = HEAP32[3989] | 0;
      HEAP32[$vararg_buffer4 >> 2] = 3567;
      _fprintf($57, 960, $vararg_buffer4) | 0;
      $58 = HEAP32[3990] | 0;
      HEAP32[$vararg_buffer7 >> 2] = 3567;
      _fprintf($58, 960, $vararg_buffer7) | 0;
     } else _zprintlit(HEAP32[$stklt$i >> 2] | 0, $55);
     STACKTOP = sp;
     return;
    }
   case 32:
    {
     _xtype();
     STACKTOP = sp;
     return;
    }
   case 33:
    {
     _xwarning();
     STACKTOP = sp;
     return;
    }
   case 34:
    {
     _zzpoplitstk($rpoplt1, $rpoptp1);
     _zzpoplitstk($rpoplt2, $rpoptp2);
     $60 = HEAP8[$rpoptp1 >> 0] | 0;
     switch ($60 << 24 >> 24) {
     case 2:
      {
       $64 = HEAP8[$rpoptp2 >> 0] | 0;
       switch ($64 << 24 >> 24) {
       case 2:
        {
         $65 = HEAP32[$rpoplt2 >> 2] | 0;
         $66 = HEAP32[$rpoplt1 >> 2] | 0;
         L128 : while (1) {
          _zexecutefn($65);
          _zzpoplitstk(17380, 26648);
          $70 = HEAP8[26648] | 0;
          $71 = HEAP32[4345] | 0;
          switch ($70 << 24 >> 24) {
          case 4:
           {
            label = 102;
            break L128;
            break;
           }
          case 0:
           break;
          default:
           {
            $$lcssa = $70;
            $$lcssa55 = $71;
            label = 65;
            break L128;
           }
          }
          if (($71 | 0) <= 0) {
           label = 102;
           break;
          }
          _zexecutefn($66);
         }
         if ((label | 0) == 65) {
          _zprintstklit($$lcssa55, $$lcssa);
          _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
          _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
          _bstexwarnprint();
          STACKTOP = sp;
          return;
         } else if ((label | 0) == 102) {
          STACKTOP = sp;
          return;
         }
         break;
        }
       case 4:
        {
         STACKTOP = sp;
         return;
        }
       default:
        {
         _zprintstklit(HEAP32[$rpoplt2 >> 2] | 0, $64);
         _fwrite(3549, 17, 1, HEAP32[3989] | 0) | 0;
         _fwrite(3549, 17, 1, HEAP32[3990] | 0) | 0;
         _bstexwarnprint();
         STACKTOP = sp;
         return;
        }
       }
       break;
      }
     case 4:
      {
       STACKTOP = sp;
       return;
      }
     default:
      {
       _zprintstklit(HEAP32[$rpoplt1 >> 2] | 0, $60);
       _fwrite(3549, 17, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3549, 17, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
       STACKTOP = sp;
       return;
      }
     }
     break;
    }
   case 35:
    {
     _xwidth();
     STACKTOP = sp;
     return;
    }
   case 36:
    {
     _xwrite();
     STACKTOP = sp;
     return;
    }
   case 25:
    {
     STACKTOP = sp;
     return;
    }
   default:
    {
     _fwrite(4101, 25, 1, HEAP32[3989] | 0) | 0;
     _fwrite(4101, 25, 1, HEAP32[3990] | 0) | 0;
     $77 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer10 >> 2] = 964;
     _fprintf($77, 960, $vararg_buffer10) | 0;
     $78 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer13 >> 2] = 964;
     _fprintf($78, 960, $vararg_buffer13) | 0;
     $79 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer16 >> 2] = 985;
     _fprintf($79, 960, $vararg_buffer16) | 0;
     $80 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer19 >> 2] = 985;
     _fprintf($80, 960, $vararg_buffer19) | 0;
     HEAP8[25620] = 3;
     _longjmp(16008, 1);
    }
   } while (0);
   break;
  }
 case 1:
  {
   $83 = HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0;
   $84 = HEAP32[4315] | 0;
   $86 = HEAP32[$84 + ($83 << 2) >> 2] | 0;
   if (($86 | 0) == (HEAP32[4313] | 0)) {
    STACKTOP = sp;
    return;
   } else {
    $89 = $86;
    $93 = $84;
    $wizptr$014 = $83;
   }
   while (1) {
    if (!$89) {
     $91 = $wizptr$014 + 1 | 0;
     _zpushlitstk(HEAP32[$93 + ($91 << 2) >> 2] | 0, 2);
     $wizptr$1 = $91;
    } else {
     _zexecutefn($89);
     $wizptr$1 = $wizptr$014;
    }
    $95 = $wizptr$1 + 1 | 0;
    $96 = HEAP32[4315] | 0;
    $98 = HEAP32[$96 + ($95 << 2) >> 2] | 0;
    if (($98 | 0) == (HEAP32[4313] | 0)) break; else {
     $89 = $98;
     $93 = $96;
     $wizptr$014 = $95;
    }
   }
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   _zpushlitstk(HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0, 0);
   STACKTOP = sp;
   return;
  }
 case 3:
  {
   _zpushlitstk(HEAP32[(HEAP32[4145] | 0) + ($exfnloc << 2) >> 2] | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  {
   if (!(HEAP32[4152] | 0)) {
    _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
    _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
    _bstexwarnprint();
    STACKTOP = sp;
    return;
   }
   $113 = Math_imul(HEAP32[4247] | 0, HEAP32[4150] | 0) | 0;
   $117 = (HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0) + $113 | 0;
   HEAP32[4151] = $117;
   if (($117 | 0) >= (HEAP32[4148] | 0)) {
    _fwrite(3267, 32, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3267, 32, 1, HEAP32[3990] | 0) | 0;
    $122 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer22 >> 2] = 964;
    _fprintf($122, 960, $vararg_buffer22) | 0;
    $123 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer25 >> 2] = 964;
    _fprintf($123, 960, $vararg_buffer25) | 0;
    $124 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer28 >> 2] = 985;
    _fprintf($124, 960, $vararg_buffer28) | 0;
    $125 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer31 >> 2] = 985;
    _fprintf($125, 960, $vararg_buffer31) | 0;
    HEAP8[25620] = 3;
    _longjmp(16008, 1);
   }
   $128 = HEAP32[(HEAP32[4149] | 0) + ($117 << 2) >> 2] | 0;
   if (!$128) {
    _zpushlitstk(HEAP32[(HEAP32[4145] | 0) + ($exfnloc << 2) >> 2] | 0, 3);
    STACKTOP = sp;
    return;
   } else {
    _zpushlitstk($128, 1);
    STACKTOP = sp;
    return;
   }
   break;
  }
 case 5:
  {
   if (!(HEAP32[4152] | 0)) {
    _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
    _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
    _bstexwarnprint();
    STACKTOP = sp;
    return;
   } else {
    $139 = Math_imul(HEAP32[4368] | 0, HEAP32[4150] | 0) | 0;
    _zpushlitstk(HEAP32[(HEAP32[4369] | 0) + ((HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0) + $139 << 2) >> 2] | 0, 0);
    STACKTOP = sp;
    return;
   }
   break;
  }
 case 6:
  {
   if (!(HEAP32[4152] | 0)) {
    _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
    _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
    _bstexwarnprint();
    STACKTOP = sp;
    return;
   }
   $153 = Math_imul(HEAP32[4255] | 0, HEAP32[4150] | 0) | 0;
   $157 = (HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0) + $153 | 0;
   HEAP32[4370] = $157;
   HEAP32[4251] = 0;
   $160 = Math_imul((HEAP32[4257] | 0) + 1 | 0, $157) | 0;
   $163 = HEAP8[(HEAP32[4258] | 0) + $160 >> 0] | 0;
   if ($163 << 24 >> 24 == 127) $storemerge1$lcssa = 0; else {
    $167 = $163;
    $storemerge115 = 0;
    while (1) {
     HEAP8[(HEAP32[3995] | 0) + $storemerge115 >> 0] = $167;
     $169 = (HEAP32[4251] | 0) + 1 | 0;
     HEAP32[4251] = $169;
     $174 = (Math_imul((HEAP32[4257] | 0) + 1 | 0, HEAP32[4370] | 0) | 0) + $169 | 0;
     $177 = HEAP8[(HEAP32[4258] | 0) + $174 >> 0] | 0;
     if ($177 << 24 >> 24 == 127) {
      $storemerge1$lcssa = $169;
      break;
     } else {
      $167 = $177;
      $storemerge115 = $169;
     }
    }
   }
   HEAP32[4333] = $storemerge1$lcssa;
   _addpoolbufandpush();
   STACKTOP = sp;
   return;
  }
 case 7:
  {
   _zpushlitstk(HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0, 0);
   STACKTOP = sp;
   return;
  }
 case 8:
  {
   $184 = HEAP32[(HEAP32[4249] | 0) + ($exfnloc << 2) >> 2] | 0;
   HEAP32[4372] = $184;
   $187 = HEAP32[(HEAP32[4373] | 0) + ($184 << 2) >> 2] | 0;
   if (($187 | 0) > 0) {
    _zpushlitstk($187, 1);
    STACKTOP = sp;
    return;
   }
   $189 = HEAP32[4237] | 0;
   $190 = HEAP32[4376] | 0;
   $194 = HEAP32[4043] | 0;
   if (((HEAP32[$190 + ($184 << 2) >> 2] | 0) + $189 | 0) > ($194 | 0)) {
    $203 = $194;
    while (1) {
     $201 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer34 >> 2] = 1161;
     HEAP32[$vararg_buffer34 + 4 >> 2] = 1;
     HEAP32[$vararg_buffer34 + 8 >> 2] = $203 + 65e3;
     HEAP32[$vararg_buffer34 + 12 >> 2] = $203;
     _fprintf($201, 1023, $vararg_buffer34) | 0;
     HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
     $209 = (HEAP32[4043] | 0) + 65e3 | 0;
     HEAP32[4043] = $209;
     $210 = HEAP32[4237] | 0;
     $211 = HEAP32[4372] | 0;
     $212 = HEAP32[4376] | 0;
     if (((HEAP32[$212 + ($211 << 2) >> 2] | 0) + $210 | 0) > ($209 | 0)) $203 = $209; else {
      $197 = $212;
      $198 = $211;
      $238 = $210;
      break;
     }
    }
   } else {
    $197 = $190;
    $198 = $184;
    $238 = $189;
   }
   HEAP32[4374] = 0;
   if ((HEAP32[$197 + ($198 << 2) >> 2] | 0) > 0) {
    $220 = $198;
    $227 = $238;
    $storemerge17 = 0;
    while (1) {
     $221 = (Math_imul((HEAP32[4307] | 0) + 1 | 0, $220) | 0) + $storemerge17 | 0;
     HEAP8[(HEAP32[4042] | 0) + $227 >> 0] = HEAP8[(HEAP32[4375] | 0) + $221 >> 0] | 0;
     $229 = (HEAP32[4237] | 0) + 1 | 0;
     HEAP32[4237] = $229;
     $231 = (HEAP32[4374] | 0) + 1 | 0;
     HEAP32[4374] = $231;
     $232 = HEAP32[4372] | 0;
     if (($231 | 0) < (HEAP32[(HEAP32[4376] | 0) + ($232 << 2) >> 2] | 0)) {
      $220 = $232;
      $227 = $229;
      $storemerge17 = $231;
     } else break;
    }
   }
   _zpushlitstk(_makestring() | 0, 1);
   STACKTOP = sp;
   return;
  }
 default:
  _unknwnfunctionclassconfusion();
 } while (0);
}

function _scanafieldtokenandeatwhite() {
 var $$lcssa$i$i = 0, $$lcssa87 = 0, $$lcssa88 = 0, $$lcssa90 = 0, $$lcssa92 = 0, $$lcssa93 = 0, $$lcssa94 = 0, $$lcssa95 = 0, $$lcssa96 = 0, $$lcssa98 = 0, $$lcssa99 = 0, $$pre41 = 0, $$pre42 = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $108 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $117 = 0, $118 = 0, $122 = 0, $124 = 0, $134 = 0, $14 = 0, $140 = 0, $142 = 0, $149 = 0, $150 = 0, $156 = 0, $157 = 0, $165 = 0, $167 = 0, $169 = 0, $17 = 0, $173 = 0, $174 = 0, $186 = 0, $187 = 0, $188 = 0, $19 = 0, $191 = 0, $2 = 0, $20 = 0, $200 = 0, $202 = 0, $205 = 0, $206 = 0, $21 = 0, $212 = 0, $214 = 0, $215 = 0, $216 = 0, $22 = 0, $220 = 0, $222 = 0, $228 = 0, $229 = 0, $230 = 0, $233 = 0, $235 = 0, $238 = 0, $240 = 0, $246 = 0, $247 = 0, $249 = 0, $25 = 0, $250 = 0, $257 = 0, $269 = 0, $270 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $40 = 0, $42 = 0, $43 = 0, $44 = 0, $51 = 0, $53 = 0, $56 = 0, $58 = 0, $65 = 0, $67 = 0, $68 = 0, $70 = 0, $71 = 0, $87 = 0, $88 = 0, $95 = 0, $96 = 0, $97 = 0, $99 = 0, $Result$0 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$0$i = 0, $i$01$i$i = 0, $j$02$i$i = 0, $k$07$i = 0, $storemerge13 = 0, $storemerge14 = 0, $storemerge2 = 0, $storemerge2$in = 0, $storemerge25 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer10 = 0, $vararg_buffer15 = 0, $vararg_buffer20 = 0, $vararg_buffer23 = 0, $vararg_buffer26 = 0, $vararg_buffer29 = 0, $vararg_buffer32 = 0, $vararg_buffer37 = 0, $vararg_buffer4 = 0, $vararg_buffer42 = 0, $vararg_buffer47 = 0, $vararg_buffer52 = 0, $vararg_buffer57 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 $vararg_buffer57 = sp + 176 | 0;
 $vararg_buffer52 = sp + 160 | 0;
 $vararg_buffer47 = sp + 144 | 0;
 $vararg_buffer42 = sp + 128 | 0;
 $vararg_buffer37 = sp + 112 | 0;
 $vararg_buffer32 = sp + 96 | 0;
 $vararg_buffer29 = sp + 88 | 0;
 $vararg_buffer26 = sp + 80 | 0;
 $vararg_buffer23 = sp + 72 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer15 = sp + 48 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4045] | 0;
 $1 = HEAP32[3993] | 0;
 $2 = $1 + $0 | 0;
 L1 : do switch (HEAPU8[$2 >> 0] | 0) {
 case 123:
  {
   HEAP8[26646] = 125;
   if (!(_scanbalancedbraces() | 0)) {
    $Result$0 = 0;
    STACKTOP = sp;
    return $Result$0 | 0;
   }
   break;
  }
 case 34:
  {
   HEAP8[26646] = 34;
   if (!(_scanbalancedbraces() | 0)) {
    $Result$0 = 0;
    STACKTOP = sp;
    return $Result$0 | 0;
   }
   break;
  }
 case 57:
 case 56:
 case 55:
 case 54:
 case 53:
 case 52:
 case 51:
 case 50:
 case 49:
 case 48:
  {
   HEAP32[4044] = $0;
   HEAP32[4308] = 0;
   $10 = HEAPU8[$2 >> 0] | 0;
   $14 = HEAP32[3999] | 0;
   if ((HEAP8[25877 + $10 >> 0] | 0) == 3 & ($0 | 0) < ($14 | 0)) {
    $17 = 0;
    $19 = $10;
    $22 = $0;
   } else {
    $30 = HEAP32[3989] | 0;
    _fwrite(3197, 19, 1, $30) | 0;
    $31 = HEAP32[3990] | 0;
    _fwrite(3197, 19, 1, $31) | 0;
    $32 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer >> 2] = 964;
    _fprintf($32, 960, $vararg_buffer) | 0;
    $33 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer1 >> 2] = 964;
    _fprintf($33, 960, $vararg_buffer1) | 0;
    $34 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer4 >> 2] = 985;
    _fprintf($34, 960, $vararg_buffer4) | 0;
    $35 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer7 >> 2] = 985;
    _fprintf($35, 960, $vararg_buffer7) | 0;
    HEAP8[25620] = 3;
    _longjmp(16008, 1);
   }
   while (1) {
    $20 = $19 + -48 + ($17 * 10 | 0) | 0;
    HEAP32[4308] = $20;
    $21 = $22 + 1 | 0;
    HEAP32[4045] = $21;
    $25 = HEAPU8[$1 + $21 >> 0] | 0;
    if (($21 | 0) < ($14 | 0) & (HEAP8[25877 + $25 >> 0] | 0) == 3) {
     $17 = $20;
     $19 = $25;
     $22 = $21;
    } else {
     $$lcssa98 = $22;
     $$lcssa99 = $21;
     break;
    }
   }
   if (($$lcssa99 | 0) == ($0 | 0)) {
    $30 = HEAP32[3989] | 0;
    _fwrite(3197, 19, 1, $30) | 0;
    $31 = HEAP32[3990] | 0;
    _fwrite(3197, 19, 1, $31) | 0;
    $32 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer >> 2] = 964;
    _fprintf($32, 960, $vararg_buffer) | 0;
    $33 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer1 >> 2] = 964;
    _fprintf($33, 960, $vararg_buffer1) | 0;
    $34 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer4 >> 2] = 985;
    _fprintf($34, 960, $vararg_buffer4) | 0;
    $35 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer7 >> 2] = 985;
    _fprintf($35, 960, $vararg_buffer7) | 0;
    HEAP8[25620] = 3;
    _longjmp(16008, 1);
   }
   if (HEAP32[4318] | 0) {
    HEAP32[4252] = $0;
    if (($0 | 0) <= ($$lcssa98 | 0)) {
     $40 = HEAP32[4251] | 0;
     $storemerge25 = $0;
     while (1) {
      if (($40 | 0) == (HEAP32[3992] | 0)) {
       $$lcssa96 = $40;
       break;
      }
      HEAP8[(HEAP32[3995] | 0) + $40 >> 0] = HEAP8[(HEAP32[3993] | 0) + $storemerge25 >> 0] | 0;
      $51 = (HEAP32[4251] | 0) + 1 | 0;
      HEAP32[4251] = $51;
      $53 = (HEAP32[4252] | 0) + 1 | 0;
      HEAP32[4252] = $53;
      if (($53 | 0) < (HEAP32[4045] | 0)) {
       $40 = $51;
       $storemerge25 = $53;
      } else break L1;
     }
     $42 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer10 >> 2] = 2020;
     HEAP32[$vararg_buffer10 + 4 >> 2] = $$lcssa96;
     HEAP32[$vararg_buffer10 + 8 >> 2] = 2045;
     _fprintf($42, 1280, $vararg_buffer10) | 0;
     $43 = HEAP32[3990] | 0;
     $44 = HEAP32[3992] | 0;
     HEAP32[$vararg_buffer15 >> 2] = 2020;
     HEAP32[$vararg_buffer15 + 4 >> 2] = $44;
     HEAP32[$vararg_buffer15 + 8 >> 2] = 2045;
     _fprintf($43, 1280, $vararg_buffer15) | 0;
     _biberrprint();
     $Result$0 = 0;
     STACKTOP = sp;
     return $Result$0 | 0;
    }
   }
   break;
  }
 default:
  {
   $56 = HEAP8[26647] | 0;
   HEAP32[4044] = $0;
   $58 = HEAPU8[$2 >> 0] | 0;
   L3 : do if ((HEAP8[25877 + $58 >> 0] | 0) == 3) $storemerge13 = 0; else {
    $65 = HEAP32[3999] | 0;
    if ((HEAP8[26390 + $58 >> 0] | 0) == 1 & ($0 | 0) < ($65 | 0)) {
     $68 = $0;
     while (1) {
      $67 = $68 + 1 | 0;
      HEAP32[4045] = $67;
      $70 = HEAP8[$1 + $67 >> 0] | 0;
      $71 = $70 & 255;
      if (($67 | 0) < ($65 | 0) & (HEAP8[26390 + $71 >> 0] | 0) == 1) $68 = $67; else {
       $$lcssa92 = $68;
       $$lcssa93 = $67;
       $$lcssa94 = $70;
       $$lcssa95 = $71;
       break;
      }
     }
     if (($$lcssa93 | 0) == ($0 | 0)) $storemerge13 = 0; else {
      if ((HEAP8[25877 + $$lcssa95 >> 0] | 0) == 1 | ($$lcssa93 | 0) == ($65 | 0)) $storemerge14 = 3; else if ($$lcssa94 << 24 >> 24 == $56 << 24 >> 24) $storemerge14 = 1; else switch ($$lcssa94 << 24 >> 24) {
      case 35:
      case 44:
       {
        $storemerge14 = 1;
        break;
       }
      default:
       {
        $storemerge13 = 2;
        break L3;
       }
      }
      HEAP8[26389] = $storemerge14;
      if (!(HEAP32[4318] | 0)) break L1;
      if (($$lcssa92 | 0) < ($0 | 0)) {
       $102 = $1;
       $96 = $0;
       $97 = $$lcssa93;
      } else {
       $i$0$i = $0;
       while (1) {
        $87 = $1 + $i$0$i | 0;
        $88 = HEAP8[$87 >> 0] | 0;
        if (($88 + -65 & 255) < 26) HEAP8[$87 >> 0] = ($88 & 255) + 32;
        if (($i$0$i | 0) < ($$lcssa92 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
       }
       $102 = HEAP32[3993] | 0;
       $96 = HEAP32[4044] | 0;
       $97 = HEAP32[4045] | 0;
      }
      $95 = $97 - $96 | 0;
      if (($95 | 0) > 0) {
       $99 = HEAP32[4240] | 0;
       $h$06$i = 0;
       $k$07$i = $96;
       while (1) {
        $h$1$i = (HEAPU8[$102 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
        while (1) if (($h$1$i | 0) < ($99 | 0)) {
         $h$1$i$lcssa = $h$1$i;
         break;
        } else $h$1$i = $h$1$i - $99 | 0;
        $108 = $k$07$i + 1 | 0;
        if (($108 | 0) < ($97 | 0)) {
         $h$06$i = $h$1$i$lcssa;
         $k$07$i = $108;
        } else {
         $h$0$lcssa$i = $h$1$i$lcssa;
         break;
        }
       }
      } else $h$0$lcssa$i = 0;
      HEAP32[4241] = 0;
      $111 = HEAP32[4145] | 0;
      $112 = HEAP32[4041] | 0;
      $113 = HEAP32[4042] | 0;
      $114 = HEAP32[4242] | 0;
      $115 = HEAP32[4243] | 0;
      $117 = $h$0$lcssa$i + 1 | 0;
      L30 : while (1) {
       $118 = HEAP32[$111 + ($117 << 2) >> 2] | 0;
       L32 : do if (($118 | 0) > 0) {
        $122 = HEAP32[$112 + ($118 + 1 << 2) >> 2] | 0;
        $124 = HEAP32[$112 + ($118 << 2) >> 2] | 0;
        if (($122 - $124 | 0) == ($95 | 0)) {
         if (($122 | 0) > ($124 | 0)) {
          $i$01$i$i = $96;
          $j$02$i$i = $124;
          while (1) {
           if ((HEAP8[$113 + $j$02$i$i >> 0] | 0) != (HEAP8[$102 + $i$01$i$i >> 0] | 0)) break L32;
           $134 = $j$02$i$i + 1 | 0;
           if (($134 | 0) < ($122 | 0)) {
            $i$01$i$i = $i$01$i$i + 1 | 0;
            $j$02$i$i = $134;
           } else break;
          }
         }
         if ((HEAP8[$114 + $117 >> 0] | 0) == 13) {
          $$lcssa90 = $117;
          label = 40;
          break L30;
         }
        }
       } while (0);
       $140 = HEAP32[$115 + ($117 << 2) >> 2] | 0;
       if (!$140) {
        $142 = $117;
        break;
       } else $117 = $140;
      }
      if ((label | 0) == 40) {
       HEAP32[4241] = 1;
       $142 = $$lcssa90;
      }
      HEAP32[4319] = $142;
      HEAP32[4320] = 1;
      L44 : do if ((HEAP32[4147] | 0) != 0 & (HEAP32[4321] | 0) == 2 & ($142 | 0) == (HEAP32[4322] | 0)) {
       HEAP32[4320] = 0;
       _macrowarnprint();
       $149 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer20 >> 2] = 3230;
       _fprintf($149, 960, $vararg_buffer20) | 0;
       $150 = HEAP32[3990] | 0;
       HEAP32[$vararg_buffer23 >> 2] = 3230;
       _fprintf($150, 960, $vararg_buffer23) | 0;
       _biblnnumprint();
       switch (HEAP8[25620] | 0) {
       case 1:
        {
         HEAP32[3991] = (HEAP32[3991] | 0) + 1;
         break L44;
         break;
        }
       case 0:
        {
         HEAP8[25620] = 1;
         HEAP32[3991] = 1;
         break L44;
         break;
        }
       default:
        break L44;
       }
      } while (0);
      L50 : do if (!(HEAP32[4241] | 0)) {
       HEAP32[4320] = 0;
       _macrowarnprint();
       $156 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer26 >> 2] = 3257;
       _fprintf($156, 960, $vararg_buffer26) | 0;
       $157 = HEAP32[3990] | 0;
       HEAP32[$vararg_buffer29 >> 2] = 3257;
       _fprintf($157, 960, $vararg_buffer29) | 0;
       _biblnnumprint();
       switch (HEAP8[25620] | 0) {
       case 1:
        {
         HEAP32[3991] = (HEAP32[3991] | 0) + 1;
         break L50;
         break;
        }
       case 0:
        {
         HEAP8[25620] = 1;
         HEAP32[3991] = 1;
         break L50;
         break;
        }
       default:
        break L50;
       }
      } while (0);
      if (!(HEAP32[4320] | 0)) break L1;
      $165 = (HEAP32[4249] | 0) + (HEAP32[4319] << 2) | 0;
      $167 = HEAP32[4041] | 0;
      $169 = HEAP32[$167 + (HEAP32[$165 >> 2] << 2) >> 2] | 0;
      HEAP32[4252] = $169;
      $173 = HEAP32[$167 + ((HEAP32[$165 >> 2] | 0) + 1 << 2) >> 2] | 0;
      HEAP32[4253] = $173;
      $174 = HEAP32[4251] | 0;
      if (!$174) if (($169 | 0) < ($173 | 0) ? (HEAP8[25877 + (HEAPU8[(HEAP32[4042] | 0) + $169 >> 0] | 0) >> 0] | 0) == 1 : 0) if (!(HEAP32[3992] | 0)) {
       $186 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer32 >> 2] = 2020;
       HEAP32[$vararg_buffer32 + 4 >> 2] = 0;
       HEAP32[$vararg_buffer32 + 8 >> 2] = 2045;
       _fprintf($186, 1280, $vararg_buffer32) | 0;
       $187 = HEAP32[3990] | 0;
       $188 = HEAP32[3992] | 0;
       HEAP32[$vararg_buffer37 >> 2] = 2020;
       HEAP32[$vararg_buffer37 + 4 >> 2] = $188;
       HEAP32[$vararg_buffer37 + 8 >> 2] = 2045;
       _fprintf($187, 1280, $vararg_buffer37) | 0;
       _biberrprint();
       $Result$0 = 0;
       STACKTOP = sp;
       return $Result$0 | 0;
      } else {
       HEAP8[HEAP32[3995] >> 0] = 32;
       $191 = (HEAP32[4251] | 0) + 1 | 0;
       HEAP32[4251] = $191;
       $$pre41 = HEAP32[4042] | 0;
       $$pre42 = HEAP32[4253] | 0;
       $storemerge2$in = HEAP32[4252] | 0;
       while (1) {
        $storemerge2 = $storemerge2$in + 1 | 0;
        HEAP32[4252] = $storemerge2;
        if (($storemerge2 | 0) < ($$pre42 | 0) ? (HEAP8[25877 + (HEAPU8[$$pre41 + $storemerge2 >> 0] | 0) >> 0] | 0) == 1 : 0) $storemerge2$in = $storemerge2; else {
         $200 = $storemerge2;
         $202 = $$pre42;
         $269 = $191;
         break;
        }
       }
      } else {
       $200 = $169;
       $202 = $173;
       $269 = 0;
      } else {
       $200 = $169;
       $202 = $173;
       $269 = $174;
      }
      if (($200 | 0) < ($202 | 0)) {
       $205 = $200;
       $212 = $269;
      } else break L1;
      while (1) {
       $206 = HEAP8[(HEAP32[4042] | 0) + $205 >> 0] | 0;
       if ((HEAP8[25877 + ($206 & 255) >> 0] | 0) == 1) {
        $222 = HEAP32[3995] | 0;
        if ((HEAP8[$222 + ($212 + -1) >> 0] | 0) == 32) $270 = $212; else {
         if (($212 | 0) == (HEAP32[3992] | 0)) {
          $$lcssa88 = $212;
          label = 64;
          break;
         }
         HEAP8[$222 + $212 >> 0] = 32;
         $233 = (HEAP32[4251] | 0) + 1 | 0;
         HEAP32[4251] = $233;
         $270 = $233;
        }
       } else {
        if (($212 | 0) == (HEAP32[3992] | 0)) {
         $$lcssa87 = $212;
         label = 60;
         break;
        }
        HEAP8[(HEAP32[3995] | 0) + $212 >> 0] = $206;
        $220 = (HEAP32[4251] | 0) + 1 | 0;
        HEAP32[4251] = $220;
        $270 = $220;
       }
       $235 = (HEAP32[4252] | 0) + 1 | 0;
       HEAP32[4252] = $235;
       if (($235 | 0) < (HEAP32[4253] | 0)) {
        $205 = $235;
        $212 = $270;
       } else break L1;
      }
      if ((label | 0) == 60) {
       $214 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer42 >> 2] = 2020;
       HEAP32[$vararg_buffer42 + 4 >> 2] = $$lcssa87;
       HEAP32[$vararg_buffer42 + 8 >> 2] = 2045;
       _fprintf($214, 1280, $vararg_buffer42) | 0;
       $215 = HEAP32[3990] | 0;
       $216 = HEAP32[3992] | 0;
       HEAP32[$vararg_buffer47 >> 2] = 2020;
       HEAP32[$vararg_buffer47 + 4 >> 2] = $216;
       HEAP32[$vararg_buffer47 + 8 >> 2] = 2045;
       _fprintf($215, 1280, $vararg_buffer47) | 0;
       _biberrprint();
       $Result$0 = 0;
       STACKTOP = sp;
       return $Result$0 | 0;
      } else if ((label | 0) == 64) {
       $228 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer52 >> 2] = 2020;
       HEAP32[$vararg_buffer52 + 4 >> 2] = $$lcssa88;
       HEAP32[$vararg_buffer52 + 8 >> 2] = 2045;
       _fprintf($228, 1280, $vararg_buffer52) | 0;
       $229 = HEAP32[3990] | 0;
       $230 = HEAP32[3992] | 0;
       HEAP32[$vararg_buffer57 >> 2] = 2020;
       HEAP32[$vararg_buffer57 + 4 >> 2] = $230;
       HEAP32[$vararg_buffer57 + 8 >> 2] = 2045;
       _fprintf($229, 1280, $vararg_buffer57) | 0;
       _biberrprint();
       $Result$0 = 0;
       STACKTOP = sp;
       return $Result$0 | 0;
      }
     }
    } else $storemerge13 = 0;
   } while (0);
   HEAP8[26389] = $storemerge13;
   _bibidprint();
   _fwrite(3217, 12, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3217, 12, 1, HEAP32[3990] | 0) | 0;
   _biberrprint();
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  }
 } while (0);
 $240 = HEAP32[4045] | 0;
 while (1) {
  $238 = HEAP32[3993] | 0;
  $246 = HEAP32[3999] | 0;
  $247 = ($240 | 0) < ($246 | 0);
  if ((HEAP8[25877 + (HEAPU8[$238 + $240 >> 0] | 0) >> 0] | 0) == 1 & $247) {
   $250 = $240;
   while (1) {
    $249 = $250 + 1 | 0;
    HEAP32[4045] = $249;
    $257 = ($249 | 0) < ($246 | 0);
    if ($257 & (HEAP8[25877 + (HEAPU8[$238 + $249 >> 0] | 0) >> 0] | 0) == 1) $250 = $249; else {
     $$lcssa$i$i = $257;
     break;
    }
   }
  } else $$lcssa$i$i = $247;
  if ($$lcssa$i$i) {
   $Result$0 = 1;
   label = 74;
   break;
  }
  if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) break;
  HEAP32[4146] = (HEAP32[4146] | 0) + 1;
  HEAP32[4045] = 0;
  $240 = 0;
 }
 if ((label | 0) == 74) {
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
 _biberrprint();
 $Result$0 = 0;
 STACKTOP = sp;
 return $Result$0 | 0;
}

function _strstr($h, $n) {
 $h = $h | 0;
 $n = $n | 0;
 var $$0 = 0, $$0$lcssa$i = 0, $$0$lcssa$i12 = 0, $$0$lcssa$i4 = 0, $$01$i = 0, $$02$i = 0, $$02$i8 = 0, $$03$i = 0, $$3$i = 0, $$lcssa$i = 0, $$lcssa$i11 = 0, $$lcssa291 = 0, $$lcssa294 = 0, $$lcssa297 = 0, $$lcssa311 = 0, $$lcssa314 = 0, $$lcssa317 = 0, $$lcssa332 = 0, $$pr$i = 0, $0 = 0, $101 = 0, $111 = 0, $115 = 0, $118 = 0, $12 = 0, $122 = 0, $125 = 0, $127 = 0, $128 = 0, $132 = 0, $134 = 0, $135 = 0, $138 = 0, $139 = 0, $142 = 0, $144 = 0, $146 = 0, $147 = 0, $151 = 0, $153 = 0, $154 = 0, $157 = 0, $158 = 0, $161 = 0, $163 = 0, $165 = 0, $169 = 0, $17 = 0, $171 = 0, $175 = 0, $179 = 0, $180 = 0, $181 = 0, $183 = 0, $186 = 0, $193 = 0, $204 = 0, $205 = 0, $212 = 0, $214 = 0, $219 = 0, $221 = 0, $226 = 0, $23 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $26 = 0, $27 = 0, $3 = 0, $31 = 0, $35 = 0, $36 = 0, $39 = 0, $48 = 0, $57 = 0, $59 = 0, $6 = 0, $60 = 0, $63 = 0, $69 = 0, $70 = 0, $8 = 0, $84 = 0, $9 = 0, $95 = 0, $98 = 0, $99 = 0, $byteset$i = 0, $hw$0$in2$i = 0, $hw$03$i = 0, $hw$03$i7 = 0, $ip$0$ph$lcssa$i = 0, $ip$0$ph$lcssa145$i = 0, $ip$0$ph78$i = 0, $ip$1$ip$0$i = 0, $ip$1$ph$lcssa$i = 0, $ip$1$ph57$i = 0, $jp$0$ph15$ph72$i = 0, $jp$0$ph1567$i = 0, $jp$0$ph1567$i$lcssa = 0, $jp$0$ph1567$i$lcssa$lcssa = 0, $jp$0$ph79$i = 0, $jp$1$ph11$ph51$i = 0, $jp$1$ph1146$i = 0, $jp$1$ph1146$i$lcssa = 0, $jp$1$ph1146$i$lcssa$lcssa = 0, $jp$1$ph58$i = 0, $k$061$i = 0, $k$141$i = 0, $k$340$i = 0, $k$340$i$lcssa = 0, $k$4$i = 0, $l$082$i = 0, $l$082$i$lcssa331 = 0, $mem$0$i = 0, $mem0$0$i = 0, $p$0$ph$ph$lcssa34$i = 0, $p$0$ph$ph$lcssa34146$i = 0, $p$0$ph$ph73$i = 0, $p$1$p$0$i = 0, $p$1$ph$ph$lcssa25$i = 0, $p$1$ph$ph52$i = 0, $p$3$i = 0, $shift$i = 0, $z$0$i = 0, $z$3$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1056 | 0;
 $byteset$i = sp + 1024 | 0;
 $shift$i = sp;
 $0 = HEAP8[$n >> 0] | 0;
 do if (!($0 << 24 >> 24)) $$0 = $h; else {
  $3 = _strchr($h, $0 << 24 >> 24) | 0;
  if (!$3) $$0 = 0; else {
   $6 = HEAP8[$n + 1 >> 0] | 0;
   if (!($6 << 24 >> 24)) $$0 = $3; else {
    $8 = $3 + 1 | 0;
    $9 = HEAP8[$8 >> 0] | 0;
    if (!($9 << 24 >> 24)) $$0 = 0; else {
     $12 = HEAP8[$n + 2 >> 0] | 0;
     if (!($12 << 24 >> 24)) {
      $17 = $6 & 255 | ($0 & 255) << 8;
      $$01$i = $8;
      $233 = $9;
      $hw$0$in2$i = HEAPU8[$3 >> 0] << 8 | $9 & 255;
      while (1) {
       $23 = $hw$0$in2$i & 65535;
       if (($23 | 0) == ($17 | 0)) {
        $$0$lcssa$i = $$01$i;
        $31 = $233;
        break;
       }
       $26 = $$01$i + 1 | 0;
       $27 = HEAP8[$26 >> 0] | 0;
       if (!($27 << 24 >> 24)) {
        $$0$lcssa$i = $26;
        $31 = 0;
        break;
       } else {
        $$01$i = $26;
        $233 = $27;
        $hw$0$in2$i = $27 & 255 | $23 << 8;
       }
      }
      $$0 = $31 << 24 >> 24 ? $$0$lcssa$i + -1 | 0 : 0;
      break;
     }
     $35 = $3 + 2 | 0;
     $36 = HEAP8[$35 >> 0] | 0;
     if (!($36 << 24 >> 24)) $$0 = 0; else {
      $39 = HEAP8[$n + 3 >> 0] | 0;
      if (!($39 << 24 >> 24)) {
       $48 = ($6 & 255) << 16 | ($0 & 255) << 24 | ($12 & 255) << 8;
       $57 = ($36 & 255) << 8 | ($9 & 255) << 16 | HEAPU8[$3 >> 0] << 24;
       if (($57 | 0) == ($48 | 0)) {
        $$0$lcssa$i4 = $35;
        $$lcssa$i = $36;
       } else {
        $$02$i = $35;
        $hw$03$i = $57;
        while (1) {
         $59 = $$02$i + 1 | 0;
         $60 = HEAP8[$59 >> 0] | 0;
         $63 = ($60 & 255 | $hw$03$i) << 8;
         if ($60 << 24 >> 24 == 0 | ($63 | 0) == ($48 | 0)) {
          $$0$lcssa$i4 = $59;
          $$lcssa$i = $60;
          break;
         } else {
          $$02$i = $59;
          $hw$03$i = $63;
         }
        }
       }
       $$0 = $$lcssa$i << 24 >> 24 ? $$0$lcssa$i4 + -2 | 0 : 0;
       break;
      }
      $69 = $3 + 3 | 0;
      $70 = HEAP8[$69 >> 0] | 0;
      if (!($70 << 24 >> 24)) $$0 = 0; else {
       if (!(HEAP8[$n + 4 >> 0] | 0)) {
        $84 = ($6 & 255) << 16 | ($0 & 255) << 24 | ($12 & 255) << 8 | $39 & 255;
        $95 = ($36 & 255) << 8 | ($9 & 255) << 16 | $70 & 255 | HEAPU8[$3 >> 0] << 24;
        if (($95 | 0) == ($84 | 0)) {
         $$0$lcssa$i12 = $69;
         $$lcssa$i11 = $70;
        } else {
         $$02$i8 = $69;
         $hw$03$i7 = $95;
         while (1) {
          $98 = $$02$i8 + 1 | 0;
          $99 = HEAP8[$98 >> 0] | 0;
          $101 = $99 & 255 | $hw$03$i7 << 8;
          if ($99 << 24 >> 24 == 0 | ($101 | 0) == ($84 | 0)) {
           $$0$lcssa$i12 = $98;
           $$lcssa$i11 = $99;
           break;
          } else {
           $$02$i8 = $98;
           $hw$03$i7 = $101;
          }
         }
        }
        $$0 = $$lcssa$i11 << 24 >> 24 ? $$0$lcssa$i12 + -3 | 0 : 0;
        break;
       };
       HEAP32[$byteset$i >> 2] = 0;
       HEAP32[$byteset$i + 4 >> 2] = 0;
       HEAP32[$byteset$i + 8 >> 2] = 0;
       HEAP32[$byteset$i + 12 >> 2] = 0;
       HEAP32[$byteset$i + 16 >> 2] = 0;
       HEAP32[$byteset$i + 20 >> 2] = 0;
       HEAP32[$byteset$i + 24 >> 2] = 0;
       HEAP32[$byteset$i + 28 >> 2] = 0;
       $111 = $0;
       $l$082$i = 0;
       while (1) {
        if (!(HEAP8[$3 + $l$082$i >> 0] | 0)) {
         $$3$i = 0;
         break;
        }
        $115 = $byteset$i + ((($111 & 255) >>> 5 & 255) << 2) | 0;
        HEAP32[$115 >> 2] = HEAP32[$115 >> 2] | 1 << ($111 & 31);
        $118 = $l$082$i + 1 | 0;
        HEAP32[$shift$i + (($111 & 255) << 2) >> 2] = $118;
        $122 = HEAP8[$n + $118 >> 0] | 0;
        if (!($122 << 24 >> 24)) {
         $$lcssa332 = $118;
         $l$082$i$lcssa331 = $l$082$i;
         label = 23;
         break;
        } else {
         $111 = $122;
         $l$082$i = $118;
        }
       }
       L32 : do if ((label | 0) == 23) {
        L34 : do if ($$lcssa332 >>> 0 > 1) {
         $234 = 1;
         $ip$0$ph78$i = -1;
         $jp$0$ph79$i = 0;
         L35 : while (1) {
          $235 = $234;
          $jp$0$ph15$ph72$i = $jp$0$ph79$i;
          $p$0$ph$ph73$i = 1;
          while (1) {
           $236 = $235;
           $jp$0$ph1567$i = $jp$0$ph15$ph72$i;
           L39 : while (1) {
            $134 = $236;
            $k$061$i = 1;
            while (1) {
             $132 = HEAP8[$n + ($k$061$i + $ip$0$ph78$i) >> 0] | 0;
             $135 = HEAP8[$n + $134 >> 0] | 0;
             if ($132 << 24 >> 24 != $135 << 24 >> 24) {
              $$lcssa311 = $134;
              $$lcssa314 = $132;
              $$lcssa317 = $135;
              $jp$0$ph1567$i$lcssa = $jp$0$ph1567$i;
              break L39;
             }
             $128 = $k$061$i + 1 | 0;
             if (($k$061$i | 0) == ($p$0$ph$ph73$i | 0)) break;
             $127 = $128 + $jp$0$ph1567$i | 0;
             if ($127 >>> 0 < $$lcssa332 >>> 0) {
              $134 = $127;
              $k$061$i = $128;
             } else {
              $ip$0$ph$lcssa$i = $ip$0$ph78$i;
              $p$0$ph$ph$lcssa34$i = $p$0$ph$ph73$i;
              break L35;
             }
            }
            $138 = $jp$0$ph1567$i + $p$0$ph$ph73$i | 0;
            $139 = $138 + 1 | 0;
            if ($139 >>> 0 < $$lcssa332 >>> 0) {
             $236 = $139;
             $jp$0$ph1567$i = $138;
            } else {
             $ip$0$ph$lcssa$i = $ip$0$ph78$i;
             $p$0$ph$ph$lcssa34$i = $p$0$ph$ph73$i;
             break L35;
            }
           }
           $142 = $$lcssa311 - $ip$0$ph78$i | 0;
           if (($$lcssa314 & 255) <= ($$lcssa317 & 255)) {
            $jp$0$ph1567$i$lcssa$lcssa = $jp$0$ph1567$i$lcssa;
            break;
           }
           $125 = $$lcssa311 + 1 | 0;
           if ($125 >>> 0 < $$lcssa332 >>> 0) {
            $235 = $125;
            $jp$0$ph15$ph72$i = $$lcssa311;
            $p$0$ph$ph73$i = $142;
           } else {
            $ip$0$ph$lcssa$i = $ip$0$ph78$i;
            $p$0$ph$ph$lcssa34$i = $142;
            break L35;
           }
          }
          $144 = $jp$0$ph1567$i$lcssa$lcssa + 2 | 0;
          if ($144 >>> 0 < $$lcssa332 >>> 0) {
           $234 = $144;
           $ip$0$ph78$i = $jp$0$ph1567$i$lcssa$lcssa;
           $jp$0$ph79$i = $jp$0$ph1567$i$lcssa$lcssa + 1 | 0;
          } else {
           $ip$0$ph$lcssa$i = $jp$0$ph1567$i$lcssa$lcssa;
           $p$0$ph$ph$lcssa34$i = 1;
           break;
          }
         }
         $237 = 1;
         $ip$1$ph57$i = -1;
         $jp$1$ph58$i = 0;
         while (1) {
          $239 = $237;
          $jp$1$ph11$ph51$i = $jp$1$ph58$i;
          $p$1$ph$ph52$i = 1;
          while (1) {
           $238 = $239;
           $jp$1$ph1146$i = $jp$1$ph11$ph51$i;
           L54 : while (1) {
            $153 = $238;
            $k$141$i = 1;
            while (1) {
             $151 = HEAP8[$n + ($k$141$i + $ip$1$ph57$i) >> 0] | 0;
             $154 = HEAP8[$n + $153 >> 0] | 0;
             if ($151 << 24 >> 24 != $154 << 24 >> 24) {
              $$lcssa291 = $153;
              $$lcssa294 = $151;
              $$lcssa297 = $154;
              $jp$1$ph1146$i$lcssa = $jp$1$ph1146$i;
              break L54;
             }
             $147 = $k$141$i + 1 | 0;
             if (($k$141$i | 0) == ($p$1$ph$ph52$i | 0)) break;
             $146 = $147 + $jp$1$ph1146$i | 0;
             if ($146 >>> 0 < $$lcssa332 >>> 0) {
              $153 = $146;
              $k$141$i = $147;
             } else {
              $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
              $ip$1$ph$lcssa$i = $ip$1$ph57$i;
              $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
              $p$1$ph$ph$lcssa25$i = $p$1$ph$ph52$i;
              break L34;
             }
            }
            $157 = $jp$1$ph1146$i + $p$1$ph$ph52$i | 0;
            $158 = $157 + 1 | 0;
            if ($158 >>> 0 < $$lcssa332 >>> 0) {
             $238 = $158;
             $jp$1$ph1146$i = $157;
            } else {
             $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
             $ip$1$ph$lcssa$i = $ip$1$ph57$i;
             $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
             $p$1$ph$ph$lcssa25$i = $p$1$ph$ph52$i;
             break L34;
            }
           }
           $161 = $$lcssa291 - $ip$1$ph57$i | 0;
           if (($$lcssa294 & 255) >= ($$lcssa297 & 255)) {
            $jp$1$ph1146$i$lcssa$lcssa = $jp$1$ph1146$i$lcssa;
            break;
           }
           $165 = $$lcssa291 + 1 | 0;
           if ($165 >>> 0 < $$lcssa332 >>> 0) {
            $239 = $165;
            $jp$1$ph11$ph51$i = $$lcssa291;
            $p$1$ph$ph52$i = $161;
           } else {
            $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
            $ip$1$ph$lcssa$i = $ip$1$ph57$i;
            $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
            $p$1$ph$ph$lcssa25$i = $161;
            break L34;
           }
          }
          $163 = $jp$1$ph1146$i$lcssa$lcssa + 2 | 0;
          if ($163 >>> 0 < $$lcssa332 >>> 0) {
           $237 = $163;
           $ip$1$ph57$i = $jp$1$ph1146$i$lcssa$lcssa;
           $jp$1$ph58$i = $jp$1$ph1146$i$lcssa$lcssa + 1 | 0;
          } else {
           $ip$0$ph$lcssa145$i = $ip$0$ph$lcssa$i;
           $ip$1$ph$lcssa$i = $jp$1$ph1146$i$lcssa$lcssa;
           $p$0$ph$ph$lcssa34146$i = $p$0$ph$ph$lcssa34$i;
           $p$1$ph$ph$lcssa25$i = 1;
           break;
          }
         }
        } else {
         $ip$0$ph$lcssa145$i = -1;
         $ip$1$ph$lcssa$i = -1;
         $p$0$ph$ph$lcssa34146$i = 1;
         $p$1$ph$ph$lcssa25$i = 1;
        } while (0);
        $169 = ($ip$1$ph$lcssa$i + 1 | 0) >>> 0 > ($ip$0$ph$lcssa145$i + 1 | 0) >>> 0;
        $p$1$p$0$i = $169 ? $p$1$ph$ph$lcssa25$i : $p$0$ph$ph$lcssa34146$i;
        $ip$1$ip$0$i = $169 ? $ip$1$ph$lcssa$i : $ip$0$ph$lcssa145$i;
        $171 = $ip$1$ip$0$i + 1 | 0;
        if (!(_memcmp($n, $n + $p$1$p$0$i | 0, $171) | 0)) {
         $mem0$0$i = $$lcssa332 - $p$1$p$0$i | 0;
         $p$3$i = $p$1$p$0$i;
        } else {
         $175 = $$lcssa332 - $ip$1$ip$0$i + -1 | 0;
         $mem0$0$i = 0;
         $p$3$i = ($ip$1$ip$0$i >>> 0 > $175 >>> 0 ? $ip$1$ip$0$i : $175) + 1 | 0;
        }
        $179 = $$lcssa332 | 63;
        $180 = ($mem0$0$i | 0) != 0;
        $181 = $$lcssa332 - $p$3$i | 0;
        $$03$i = $3;
        $mem$0$i = 0;
        $z$0$i = $3;
        L69 : while (1) {
         $183 = $$03$i;
         do if (($z$0$i - $183 | 0) >>> 0 < $$lcssa332 >>> 0) {
          $186 = _memchr($z$0$i, 0, $179) | 0;
          if (!$186) {
           $z$3$i = $z$0$i + $179 | 0;
           break;
          } else if (($186 - $183 | 0) >>> 0 < $$lcssa332 >>> 0) {
           $$3$i = 0;
           break L32;
          } else {
           $z$3$i = $186;
           break;
          }
         } else $z$3$i = $z$0$i; while (0);
         $193 = HEAP8[$$03$i + $l$082$i$lcssa331 >> 0] | 0;
         if (!(1 << ($193 & 31) & HEAP32[$byteset$i + ((($193 & 255) >>> 5 & 255) << 2) >> 2])) {
          $$03$i = $$03$i + $$lcssa332 | 0;
          $mem$0$i = 0;
          $z$0$i = $z$3$i;
          continue;
         }
         $204 = HEAP32[$shift$i + (($193 & 255) << 2) >> 2] | 0;
         $205 = $$lcssa332 - $204 | 0;
         if (($$lcssa332 | 0) != ($204 | 0)) {
          $$03$i = $$03$i + ($180 & ($mem$0$i | 0) != 0 & $205 >>> 0 < $p$3$i >>> 0 ? $181 : $205) | 0;
          $mem$0$i = 0;
          $z$0$i = $z$3$i;
          continue;
         }
         $212 = $171 >>> 0 > $mem$0$i >>> 0 ? $171 : $mem$0$i;
         $214 = HEAP8[$n + $212 >> 0] | 0;
         L83 : do if (!($214 << 24 >> 24)) $k$4$i = $171; else {
          $$pr$i = $214;
          $k$340$i = $212;
          while (1) {
           if ($$pr$i << 24 >> 24 != (HEAP8[$$03$i + $k$340$i >> 0] | 0)) {
            $k$340$i$lcssa = $k$340$i;
            break;
           }
           $219 = $k$340$i + 1 | 0;
           $221 = HEAP8[$n + $219 >> 0] | 0;
           if (!($221 << 24 >> 24)) {
            $k$4$i = $171;
            break L83;
           } else {
            $$pr$i = $221;
            $k$340$i = $219;
           }
          }
          $$03$i = $$03$i + ($k$340$i$lcssa - $ip$1$ip$0$i) | 0;
          $mem$0$i = 0;
          $z$0$i = $z$3$i;
          continue L69;
         } while (0);
         while (1) {
          if ($k$4$i >>> 0 <= $mem$0$i >>> 0) {
           $$3$i = $$03$i;
           break L32;
          }
          $226 = $k$4$i + -1 | 0;
          if ((HEAP8[$n + $226 >> 0] | 0) == (HEAP8[$$03$i + $226 >> 0] | 0)) $k$4$i = $226; else break;
         }
         $$03$i = $$03$i + $p$3$i | 0;
         $mem$0$i = $mem0$0$i;
         $z$0$i = $z$3$i;
        }
       } while (0);
       $$0 = $$3$i;
      }
     }
    }
   }
  }
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _kpathsea_init_db($kpse) {
 $kpse = $kpse | 0;
 var $$byval_copy18 = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $103 = 0, $106 = 0, $107 = 0, $108 = 0, $11 = 0, $113 = 0, $114 = 0, $119 = 0, $120 = 0, $121 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $128 = 0, $129 = 0, $13 = 0, $132 = 0, $135 = 0, $137 = 0, $138 = 0, $141 = 0, $146 = 0, $147 = 0, $149 = 0, $150 = 0, $153 = 0, $156 = 0, $157 = 0, $161 = 0, $164 = 0, $170 = 0, $171 = 0, $174 = 0, $2 = 0, $24 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $34 = 0, $35 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $45 = 0, $46 = 0, $47 = 0, $49 = 0, $5 = 0, $50 = 0, $53 = 0, $55 = 0, $56 = 0, $59 = 0, $65 = 0, $68 = 0, $7 = 0, $71 = 0, $72 = 0, $8 = 0, $82 = 0, $9 = 0, $93 = 0, $alias$0$be$i = 0, $alias$0$lcssa$i = 0, $alias$011$i = 0, $alias$015$i = 0, $alias$1$lcssa$i = 0, $alias$118$i = 0, $count$0$lcssa$i = 0, $count$023$i = 0, $count$1$i = 0, $cur_dir$04$i = 0, $cur_dir$1$i = 0, $db_file$0$i = 0, $db_file$1$i = 0, $db_files$01840 = 0, $db_files$11437 = 0, $dbi$023 = 0, $dir_count$0$lcssa8$i = 0, $dir_count$0$lcssa9$i = 0, $dir_count$05$i = 0, $dir_count$1$i = 0, $dir_count$1$i$lcssa = 0, $file_count$0$lcssa10$i = 0, $file_count$03$i = 0, $file_count$1$i = 0, $file_count$1$i$lcssa = 0, $ignore_dir_count$0$lcssa12$i = 0, $ignore_dir_count$0$lcssa13$i = 0, $ignore_dir_count$02$i = 0, $ignore_dir_count$1$i = 0, $ignore_dir_count$1$i$lcssa = 0, $ok$0$ = 0, $ok$0$$lcssa = 0, $ok$01741 = 0, $ok$2$ = 0, $ok$2$$lcssa = 0, $ok$21338 = 0, $real$0$lcssa$i = 0, $real$012$i = 0, $real$012$i$lcssa = 0, $unique_list = 0, $vararg_buffer = 0, $vararg_buffer14 = 0, $vararg_buffer2 = 0, $vararg_buffer5 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $$byval_copy18 = sp + 72 | 0;
 $vararg_buffer14 = sp + 64 | 0;
 $vararg_buffer8 = sp + 48 | 0;
 $vararg_buffer5 = sp + 40 | 0;
 $vararg_buffer2 = sp + 32 | 0;
 $vararg_buffer = sp + 24 | 0;
 $unique_list = sp + 8 | 0;
 $0 = sp + 16 | 0;
 $1 = sp;
 $2 = _kpathsea_init_format($kpse, 9) | 0;
 $3 = _kpathsea_path_search_list_generic($kpse, $2, 52, 1, 1) | 0;
 HEAP32[$unique_list >> 2] = 0;
 HEAP32[$unique_list + 4 >> 2] = 0;
 $5 = HEAP32[$3 >> 2] | 0;
 if ($5 | 0) {
  $7 = $kpse + 44 | 0;
  $8 = HEAP32[21] | 0;
  $13 = $5;
  $dbi$023 = 0;
  while (1) {
   $9 = $dbi$023 + 1 | 0;
   $10 = $3 + ($9 << 2) | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   if (!$11) label = 9; else if (!(_strcasecmp($13, $11) | 0)) if (!(_same_file_p($13, $11) | 0)) label = 9; else {
    if (HEAP32[$7 >> 2] & 2 | 0) {
     _fwrite(13458, 7, 1, $8) | 0;
     HEAP32[$vararg_buffer >> 2] = $13;
     HEAP32[$vararg_buffer + 4 >> 2] = $11;
     _fprintf($8, 10214, $vararg_buffer) | 0;
     _fflush($8) | 0;
    }
    _free($13);
   } else label = 9;
   if ((label | 0) == 9) {
    label = 0;
    if (HEAP32[$7 >> 2] & 2 | 0) {
     _fwrite(13458, 7, 1, $8) | 0;
     HEAP32[$vararg_buffer2 >> 2] = $13;
     _fprintf($8, 10267, $vararg_buffer2) | 0;
     _fflush($8) | 0;
    }
    _str_list_add($unique_list, $13);
   }
   $24 = HEAP32[$10 >> 2] | 0;
   if (!$24) break; else {
    $13 = $24;
    $dbi$023 = $9;
   }
  }
 }
 _str_list_add($unique_list, 0);
 _free($3);
 $27 = HEAP32[$unique_list + 4 >> 2] | 0;
 $28 = $kpse + 20 | 0;
 _hash_create($0, 64007);
 $29 = $0;
 $34 = HEAP32[$29 + 4 >> 2] | 0;
 $35 = $28;
 HEAP32[$35 >> 2] = HEAP32[$29 >> 2];
 HEAP32[$35 + 4 >> 2] = $34;
 if (!$27) label = 43; else {
  $40 = HEAP32[21] | 0;
  $41 = $kpse + 44 | 0;
  $42 = $kpse + 36 | 0;
  $43 = HEAP32[$27 >> 2] | 0;
  if (!$43) label = 43; else {
   $45 = $43;
   $db_files$01840 = $27;
   $ok$01741 = 0;
   while (1) {
    $46 = _strlen($45) | 0;
    $47 = $46 + -4 | 0;
    $49 = _xmalloc($46 + -3 | 0) | 0;
    $50 = _kpse_fopen_trace($45, 10611) | 0;
    _strncpy($49, $45, $47) | 0;
    HEAP8[$49 + $47 >> 0] = 0;
    if (!$50) $db_file$1$i = 0; else {
     $53 = _read_line($50) | 0;
     if (!$53) {
      _xfclose($50, $45);
      $dir_count$0$lcssa9$i = 0;
      $ignore_dir_count$0$lcssa13$i = 0;
      label = 37;
     } else {
      $55 = $53;
      $cur_dir$04$i = 0;
      $dir_count$05$i = 0;
      $file_count$03$i = 0;
      $ignore_dir_count$02$i = 0;
      while (1) {
       $56 = _strlen($55) | 0;
       L29 : do if (!$56) label = 30; else {
        $59 = $55 + ($56 + -1) | 0;
        if ((HEAP8[$59 >> 0] | 0) == 58) if (!(_kpathsea_absolute_p($kpse, $55, 1) | 0)) label = 30; else {
         $65 = _strchr($55 + 1 | 0, 46) | 0;
         L33 : do if ($65 | 0) {
          $68 = $65;
          L34 : while (1) {
           $71 = $68 + 1 | 0;
           if ((HEAP8[$68 + -1 >> 0] | 0) == 47) switch (HEAP8[$71 >> 0] | 0) {
           case 47:
           case 0:
            break;
           default:
            break L34;
           }
           $72 = _strchr($71, 46) | 0;
           if (!$72) break L33; else $68 = $72;
          }
          $cur_dir$1$i = 0;
          $dir_count$1$i = $dir_count$05$i;
          $file_count$1$i = $file_count$03$i;
          $ignore_dir_count$1$i = $ignore_dir_count$02$i + 1 | 0;
          break L29;
         } while (0);
         HEAP8[$59 >> 0] = 47;
         if ((HEAP8[$55 >> 0] | 0) == 46) $174 = _concat($49, $55 + 2 | 0) | 0; else $174 = _xstrdup($55) | 0;
         $cur_dir$1$i = $174;
         $dir_count$1$i = $dir_count$05$i + 1 | 0;
         $file_count$1$i = $file_count$03$i;
         $ignore_dir_count$1$i = $ignore_dir_count$02$i;
        } else label = 30;
       } while (0);
       L45 : do if ((label | 0) == 30) {
        label = 0;
        $82 = HEAP8[$55 >> 0] | 0;
        if (($cur_dir$04$i | 0) != 0 & $82 << 24 >> 24 != 0) {
         L48 : do if ($82 << 24 >> 24 == 46) {
          switch (HEAP8[$55 + 1 >> 0] | 0) {
          case 0:
           {
            $cur_dir$1$i = $cur_dir$04$i;
            $dir_count$1$i = $dir_count$05$i;
            $file_count$1$i = $file_count$03$i;
            $ignore_dir_count$1$i = $ignore_dir_count$02$i;
            break L45;
            break;
           }
          case 46:
           break;
          default:
           break L48;
          }
          if (!(HEAP8[$55 + 2 >> 0] | 0)) {
           $cur_dir$1$i = $cur_dir$04$i;
           $dir_count$1$i = $dir_count$05$i;
           $file_count$1$i = $file_count$03$i;
           $ignore_dir_count$1$i = $ignore_dir_count$02$i;
           break L45;
          }
         } while (0);
         _hash_insert_normalized($28, _xstrdup($55) | 0, $cur_dir$04$i);
         $cur_dir$1$i = $cur_dir$04$i;
         $dir_count$1$i = $dir_count$05$i;
         $file_count$1$i = $file_count$03$i + 1 | 0;
         $ignore_dir_count$1$i = $ignore_dir_count$02$i;
        } else {
         $cur_dir$1$i = $cur_dir$04$i;
         $dir_count$1$i = $dir_count$05$i;
         $file_count$1$i = $file_count$03$i;
         $ignore_dir_count$1$i = $ignore_dir_count$02$i;
        }
       } while (0);
       _free($55);
       $93 = _read_line($50) | 0;
       if (!$93) {
        $dir_count$1$i$lcssa = $dir_count$1$i;
        $file_count$1$i$lcssa = $file_count$1$i;
        $ignore_dir_count$1$i$lcssa = $ignore_dir_count$1$i;
        break;
       } else {
        $55 = $93;
        $cur_dir$04$i = $cur_dir$1$i;
        $dir_count$05$i = $dir_count$1$i;
        $file_count$03$i = $file_count$1$i;
        $ignore_dir_count$02$i = $ignore_dir_count$1$i;
       }
      }
      _xfclose($50, $45);
      if (!$file_count$1$i$lcssa) {
       $dir_count$0$lcssa9$i = $dir_count$1$i$lcssa;
       $ignore_dir_count$0$lcssa13$i = $ignore_dir_count$1$i$lcssa;
       label = 37;
      } else {
       _str_list_add($42, _xstrdup($49) | 0);
       $db_file$0$i = $50;
       $dir_count$0$lcssa8$i = $dir_count$1$i$lcssa;
       $file_count$0$lcssa10$i = $file_count$1$i$lcssa;
       $ignore_dir_count$0$lcssa12$i = $ignore_dir_count$1$i$lcssa;
      }
     }
     if ((label | 0) == 37) {
      label = 0;
      _fwrite(12399, 9, 1, $40) | 0;
      HEAP32[$vararg_buffer5 >> 2] = $45;
      _fprintf($40, 10297, $vararg_buffer5) | 0;
      _fwrite(12726, 2, 1, $40) | 0;
      _fflush($40) | 0;
      _fwrite(12399, 9, 1, $40) | 0;
      _fwrite(10337, 49, 1, $40) | 0;
      _fwrite(12726, 2, 1, $40) | 0;
      _fflush($40) | 0;
      $db_file$0$i = 0;
      $dir_count$0$lcssa8$i = $dir_count$0$lcssa9$i;
      $file_count$0$lcssa10$i = 0;
      $ignore_dir_count$0$lcssa12$i = $ignore_dir_count$0$lcssa13$i;
     }
     if (!(HEAP32[$41 >> 2] & 2)) $db_file$1$i = $db_file$0$i; else {
      _fwrite(13458, 7, 1, $40) | 0;
      HEAP32[$vararg_buffer8 >> 2] = $45;
      HEAP32[$vararg_buffer8 + 4 >> 2] = $file_count$0$lcssa10$i;
      HEAP32[$vararg_buffer8 + 8 >> 2] = $dir_count$0$lcssa8$i;
      HEAP32[$vararg_buffer8 + 12 >> 2] = $ignore_dir_count$0$lcssa12$i;
      _fprintf($40, 10387, $vararg_buffer8) | 0;
      _fflush($40) | 0;
      _fwrite(13458, 7, 1, $40) | 0;
      _fwrite(10434, 16, 1, $40) | 0;
      _fflush($40) | 0;
      HEAP32[$$byval_copy18 >> 2] = HEAP32[$28 >> 2];
      HEAP32[$$byval_copy18 + 4 >> 2] = HEAP32[$28 + 4 >> 2];
      _hash_print($$byval_copy18, 1);
      _fflush($40) | 0;
      $db_file$1$i = $db_file$0$i;
     }
    }
    _free($49);
    $ok$0$ = $db_file$1$i | 0 ? 1 : $ok$01741;
    _free(HEAP32[$db_files$01840 >> 2] | 0);
    $102 = $db_files$01840 + 4 | 0;
    $103 = HEAP32[$102 >> 2] | 0;
    if (!$103) {
     $ok$0$$lcssa = $ok$0$;
     break;
    } else {
     $45 = $103;
     $db_files$01840 = $102;
     $ok$01741 = $ok$0$;
    }
   }
   if (!$ok$0$$lcssa) label = 43;
  }
 }
 if ((label | 0) == 43) {
  _free(HEAP32[$28 >> 2] | 0);
  HEAP32[$28 >> 2] = 0;
 }
 _free($27);
 $106 = _kpathsea_all_path_search($kpse, $2, 10451) | 0;
 $107 = $kpse + 28 | 0;
 _hash_create($1, 1009);
 $108 = $1;
 $113 = HEAP32[$108 + 4 >> 2] | 0;
 $114 = $107;
 HEAP32[$114 >> 2] = HEAP32[$108 >> 2];
 HEAP32[$114 + 4 >> 2] = $113;
 if ($106 | 0) {
  $119 = $kpse + 44 | 0;
  $120 = HEAP32[21] | 0;
  $121 = HEAP32[$106 >> 2] | 0;
  if ($121 | 0) {
   $123 = $121;
   $db_files$11437 = $106;
   $ok$21338 = 0;
   while (1) {
    $124 = _kpse_fopen_trace($123, 10611) | 0;
    $125 = ($124 | 0) != 0;
    if ($125) {
     $126 = _read_line($124) | 0;
     L70 : do if (!$126) $count$0$lcssa$i = 0; else {
      $129 = $126;
      $count$023$i = 0;
      while (1) {
       $128 = HEAP8[$129 >> 0] | 0;
       switch ($128 << 24 >> 24) {
       case 35:
       case 37:
       case 0:
        {
         $count$1$i = $count$023$i;
         break;
        }
       default:
        {
         L75 : do if ($128 << 24 >> 24 > 0) {
          $132 = $128;
          $real$012$i = $129;
          while (1) {
           if (!(_isspace($132 & 255) | 0)) {
            $real$012$i$lcssa = $real$012$i;
            break;
           }
           $137 = $real$012$i + 1 | 0;
           $138 = HEAP8[$137 >> 0] | 0;
           if ($138 << 24 >> 24 > 0) {
            $132 = $138;
            $real$012$i = $137;
           } else {
            $135 = $138;
            $real$0$lcssa$i = $137;
            break L75;
           }
          }
          $135 = HEAP8[$real$012$i$lcssa >> 0] | 0;
          $real$0$lcssa$i = $real$012$i$lcssa;
         } else {
          $135 = $128;
          $real$0$lcssa$i = $129;
         } while (0);
         L81 : do if (!($135 << 24 >> 24)) {
          $alias$0$lcssa$i = $real$0$lcssa$i;
          label = 54;
         } else {
          $141 = $135;
          $alias$015$i = $real$0$lcssa$i;
          while (1) {
           if ($141 << 24 >> 24 > -1) {
            $146 = $alias$015$i + 1 | 0;
            if (!(_isspace($141 & 255) | 0)) $alias$0$be$i = $146; else {
             $150 = $146;
             $alias$011$i = $alias$015$i;
             break L81;
            }
           } else $alias$0$be$i = $alias$015$i + 1 | 0;
           $147 = HEAP8[$alias$0$be$i >> 0] | 0;
           if (!($147 << 24 >> 24)) {
            $alias$0$lcssa$i = $alias$0$be$i;
            label = 54;
            break;
           } else {
            $141 = $147;
            $alias$015$i = $alias$0$be$i;
           }
          }
         } while (0);
         if ((label | 0) == 54) {
          label = 0;
          $150 = $alias$0$lcssa$i + 1 | 0;
          $alias$011$i = $alias$0$lcssa$i;
         }
         HEAP8[$alias$011$i >> 0] = 0;
         $149 = HEAP8[$150 >> 0] | 0;
         L91 : do if ($149 << 24 >> 24 > 0) {
          $153 = $149;
          $alias$118$i = $150;
          while (1) {
           if (!(_isspace($153 & 255) | 0)) {
            $alias$1$lcssa$i = $alias$118$i;
            break L91;
           }
           $156 = $alias$118$i + 1 | 0;
           $157 = HEAP8[$156 >> 0] | 0;
           if ($157 << 24 >> 24 > 0) {
            $153 = $157;
            $alias$118$i = $156;
           } else {
            $alias$1$lcssa$i = $156;
            break;
           }
          }
         } else $alias$1$lcssa$i = $150; while (0);
         if (!(HEAP8[$real$0$lcssa$i >> 0] | 0)) $count$1$i = $count$023$i; else if (!(HEAP8[$alias$1$lcssa$i >> 0] | 0)) $count$1$i = $count$023$i; else {
          $161 = _xstrdup($alias$1$lcssa$i) | 0;
          _hash_insert_normalized($107, $161, _xstrdup($real$0$lcssa$i) | 0);
          $count$1$i = $count$023$i + 1 | 0;
         }
        }
       }
       _free($129);
       $164 = _read_line($124) | 0;
       if (!$164) {
        $count$0$lcssa$i = $count$1$i;
        break L70;
       } else {
        $129 = $164;
        $count$023$i = $count$1$i;
       }
      }
     } while (0);
     if (HEAP32[$119 >> 2] & 2 | 0) {
      _fwrite(13458, 7, 1, $120) | 0;
      HEAP32[$vararg_buffer14 >> 2] = $123;
      HEAP32[$vararg_buffer14 + 4 >> 2] = $count$0$lcssa$i;
      _fprintf($120, 10459, $vararg_buffer14) | 0;
      _fflush($120) | 0;
      _fwrite(13458, 7, 1, $120) | 0;
      _fwrite(10476, 17, 1, $120) | 0;
      _fflush($120) | 0;
      HEAP32[$$byval_copy18 >> 2] = HEAP32[$107 >> 2];
      HEAP32[$$byval_copy18 + 4 >> 2] = HEAP32[$107 + 4 >> 2];
      _hash_print($$byval_copy18, 1);
      _fflush($120) | 0;
     }
     _xfclose($124, $123);
    }
    $ok$2$ = $125 ? 1 : $ok$21338;
    _free(HEAP32[$db_files$11437 >> 2] | 0);
    $170 = $db_files$11437 + 4 | 0;
    $171 = HEAP32[$170 >> 2] | 0;
    if (!$171) {
     $ok$2$$lcssa = $ok$2$;
     break;
    } else {
     $123 = $171;
     $db_files$11437 = $170;
     $ok$21338 = $ok$2$;
    }
   }
   if ($ok$2$$lcssa | 0) {
    _free($106);
    STACKTOP = sp;
    return;
   }
  }
 }
 _free(HEAP32[$107 >> 2] | 0);
 HEAP32[$107 >> 2] = 0;
 _free($106);
 STACKTOP = sp;
 return;
}

function _kpathsea_path_search_list_generic($kpse, $path, $names, $must_exist, $all) {
 $kpse = $kpse | 0;
 $path = $path | 0;
 $names = $names | 0;
 $must_exist = $must_exist | 0;
 $all = $all | 0;
 var $$lcssa70 = 0, $$pre$phiZ2D = 0, $1 = 0, $101 = 0, $102 = 0, $108 = 0, $110 = 0, $114 = 0, $119 = 0, $12 = 0, $120 = 0, $126 = 0, $129 = 0, $131 = 0, $140 = 0, $146 = 0, $15 = 0, $157 = 0, $23 = 0, $24 = 0, $26 = 0, $34 = 0, $35 = 0, $38 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $48 = 0, $5 = 0, $55 = 0, $56 = 0, $60 = 0, $65 = 0, $67 = 0, $68 = 0, $69 = 0, $71 = 0, $72 = 0, $76 = 0, $78 = 0, $79 = 0, $84 = 0, $86 = 0, $90 = 0, $91 = 0, $92 = 0, $94 = 0, $95 = 0, $99 = 0, $all_absolute$0$lcssa = 0, $all_absolute$022 = 0, $all_absolute$022$us = 0, $all_absolute$1 = 0, $all_absolute$1$us = 0, $allocated$023$i = 0, $allocated$023$i$us = 0, $allocated$1$lcssa$i = 0, $allocated$1$lcssa$i$us = 0, $allocated$115$i = 0, $allocated$115$us$i$us = 0, $allocated$2$lcssa$i = 0, $allocated$2$lcssa$us$i$us = 0, $allocated$211$i = 0, $allocated$211$us$i$us = 0, $allocated$4$ph$i = 0, $allocated$4$ph$us$i$us = 0, $allow_disk_search$0 = 0, $elt$0$i = 0, $elt$0$i$us = 0, $elt$017 = 0, $elt$021$i = 0, $elt$024$i = 0, $elt$024$i$us = 0, $elt$024$i$us$lcssa = 0, $elt$1 = 0, $found$0 = 0, $found$24 = 0, $found$24$byval_copy = 0, $i$014$i = 0, $i$014$us$i$us = 0, $namep$0 = 0, $namep$027 = 0, $namep$028 = 0, $namep$123 = 0, $namep$123$us = 0, $namep$123$us$lcssa = 0, $namep$2 = 0, $namep$215 = 0, $namep$216 = 0, $potential$0$lcssa$i = 0, $potential$022$i = 0, $potential$022$i$us = 0, $potential$1$lcssa$i = 0, $potential$1$lcssa$i$us = 0, $potential$113$i = 0, $potential$113$us$i$us = 0, $potential$2$lcssa$i = 0, $potential$2$lcssa$us$i$us = 0, $potential$2$lcssa$us$i$us$lcssa = 0, $potential$210$i = 0, $potential$210$us$i$us = 0, $potential$4$ph$i = 0, $potential$4$ph$us$i$us = 0, $ret_list = 0, $tmpcast$1 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $found$24$byval_copy = sp + 40 | 0;
 $vararg_buffer6 = sp + 32 | 0;
 $vararg_buffer1 = sp + 16 | 0;
 $vararg_buffer = sp + 8 | 0;
 $ret_list = sp;
 HEAP32[$ret_list >> 2] = 0;
 HEAP32[$ret_list + 4 >> 2] = 0;
 $1 = $kpse + 44 | 0;
 if (HEAP32[$1 >> 2] & 32 | 0) {
  $5 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $5) | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[$names >> 2];
  _fprintf($5, 10984, $vararg_buffer) | 0;
  _fflush($5) | 0;
  $namep$027 = $names + 4 | 0;
  if (HEAP32[$namep$027 >> 2] | 0) {
   $namep$028 = $namep$027;
   while (1) {
    _fputc(32, $5) | 0;
    _fputs(HEAP32[$namep$028 >> 2] | 0, $5) | 0;
    $namep$0 = $namep$028 + 4 | 0;
    if (!(HEAP32[$namep$0 >> 2] | 0)) break; else $namep$028 = $namep$0;
   }
  }
  HEAP32[$vararg_buffer1 >> 2] = $must_exist;
  HEAP32[$vararg_buffer1 + 4 >> 2] = $all;
  HEAP32[$vararg_buffer1 + 8 >> 2] = $path;
  _fprintf($5, 11007, $vararg_buffer1) | 0;
 }
 $12 = HEAP32[$names >> 2] | 0;
 L8 : do if ($12 | 0) {
  L10 : do if (!$all) {
   $15 = $12;
   $all_absolute$022$us = 1;
   $namep$123$us = $names;
   while (1) {
    if (!(_kpathsea_absolute_p($kpse, $15, 1) | 0)) $all_absolute$1$us = 0; else if (!(_kpathsea_readable_file($kpse, HEAP32[$namep$123$us >> 2] | 0) | 0)) $all_absolute$1$us = $all_absolute$022$us; else {
     $namep$123$us$lcssa = $namep$123$us;
     break;
    }
    $23 = $namep$123$us + 4 | 0;
    $24 = HEAP32[$23 >> 2] | 0;
    if (!$24) {
     $all_absolute$0$lcssa = $all_absolute$1$us;
     break L10;
    } else {
     $15 = $24;
     $all_absolute$022$us = $all_absolute$1$us;
     $namep$123$us = $23;
    }
   }
   _str_list_add($ret_list, _xstrdup(HEAP32[$namep$123$us$lcssa >> 2] | 0) | 0);
   break L8;
  } else {
   $26 = $12;
   $all_absolute$022 = 1;
   $namep$123 = $names;
   while (1) {
    if (!(_kpathsea_absolute_p($kpse, $26, 1) | 0)) $all_absolute$1 = 0; else if (!(_kpathsea_readable_file($kpse, HEAP32[$namep$123 >> 2] | 0) | 0)) $all_absolute$1 = $all_absolute$022; else {
     _str_list_add($ret_list, _xstrdup(HEAP32[$namep$123 >> 2] | 0) | 0);
     $all_absolute$1 = $all_absolute$022;
    }
    $34 = $namep$123 + 4 | 0;
    $35 = HEAP32[$34 >> 2] | 0;
    if (!$35) {
     $all_absolute$0$lcssa = $all_absolute$1;
     break;
    } else {
     $26 = $35;
     $all_absolute$022 = $all_absolute$1;
     $namep$123 = $34;
    }
   }
  } while (0);
  if (!$all_absolute$0$lcssa) {
   $38 = _kpathsea_path_element($kpse, $path) | 0;
   if ($38 | 0) {
    $40 = $kpse + 92 | 0;
    $41 = ($all | 0) == 0;
    $42 = ($must_exist | 0) == 0;
    $43 = $found$24$byval_copy + 4 | 0;
    $elt$017 = $38;
    while (1) {
     if ((HEAP8[$elt$017 >> 0] | 0) == 33) {
      $48 = (HEAP8[$elt$017 + 1 >> 0] | 0) == 33;
      $allow_disk_search$0 = $48 & 1 ^ 1;
      $elt$1 = $48 ? $elt$017 + 2 | 0 : $elt$017;
     } else {
      $allow_disk_search$0 = 1;
      $elt$1 = $elt$017;
     }
     _kpathsea_normalize_path($kpse, $elt$1) | 0;
     if (!(HEAP32[$40 >> 2] | 0)) $55 = 0; else $55 = _kpathsea_db_search_list($kpse, $names, $elt$1, $all) | 0;
     do if (!$allow_disk_search$0) label = 52; else {
      $56 = ($55 | 0) != 0;
      if ($56) {
       if ($42) {
        $found$24 = $55;
        label = 53;
        break;
       }
       if (HEAP32[$55 + 4 >> 2] | 0) {
        $found$24 = $55;
        label = 53;
        break;
       }
      }
      $60 = _kpathsea_element_dirs($kpse, $elt$1) | 0;
      if (!$60) label = 52; else if (!(HEAP32[$60 >> 2] | 0)) label = 52; else {
       if ($56) $found$0 = $55; else $found$0 = _xmalloc(8) | 0;
       $65 = _xmalloc(75) | 0;
       HEAP32[$found$24$byval_copy >> 2] = 0;
       HEAP32[$43 >> 2] = 0;
       $elt$021$i = HEAP32[$60 >> 2] | 0;
       L45 : do if (!$elt$021$i) {
        $potential$0$lcssa$i = $65;
        label = 50;
       } else if ($41) {
        $allocated$023$i$us = 75;
        $elt$024$i$us = $elt$021$i;
        $potential$022$i$us = $65;
        L48 : while (1) {
         $67 = HEAP32[$elt$024$i$us >> 2] | 0;
         $68 = _strlen($67) | 0;
         $69 = HEAP32[$names >> 2] | 0;
         if (!$69) {
          $allocated$1$lcssa$i$us = $allocated$023$i$us;
          $potential$1$lcssa$i$us = $potential$022$i$us;
         } else {
          $71 = $68 + 1 | 0;
          $72 = $69;
          $allocated$115$us$i$us = $allocated$023$i$us;
          $i$014$us$i$us = 0;
          $potential$113$us$i$us = $potential$022$i$us;
          while (1) {
           if (!(_kpathsea_absolute_p($kpse, $72, 1) | 0)) {
            $76 = (_strlen($72) | 0) + $71 | 0;
            if ($76 >>> 0 > $allocated$115$us$i$us >>> 0) {
             $allocated$211$us$i$us = $allocated$115$us$i$us;
             $potential$210$us$i$us = $potential$113$us$i$us;
             while (1) {
              $78 = $allocated$211$us$i$us << 1;
              $79 = _xrealloc($potential$210$us$i$us, $78) | 0;
              if ($76 >>> 0 > $78 >>> 0) {
               $allocated$211$us$i$us = $78;
               $potential$210$us$i$us = $79;
              } else {
               $allocated$2$lcssa$us$i$us = $78;
               $potential$2$lcssa$us$i$us = $79;
               break;
              }
             }
            } else {
             $allocated$2$lcssa$us$i$us = $allocated$115$us$i$us;
             $potential$2$lcssa$us$i$us = $potential$113$us$i$us;
            }
            _strcpy($potential$2$lcssa$us$i$us, $67) | 0;
            _strcat($potential$2$lcssa$us$i$us + $68 | 0, $72) | 0;
            if (!(_kpathsea_readable_file($kpse, $potential$2$lcssa$us$i$us) | 0)) {
             $allocated$4$ph$us$i$us = $allocated$2$lcssa$us$i$us;
             $potential$4$ph$us$i$us = $potential$2$lcssa$us$i$us;
            } else {
             $elt$024$i$us$lcssa = $elt$024$i$us;
             $potential$2$lcssa$us$i$us$lcssa = $potential$2$lcssa$us$i$us;
             break L48;
            }
           } else {
            $allocated$4$ph$us$i$us = $allocated$115$us$i$us;
            $potential$4$ph$us$i$us = $potential$113$us$i$us;
           }
           $84 = $i$014$us$i$us + 1 | 0;
           $86 = HEAP32[$names + ($84 << 2) >> 2] | 0;
           if (!$86) {
            $allocated$1$lcssa$i$us = $allocated$4$ph$us$i$us;
            $potential$1$lcssa$i$us = $potential$4$ph$us$i$us;
            break;
           } else {
            $72 = $86;
            $allocated$115$us$i$us = $allocated$4$ph$us$i$us;
            $i$014$us$i$us = $84;
            $potential$113$us$i$us = $potential$4$ph$us$i$us;
           }
          }
         }
         $elt$0$i$us = HEAP32[$elt$024$i$us + 8 >> 2] | 0;
         if (!$elt$0$i$us) {
          $potential$0$lcssa$i = $potential$1$lcssa$i$us;
          label = 50;
          break L45;
         } else {
          $allocated$023$i$us = $allocated$1$lcssa$i$us;
          $elt$024$i$us = $elt$0$i$us;
          $potential$022$i$us = $potential$1$lcssa$i$us;
         }
        }
        _str_list_add($found$24$byval_copy, $potential$2$lcssa$us$i$us$lcssa);
        _str_llist_float($60, $elt$024$i$us$lcssa);
        break;
       } else {
        $allocated$023$i = 75;
        $elt$024$i = $elt$021$i;
        $potential$022$i = $65;
        while (1) {
         $90 = HEAP32[$elt$024$i >> 2] | 0;
         $91 = _strlen($90) | 0;
         $92 = HEAP32[$names >> 2] | 0;
         if (!$92) {
          $allocated$1$lcssa$i = $allocated$023$i;
          $potential$1$lcssa$i = $potential$022$i;
         } else {
          $94 = $91 + 1 | 0;
          $95 = $92;
          $allocated$115$i = $allocated$023$i;
          $i$014$i = 0;
          $potential$113$i = $potential$022$i;
          while (1) {
           do if (!(_kpathsea_absolute_p($kpse, $95, 1) | 0)) {
            $99 = (_strlen($95) | 0) + $94 | 0;
            if ($99 >>> 0 > $allocated$115$i >>> 0) {
             $allocated$211$i = $allocated$115$i;
             $potential$210$i = $potential$113$i;
             while (1) {
              $101 = $allocated$211$i << 1;
              $102 = _xrealloc($potential$210$i, $101) | 0;
              if ($99 >>> 0 > $101 >>> 0) {
               $allocated$211$i = $101;
               $potential$210$i = $102;
              } else {
               $allocated$2$lcssa$i = $101;
               $potential$2$lcssa$i = $102;
               break;
              }
             }
            } else {
             $allocated$2$lcssa$i = $allocated$115$i;
             $potential$2$lcssa$i = $potential$113$i;
            }
            _strcpy($potential$2$lcssa$i, $90) | 0;
            _strcat($potential$2$lcssa$i + $91 | 0, $95) | 0;
            if (!(_kpathsea_readable_file($kpse, $potential$2$lcssa$i) | 0)) {
             $allocated$4$ph$i = $allocated$2$lcssa$i;
             $potential$4$ph$i = $potential$2$lcssa$i;
             break;
            }
            _str_list_add($found$24$byval_copy, $potential$2$lcssa$i);
            _str_llist_float($60, $elt$024$i);
            $allocated$4$ph$i = 75;
            $potential$4$ph$i = _xmalloc(75) | 0;
           } else {
            $allocated$4$ph$i = $allocated$115$i;
            $potential$4$ph$i = $potential$113$i;
           } while (0);
           $108 = $i$014$i + 1 | 0;
           $110 = HEAP32[$names + ($108 << 2) >> 2] | 0;
           if (!$110) {
            $allocated$1$lcssa$i = $allocated$4$ph$i;
            $potential$1$lcssa$i = $potential$4$ph$i;
            break;
           } else {
            $95 = $110;
            $allocated$115$i = $allocated$4$ph$i;
            $i$014$i = $108;
            $potential$113$i = $potential$4$ph$i;
           }
          }
         }
         $elt$0$i = HEAP32[$elt$024$i + 8 >> 2] | 0;
         if (!$elt$0$i) {
          $potential$0$lcssa$i = $potential$1$lcssa$i;
          label = 50;
          break;
         } else {
          $allocated$023$i = $allocated$1$lcssa$i;
          $elt$024$i = $elt$0$i;
          $potential$022$i = $potential$1$lcssa$i;
         }
        }
       } while (0);
       if ((label | 0) == 50) {
        label = 0;
        _free($potential$0$lcssa$i);
       }
       $114 = $found$24$byval_copy;
       $119 = HEAP32[$114 + 4 >> 2] | 0;
       $120 = $found$0;
       HEAP32[$120 >> 2] = HEAP32[$114 >> 2];
       HEAP32[$120 + 4 >> 2] = $119;
       $found$24 = $found$0;
       label = 53;
      }
     } while (0);
     if ((label | 0) == 52) {
      label = 0;
      if ($55 | 0) {
       $found$24 = $55;
       label = 53;
      }
     }
     if ((label | 0) == 53) {
      label = 0;
      $126 = HEAP32[$found$24 + 4 >> 2] | 0;
      if ($126 | 0) {
       if ($41) {
        $$lcssa70 = $126;
        break;
       };
       HEAP32[$found$24$byval_copy >> 2] = HEAP32[$found$24 >> 2];
       HEAP32[$found$24$byval_copy + 4 >> 2] = HEAP32[$found$24 + 4 >> 2];
       _str_list_concat($ret_list, $found$24$byval_copy);
      }
     }
     $129 = _kpathsea_path_element($kpse, 0) | 0;
     if (!$129) break L8; else $elt$017 = $129;
    }
    _str_list_add($ret_list, HEAP32[$$lcssa70 >> 2] | 0);
    _kpathsea_path_element($kpse, 0) | 0;
   }
  }
 } while (0);
 _str_list_uniqify($ret_list);
 $131 = HEAP32[$ret_list >> 2] | 0;
 if (!$131) label = 61; else if ($all | 0) if (HEAP32[(HEAP32[$ret_list + 4 >> 2] | 0) + ($131 + -1 << 2) >> 2] | 0) label = 61;
 if ((label | 0) == 61) _str_list_add($ret_list, 0);
 $140 = $kpse + 92 | 0;
 if (!(HEAP32[$140 >> 2] | 0)) {
  HEAP32[$140 >> 2] = 1;
  $$pre$phiZ2D = $ret_list + 4 | 0;
  $157 = HEAP32[$$pre$phiZ2D >> 2] | 0;
  STACKTOP = sp;
  return $157 | 0;
 }
 if (HEAP32[$1 >> 2] & 32 | 0) {
  $146 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $146) | 0;
  HEAP32[$vararg_buffer6 >> 2] = HEAP32[$names >> 2];
  _fprintf($146, 11049, $vararg_buffer6) | 0;
  _fflush($146) | 0;
  $namep$215 = $names + 4 | 0;
  if (HEAP32[$namep$215 >> 2] | 0) {
   $namep$216 = $namep$215;
   while (1) {
    _fputc(32, $146) | 0;
    _fputs(HEAP32[$namep$216 >> 2] | 0, $146) | 0;
    $namep$2 = $namep$216 + 4 | 0;
    if (!(HEAP32[$namep$2 >> 2] | 0)) break; else $namep$216 = $namep$2;
   }
  }
  _fwrite(11060, 5, 1, $146) | 0;
 }
 $tmpcast$1 = $ret_list + 4 | 0;
 _log_search($kpse, HEAP32[$ret_list >> 2] | 0, HEAP32[$tmpcast$1 >> 2] | 0);
 if (!(HEAP32[$1 >> 2] & 32)) {
  $$pre$phiZ2D = $tmpcast$1;
  $157 = HEAP32[$$pre$phiZ2D >> 2] | 0;
  STACKTOP = sp;
  return $157 | 0;
 }
 _putc(10, HEAP32[21] | 0) | 0;
 $$pre$phiZ2D = $tmpcast$1;
 $157 = HEAP32[$$pre$phiZ2D >> 2] | 0;
 STACKTOP = sp;
 return $157 | 0;
}

function _kpathsea_cnf_get($kpse, $name) {
 $kpse = $kpse | 0;
 $name = $name | 0;
 var $$0 = 0, $$028$i$i = 0, $$047$i$i = 0, $$047$i$i$lcssa = 0, $$1$i$i = 0, $$1$i$i$lcssa = 0, $$2$pn$i$i = 0, $$233$i$i = 0, $$233$i$i$lcssa = 0, $$3$i$i = 0, $$3$i$i$lcssa = 0, $$4$i$i = 0, $$4$i$i$lcssa = 0, $$5$ph$i$i = 0, $$5$pn$i$i = 0, $$531$i$i = 0, $$531$i$i$lcssa = 0, $$6$i$i = 0, $$7$i$i = 0, $$byval_copy4 = 0, $$lcssa = 0, $$pn$be$i$i = 0, $$pn43$i$i = 0, $$pr19$i$i = 0, $0 = 0, $105 = 0, $107 = 0, $109 = 0, $111 = 0, $114 = 0, $115 = 0, $117 = 0, $123 = 0, $125 = 0, $13 = 0, $130 = 0, $135 = 0, $136 = 0, $14 = 0, $140 = 0, $141 = 0, $143 = 0, $147 = 0, $149 = 0, $151 = 0, $152 = 0, $154 = 0, $155 = 0, $157 = 0, $18 = 0, $20 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $28 = 0, $3 = 0, $30 = 0, $31 = 0, $33 = 0, $34 = 0, $35 = 0, $40 = 0, $41 = 0, $46 = 0, $47 = 0, $52 = 0, $54 = 0, $57 = 0, $58 = 0, $59 = 0, $61 = 0, $65 = 0, $66 = 0, $68 = 0, $7 = 0, $71 = 0, $72 = 0, $73 = 0, $77 = 0, $8 = 0, $81 = 0, $83 = 0, $85 = 0, $87 = 0, $90 = 0, $91 = 0, $93 = 0, $97 = 0, $cnf$029$i = 0, $len$0$i$i = 0, $len$0$lcssa$i$i = 0, $len$016$i = 0, $len$1$ph725$i = 0, $line$0$ph$lcssa$i = 0, $line$0$ph26$i = 0, $loc$0$i$i = 0, $prog$0$ph$i$i = 0, $prog$0$ph60$i$i = 0, $value$0$i$i = 0, $value$042$i$i = 0, $value$044$i$i = 0, $value$137$i$i = 0, $var$0$i$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $$byval_copy4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = $kpse + 16 | 0;
 if (HEAP32[$0 >> 2] | 0) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $3 = $kpse + 8 | 0;
 if (!(HEAP32[$kpse + 12 >> 2] | 0)) {
  HEAP32[$0 >> 2] = 1;
  $7 = _kpathsea_init_format($kpse, 8) | 0;
  _hash_create($$byval_copy4, 751);
  $8 = $$byval_copy4;
  $13 = HEAP32[$8 + 4 >> 2] | 0;
  $14 = $3;
  HEAP32[$14 >> 2] = HEAP32[$8 >> 2];
  HEAP32[$14 + 4 >> 2] = $13;
  $18 = _kpathsea_all_path_search($kpse, $7, 10011) | 0;
  if (!$18) label = 65; else {
   $20 = HEAP32[$18 >> 2] | 0;
   if (!$20) label = 65; else {
    $22 = HEAP32[21] | 0;
    $23 = $20;
    $cnf$029$i = $18;
    while (1) {
     $24 = _xfopen($23, 10611) | 0;
     $25 = HEAP32[$kpse >> 2] | 0;
     if ($25 | 0) FUNCTION_TABLE_vi[$25 & 7](HEAP32[$cnf$029$i >> 2] | 0);
     $28 = _read_line($24) | 0;
     L14 : do if ($28 | 0) {
      $30 = $28;
      while (1) {
       $31 = _strlen($30) | 0;
       L17 : do if (!$31) $line$0$ph$lcssa$i = $30; else {
        $len$016$i = $31;
        while (1) {
         $33 = $len$016$i + -1 | 0;
         $34 = $30 + $33 | 0;
         $35 = HEAP8[$34 >> 0] | 0;
         if ($35 << 24 >> 24 <= -1) {
          $len$1$ph725$i = $len$016$i;
          $line$0$ph26$i = $30;
          break;
         }
         if (!(_isspace($35 & 255) | 0)) {
          $len$1$ph725$i = $len$016$i;
          $line$0$ph26$i = $30;
          break;
         }
         HEAP8[$34 >> 0] = 0;
         if (!$33) {
          $line$0$ph$lcssa$i = $30;
          break L17;
         } else $len$016$i = $33;
        }
        while (1) {
         $41 = $line$0$ph26$i + ($len$1$ph725$i + -1) | 0;
         if ((HEAP8[$41 >> 0] | 0) != 92) {
          $line$0$ph$lcssa$i = $line$0$ph26$i;
          break L17;
         }
         while (1) {
          $40 = _read_line($24) | 0;
          HEAP8[$41 >> 0] = 0;
          if ($40 | 0) {
           $$lcssa = $40;
           break;
          }
          _fwrite(12399, 9, 1, $22) | 0;
          HEAP32[$vararg_buffer >> 2] = HEAP32[$cnf$029$i >> 2];
          _fprintf($22, 10021, $vararg_buffer) | 0;
          _fwrite(12726, 2, 1, $22) | 0;
          _fflush($22) | 0;
          if ((HEAP8[$41 >> 0] | 0) != 92) {
           $line$0$ph$lcssa$i = $line$0$ph26$i;
           break L17;
          }
         }
         $46 = _concat($line$0$ph26$i, $$lcssa) | 0;
         _free($line$0$ph26$i);
         $47 = _strlen($46) | 0;
         if (!$47) {
          $line$0$ph$lcssa$i = $46;
          break;
         } else {
          $len$1$ph725$i = $47;
          $line$0$ph26$i = $46;
         }
        }
       } while (0);
       $52 = HEAP8[$line$0$ph$lcssa$i >> 0] | 0;
       L29 : do if ($52 << 24 >> 24 > -1) {
        $$047$i$i = $line$0$ph$lcssa$i;
        $54 = $52;
        while (1) {
         if (!(_isspace($54 & 255) | 0)) {
          $$047$i$i$lcssa = $$047$i$i;
          break;
         }
         $57 = $$047$i$i + 1 | 0;
         $58 = HEAP8[$57 >> 0] | 0;
         if ($58 << 24 >> 24 > -1) {
          $$047$i$i = $57;
          $54 = $58;
         } else {
          $$028$i$i = $57;
          $59 = $58;
          break L29;
         }
        }
        $$028$i$i = $$047$i$i$lcssa;
        $59 = HEAP8[$$047$i$i$lcssa >> 0] | 0;
       } else {
        $$028$i$i = $line$0$ph$lcssa$i;
        $59 = $52;
       } while (0);
       switch ($59 << 24 >> 24) {
       case 35:
       case 37:
       case 0:
        break;
       default:
        {
         $61 = $$028$i$i + (_strlen($$028$i$i) | 0) | 0;
         $value$042$i$i = $61 + -1 | 0;
         L37 : do if ($value$042$i$i >>> 0 > $$028$i$i >>> 0) {
          $$pn43$i$i = $61;
          $value$044$i$i = $value$042$i$i;
          while (1) {
           L40 : do switch (HEAP8[$value$044$i$i >> 0] | 0) {
           case 35:
           case 37:
            {
             $65 = $$pn43$i$i + -2 | 0;
             $66 = HEAP8[$65 >> 0] | 0;
             if ($66 << 24 >> 24 > -1) {
              $68 = $66;
              $value$137$i$i = $65;
              while (1) {
               if (!(_isspace($68 & 255) | 0)) {
                $$pn$be$i$i = $value$137$i$i;
                break L40;
               }
               $71 = $value$137$i$i + -1 | 0;
               HEAP8[$value$137$i$i >> 0] = 0;
               $72 = HEAP8[$71 >> 0] | 0;
               if ($72 << 24 >> 24 > -1) {
                $68 = $72;
                $value$137$i$i = $71;
               } else {
                $$pn$be$i$i = $71;
                break;
               }
              }
             } else $$pn$be$i$i = $65;
             break;
            }
           default:
            $$pn$be$i$i = $value$044$i$i;
           } while (0);
           $value$0$i$i = $$pn$be$i$i + -1 | 0;
           if ($value$0$i$i >>> 0 > $$028$i$i >>> 0) {
            $$pn43$i$i = $$pn$be$i$i;
            $value$044$i$i = $value$0$i$i;
           } else {
            $$1$i$i = $$028$i$i;
            break L37;
           }
          }
         } else $$1$i$i = $$028$i$i; while (0);
         L46 : while (1) {
          $73 = HEAP8[$$1$i$i >> 0] | 0;
          if ($73 << 24 >> 24 > -1) {
           if (_isspace($73 & 255) | 0) {
            $$1$i$i$lcssa = $$1$i$i;
            break;
           }
           $77 = HEAP8[$$1$i$i >> 0] | 0;
          } else $77 = $73;
          switch ($77 << 24 >> 24) {
          case 46:
          case 61:
           {
            $$1$i$i$lcssa = $$1$i$i;
            break L46;
            break;
           }
          default:
           {}
          }
          $$1$i$i = $$1$i$i + 1 | 0;
         }
         $81 = $$1$i$i$lcssa - $$028$i$i | 0;
         $83 = _xmalloc($81 + 1 | 0) | 0;
         _strncpy($83, $$028$i$i, $81) | 0;
         HEAP8[$83 + $81 >> 0] = 0;
         $85 = HEAP8[$$1$i$i$lcssa >> 0] | 0;
         L54 : do if ($85 << 24 >> 24 > -1) {
          $$233$i$i = $$1$i$i$lcssa;
          $87 = $85;
          while (1) {
           if (!(_isspace($87 & 255) | 0)) {
            $$233$i$i$lcssa = $$233$i$i;
            break;
           }
           $90 = $$233$i$i + 1 | 0;
           $91 = HEAP8[$90 >> 0] | 0;
           if ($91 << 24 >> 24 > -1) {
            $$233$i$i = $90;
            $87 = $91;
           } else {
            $$7$i$i = $90;
            $prog$0$ph60$i$i = 0;
            break L54;
           }
          }
          $$pr19$i$i = HEAP8[$$233$i$i$lcssa >> 0] | 0;
          if ($$pr19$i$i << 24 >> 24 == 46) {
           $$2$pn$i$i = $$233$i$i$lcssa;
           while (1) {
            $$3$i$i = $$2$pn$i$i + 1 | 0;
            $93 = HEAP8[$$3$i$i >> 0] | 0;
            if ($93 << 24 >> 24 <= -1) {
             $$3$i$i$lcssa = $$3$i$i;
             break;
            }
            if (!(_isspace($93 & 255) | 0)) {
             $$3$i$i$lcssa = $$3$i$i;
             break;
            } else $$2$pn$i$i = $$3$i$i;
           }
           $$4$i$i = $$3$i$i$lcssa;
           while (1) {
            $97 = HEAP8[$$4$i$i >> 0] | 0;
            if ($97 << 24 >> 24 > -1) {
             if (_isspace($97 & 255) | 0) {
              $$4$i$i$lcssa = $$4$i$i;
              break;
             }
             if ((HEAP8[$$4$i$i >> 0] | 0) == 61) {
              $$4$i$i$lcssa = $$4$i$i;
              break;
             }
            }
            $$4$i$i = $$4$i$i + 1 | 0;
           }
           $105 = $$4$i$i$lcssa - $$3$i$i$lcssa | 0;
           $107 = _xmalloc($105 + 1 | 0) | 0;
           _strncpy($107, $$3$i$i$lcssa, $105) | 0;
           HEAP8[$107 + $105 >> 0] = 0;
           $$5$ph$i$i = $$4$i$i$lcssa;
           $109 = HEAP8[$$4$i$i$lcssa >> 0] | 0;
           $prog$0$ph$i$i = $107;
          } else {
           $$5$ph$i$i = $$233$i$i$lcssa;
           $109 = $$pr19$i$i;
           $prog$0$ph$i$i = 0;
          }
          if ($109 << 24 >> 24 > -1) {
           $$531$i$i = $$5$ph$i$i;
           $111 = $109;
           while (1) {
            if (!(_isspace($111 & 255) | 0)) {
             $$531$i$i$lcssa = $$531$i$i;
             break;
            }
            $114 = $$531$i$i + 1 | 0;
            $115 = HEAP8[$114 >> 0] | 0;
            if ($115 << 24 >> 24 > -1) {
             $$531$i$i = $114;
             $111 = $115;
            } else {
             $$7$i$i = $114;
             $prog$0$ph60$i$i = $prog$0$ph$i$i;
             break L54;
            }
           }
           if ((HEAP8[$$531$i$i$lcssa >> 0] | 0) == 61) {
            $$5$pn$i$i = $$531$i$i$lcssa;
            while (1) {
             $$6$i$i = $$5$pn$i$i + 1 | 0;
             $117 = HEAP8[$$6$i$i >> 0] | 0;
             if ($117 << 24 >> 24 <= -1) {
              $$7$i$i = $$6$i$i;
              $prog$0$ph60$i$i = $prog$0$ph$i$i;
              break L54;
             }
             if (!(_isspace($117 & 255) | 0)) {
              $$7$i$i = $$6$i$i;
              $prog$0$ph60$i$i = $prog$0$ph$i$i;
              break;
             } else $$5$pn$i$i = $$6$i$i;
            }
           } else {
            $$7$i$i = $$531$i$i$lcssa;
            $prog$0$ph60$i$i = $prog$0$ph$i$i;
           }
          } else {
           $$7$i$i = $$5$ph$i$i;
           $prog$0$ph60$i$i = $prog$0$ph$i$i;
          }
         } else {
          $$7$i$i = $$1$i$i$lcssa;
          $prog$0$ph60$i$i = 0;
         } while (0);
         $len$0$i$i = _strlen($$7$i$i) | 0;
         while (1) {
          if (!$len$0$i$i) {
           $len$0$lcssa$i$i = 0;
           break;
          }
          $123 = $len$0$i$i + -1 | 0;
          $125 = HEAP8[$$7$i$i + $123 >> 0] | 0;
          if ($125 << 24 >> 24 <= -1) {
           $len$0$lcssa$i$i = $len$0$i$i;
           break;
          }
          if (!(_isspace($125 & 255) | 0)) {
           $len$0$lcssa$i$i = $len$0$i$i;
           break;
          } else $len$0$i$i = $123;
         }
         $130 = _xmalloc($len$0$lcssa$i$i + 1 | 0) | 0;
         _strncpy($130, $$7$i$i, $len$0$lcssa$i$i) | 0;
         HEAP8[$130 + $len$0$lcssa$i$i >> 0] = 0;
         $loc$0$i$i = $130;
         L85 : while (1) {
          switch (HEAP8[$loc$0$i$i >> 0] | 0) {
          case 0:
           {
            break L85;
            break;
           }
          case 59:
           {
            HEAP8[$loc$0$i$i >> 0] = 58;
            break;
           }
          default:
           {}
          }
          $loc$0$i$i = $loc$0$i$i + 1 | 0;
         }
         if (!$prog$0$ph60$i$i) $var$0$i$i = $83; else {
          $135 = _concat3($83, 15912, $prog$0$ph60$i$i) | 0;
          _free($83);
          _free($prog$0$ph60$i$i);
          $var$0$i$i = $135;
         }
         _hash_insert($3, $var$0$i$i, $130);
        }
       }
       _free($line$0$ph$lcssa$i);
       $136 = _read_line($24) | 0;
       if (!$136) break L14; else $30 = $136;
      }
     } while (0);
     _xfclose($24, HEAP32[$cnf$029$i >> 2] | 0);
     _free(HEAP32[$cnf$029$i >> 2] | 0);
     $140 = $cnf$029$i + 4 | 0;
     $141 = HEAP32[$140 >> 2] | 0;
     if (!$141) break; else {
      $23 = $141;
      $cnf$029$i = $140;
     }
    }
    _free($18);
   }
  }
  do if ((label | 0) == 65) {
   $143 = _getenv(10065) | 0;
   if ($143 | 0) if (!(_strcmp($143, 10082) | 0)) break;
   $147 = HEAP32[21] | 0;
   _fwrite(12399, 9, 1, $147) | 0;
   HEAP32[$vararg_buffer1 >> 2] = $7;
   _fprintf($147, 10084, $vararg_buffer1) | 0;
   _fwrite(12726, 2, 1, $147) | 0;
   _fflush($147) | 0;
  } while (0);
  HEAP32[$0 >> 2] = 0;
  _kpathsea_init_db($kpse);
 }
 $149 = HEAP32[$kpse + 112 >> 2] | 0;
 if (!$149) ___assert_fail(12300, 10158, 254, 10187);
 $151 = _concat3($name, 15912, $149) | 0;
 HEAP32[$$byval_copy4 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$$byval_copy4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
 $152 = _hash_lookup($$byval_copy4, $151) | 0;
 _free($151);
 if ($152 | 0) {
  $154 = HEAP32[$152 >> 2] | 0;
  _free($152);
  $$0 = $154;
  STACKTOP = sp;
  return $$0 | 0;
 };
 HEAP32[$$byval_copy4 >> 2] = HEAP32[$3 >> 2];
 HEAP32[$$byval_copy4 + 4 >> 2] = HEAP32[$3 + 4 >> 2];
 $155 = _hash_lookup($$byval_copy4, $name) | 0;
 if (!$155) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $157 = HEAP32[$155 >> 2] | 0;
 _free($155);
 $$0 = $157;
 STACKTOP = sp;
 return $$0 | 0;
}

function _kpathsea_make_tex($kpse, $format, $base) {
 $kpse = $kpse | 0;
 $format = $format | 0;
 $base = $base | 0;
 var $$1 = 0, $$lcssa$i$i = 0, $$lcssa55 = 0, $$lcssa60 = 0, $$pr14$pre$i$i = 0, $11 = 0, $111 = 0, $116 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $123 = 0, $126 = 0, $129 = 0, $13 = 0, $131 = 0, $132 = 0, $136 = 0, $138 = 0, $14 = 0, $140 = 0, $145 = 0, $146 = 0, $147 = 0, $149 = 0, $152 = 0, $155 = 0, $156 = 0, $161 = 0, $162 = 0, $164 = 0, $165 = 0, $167 = 0, $18 = 0, $19 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $29 = 0, $30 = 0, $34 = 0, $35 = 0, $38 = 0, $43 = 0, $44 = 0, $47 = 0, $48 = 0, $55 = 0, $57 = 0, $66 = 0, $71 = 0, $74 = 0, $75 = 0, $77 = 0, $78 = 0, $79 = 0, $81 = 0, $85 = 0, $87 = 0, $95 = 0, $argnum$0$lcssa = 0, $argnum$018 = 0, $argnum$117 = 0, $childout$i = 0, $fn$0$ph$i = 0, $fn$0$ph$i$lcssa58 = 0, $fn$0$ph$i59 = 0, $i$021 = 0, $len$016$i = 0, $len$016$i$lcssa = 0, $m$i = 0, $missfont_name$0$ph$i$i = 0, $missfont_name$0910$i$i = 0, $missfont_name$1$i$i = 0, $missfont_name$112$i$i = 0, $ret$06$i = 0, $s$0$i$i = 0, $s$016$i$i = 0, $s$017$i = 0, $s$017$i$i = 0, $sign$0$i = 0, $spec$sroa$6$0 = 0, $spec$sroa$8$0 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer18 = 0, $vararg_buffer2 = 0, $vararg_buffer24 = 0, $vararg_buffer29 = 0, $vararg_buffer34 = 0, $vararg_buffer37 = 0, $vararg_buffer39 = 0, $vararg_buffer41 = 0, $vararg_buffer45 = 0, $vararg_buffer6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 1248 | 0;
 $vararg_buffer45 = sp + 1160 | 0;
 $vararg_buffer41 = sp + 1152 | 0;
 $vararg_buffer39 = sp + 120 | 0;
 $vararg_buffer37 = sp + 112 | 0;
 $vararg_buffer34 = sp + 104 | 0;
 $vararg_buffer29 = sp + 88 | 0;
 $vararg_buffer24 = sp + 72 | 0;
 $vararg_buffer18 = sp + 56 | 0;
 $vararg_buffer11 = sp + 32 | 0;
 $vararg_buffer6 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $childout$i = sp + 1168 | 0;
 $m$i = sp + 1164 | 0;
 if (!(HEAP32[$kpse + 132 + ($format * 68 | 0) >> 2] | 0)) _kpathsea_init_format($kpse, $format) | 0;
 $spec$sroa$6$0 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 48 >> 2] | 0;
 $spec$sroa$8$0 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 52 >> 2] | 0;
 if (!(HEAP32[$kpse + 132 + ($format * 68 | 0) + 44 >> 2] | 0)) {
  $$1 = 0;
  STACKTOP = sp;
  return $$1 | 0;
 }
 if (!(HEAP32[$kpse + 132 + ($format * 68 | 0) + 56 >> 2] | 0)) {
  $$1 = 0;
  STACKTOP = sp;
  return $$1 | 0;
 }
 $11 = _xmalloc(($spec$sroa$6$0 << 2) + 8 | 0) | 0;
 $12 = HEAP8[$base >> 0] | 0;
 switch ($12 << 24 >> 24) {
 case 45:
  {
   $13 = HEAP32[21] | 0;
   HEAP32[$vararg_buffer >> 2] = $base;
   HEAP32[$vararg_buffer + 4 >> 2] = 45;
   _fprintf($13, 11631, $vararg_buffer) | 0;
   $$1 = 0;
   STACKTOP = sp;
   return $$1 | 0;
  }
 case 0:
  break;
 default:
  {
   $14 = $12;
   $18 = $base;
   $i$021 = 0;
   label = 7;
  }
 }
 L13 : do if ((label | 0) == 7) {
  L14 : while (1) {
   label = 0;
   if ($14 << 24 >> 24 > -1) {
    if (!(_isalnum($14 & 255) | 0)) {
     $19 = HEAP8[$18 >> 0] | 0;
     label = 10;
    }
   } else {
    $19 = $14;
    label = 10;
   }
   if ((label | 0) == 10) {
    label = 0;
    switch ($19 << 24 >> 24) {
    case 47:
    case 46:
    case 95:
    case 43:
    case 45:
     break;
    default:
     {
      $$lcssa60 = $19;
      break L14;
     }
    }
   }
   $22 = $i$021 + 1 | 0;
   $23 = $base + $22 | 0;
   $24 = HEAP8[$23 >> 0] | 0;
   if (!($24 << 24 >> 24)) break L13; else {
    $14 = $24;
    $18 = $23;
    $i$021 = $22;
    label = 7;
   }
  }
  $21 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer2 >> 2] = $base;
  HEAP32[$vararg_buffer2 + 4 >> 2] = $$lcssa60 << 24 >> 24;
  _fprintf($21, 11691, $vararg_buffer2) | 0;
  $$1 = 0;
  STACKTOP = sp;
  return $$1 | 0;
 } while (0);
 if (($format | 0) == 2 | ($format | 1 | 0) == 1) {
  $29 = _getenv(11748) | 0;
  $30 = _getenv(11761) | 0;
  if (!$29) $35 = 0; else $35 = _atoi($29) | 0;
  if (!$30) ___assert_fail(11778, 11800, 49, 11834);
  $34 = _atoi($30) | 0;
  if (!(($35 | 0) != 0 & ($34 | 0) != 0)) ___assert_fail(11778, 11800, 49, 11834);
  _kpathsea_magstep_fix($kpse, $35, $34, $m$i) | 0;
  $38 = HEAP32[$m$i >> 2] | 0;
  do if (!$38) {
   if ($34 >>> 0 < 4001) {
    HEAP32[$vararg_buffer6 >> 2] = ($35 >>> 0) / ($34 >>> 0) | 0;
    HEAP32[$vararg_buffer6 + 4 >> 2] = ($35 >>> 0) % ($34 >>> 0) | 0;
    HEAP32[$vararg_buffer6 + 8 >> 2] = $34;
    _sprintf($childout$i, 11850, $vararg_buffer6) | 0;
    break;
   }
   $43 = ($34 >>> 0) / 4e3 | 0;
   $44 = ($34 >>> 0) % 4e3 | 0;
   if ($34 >>> 0 <= 7999) {
    HEAP32[$vararg_buffer24 >> 2] = ($35 >>> 0) / ($34 >>> 0) | 0;
    HEAP32[$vararg_buffer24 + 4 >> 2] = ($35 >>> 0) % ($34 >>> 0) | 0;
    HEAP32[$vararg_buffer24 + 8 >> 2] = $44;
    _sprintf($childout$i, 11890, $vararg_buffer24) | 0;
    break;
   }
   $47 = ($35 >>> 0) / ($34 >>> 0) | 0;
   $48 = ($35 >>> 0) % ($34 >>> 0) | 0;
   if (!$44) {
    HEAP32[$vararg_buffer18 >> 2] = $47;
    HEAP32[$vararg_buffer18 + 4 >> 2] = $48;
    HEAP32[$vararg_buffer18 + 8 >> 2] = $43;
    HEAP32[$vararg_buffer18 + 12 >> 2] = ($34 >>> 0) / ($43 >>> 0) | 0;
    _sprintf($childout$i, 11876, $vararg_buffer18) | 0;
    break;
   } else {
    HEAP32[$vararg_buffer11 >> 2] = $47;
    HEAP32[$vararg_buffer11 + 4 >> 2] = $48;
    HEAP32[$vararg_buffer11 + 8 >> 2] = $43;
    HEAP32[$vararg_buffer11 + 12 >> 2] = (($34 - $44 | 0) >>> 0) / ($43 >>> 0) | 0;
    HEAP32[$vararg_buffer11 + 16 >> 2] = $44;
    _sprintf($childout$i, 11859, $vararg_buffer11) | 0;
    break;
   }
  } else {
   if (($38 | 0) < 0) {
    $55 = 0 - $38 | 0;
    HEAP32[$m$i >> 2] = $55;
    $57 = $55;
    $sign$0$i = 11906;
   } else {
    $57 = $38;
    $sign$0$i = 30748;
   }
   HEAP32[$vararg_buffer29 >> 2] = $sign$0$i;
   HEAP32[$vararg_buffer29 + 4 >> 2] = ($57 | 0) / 2 | 0;
   HEAP32[$vararg_buffer29 + 8 >> 2] = 0 - ($57 & 1) & 5;
   _sprintf($childout$i, 11908, $vararg_buffer29) | 0;
  } while (0);
  _kpathsea_xputenv($kpse, 11927, $childout$i);
 }
 if (($spec$sroa$6$0 | 0) > 0) {
  $argnum$018 = 0;
  while (1) {
   HEAP32[$11 + ($argnum$018 << 2) >> 2] = _kpathsea_var_expand($kpse, HEAP32[$spec$sroa$8$0 + ($argnum$018 << 2) >> 2] | 0) | 0;
   $66 = $argnum$018 + 1 | 0;
   if (($66 | 0) == ($spec$sroa$6$0 | 0)) {
    $argnum$0$lcssa = $spec$sroa$6$0;
    break;
   } else $argnum$018 = $66;
  }
 } else $argnum$0$lcssa = 0;
 HEAP32[$11 + ($argnum$0$lcssa << 2) >> 2] = _xstrdup($base) | 0;
 HEAP32[$11 + ($argnum$0$lcssa + 1 << 2) >> 2] = 0;
 $71 = $kpse + 4144 | 0;
 if (!(HEAP32[$71 >> 2] | 0)) {
  $74 = HEAP32[21] | 0;
  _fwrite(11939, 18, 1, $74) | 0;
  $75 = HEAP32[$11 >> 2] | 0;
  if ($75 | 0) {
   $77 = $75;
   $s$017$i = $11;
   while (1) {
    HEAP32[$vararg_buffer34 >> 2] = $77;
    _fprintf($74, 13361, $vararg_buffer34) | 0;
    $78 = $s$017$i + 4 | 0;
    $79 = HEAP32[$78 >> 2] | 0;
    if (!$79) break; else {
     $77 = $79;
     $s$017$i = $78;
    }
   }
  }
  _fputc(10, $74) | 0;
 }
 $81 = _open(11958, 0, $vararg_buffer37) | 0;
 L64 : do if (($81 | 0) < 0) {
  _perror(11968);
  label = 73;
 } else {
  if ((_pipe($childout$i) | 0) < 0) _perror(12006); else {
   $85 = _open(11958, 1, $vararg_buffer39) | 0;
   do if (($85 | 0) < 0) _perror(12023); else {
    $87 = _fork() | 0;
    if (($87 | 0) < 0) {
     _perror(12061);
     _close($85) | 0;
     break;
    }
    if (!$87) {
     _close(HEAP32[$childout$i >> 2] | 0) | 0;
     if ($81 | 0) {
      _close(0) | 0;
      _dup($81) | 0;
      _close($81) | 0;
     }
     $95 = $childout$i + 4 | 0;
     if ((HEAP32[$95 >> 2] | 0) != 1) {
      _close(1) | 0;
      _dup(HEAP32[$95 >> 2] | 0) | 0;
      _close(HEAP32[$95 >> 2] | 0) | 0;
     }
     if (($85 | 0) != 2) {
      if (HEAP32[$71 >> 2] | 0) {
       _close(2) | 0;
       _dup($85) | 0;
      }
      _close($85) | 0;
     }
     if (!(_execvp(HEAP32[$11 >> 2] | 0, $11) | 0)) __exit(1);
     _perror(HEAP32[$11 >> 2] | 0);
     __exit(1);
    }
    _close($81) | 0;
    _close(HEAP32[$childout$i + 4 >> 2] | 0) | 0;
    _close($85) | 0;
    $fn$0$ph$i = _xstrdup(30748) | 0;
    L95 : while (1) {
     L97 : while (1) {
      $111 = _read(HEAP32[$childout$i >> 2] | 0, $vararg_buffer39, 1024) | 0;
      switch ($111 | 0) {
      case 0:
       {
        $fn$0$ph$i59 = $fn$0$ph$i;
        break L95;
        break;
       }
      case -1:
       break;
      default:
       {
        $$lcssa55 = $111;
        break L97;
       }
      }
      if ((HEAP32[(___errno_location() | 0) >> 2] | 0) != 4) {
       $fn$0$ph$i$lcssa58 = $fn$0$ph$i;
       label = 63;
       break L95;
      }
     }
     HEAP8[$vararg_buffer39 + $$lcssa55 >> 0] = 0;
     $116 = _concat($fn$0$ph$i, $vararg_buffer39) | 0;
     _free($fn$0$ph$i);
     $fn$0$ph$i = $116;
    }
    if ((label | 0) == 63) {
     _perror(12078);
     $fn$0$ph$i59 = $fn$0$ph$i$lcssa58;
    }
    _close(HEAP32[$childout$i >> 2] | 0) | 0;
    _wait(0) | 0;
    if (!$fn$0$ph$i59) {
     label = 73;
     break L64;
    }
    $119 = _strlen($fn$0$ph$i59) | 0;
    L105 : do if (!$119) $129 = 0; else {
     $len$016$i = $119;
     L106 : while (1) {
      $120 = $len$016$i + -1 | 0;
      $121 = $fn$0$ph$i59 + $120 | 0;
      switch (HEAP8[$121 >> 0] | 0) {
      case 10:
      case 13:
       break;
      default:
       {
        $len$016$i$lcssa = $len$016$i;
        break L106;
       }
      }
      HEAP8[$121 >> 0] = 0;
      if (!$120) {
       $129 = 0;
       break L105;
      } else $len$016$i = $120;
     }
     $123 = _kpathsea_readable_file($kpse, $fn$0$ph$i59) | 0;
     if ($len$016$i$lcssa >>> 0 > 1 & ($123 | 0) == 0) {
      $126 = HEAP32[21] | 0;
      _fwrite(12399, 9, 1, $126) | 0;
      HEAP32[$vararg_buffer41 >> 2] = HEAP32[$11 >> 2];
      HEAP32[$vararg_buffer41 + 4 >> 2] = $fn$0$ph$i59;
      _fprintf($126, 12095, $vararg_buffer41) | 0;
      _fwrite(12726, 2, 1, $126) | 0;
      _fflush($126) | 0;
      $129 = 0;
     } else $129 = $123;
    } while (0);
    if (($fn$0$ph$i59 | 0) != ($129 | 0)) _free($fn$0$ph$i59);
    if (!$129) {
     label = 75;
     break L64;
    }
    _kpathsea_db_insert($kpse, $129);
    $ret$06$i = $129;
    break L64;
   } while (0);
   _close(HEAP32[$childout$i >> 2] | 0) | 0;
   _close(HEAP32[$childout$i + 4 >> 2] | 0) | 0;
  }
  _close($81) | 0;
  label = 73;
 } while (0);
 if ((label | 0) == 73) label = 75;
 L120 : do if ((label | 0) == 75) {
  switch ($format | 0) {
  case 0:
  case 1:
  case 2:
  case 3:
  case 33:
   break;
  default:
   {
    $ret$06$i = 0;
    break L120;
   }
  }
  $131 = $kpse + 4148 | 0;
  $132 = HEAP32[$131 >> 2] | 0;
  if (!$132) {
   if (HEAP32[$71 >> 2] | 0) {
    $ret$06$i = 0;
    break;
   }
   $136 = _kpathsea_var_value($kpse, 12142) | 0;
   L126 : do if (!$136) {
    $missfont_name$0$ph$i$i = 12155;
    label = 82;
   } else {
    $138 = HEAP8[$136 >> 0] | 0;
    switch ($138 << 24 >> 24) {
    case 49:
     {
      $missfont_name$0$ph$i$i = 12155;
      label = 82;
      break L126;
      break;
     }
    case 0:
     break;
    default:
     if ($138 << 24 >> 24 != 48) {
      $missfont_name$0$ph$i$i = $136;
      label = 82;
      break L126;
     }
    }
    HEAP32[$131 >> 2] = 0;
    $missfont_name$0910$i$i = 0;
    label = 83;
   } while (0);
   if ((label | 0) == 82) {
    $140 = _kpse_fopen_trace($missfont_name$0$ph$i$i, 12168) | 0;
    HEAP32[$131 >> 2] = $140;
    if (!$140) {
     $missfont_name$0910$i$i = $missfont_name$0$ph$i$i;
     label = 83;
    } else $missfont_name$112$i$i = $missfont_name$0$ph$i$i;
   }
   if ((label | 0) == 83) {
    if (!(_kpathsea_var_value($kpse, 12171) | 0)) {
     $147 = HEAP32[$131 >> 2] | 0;
     $missfont_name$1$i$i = $missfont_name$0910$i$i;
    } else {
     $145 = _concat3(_kpathsea_var_value($kpse, 12171) | 0, 13340, $missfont_name$0910$i$i) | 0;
     $146 = _kpse_fopen_trace($145, 12168) | 0;
     HEAP32[$131 >> 2] = $146;
     $147 = $146;
     $missfont_name$1$i$i = $145;
    }
    if (!$147) {
     $ret$06$i = 0;
     break;
    } else $missfont_name$112$i$i = $missfont_name$1$i$i;
   }
   $149 = HEAP32[21] | 0;
   HEAP32[$vararg_buffer45 >> 2] = $missfont_name$112$i$i;
   _fprintf($149, 12183, $vararg_buffer45) | 0;
   $$pr14$pre$i$i = HEAP32[$131 >> 2] | 0;
   if (!$$pr14$pre$i$i) {
    $ret$06$i = 0;
    break;
   } else $152 = $$pr14$pre$i$i;
  } else $152 = $132;
  _fputs(HEAP32[$11 >> 2] | 0, $152) | 0;
  $s$016$i$i = $11 + 4 | 0;
  $155 = HEAP32[$131 >> 2] | 0;
  if (!(HEAP32[$s$016$i$i >> 2] | 0)) $$lcssa$i$i = $155; else {
   $156 = $155;
   $s$017$i$i = $s$016$i$i;
   while (1) {
    _putc(32, $156) | 0;
    _fputs(HEAP32[$s$017$i$i >> 2] | 0, HEAP32[$131 >> 2] | 0) | 0;
    $s$0$i$i = $s$017$i$i + 4 | 0;
    $161 = HEAP32[$131 >> 2] | 0;
    if (!(HEAP32[$s$0$i$i >> 2] | 0)) {
     $$lcssa$i$i = $161;
     break;
    } else {
     $156 = $161;
     $s$017$i$i = $s$0$i$i;
    }
   }
  }
  _putc(10, $$lcssa$i$i) | 0;
  $ret$06$i = 0;
 } while (0);
 $162 = HEAP32[$11 >> 2] | 0;
 if ($162 | 0) {
  $164 = $162;
  $argnum$117 = 0;
  while (1) {
   _free($164);
   $165 = $argnum$117 + 1 | 0;
   $167 = HEAP32[$11 + ($165 << 2) >> 2] | 0;
   if (!$167) break; else {
    $164 = $167;
    $argnum$117 = $165;
   }
  }
 }
 _free($11);
 $$1 = $ret$06$i;
 STACKTOP = sp;
 return $$1 | 0;
}

function _free($mem) {
 $mem = $mem | 0;
 var $$lcssa = 0, $$pre$phi41Z2D = 0, $$pre$phi43Z2D = 0, $$pre$phiZ2D = 0, $1 = 0, $104 = 0, $105 = 0, $113 = 0, $114 = 0, $12 = 0, $122 = 0, $130 = 0, $135 = 0, $136 = 0, $139 = 0, $141 = 0, $143 = 0, $15 = 0, $158 = 0, $16 = 0, $163 = 0, $165 = 0, $168 = 0, $171 = 0, $174 = 0, $177 = 0, $178 = 0, $179 = 0, $181 = 0, $183 = 0, $184 = 0, $186 = 0, $187 = 0, $193 = 0, $194 = 0, $2 = 0, $20 = 0, $203 = 0, $208 = 0, $211 = 0, $212 = 0, $218 = 0, $23 = 0, $233 = 0, $236 = 0, $237 = 0, $238 = 0, $242 = 0, $243 = 0, $249 = 0, $25 = 0, $254 = 0, $255 = 0, $258 = 0, $260 = 0, $263 = 0, $268 = 0, $27 = 0, $274 = 0, $278 = 0, $279 = 0, $297 = 0, $299 = 0, $306 = 0, $307 = 0, $308 = 0, $316 = 0, $40 = 0, $45 = 0, $47 = 0, $5 = 0, $50 = 0, $52 = 0, $55 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $62 = 0, $64 = 0, $65 = 0, $67 = 0, $68 = 0, $73 = 0, $74 = 0, $8 = 0, $83 = 0, $88 = 0, $9 = 0, $91 = 0, $92 = 0, $98 = 0, $F18$0 = 0, $I20$0 = 0, $K21$0 = 0, $R$1 = 0, $R$1$lcssa = 0, $R$3 = 0, $R8$1 = 0, $R8$1$lcssa = 0, $R8$3 = 0, $RP$1 = 0, $RP$1$lcssa = 0, $RP10$1 = 0, $RP10$1$lcssa = 0, $T$0 = 0, $T$0$lcssa = 0, $T$0$lcssa48 = 0, $p$1 = 0, $psize$1 = 0, $psize$2 = 0, $sp$0$i = 0, $sp$0$in$i = 0, label = 0;
 if (!$mem) return;
 $1 = $mem + -8 | 0;
 $2 = HEAP32[5773] | 0;
 if ($1 >>> 0 < $2 >>> 0) _abort();
 $5 = HEAP32[$mem + -4 >> 2] | 0;
 $6 = $5 & 3;
 if (($6 | 0) == 1) _abort();
 $8 = $5 & -8;
 $9 = $1 + $8 | 0;
 do if (!($5 & 1)) {
  $12 = HEAP32[$1 >> 2] | 0;
  if (!$6) return;
  $15 = $1 + (0 - $12) | 0;
  $16 = $12 + $8 | 0;
  if ($15 >>> 0 < $2 >>> 0) _abort();
  if (($15 | 0) == (HEAP32[5774] | 0)) {
   $104 = $9 + 4 | 0;
   $105 = HEAP32[$104 >> 2] | 0;
   if (($105 & 3 | 0) != 3) {
    $p$1 = $15;
    $psize$1 = $16;
    break;
   }
   HEAP32[5771] = $16;
   HEAP32[$104 >> 2] = $105 & -2;
   HEAP32[$15 + 4 >> 2] = $16 | 1;
   HEAP32[$15 + $16 >> 2] = $16;
   return;
  }
  $20 = $12 >>> 3;
  if ($12 >>> 0 < 256) {
   $23 = HEAP32[$15 + 8 >> 2] | 0;
   $25 = HEAP32[$15 + 12 >> 2] | 0;
   $27 = 23116 + ($20 << 1 << 2) | 0;
   if (($23 | 0) != ($27 | 0)) {
    if ($23 >>> 0 < $2 >>> 0) _abort();
    if ((HEAP32[$23 + 12 >> 2] | 0) != ($15 | 0)) _abort();
   }
   if (($25 | 0) == ($23 | 0)) {
    HEAP32[5769] = HEAP32[5769] & ~(1 << $20);
    $p$1 = $15;
    $psize$1 = $16;
    break;
   }
   if (($25 | 0) == ($27 | 0)) $$pre$phi43Z2D = $25 + 8 | 0; else {
    if ($25 >>> 0 < $2 >>> 0) _abort();
    $40 = $25 + 8 | 0;
    if ((HEAP32[$40 >> 2] | 0) == ($15 | 0)) $$pre$phi43Z2D = $40; else _abort();
   }
   HEAP32[$23 + 12 >> 2] = $25;
   HEAP32[$$pre$phi43Z2D >> 2] = $23;
   $p$1 = $15;
   $psize$1 = $16;
   break;
  }
  $45 = HEAP32[$15 + 24 >> 2] | 0;
  $47 = HEAP32[$15 + 12 >> 2] | 0;
  do if (($47 | 0) == ($15 | 0)) {
   $58 = $15 + 16 | 0;
   $59 = $58 + 4 | 0;
   $60 = HEAP32[$59 >> 2] | 0;
   if (!$60) {
    $62 = HEAP32[$58 >> 2] | 0;
    if (!$62) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $62;
     $RP$1 = $58;
    }
   } else {
    $R$1 = $60;
    $RP$1 = $59;
   }
   while (1) {
    $64 = $R$1 + 20 | 0;
    $65 = HEAP32[$64 >> 2] | 0;
    if ($65 | 0) {
     $R$1 = $65;
     $RP$1 = $64;
     continue;
    }
    $67 = $R$1 + 16 | 0;
    $68 = HEAP32[$67 >> 2] | 0;
    if (!$68) {
     $R$1$lcssa = $R$1;
     $RP$1$lcssa = $RP$1;
     break;
    } else {
     $R$1 = $68;
     $RP$1 = $67;
    }
   }
   if ($RP$1$lcssa >>> 0 < $2 >>> 0) _abort(); else {
    HEAP32[$RP$1$lcssa >> 2] = 0;
    $R$3 = $R$1$lcssa;
    break;
   }
  } else {
   $50 = HEAP32[$15 + 8 >> 2] | 0;
   if ($50 >>> 0 < $2 >>> 0) _abort();
   $52 = $50 + 12 | 0;
   if ((HEAP32[$52 >> 2] | 0) != ($15 | 0)) _abort();
   $55 = $47 + 8 | 0;
   if ((HEAP32[$55 >> 2] | 0) == ($15 | 0)) {
    HEAP32[$52 >> 2] = $47;
    HEAP32[$55 >> 2] = $50;
    $R$3 = $47;
    break;
   } else _abort();
  } while (0);
  if (!$45) {
   $p$1 = $15;
   $psize$1 = $16;
  } else {
   $73 = HEAP32[$15 + 28 >> 2] | 0;
   $74 = 23380 + ($73 << 2) | 0;
   if (($15 | 0) == (HEAP32[$74 >> 2] | 0)) {
    HEAP32[$74 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[5770] = HEAP32[5770] & ~(1 << $73);
     $p$1 = $15;
     $psize$1 = $16;
     break;
    }
   } else {
    if ($45 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    $83 = $45 + 16 | 0;
    if ((HEAP32[$83 >> 2] | 0) == ($15 | 0)) HEAP32[$83 >> 2] = $R$3; else HEAP32[$45 + 20 >> 2] = $R$3;
    if (!$R$3) {
     $p$1 = $15;
     $psize$1 = $16;
     break;
    }
   }
   $88 = HEAP32[5773] | 0;
   if ($R$3 >>> 0 < $88 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $45;
   $91 = $15 + 16 | 0;
   $92 = HEAP32[$91 >> 2] | 0;
   do if ($92 | 0) if ($92 >>> 0 < $88 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $92;
    HEAP32[$92 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $98 = HEAP32[$91 + 4 >> 2] | 0;
   if (!$98) {
    $p$1 = $15;
    $psize$1 = $16;
   } else if ($98 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $98;
    HEAP32[$98 + 24 >> 2] = $R$3;
    $p$1 = $15;
    $psize$1 = $16;
    break;
   }
  }
 } else {
  $p$1 = $1;
  $psize$1 = $8;
 } while (0);
 if ($p$1 >>> 0 >= $9 >>> 0) _abort();
 $113 = $9 + 4 | 0;
 $114 = HEAP32[$113 >> 2] | 0;
 if (!($114 & 1)) _abort();
 if (!($114 & 2)) {
  if (($9 | 0) == (HEAP32[5775] | 0)) {
   $122 = (HEAP32[5772] | 0) + $psize$1 | 0;
   HEAP32[5772] = $122;
   HEAP32[5775] = $p$1;
   HEAP32[$p$1 + 4 >> 2] = $122 | 1;
   if (($p$1 | 0) != (HEAP32[5774] | 0)) return;
   HEAP32[5774] = 0;
   HEAP32[5771] = 0;
   return;
  }
  if (($9 | 0) == (HEAP32[5774] | 0)) {
   $130 = (HEAP32[5771] | 0) + $psize$1 | 0;
   HEAP32[5771] = $130;
   HEAP32[5774] = $p$1;
   HEAP32[$p$1 + 4 >> 2] = $130 | 1;
   HEAP32[$p$1 + $130 >> 2] = $130;
   return;
  }
  $135 = ($114 & -8) + $psize$1 | 0;
  $136 = $114 >>> 3;
  do if ($114 >>> 0 < 256) {
   $139 = HEAP32[$9 + 8 >> 2] | 0;
   $141 = HEAP32[$9 + 12 >> 2] | 0;
   $143 = 23116 + ($136 << 1 << 2) | 0;
   if (($139 | 0) != ($143 | 0)) {
    if ($139 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    if ((HEAP32[$139 + 12 >> 2] | 0) != ($9 | 0)) _abort();
   }
   if (($141 | 0) == ($139 | 0)) {
    HEAP32[5769] = HEAP32[5769] & ~(1 << $136);
    break;
   }
   if (($141 | 0) == ($143 | 0)) $$pre$phi41Z2D = $141 + 8 | 0; else {
    if ($141 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    $158 = $141 + 8 | 0;
    if ((HEAP32[$158 >> 2] | 0) == ($9 | 0)) $$pre$phi41Z2D = $158; else _abort();
   }
   HEAP32[$139 + 12 >> 2] = $141;
   HEAP32[$$pre$phi41Z2D >> 2] = $139;
  } else {
   $163 = HEAP32[$9 + 24 >> 2] | 0;
   $165 = HEAP32[$9 + 12 >> 2] | 0;
   do if (($165 | 0) == ($9 | 0)) {
    $177 = $9 + 16 | 0;
    $178 = $177 + 4 | 0;
    $179 = HEAP32[$178 >> 2] | 0;
    if (!$179) {
     $181 = HEAP32[$177 >> 2] | 0;
     if (!$181) {
      $R8$3 = 0;
      break;
     } else {
      $R8$1 = $181;
      $RP10$1 = $177;
     }
    } else {
     $R8$1 = $179;
     $RP10$1 = $178;
    }
    while (1) {
     $183 = $R8$1 + 20 | 0;
     $184 = HEAP32[$183 >> 2] | 0;
     if ($184 | 0) {
      $R8$1 = $184;
      $RP10$1 = $183;
      continue;
     }
     $186 = $R8$1 + 16 | 0;
     $187 = HEAP32[$186 >> 2] | 0;
     if (!$187) {
      $R8$1$lcssa = $R8$1;
      $RP10$1$lcssa = $RP10$1;
      break;
     } else {
      $R8$1 = $187;
      $RP10$1 = $186;
     }
    }
    if ($RP10$1$lcssa >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
     HEAP32[$RP10$1$lcssa >> 2] = 0;
     $R8$3 = $R8$1$lcssa;
     break;
    }
   } else {
    $168 = HEAP32[$9 + 8 >> 2] | 0;
    if ($168 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    $171 = $168 + 12 | 0;
    if ((HEAP32[$171 >> 2] | 0) != ($9 | 0)) _abort();
    $174 = $165 + 8 | 0;
    if ((HEAP32[$174 >> 2] | 0) == ($9 | 0)) {
     HEAP32[$171 >> 2] = $165;
     HEAP32[$174 >> 2] = $168;
     $R8$3 = $165;
     break;
    } else _abort();
   } while (0);
   if ($163 | 0) {
    $193 = HEAP32[$9 + 28 >> 2] | 0;
    $194 = 23380 + ($193 << 2) | 0;
    if (($9 | 0) == (HEAP32[$194 >> 2] | 0)) {
     HEAP32[$194 >> 2] = $R8$3;
     if (!$R8$3) {
      HEAP32[5770] = HEAP32[5770] & ~(1 << $193);
      break;
     }
    } else {
     if ($163 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
     $203 = $163 + 16 | 0;
     if ((HEAP32[$203 >> 2] | 0) == ($9 | 0)) HEAP32[$203 >> 2] = $R8$3; else HEAP32[$163 + 20 >> 2] = $R8$3;
     if (!$R8$3) break;
    }
    $208 = HEAP32[5773] | 0;
    if ($R8$3 >>> 0 < $208 >>> 0) _abort();
    HEAP32[$R8$3 + 24 >> 2] = $163;
    $211 = $9 + 16 | 0;
    $212 = HEAP32[$211 >> 2] | 0;
    do if ($212 | 0) if ($212 >>> 0 < $208 >>> 0) _abort(); else {
     HEAP32[$R8$3 + 16 >> 2] = $212;
     HEAP32[$212 + 24 >> 2] = $R8$3;
     break;
    } while (0);
    $218 = HEAP32[$211 + 4 >> 2] | 0;
    if ($218 | 0) if ($218 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
     HEAP32[$R8$3 + 20 >> 2] = $218;
     HEAP32[$218 + 24 >> 2] = $R8$3;
     break;
    }
   }
  } while (0);
  HEAP32[$p$1 + 4 >> 2] = $135 | 1;
  HEAP32[$p$1 + $135 >> 2] = $135;
  if (($p$1 | 0) == (HEAP32[5774] | 0)) {
   HEAP32[5771] = $135;
   return;
  } else $psize$2 = $135;
 } else {
  HEAP32[$113 >> 2] = $114 & -2;
  HEAP32[$p$1 + 4 >> 2] = $psize$1 | 1;
  HEAP32[$p$1 + $psize$1 >> 2] = $psize$1;
  $psize$2 = $psize$1;
 }
 $233 = $psize$2 >>> 3;
 if ($psize$2 >>> 0 < 256) {
  $236 = 23116 + ($233 << 1 << 2) | 0;
  $237 = HEAP32[5769] | 0;
  $238 = 1 << $233;
  if (!($237 & $238)) {
   HEAP32[5769] = $237 | $238;
   $$pre$phiZ2D = $236 + 8 | 0;
   $F18$0 = $236;
  } else {
   $242 = $236 + 8 | 0;
   $243 = HEAP32[$242 >> 2] | 0;
   if ($243 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
    $$pre$phiZ2D = $242;
    $F18$0 = $243;
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $p$1;
  HEAP32[$F18$0 + 12 >> 2] = $p$1;
  HEAP32[$p$1 + 8 >> 2] = $F18$0;
  HEAP32[$p$1 + 12 >> 2] = $236;
  return;
 }
 $249 = $psize$2 >>> 8;
 if (!$249) $I20$0 = 0; else if ($psize$2 >>> 0 > 16777215) $I20$0 = 31; else {
  $254 = ($249 + 1048320 | 0) >>> 16 & 8;
  $255 = $249 << $254;
  $258 = ($255 + 520192 | 0) >>> 16 & 4;
  $260 = $255 << $258;
  $263 = ($260 + 245760 | 0) >>> 16 & 2;
  $268 = 14 - ($258 | $254 | $263) + ($260 << $263 >>> 15) | 0;
  $I20$0 = $psize$2 >>> ($268 + 7 | 0) & 1 | $268 << 1;
 }
 $274 = 23380 + ($I20$0 << 2) | 0;
 HEAP32[$p$1 + 28 >> 2] = $I20$0;
 HEAP32[$p$1 + 20 >> 2] = 0;
 HEAP32[$p$1 + 16 >> 2] = 0;
 $278 = HEAP32[5770] | 0;
 $279 = 1 << $I20$0;
 do if (!($278 & $279)) {
  HEAP32[5770] = $278 | $279;
  HEAP32[$274 >> 2] = $p$1;
  HEAP32[$p$1 + 24 >> 2] = $274;
  HEAP32[$p$1 + 12 >> 2] = $p$1;
  HEAP32[$p$1 + 8 >> 2] = $p$1;
 } else {
  $K21$0 = $psize$2 << (($I20$0 | 0) == 31 ? 0 : 25 - ($I20$0 >>> 1) | 0);
  $T$0 = HEAP32[$274 >> 2] | 0;
  while (1) {
   if ((HEAP32[$T$0 + 4 >> 2] & -8 | 0) == ($psize$2 | 0)) {
    $T$0$lcssa = $T$0;
    label = 130;
    break;
   }
   $297 = $T$0 + 16 + ($K21$0 >>> 31 << 2) | 0;
   $299 = HEAP32[$297 >> 2] | 0;
   if (!$299) {
    $$lcssa = $297;
    $T$0$lcssa48 = $T$0;
    label = 127;
    break;
   } else {
    $K21$0 = $K21$0 << 1;
    $T$0 = $299;
   }
  }
  if ((label | 0) == 127) if ($$lcssa >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
   HEAP32[$$lcssa >> 2] = $p$1;
   HEAP32[$p$1 + 24 >> 2] = $T$0$lcssa48;
   HEAP32[$p$1 + 12 >> 2] = $p$1;
   HEAP32[$p$1 + 8 >> 2] = $p$1;
   break;
  } else if ((label | 0) == 130) {
   $306 = $T$0$lcssa + 8 | 0;
   $307 = HEAP32[$306 >> 2] | 0;
   $308 = HEAP32[5773] | 0;
   if ($307 >>> 0 >= $308 >>> 0 & $T$0$lcssa >>> 0 >= $308 >>> 0) {
    HEAP32[$307 + 12 >> 2] = $p$1;
    HEAP32[$306 >> 2] = $p$1;
    HEAP32[$p$1 + 8 >> 2] = $307;
    HEAP32[$p$1 + 12 >> 2] = $T$0$lcssa;
    HEAP32[$p$1 + 24 >> 2] = 0;
    break;
   } else _abort();
  }
 } while (0);
 $316 = (HEAP32[5777] | 0) + -1 | 0;
 HEAP32[5777] = $316;
 if (!$316) $sp$0$in$i = 23532; else return;
 while (1) {
  $sp$0$i = HEAP32[$sp$0$in$i >> 2] | 0;
  if (!$sp$0$i) break; else $sp$0$in$i = $sp$0$i + 8 | 0;
 }
 HEAP32[5777] = -1;
 return;
}

function _xconcatenate() {
 var $$lcssa4 = 0, $$lcssa52 = 0, $$lcssa53 = 0, $$lcssa54 = 0, $$lcssa55 = 0, $$lcssa56 = 0, $$lcssa75 = 0, $$lcssa76 = 0, $$pre = 0, $$pre25 = 0, $$pre27 = 0, $$pre29 = 0, $$pre30 = 0, $$pre35 = 0, $$pre37 = 0, $0 = 0, $10 = 0, $100 = 0, $104 = 0, $107 = 0, $111 = 0, $113 = 0, $115 = 0, $12 = 0, $121 = 0, $125 = 0, $129 = 0, $13 = 0, $131 = 0, $132 = 0, $134 = 0, $135 = 0, $136 = 0, $138 = 0, $139 = 0, $140 = 0, $144 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $154 = 0, $157 = 0, $159 = 0, $160 = 0, $163 = 0, $165 = 0, $167 = 0, $170 = 0, $172 = 0, $174 = 0, $179 = 0, $182 = 0, $186 = 0, $194 = 0, $196 = 0, $20 = 0, $201 = 0, $208 = 0, $210 = 0, $216 = 0, $217 = 0, $222 = 0, $229 = 0, $231 = 0, $233 = 0, $236 = 0, $238 = 0, $240 = 0, $244 = 0, $245 = 0, $246 = 0, $249 = 0, $251 = 0, $253 = 0, $256 = 0, $258 = 0, $26 = 0, $260 = 0, $264 = 0, $265 = 0, $28 = 0, $36 = 0, $39 = 0, $41 = 0, $43 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $53 = 0, $57 = 0, $6 = 0, $62 = 0, $64 = 0, $65 = 0, $67 = 0, $69 = 0, $72 = 0, $74 = 0, $76 = 0, $81 = 0, $82 = 0, $84 = 0, $88 = 0, $98 = 0, $vararg_buffer = 0, $vararg_buffer10 = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   $5 = HEAP8[26649] | 0;
   $6 = HEAP32[4365] | 0;
   switch ($5 << 24 >> 24) {
   case 1:
    {
     $10 = HEAP32[4364] | 0;
     $12 = HEAP32[4345] | 0;
     $13 = ($12 | 0) >= ($10 | 0);
     if (($6 | 0) >= ($10 | 0)) {
      if ($13) {
       $15 = HEAP32[4041] | 0;
       HEAP32[$15 + ($12 << 2) >> 2] = HEAP32[$15 + ($12 + 1 << 2) >> 2];
       $20 = (HEAP32[4e3] | 0) + 1 | 0;
       HEAP32[4e3] = $20;
       HEAP32[4237] = HEAP32[$15 + ($20 << 2) >> 2];
       HEAP32[4360] = (HEAP32[4360] | 0) + 1;
       STACKTOP = sp;
       return;
      }
      $26 = HEAP32[4041] | 0;
      $28 = HEAP32[$26 + ($6 + 1 << 2) >> 2] | 0;
      if (($28 | 0) == (HEAP32[$26 + ($6 << 2) >> 2] | 0)) {
       _zpushlitstk($12, 1);
       STACKTOP = sp;
       return;
      }
      HEAP32[4237] = $28;
      $36 = HEAP32[$26 + ($12 << 2) >> 2] | 0;
      $39 = HEAP32[4043] | 0;
      if (((HEAP32[$26 + ($12 + 1 << 2) >> 2] | 0) + $28 - $36 | 0) > ($39 | 0)) {
       $43 = $39;
       while (1) {
        $41 = HEAP32[3989] | 0;
        HEAP32[$vararg_buffer >> 2] = 1161;
        HEAP32[$vararg_buffer + 4 >> 2] = 1;
        HEAP32[$vararg_buffer + 8 >> 2] = $43 + 65e3;
        HEAP32[$vararg_buffer + 12 >> 2] = $43;
        _fprintf($41, 1023, $vararg_buffer) | 0;
        HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
        $49 = (HEAP32[4043] | 0) + 65e3 | 0;
        HEAP32[4043] = $49;
        $50 = HEAP32[4237] | 0;
        $51 = HEAP32[4345] | 0;
        $53 = HEAP32[4041] | 0;
        $57 = HEAP32[$53 + ($51 << 2) >> 2] | 0;
        if (((HEAP32[$53 + ($51 + 1 << 2) >> 2] | 0) + $50 - $57 | 0) > ($49 | 0)) $43 = $49; else {
         $$lcssa4 = $57;
         $264 = $50;
         $62 = $51;
         $64 = $53;
         break;
        }
       }
      } else {
       $$lcssa4 = $36;
       $264 = $28;
       $62 = $12;
       $64 = $26;
      }
      HEAP32[4343] = $$lcssa4;
      $65 = HEAP32[$64 + ($62 + 1 << 2) >> 2] | 0;
      HEAP32[4344] = $65;
      if (($$lcssa4 | 0) < ($65 | 0)) {
       $69 = $$lcssa4;
       $72 = $264;
       while (1) {
        $67 = HEAP32[4042] | 0;
        HEAP8[$67 + $72 >> 0] = HEAP8[$67 + $69 >> 0] | 0;
        $74 = (HEAP32[4237] | 0) + 1 | 0;
        HEAP32[4237] = $74;
        $76 = (HEAP32[4343] | 0) + 1 | 0;
        HEAP32[4343] = $76;
        if (($76 | 0) < (HEAP32[4344] | 0)) {
         $69 = $76;
         $72 = $74;
        } else break;
       }
      }
      _zpushlitstk(_makestring() | 0, 1);
      STACKTOP = sp;
      return;
     }
     if (!$13) {
      $182 = HEAP32[4041] | 0;
      $186 = HEAP32[$182 + ($12 << 2) >> 2] | 0;
      if ((HEAP32[$182 + ($12 + 1 << 2) >> 2] | 0) == ($186 | 0)) {
       HEAP32[4360] = (HEAP32[4360] | 0) + 1;
       STACKTOP = sp;
       return;
      }
      $194 = HEAP32[$182 + ($6 << 2) >> 2] | 0;
      if ((HEAP32[$182 + ($6 + 1 << 2) >> 2] | 0) == ($194 | 0)) {
       _zpushlitstk($12, 1);
       STACKTOP = sp;
       return;
      }
      $$pre30 = HEAP32[4043] | 0;
      $196 = HEAP32[4237] | 0;
      $201 = $182 + ($6 + 1 << 2) | 0;
      if (((HEAP32[$182 + ($12 + 1 << 2) >> 2] | 0) + $196 - $186 + (HEAP32[$201 >> 2] | 0) - $194 | 0) > ($$pre30 | 0)) {
       $210 = $$pre30;
       while (1) {
        $208 = HEAP32[3989] | 0;
        HEAP32[$vararg_buffer10 >> 2] = 1161;
        HEAP32[$vararg_buffer10 + 4 >> 2] = 1;
        HEAP32[$vararg_buffer10 + 8 >> 2] = $210 + 65e3;
        HEAP32[$vararg_buffer10 + 12 >> 2] = $210;
        _fprintf($208, 1023, $vararg_buffer10) | 0;
        HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
        $216 = (HEAP32[4043] | 0) + 65e3 | 0;
        HEAP32[4043] = $216;
        $$pre = HEAP32[4345] | 0;
        $$pre25 = HEAP32[4041] | 0;
        $$pre27 = HEAP32[4365] | 0;
        $$pre29 = HEAP32[$$pre25 + ($$pre27 << 2) >> 2] | 0;
        $217 = HEAP32[4237] | 0;
        $222 = $$pre25 + ($$pre27 + 1 << 2) | 0;
        if (((HEAP32[$$pre25 + ($$pre + 1 << 2) >> 2] | 0) + $217 - (HEAP32[$$pre25 + ($$pre << 2) >> 2] | 0) + (HEAP32[$222 >> 2] | 0) - $$pre29 | 0) > ($216 | 0)) $210 = $216; else {
         $$lcssa52 = $$pre29;
         $$lcssa53 = $$pre25;
         $$lcssa54 = $$pre;
         $$lcssa55 = $217;
         $$lcssa56 = $222;
         break;
        }
       }
      } else {
       $$lcssa52 = $194;
       $$lcssa53 = $182;
       $$lcssa54 = $12;
       $$lcssa55 = $196;
       $$lcssa56 = $201;
      }
      HEAP32[4343] = $$lcssa52;
      $229 = HEAP32[$$lcssa56 >> 2] | 0;
      HEAP32[4344] = $229;
      if (($$lcssa52 | 0) < ($229 | 0)) {
       $233 = $$lcssa52;
       $236 = $$lcssa55;
       while (1) {
        $231 = HEAP32[4042] | 0;
        HEAP8[$231 + $236 >> 0] = HEAP8[$231 + $233 >> 0] | 0;
        $238 = (HEAP32[4237] | 0) + 1 | 0;
        HEAP32[4237] = $238;
        $240 = (HEAP32[4343] | 0) + 1 | 0;
        HEAP32[4343] = $240;
        if (($240 | 0) < (HEAP32[4344] | 0)) {
         $233 = $240;
         $236 = $238;
        } else {
         $$lcssa76 = $238;
         break;
        }
       }
       $244 = HEAP32[4041] | 0;
       $245 = HEAP32[4345] | 0;
       $265 = $$lcssa76;
      } else {
       $244 = $$lcssa53;
       $245 = $$lcssa54;
       $265 = $$lcssa55;
      }
      $246 = HEAP32[$244 + ($245 << 2) >> 2] | 0;
      HEAP32[4343] = $246;
      $249 = HEAP32[$244 + ($245 + 1 << 2) >> 2] | 0;
      HEAP32[4344] = $249;
      if (($246 | 0) < ($249 | 0)) {
       $253 = $246;
       $256 = $265;
       while (1) {
        $251 = HEAP32[4042] | 0;
        HEAP8[$251 + $256 >> 0] = HEAP8[$251 + $253 >> 0] | 0;
        $258 = (HEAP32[4237] | 0) + 1 | 0;
        HEAP32[4237] = $258;
        $260 = (HEAP32[4343] | 0) + 1 | 0;
        HEAP32[4343] = $260;
        if (($260 | 0) < (HEAP32[4344] | 0)) {
         $253 = $260;
         $256 = $258;
        } else break;
       }
      }
      _zpushlitstk(_makestring() | 0, 1);
      STACKTOP = sp;
      return;
     }
     $81 = HEAP32[4041] | 0;
     $82 = $81 + ($6 + 1 << 2) | 0;
     $84 = $81 + ($6 << 2) | 0;
     if ((HEAP32[$82 >> 2] | 0) == (HEAP32[$84 >> 2] | 0)) {
      $88 = (HEAP32[4e3] | 0) + 1 | 0;
      HEAP32[4e3] = $88;
      HEAP32[4237] = HEAP32[$81 + ($88 << 2) >> 2];
      HEAP32[(HEAP32[4361] | 0) + (HEAP32[4360] << 2) >> 2] = $12;
      HEAP32[4360] = (HEAP32[4360] | 0) + 1;
      STACKTOP = sp;
      return;
     }
     $98 = HEAP32[$81 + ($12 + 1 << 2) >> 2] | 0;
     $100 = HEAP32[$81 + ($12 << 2) >> 2] | 0;
     if (($98 | 0) == ($100 | 0)) {
      HEAP32[4360] = (HEAP32[4360] | 0) + 1;
      STACKTOP = sp;
      return;
     }
     $104 = $98 - $100 | 0;
     HEAP32[4366] = $104;
     $107 = (HEAP32[$82 >> 2] | 0) - (HEAP32[$84 >> 2] | 0) | 0;
     HEAP32[4367] = $107;
     $111 = HEAP32[4043] | 0;
     if (($104 + (HEAP32[4237] | 0) + $107 | 0) > ($111 | 0)) {
      $115 = $111;
      while (1) {
       $113 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer4 >> 2] = 1161;
       HEAP32[$vararg_buffer4 + 4 >> 2] = 1;
       HEAP32[$vararg_buffer4 + 8 >> 2] = $115 + 65e3;
       HEAP32[$vararg_buffer4 + 12 >> 2] = $115;
       _fprintf($113, 1023, $vararg_buffer4) | 0;
       HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
       $121 = (HEAP32[4043] | 0) + 65e3 | 0;
       HEAP32[4043] = $121;
       $125 = HEAP32[4367] | 0;
       if (((HEAP32[4366] | 0) + (HEAP32[4237] | 0) + $125 | 0) > ($121 | 0)) $115 = $121; else {
        $$lcssa75 = $125;
        break;
       }
      }
      $129 = HEAP32[4345] | 0;
      $131 = HEAP32[4041] | 0;
      $136 = $$lcssa75;
     } else {
      $129 = $12;
      $131 = $81;
      $136 = $107;
     }
     $132 = HEAP32[$131 + ($129 + 1 << 2) >> 2] | 0;
     HEAP32[4343] = $132;
     $134 = HEAP32[$131 + ($129 << 2) >> 2] | 0;
     HEAP32[4344] = $134;
     $135 = $136 + $132 | 0;
     HEAP32[4348] = $135;
     if (($132 | 0) > ($134 | 0)) {
      $138 = $132 + -1 | 0;
      HEAP32[4343] = $138;
      $139 = $135 + -1 | 0;
      HEAP32[4348] = $139;
      $140 = HEAP32[4042] | 0;
      HEAP8[$140 + $139 >> 0] = HEAP8[$140 + $138 >> 0] | 0;
      $144 = HEAP32[4343] | 0;
      if (($144 | 0) > (HEAP32[4344] | 0)) {
       $148 = $144;
       while (1) {
        $$pre35 = HEAP32[4348] | 0;
        $147 = $148 + -1 | 0;
        HEAP32[4343] = $147;
        $149 = $$pre35 + -1 | 0;
        HEAP32[4348] = $149;
        $150 = HEAP32[4042] | 0;
        HEAP8[$150 + $149 >> 0] = HEAP8[$150 + $147 >> 0] | 0;
        $154 = HEAP32[4343] | 0;
        if (($154 | 0) > (HEAP32[4344] | 0)) $148 = $154; else break;
       }
      }
      $159 = HEAP32[4041] | 0;
     } else $159 = $131;
     $157 = HEAP32[4365] | 0;
     $160 = HEAP32[$159 + ($157 << 2) >> 2] | 0;
     HEAP32[4343] = $160;
     $163 = HEAP32[$159 + ($157 + 1 << 2) >> 2] | 0;
     HEAP32[4344] = $163;
     $$pre37 = HEAP32[4237] | 0;
     if (($160 | 0) < ($163 | 0)) {
      $167 = $160;
      $170 = $$pre37;
      while (1) {
       $165 = HEAP32[4042] | 0;
       HEAP8[$165 + $170 >> 0] = HEAP8[$165 + $167 >> 0] | 0;
       $172 = (HEAP32[4237] | 0) + 1 | 0;
       HEAP32[4237] = $172;
       $174 = (HEAP32[4343] | 0) + 1 | 0;
       HEAP32[4343] = $174;
       if (($174 | 0) < (HEAP32[4344] | 0)) {
        $167 = $174;
        $170 = $172;
       } else {
        $179 = $172;
        break;
       }
      }
     } else $179 = $$pre37;
     HEAP32[4237] = (HEAP32[4366] | 0) + $179;
     _zpushlitstk(_makestring() | 0, 1);
     STACKTOP = sp;
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit($6, $5);
     _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(HEAP32[4301] | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 STACKTOP = sp;
 return;
}

function _bstfunctioncommand() {
 var $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i20 = 0, $$lcssa$i$i3 = 0, $$lcssa183 = 0, $$lcssa185 = 0, $$lcssa190 = 0, $$lcssa192 = 0, $$lcssa194 = 0, $$lcssa196 = 0, $$lcssa198 = 0, $$lcssa199 = 0, $$lcssa200 = 0, $$lcssa201 = 0, $$lcssa205 = 0, $$lcssa207 = 0, $$lcssa209 = 0, $$lcssa214 = 0, $$lcssa216 = 0, $$lcssa218 = 0, $$lcssa220 = 0, $0 = 0, $100 = 0, $101 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $117 = 0, $12 = 0, $122 = 0, $123 = 0, $126 = 0, $132 = 0, $134 = 0, $135 = 0, $14 = 0, $140 = 0, $141 = 0, $143 = 0, $144 = 0, $146 = 0, $151 = 0, $153 = 0, $165 = 0, $167 = 0, $168 = 0, $170 = 0, $175 = 0, $176 = 0, $181 = 0, $182 = 0, $184 = 0, $185 = 0, $187 = 0, $19 = 0, $192 = 0, $194 = 0, $2 = 0, $206 = 0, $208 = 0, $209 = 0, $21 = 0, $211 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $3 = 0, $33 = 0, $35 = 0, $36 = 0, $38 = 0, $43 = 0, $44 = 0, $49 = 0, $50 = 0, $52 = 0, $53 = 0, $55 = 0, $60 = 0, $62 = 0, $75 = 0, $8 = 0, $83 = 0, $84 = 0, $86 = 0, $87 = 0, $9 = 0, $i$0$i = 0, $storemerge = 0, $storemerge29 = 0, $storemerge30 = 0, $storemerge31 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer14 = 0, $vararg_buffer19 = 0, $vararg_buffer24 = 0, $vararg_buffer29 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $vararg_buffer29 = sp + 96 | 0;
 $vararg_buffer24 = sp + 80 | 0;
 $vararg_buffer19 = sp + 64 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $2 = HEAP32[4045] | 0;
 while (1) {
  $0 = HEAP32[3993] | 0;
  $3 = HEAP8[$0 + $2 >> 0] | 0;
  $8 = HEAP32[3999] | 0;
  $9 = ($2 | 0) < ($8 | 0);
  if ((HEAP8[25877 + ($3 & 255) >> 0] | 0) == 1 & $9) {
   $12 = $2;
   while (1) {
    $11 = $12 + 1 | 0;
    HEAP32[4045] = $11;
    $14 = HEAP8[$0 + $11 >> 0] | 0;
    $19 = ($11 | 0) < ($8 | 0);
    if ($19 & (HEAP8[25877 + ($14 & 255) >> 0] | 0) == 1) $12 = $11; else {
     $$lcssa$i$i = $19;
     $21 = $14;
     $216 = $11;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $9;
   $21 = $3;
   $216 = $2;
  }
  if (!($21 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa214 = $0;
   $$lcssa216 = $8;
   $$lcssa218 = $216;
   $$lcssa220 = $21;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 7;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $2 = 0;
 }
 if ((label | 0) == 7) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa220 << 24 >> 24 != 123) {
  $33 = HEAP32[3989] | 0;
  $35 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $35;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($33, 1750, $vararg_buffer) | 0;
  $36 = HEAP32[3990] | 0;
  $38 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $38;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($36, 1750, $vararg_buffer3) | 0;
  _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $43 = $$lcssa214;
 $50 = $$lcssa216;
 $storemerge = $$lcssa218 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge;
  $44 = HEAP8[$43 + $storemerge >> 0] | 0;
  $49 = ($storemerge | 0) < ($50 | 0);
  if ((HEAP8[25877 + ($44 & 255) >> 0] | 0) == 1 & $49) {
   $53 = $storemerge;
   while (1) {
    $52 = $53 + 1 | 0;
    HEAP32[4045] = $52;
    $55 = HEAP8[$43 + $52 >> 0] | 0;
    $60 = ($52 | 0) < ($50 | 0);
    if ($60 & (HEAP8[25877 + ($55 & 255) >> 0] | 0) == 1) $53 = $52; else {
     $$lcssa$i$i3 = $60;
     $217 = $52;
     $62 = $55;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $49;
   $217 = $storemerge;
   $62 = $44;
  }
  if (!($62 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa205 = $50;
   $$lcssa207 = $43;
   $$lcssa209 = $217;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 16;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $43 = HEAP32[3993] | 0;
  $50 = HEAP32[3999] | 0;
  $storemerge = 0;
 }
 if ((label | 0) == 16) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4044] = $$lcssa209;
 $75 = HEAPU8[$$lcssa207 + $$lcssa209 >> 0] | 0;
 L29 : do if ((HEAP8[25877 + $75 >> 0] | 0) == 3) $storemerge29 = 0; else if ((HEAP8[26390 + $75 >> 0] | 0) == 1 & ($$lcssa209 | 0) < ($$lcssa205 | 0)) {
  $84 = $$lcssa209;
  while (1) {
   $83 = $84 + 1 | 0;
   HEAP32[4045] = $83;
   $86 = HEAP8[$$lcssa207 + $83 >> 0] | 0;
   $87 = $86 & 255;
   if (($83 | 0) < ($$lcssa205 | 0) & (HEAP8[26390 + $87 >> 0] | 0) == 1) $84 = $83; else {
    $$lcssa198 = $84;
    $$lcssa199 = $83;
    $$lcssa200 = $86;
    $$lcssa201 = $87;
    break;
   }
  }
  if (($$lcssa199 | 0) == ($$lcssa209 | 0)) $storemerge29 = 0; else {
   if ((HEAP8[25877 + $$lcssa201 >> 0] | 0) == 1 | ($$lcssa199 | 0) == ($$lcssa205 | 0)) $storemerge30 = 3; else switch ($$lcssa200 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge30 = 1;
     break;
    }
   default:
    {
     $storemerge29 = 2;
     break L29;
    }
   }
   HEAP8[26389] = $storemerge30;
   if (($$lcssa198 | 0) < ($$lcssa209 | 0)) {
    $109 = $$lcssa209;
    $110 = $$lcssa199;
    $111 = $$lcssa207;
   } else {
    $i$0$i = $$lcssa209;
    while (1) {
     $100 = $$lcssa207 + $i$0$i | 0;
     $101 = HEAP8[$100 >> 0] | 0;
     if (($101 + -65 & 255) < 26) HEAP8[$100 >> 0] = ($101 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa198 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $109 = HEAP32[4044] | 0;
    $110 = HEAP32[4045] | 0;
    $111 = HEAP32[3993] | 0;
   }
   $112 = _zstrlookup($111, $109, $110 - $109 | 0, 11, 1) | 0;
   HEAP32[4311] = $112;
   if (HEAP32[4241] | 0) {
    $117 = HEAP32[(HEAP32[4145] | 0) + ($112 << 2) >> 2] | 0;
    _zoutpoolstr(HEAP32[3990] | 0, $117);
    _zoutpoolstr(HEAP32[3989] | 0, $117);
    _fwrite(1858, 20, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1858, 20, 1, HEAP32[3990] | 0) | 0;
    _zprintfnclass($112);
    $122 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer8 >> 2] = 1879;
    _fprintf($122, 960, $vararg_buffer8) | 0;
    $123 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer11 >> 2] = 1879;
    _fprintf($123, 960, $vararg_buffer11) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   HEAP8[(HEAP32[4144] | 0) + $112 >> 0] = 1;
   $126 = HEAP32[4311] | 0;
   if ((HEAP32[(HEAP32[4145] | 0) + ($126 << 2) >> 2] | 0) == (HEAP32[4302] | 0)) HEAP32[4303] = $126;
   $134 = HEAP32[4045] | 0;
   while (1) {
    $132 = HEAP32[3993] | 0;
    $135 = HEAP8[$132 + $134 >> 0] | 0;
    $140 = HEAP32[3999] | 0;
    $141 = ($134 | 0) < ($140 | 0);
    if ((HEAP8[25877 + ($135 & 255) >> 0] | 0) == 1 & $141) {
     $144 = $134;
     while (1) {
      $143 = $144 + 1 | 0;
      HEAP32[4045] = $143;
      $146 = HEAP8[$132 + $143 >> 0] | 0;
      $151 = ($143 | 0) < ($140 | 0);
      if ($151 & (HEAP8[25877 + ($146 & 255) >> 0] | 0) == 1) $144 = $143; else {
       $$lcssa$i$i12 = $151;
       $153 = $146;
       $218 = $143;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $141;
     $153 = $135;
     $218 = $134;
    }
    if (!($153 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa190 = $132;
     $$lcssa192 = $140;
     $$lcssa194 = $218;
     $$lcssa196 = $153;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 39;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $134 = 0;
   }
   if ((label | 0) == 39) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa196 << 24 >> 24 != 125) {
    $165 = HEAP32[3989] | 0;
    $167 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer14 >> 2] = 34;
    HEAP32[$vararg_buffer14 + 4 >> 2] = $167;
    HEAP32[$vararg_buffer14 + 8 >> 2] = 1832;
    _fprintf($165, 1750, $vararg_buffer14) | 0;
    $168 = HEAP32[3990] | 0;
    $170 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer19 >> 2] = 34;
    HEAP32[$vararg_buffer19 + 4 >> 2] = $170;
    HEAP32[$vararg_buffer19 + 8 >> 2] = 1832;
    _fprintf($168, 1750, $vararg_buffer19) | 0;
    _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   $175 = $$lcssa190;
   $182 = $$lcssa192;
   $storemerge31 = $$lcssa194 + 1 | 0;
   while (1) {
    HEAP32[4045] = $storemerge31;
    $176 = HEAP8[$175 + $storemerge31 >> 0] | 0;
    $181 = ($storemerge31 | 0) < ($182 | 0);
    if ((HEAP8[25877 + ($176 & 255) >> 0] | 0) == 1 & $181) {
     $185 = $storemerge31;
     while (1) {
      $184 = $185 + 1 | 0;
      HEAP32[4045] = $184;
      $187 = HEAP8[$175 + $184 >> 0] | 0;
      $192 = ($184 | 0) < ($182 | 0);
      if ($192 & (HEAP8[25877 + ($187 & 255) >> 0] | 0) == 1) $185 = $184; else {
       $$lcssa$i$i20 = $192;
       $194 = $187;
       $219 = $184;
       break;
      }
     }
    } else {
     $$lcssa$i$i20 = $181;
     $194 = $176;
     $219 = $storemerge31;
    }
    if (!($194 << 24 >> 24 == 37 | $$lcssa$i$i20 ^ 1)) {
     $$lcssa183 = $219;
     $$lcssa185 = $194;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 48;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    $175 = HEAP32[3993] | 0;
    $182 = HEAP32[3999] | 0;
    $storemerge31 = 0;
   }
   if ((label | 0) == 48) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa185 << 24 >> 24 == 123) {
    HEAP32[4045] = $$lcssa183 + 1;
    _zscanfndef(HEAP32[4311] | 0);
    STACKTOP = sp;
    return;
   } else {
    $206 = HEAP32[3989] | 0;
    $208 = HEAPU8[26256] | 0;
    HEAP32[$vararg_buffer24 >> 2] = 34;
    HEAP32[$vararg_buffer24 + 4 >> 2] = $208;
    HEAP32[$vararg_buffer24 + 8 >> 2] = 1832;
    _fprintf($206, 1750, $vararg_buffer24) | 0;
    $209 = HEAP32[3990] | 0;
    $211 = HEAPU8[26256] | 0;
    HEAP32[$vararg_buffer29 >> 2] = 34;
    HEAP32[$vararg_buffer29 + 4 >> 2] = $211;
    HEAP32[$vararg_buffer29 + 8 >> 2] = 1832;
    _fprintf($209, 1750, $vararg_buffer29) | 0;
    _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
  }
 } else $storemerge29 = 0; while (0);
 HEAP8[26389] = $storemerge29;
 _bstidprint();
 _fwrite(3050, 8, 1, HEAP32[3989] | 0) | 0;
 _fwrite(3050, 8, 1, HEAP32[3990] | 0) | 0;
 _bsterrprintandlookforblankline();
 STACKTOP = sp;
 return;
}

function _dispose_chunk($p, $psize) {
 $p = $p | 0;
 $psize = $psize | 0;
 var $$1 = 0, $$14 = 0, $$2 = 0, $$lcssa = 0, $$pre$phi22Z2D = 0, $$pre$phi24Z2D = 0, $$pre$phiZ2D = 0, $0 = 0, $10 = 0, $100 = 0, $107 = 0, $109 = 0, $11 = 0, $110 = 0, $116 = 0, $124 = 0, $129 = 0, $130 = 0, $133 = 0, $135 = 0, $137 = 0, $15 = 0, $150 = 0, $155 = 0, $157 = 0, $160 = 0, $162 = 0, $165 = 0, $168 = 0, $169 = 0, $170 = 0, $172 = 0, $174 = 0, $175 = 0, $177 = 0, $178 = 0, $18 = 0, $183 = 0, $184 = 0, $193 = 0, $198 = 0, $2 = 0, $20 = 0, $201 = 0, $202 = 0, $208 = 0, $22 = 0, $223 = 0, $226 = 0, $227 = 0, $228 = 0, $232 = 0, $233 = 0, $239 = 0, $244 = 0, $245 = 0, $248 = 0, $250 = 0, $253 = 0, $258 = 0, $264 = 0, $268 = 0, $269 = 0, $287 = 0, $289 = 0, $296 = 0, $297 = 0, $298 = 0, $35 = 0, $40 = 0, $42 = 0, $45 = 0, $47 = 0, $5 = 0, $50 = 0, $53 = 0, $54 = 0, $55 = 0, $57 = 0, $59 = 0, $60 = 0, $62 = 0, $63 = 0, $68 = 0, $69 = 0, $78 = 0, $83 = 0, $86 = 0, $87 = 0, $9 = 0, $93 = 0, $99 = 0, $F17$0 = 0, $I20$0 = 0, $K21$0 = 0, $R$1 = 0, $R$1$lcssa = 0, $R$3 = 0, $R7$1 = 0, $R7$1$lcssa = 0, $R7$3 = 0, $RP$1 = 0, $RP$1$lcssa = 0, $RP9$1 = 0, $RP9$1$lcssa = 0, $T$0 = 0, $T$0$lcssa = 0, $T$0$lcssa30 = 0, label = 0;
 $0 = $p + $psize | 0;
 $2 = HEAP32[$p + 4 >> 2] | 0;
 do if (!($2 & 1)) {
  $5 = HEAP32[$p >> 2] | 0;
  if (!($2 & 3)) return;
  $9 = $p + (0 - $5) | 0;
  $10 = $5 + $psize | 0;
  $11 = HEAP32[5773] | 0;
  if ($9 >>> 0 < $11 >>> 0) _abort();
  if (($9 | 0) == (HEAP32[5774] | 0)) {
   $99 = $0 + 4 | 0;
   $100 = HEAP32[$99 >> 2] | 0;
   if (($100 & 3 | 0) != 3) {
    $$1 = $9;
    $$14 = $10;
    break;
   }
   HEAP32[5771] = $10;
   HEAP32[$99 >> 2] = $100 & -2;
   HEAP32[$9 + 4 >> 2] = $10 | 1;
   HEAP32[$9 + $10 >> 2] = $10;
   return;
  }
  $15 = $5 >>> 3;
  if ($5 >>> 0 < 256) {
   $18 = HEAP32[$9 + 8 >> 2] | 0;
   $20 = HEAP32[$9 + 12 >> 2] | 0;
   $22 = 23116 + ($15 << 1 << 2) | 0;
   if (($18 | 0) != ($22 | 0)) {
    if ($18 >>> 0 < $11 >>> 0) _abort();
    if ((HEAP32[$18 + 12 >> 2] | 0) != ($9 | 0)) _abort();
   }
   if (($20 | 0) == ($18 | 0)) {
    HEAP32[5769] = HEAP32[5769] & ~(1 << $15);
    $$1 = $9;
    $$14 = $10;
    break;
   }
   if (($20 | 0) == ($22 | 0)) $$pre$phi24Z2D = $20 + 8 | 0; else {
    if ($20 >>> 0 < $11 >>> 0) _abort();
    $35 = $20 + 8 | 0;
    if ((HEAP32[$35 >> 2] | 0) == ($9 | 0)) $$pre$phi24Z2D = $35; else _abort();
   }
   HEAP32[$18 + 12 >> 2] = $20;
   HEAP32[$$pre$phi24Z2D >> 2] = $18;
   $$1 = $9;
   $$14 = $10;
   break;
  }
  $40 = HEAP32[$9 + 24 >> 2] | 0;
  $42 = HEAP32[$9 + 12 >> 2] | 0;
  do if (($42 | 0) == ($9 | 0)) {
   $53 = $9 + 16 | 0;
   $54 = $53 + 4 | 0;
   $55 = HEAP32[$54 >> 2] | 0;
   if (!$55) {
    $57 = HEAP32[$53 >> 2] | 0;
    if (!$57) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $57;
     $RP$1 = $53;
    }
   } else {
    $R$1 = $55;
    $RP$1 = $54;
   }
   while (1) {
    $59 = $R$1 + 20 | 0;
    $60 = HEAP32[$59 >> 2] | 0;
    if ($60 | 0) {
     $R$1 = $60;
     $RP$1 = $59;
     continue;
    }
    $62 = $R$1 + 16 | 0;
    $63 = HEAP32[$62 >> 2] | 0;
    if (!$63) {
     $R$1$lcssa = $R$1;
     $RP$1$lcssa = $RP$1;
     break;
    } else {
     $R$1 = $63;
     $RP$1 = $62;
    }
   }
   if ($RP$1$lcssa >>> 0 < $11 >>> 0) _abort(); else {
    HEAP32[$RP$1$lcssa >> 2] = 0;
    $R$3 = $R$1$lcssa;
    break;
   }
  } else {
   $45 = HEAP32[$9 + 8 >> 2] | 0;
   if ($45 >>> 0 < $11 >>> 0) _abort();
   $47 = $45 + 12 | 0;
   if ((HEAP32[$47 >> 2] | 0) != ($9 | 0)) _abort();
   $50 = $42 + 8 | 0;
   if ((HEAP32[$50 >> 2] | 0) == ($9 | 0)) {
    HEAP32[$47 >> 2] = $42;
    HEAP32[$50 >> 2] = $45;
    $R$3 = $42;
    break;
   } else _abort();
  } while (0);
  if (!$40) {
   $$1 = $9;
   $$14 = $10;
  } else {
   $68 = HEAP32[$9 + 28 >> 2] | 0;
   $69 = 23380 + ($68 << 2) | 0;
   if (($9 | 0) == (HEAP32[$69 >> 2] | 0)) {
    HEAP32[$69 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[5770] = HEAP32[5770] & ~(1 << $68);
     $$1 = $9;
     $$14 = $10;
     break;
    }
   } else {
    if ($40 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    $78 = $40 + 16 | 0;
    if ((HEAP32[$78 >> 2] | 0) == ($9 | 0)) HEAP32[$78 >> 2] = $R$3; else HEAP32[$40 + 20 >> 2] = $R$3;
    if (!$R$3) {
     $$1 = $9;
     $$14 = $10;
     break;
    }
   }
   $83 = HEAP32[5773] | 0;
   if ($R$3 >>> 0 < $83 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $40;
   $86 = $9 + 16 | 0;
   $87 = HEAP32[$86 >> 2] | 0;
   do if ($87 | 0) if ($87 >>> 0 < $83 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $87;
    HEAP32[$87 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $93 = HEAP32[$86 + 4 >> 2] | 0;
   if (!$93) {
    $$1 = $9;
    $$14 = $10;
   } else if ($93 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $93;
    HEAP32[$93 + 24 >> 2] = $R$3;
    $$1 = $9;
    $$14 = $10;
    break;
   }
  }
 } else {
  $$1 = $p;
  $$14 = $psize;
 } while (0);
 $107 = HEAP32[5773] | 0;
 if ($0 >>> 0 < $107 >>> 0) _abort();
 $109 = $0 + 4 | 0;
 $110 = HEAP32[$109 >> 2] | 0;
 if (!($110 & 2)) {
  if (($0 | 0) == (HEAP32[5775] | 0)) {
   $116 = (HEAP32[5772] | 0) + $$14 | 0;
   HEAP32[5772] = $116;
   HEAP32[5775] = $$1;
   HEAP32[$$1 + 4 >> 2] = $116 | 1;
   if (($$1 | 0) != (HEAP32[5774] | 0)) return;
   HEAP32[5774] = 0;
   HEAP32[5771] = 0;
   return;
  }
  if (($0 | 0) == (HEAP32[5774] | 0)) {
   $124 = (HEAP32[5771] | 0) + $$14 | 0;
   HEAP32[5771] = $124;
   HEAP32[5774] = $$1;
   HEAP32[$$1 + 4 >> 2] = $124 | 1;
   HEAP32[$$1 + $124 >> 2] = $124;
   return;
  }
  $129 = ($110 & -8) + $$14 | 0;
  $130 = $110 >>> 3;
  do if ($110 >>> 0 < 256) {
   $133 = HEAP32[$0 + 8 >> 2] | 0;
   $135 = HEAP32[$0 + 12 >> 2] | 0;
   $137 = 23116 + ($130 << 1 << 2) | 0;
   if (($133 | 0) != ($137 | 0)) {
    if ($133 >>> 0 < $107 >>> 0) _abort();
    if ((HEAP32[$133 + 12 >> 2] | 0) != ($0 | 0)) _abort();
   }
   if (($135 | 0) == ($133 | 0)) {
    HEAP32[5769] = HEAP32[5769] & ~(1 << $130);
    break;
   }
   if (($135 | 0) == ($137 | 0)) $$pre$phi22Z2D = $135 + 8 | 0; else {
    if ($135 >>> 0 < $107 >>> 0) _abort();
    $150 = $135 + 8 | 0;
    if ((HEAP32[$150 >> 2] | 0) == ($0 | 0)) $$pre$phi22Z2D = $150; else _abort();
   }
   HEAP32[$133 + 12 >> 2] = $135;
   HEAP32[$$pre$phi22Z2D >> 2] = $133;
  } else {
   $155 = HEAP32[$0 + 24 >> 2] | 0;
   $157 = HEAP32[$0 + 12 >> 2] | 0;
   do if (($157 | 0) == ($0 | 0)) {
    $168 = $0 + 16 | 0;
    $169 = $168 + 4 | 0;
    $170 = HEAP32[$169 >> 2] | 0;
    if (!$170) {
     $172 = HEAP32[$168 >> 2] | 0;
     if (!$172) {
      $R7$3 = 0;
      break;
     } else {
      $R7$1 = $172;
      $RP9$1 = $168;
     }
    } else {
     $R7$1 = $170;
     $RP9$1 = $169;
    }
    while (1) {
     $174 = $R7$1 + 20 | 0;
     $175 = HEAP32[$174 >> 2] | 0;
     if ($175 | 0) {
      $R7$1 = $175;
      $RP9$1 = $174;
      continue;
     }
     $177 = $R7$1 + 16 | 0;
     $178 = HEAP32[$177 >> 2] | 0;
     if (!$178) {
      $R7$1$lcssa = $R7$1;
      $RP9$1$lcssa = $RP9$1;
      break;
     } else {
      $R7$1 = $178;
      $RP9$1 = $177;
     }
    }
    if ($RP9$1$lcssa >>> 0 < $107 >>> 0) _abort(); else {
     HEAP32[$RP9$1$lcssa >> 2] = 0;
     $R7$3 = $R7$1$lcssa;
     break;
    }
   } else {
    $160 = HEAP32[$0 + 8 >> 2] | 0;
    if ($160 >>> 0 < $107 >>> 0) _abort();
    $162 = $160 + 12 | 0;
    if ((HEAP32[$162 >> 2] | 0) != ($0 | 0)) _abort();
    $165 = $157 + 8 | 0;
    if ((HEAP32[$165 >> 2] | 0) == ($0 | 0)) {
     HEAP32[$162 >> 2] = $157;
     HEAP32[$165 >> 2] = $160;
     $R7$3 = $157;
     break;
    } else _abort();
   } while (0);
   if ($155 | 0) {
    $183 = HEAP32[$0 + 28 >> 2] | 0;
    $184 = 23380 + ($183 << 2) | 0;
    if (($0 | 0) == (HEAP32[$184 >> 2] | 0)) {
     HEAP32[$184 >> 2] = $R7$3;
     if (!$R7$3) {
      HEAP32[5770] = HEAP32[5770] & ~(1 << $183);
      break;
     }
    } else {
     if ($155 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
     $193 = $155 + 16 | 0;
     if ((HEAP32[$193 >> 2] | 0) == ($0 | 0)) HEAP32[$193 >> 2] = $R7$3; else HEAP32[$155 + 20 >> 2] = $R7$3;
     if (!$R7$3) break;
    }
    $198 = HEAP32[5773] | 0;
    if ($R7$3 >>> 0 < $198 >>> 0) _abort();
    HEAP32[$R7$3 + 24 >> 2] = $155;
    $201 = $0 + 16 | 0;
    $202 = HEAP32[$201 >> 2] | 0;
    do if ($202 | 0) if ($202 >>> 0 < $198 >>> 0) _abort(); else {
     HEAP32[$R7$3 + 16 >> 2] = $202;
     HEAP32[$202 + 24 >> 2] = $R7$3;
     break;
    } while (0);
    $208 = HEAP32[$201 + 4 >> 2] | 0;
    if ($208 | 0) if ($208 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
     HEAP32[$R7$3 + 20 >> 2] = $208;
     HEAP32[$208 + 24 >> 2] = $R7$3;
     break;
    }
   }
  } while (0);
  HEAP32[$$1 + 4 >> 2] = $129 | 1;
  HEAP32[$$1 + $129 >> 2] = $129;
  if (($$1 | 0) == (HEAP32[5774] | 0)) {
   HEAP32[5771] = $129;
   return;
  } else $$2 = $129;
 } else {
  HEAP32[$109 >> 2] = $110 & -2;
  HEAP32[$$1 + 4 >> 2] = $$14 | 1;
  HEAP32[$$1 + $$14 >> 2] = $$14;
  $$2 = $$14;
 }
 $223 = $$2 >>> 3;
 if ($$2 >>> 0 < 256) {
  $226 = 23116 + ($223 << 1 << 2) | 0;
  $227 = HEAP32[5769] | 0;
  $228 = 1 << $223;
  if (!($227 & $228)) {
   HEAP32[5769] = $227 | $228;
   $$pre$phiZ2D = $226 + 8 | 0;
   $F17$0 = $226;
  } else {
   $232 = $226 + 8 | 0;
   $233 = HEAP32[$232 >> 2] | 0;
   if ($233 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
    $$pre$phiZ2D = $232;
    $F17$0 = $233;
   }
  }
  HEAP32[$$pre$phiZ2D >> 2] = $$1;
  HEAP32[$F17$0 + 12 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $F17$0;
  HEAP32[$$1 + 12 >> 2] = $226;
  return;
 }
 $239 = $$2 >>> 8;
 if (!$239) $I20$0 = 0; else if ($$2 >>> 0 > 16777215) $I20$0 = 31; else {
  $244 = ($239 + 1048320 | 0) >>> 16 & 8;
  $245 = $239 << $244;
  $248 = ($245 + 520192 | 0) >>> 16 & 4;
  $250 = $245 << $248;
  $253 = ($250 + 245760 | 0) >>> 16 & 2;
  $258 = 14 - ($248 | $244 | $253) + ($250 << $253 >>> 15) | 0;
  $I20$0 = $$2 >>> ($258 + 7 | 0) & 1 | $258 << 1;
 }
 $264 = 23380 + ($I20$0 << 2) | 0;
 HEAP32[$$1 + 28 >> 2] = $I20$0;
 HEAP32[$$1 + 20 >> 2] = 0;
 HEAP32[$$1 + 16 >> 2] = 0;
 $268 = HEAP32[5770] | 0;
 $269 = 1 << $I20$0;
 if (!($268 & $269)) {
  HEAP32[5770] = $268 | $269;
  HEAP32[$264 >> 2] = $$1;
  HEAP32[$$1 + 24 >> 2] = $264;
  HEAP32[$$1 + 12 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $$1;
  return;
 }
 $K21$0 = $$2 << (($I20$0 | 0) == 31 ? 0 : 25 - ($I20$0 >>> 1) | 0);
 $T$0 = HEAP32[$264 >> 2] | 0;
 while (1) {
  if ((HEAP32[$T$0 + 4 >> 2] & -8 | 0) == ($$2 | 0)) {
   $T$0$lcssa = $T$0;
   label = 127;
   break;
  }
  $287 = $T$0 + 16 + ($K21$0 >>> 31 << 2) | 0;
  $289 = HEAP32[$287 >> 2] | 0;
  if (!$289) {
   $$lcssa = $287;
   $T$0$lcssa30 = $T$0;
   label = 124;
   break;
  } else {
   $K21$0 = $K21$0 << 1;
   $T$0 = $289;
  }
 }
 if ((label | 0) == 124) {
  if ($$lcssa >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
  HEAP32[$$lcssa >> 2] = $$1;
  HEAP32[$$1 + 24 >> 2] = $T$0$lcssa30;
  HEAP32[$$1 + 12 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $$1;
  return;
 } else if ((label | 0) == 127) {
  $296 = $T$0$lcssa + 8 | 0;
  $297 = HEAP32[$296 >> 2] | 0;
  $298 = HEAP32[5773] | 0;
  if (!($297 >>> 0 >= $298 >>> 0 & $T$0$lcssa >>> 0 >= $298 >>> 0)) _abort();
  HEAP32[$297 + 12 >> 2] = $$1;
  HEAP32[$296 >> 2] = $$1;
  HEAP32[$$1 + 8 >> 2] = $297;
  HEAP32[$$1 + 12 >> 2] = $T$0$lcssa;
  HEAP32[$$1 + 24 >> 2] = 0;
  return;
 }
}

function _xwidth() {
 var $$lcssa = 0, $$lcssa44 = 0, $0 = 0, $10 = 0, $102 = 0, $108 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $124 = 0, $125 = 0, $128 = 0, $134 = 0, $136 = 0, $138 = 0, $14 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $153 = 0, $155 = 0, $157 = 0, $158 = 0, $160 = 0, $164 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $172 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $20 = 0, $24 = 0, $26 = 0, $28 = 0, $31 = 0, $33 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $40 = 0, $42 = 0, $46 = 0, $48 = 0, $5 = 0, $51 = 0, $52 = 0, $55 = 0, $61 = 0, $63 = 0, $66 = 0, $67 = 0, $69 = 0, $7 = 0, $77 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $86 = 0, $90 = 0, $92 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$01$i$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa43 = 0, label = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   HEAP32[4333] = 0;
   $4 = HEAP32[4345] | 0;
   $5 = HEAP32[4041] | 0;
   $7 = HEAP32[$5 + ($4 << 2) >> 2] | 0;
   HEAP32[4238] = $7;
   $10 = HEAP32[$5 + ($4 + 1 << 2) >> 2] | 0;
   HEAP32[4239] = $10;
   if (($10 - $7 | 0) > (HEAP32[3992] | 0)) {
    _bufferoverflow();
    $14 = HEAP32[4333] | 0;
    $15 = HEAP32[4238] | 0;
    $17 = HEAP32[4239] | 0;
   } else {
    $14 = 0;
    $15 = $7;
    $17 = $10;
   }
   HEAP32[4251] = $14;
   if (($15 | 0) < ($17 | 0)) {
    $20 = $15;
    $24 = $14;
    while (1) {
     HEAP8[(HEAP32[3995] | 0) + $24 >> 0] = HEAP8[(HEAP32[4042] | 0) + $20 >> 0] | 0;
     $26 = (HEAP32[4251] | 0) + 1 | 0;
     HEAP32[4251] = $26;
     $28 = (HEAP32[4238] | 0) + 1 | 0;
     HEAP32[4238] = $28;
     if (($28 | 0) < (HEAP32[4239] | 0)) {
      $20 = $28;
      $24 = $26;
     } else {
      $31 = $26;
      break;
     }
    }
   } else $31 = $14;
   HEAP32[4333] = $31;
   HEAP32[4387] = 0;
   HEAP32[4330] = 0;
   HEAP32[4251] = 0;
   L11 : do if (($31 | 0) > 0) {
    $158 = 0;
    $35 = 0;
    $42 = $31;
    while (1) {
     $33 = HEAP32[3995] | 0;
     $36 = HEAP8[$33 + $35 >> 0] | 0;
     L14 : do switch ($36 << 24 >> 24) {
     case 123:
      {
       $37 = HEAP32[4330] | 0;
       $38 = $37 + 1 | 0;
       HEAP32[4330] = $38;
       if (!$37) {
        $40 = $35 + 1 | 0;
        if (($40 | 0) < ($42 | 0)) {
         if ((HEAP8[$33 + $40 >> 0] | 0) != 92) {
          $157 = (HEAP32[4511] | 0) + $158 | 0;
          HEAP32[4387] = $157;
          $170 = $35;
          $172 = $42;
          $178 = $157;
          break L14;
         }
         HEAP32[4251] = $40;
         $114 = $158;
         $136 = $38;
         $52 = $40;
         while (1) {
          $51 = $52 + 1 | 0;
          HEAP32[4251] = $51;
          HEAP32[4323] = $51;
          L25 : do if (($51 | 0) < ($42 | 0)) {
           $55 = $51;
           while (1) {
            if ((HEAP8[25877 + (HEAPU8[$33 + $55 >> 0] | 0) >> 0] | 0) != 2) {
             $63 = $55;
             break L25;
            }
            $61 = $55 + 1 | 0;
            HEAP32[4251] = $61;
            if (($61 | 0) < ($42 | 0)) $55 = $61; else {
             $63 = $61;
             break;
            }
           }
          } else $63 = $51; while (0);
          L30 : do if (($63 | 0) < ($42 | 0) & ($63 | 0) == ($51 | 0)) {
           $66 = $52 + 2 | 0;
           HEAP32[4251] = $66;
           $125 = $66;
           $176 = $114;
          } else {
           $67 = $63 - $51 | 0;
           if (($67 | 0) > 0) {
            $69 = HEAP32[4240] | 0;
            $h$06$i = 0;
            $k$07$i = $51;
            while (1) {
             $h$1$i = (HEAPU8[$33 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
             while (1) if (($h$1$i | 0) < ($69 | 0)) {
              $h$1$i$lcssa = $h$1$i;
              break;
             } else $h$1$i = $h$1$i - $69 | 0;
             $77 = $k$07$i + 1 | 0;
             if (($77 | 0) < ($63 | 0)) {
              $h$06$i = $h$1$i$lcssa;
              $k$07$i = $77;
             } else {
              $h$0$lcssa$i = $h$1$i$lcssa;
              break;
             }
            }
           } else $h$0$lcssa$i = 0;
           HEAP32[4241] = 0;
           $80 = HEAP32[4145] | 0;
           $81 = HEAP32[4041] | 0;
           $82 = HEAP32[4042] | 0;
           $83 = HEAP32[4242] | 0;
           $84 = HEAP32[4243] | 0;
           $p$0$i = $h$0$lcssa$i + 1 | 0;
           L41 : while (1) {
            $86 = HEAP32[$80 + ($p$0$i << 2) >> 2] | 0;
            L43 : do if (($86 | 0) > 0) {
             $90 = HEAP32[$81 + ($86 + 1 << 2) >> 2] | 0;
             $92 = HEAP32[$81 + ($86 << 2) >> 2] | 0;
             if (($90 - $92 | 0) == ($67 | 0)) {
              if (($90 | 0) > ($92 | 0)) {
               $i$01$i$i = $51;
               $j$02$i$i = $92;
               while (1) {
                if ((HEAP8[$82 + $j$02$i$i >> 0] | 0) != (HEAP8[$33 + $i$01$i$i >> 0] | 0)) break L43;
                $102 = $j$02$i$i + 1 | 0;
                if (($102 | 0) < ($90 | 0)) {
                 $i$01$i$i = $i$01$i$i + 1 | 0;
                 $j$02$i$i = $102;
                } else break;
               }
              }
              if ((HEAP8[$83 + $p$0$i >> 0] | 0) == 14) {
               $p$0$i$lcssa = $p$0$i;
               break L41;
              }
             }
            } while (0);
            $108 = HEAP32[$84 + ($p$0$i << 2) >> 2] | 0;
            if (!$108) {
             $p$0$i$lcssa43 = $p$0$i;
             label = 33;
             break;
            } else $p$0$i = $108;
           }
           if ((label | 0) == 33) {
            label = 0;
            HEAP32[4338] = $p$0$i$lcssa43;
            $125 = $63;
            $176 = $114;
            break;
           }
           HEAP32[4241] = 1;
           HEAP32[4338] = $p$0$i$lcssa;
           switch (HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0) {
           case 12:
            {
             $113 = $114 + 500 | 0;
             HEAP32[4387] = $113;
             $125 = $63;
             $176 = $113;
             break L30;
             break;
            }
           case 4:
            {
             $115 = $114 + 722 | 0;
             HEAP32[4387] = $115;
             $125 = $63;
             $176 = $115;
             break L30;
             break;
            }
           case 2:
            {
             $116 = $114 + 778 | 0;
             HEAP32[4387] = $116;
             $125 = $63;
             $176 = $116;
             break L30;
             break;
            }
           case 5:
            {
             $117 = $114 + 903 | 0;
             HEAP32[4387] = $117;
             $125 = $63;
             $176 = $117;
             break L30;
             break;
            }
           case 3:
            {
             $118 = $114 + 1014 | 0;
             HEAP32[4387] = $118;
             $125 = $63;
             $176 = $118;
             break L30;
             break;
            }
           default:
            {
             $124 = (HEAP32[17552 + (HEAPU8[$33 + $51 >> 0] << 2) >> 2] | 0) + $114 | 0;
             HEAP32[4387] = $124;
             $125 = $63;
             $176 = $124;
             break L30;
            }
           }
          } while (0);
          L63 : do if (($125 | 0) < ($42 | 0)) {
           $128 = $125;
           while (1) {
            if ((HEAP8[25877 + (HEAPU8[$33 + $128 >> 0] | 0) >> 0] | 0) != 1) {
             $134 = $128;
             break L63;
            }
            $138 = $128 + 1 | 0;
            HEAP32[4251] = $138;
            if (($138 | 0) < ($42 | 0)) $128 = $138; else {
             $134 = $138;
             break;
            }
           }
          } else $134 = $125; while (0);
          L68 : do if (($134 | 0) < ($42 | 0) & ($136 | 0) > 0) {
           $141 = $134;
           $144 = $136;
           $150 = $176;
           while (1) {
            $142 = HEAP8[$33 + $141 >> 0] | 0;
            switch ($142 << 24 >> 24) {
            case 92:
             {
              $175 = $150;
              $46 = $141;
              $48 = $144;
              break L68;
              break;
             }
            case 125:
             {
              $143 = $144 + -1 | 0;
              HEAP32[4330] = $143;
              $153 = $143;
              $177 = $150;
              break;
             }
            case 123:
             {
              $145 = $144 + 1 | 0;
              HEAP32[4330] = $145;
              $153 = $145;
              $177 = $150;
              break;
             }
            default:
             {
              $149 = (HEAP32[17552 + (($142 & 255) << 2) >> 2] | 0) + $150 | 0;
              HEAP32[4387] = $149;
              $153 = $144;
              $177 = $149;
             }
            }
            $151 = $141 + 1 | 0;
            HEAP32[4251] = $151;
            if (($151 | 0) < ($42 | 0) & ($153 | 0) > 0) {
             $141 = $151;
             $144 = $153;
             $150 = $177;
            } else {
             $175 = $177;
             $46 = $151;
             $48 = $153;
             break L68;
            }
           }
          } else {
           $175 = $176;
           $46 = $134;
           $48 = $136;
          } while (0);
          if (($46 | 0) < ($42 | 0) & ($48 | 0) > 0) {
           $114 = $175;
           $136 = $48;
           $52 = $46;
          } else {
           $$lcssa = $46;
           $$lcssa44 = $175;
           break;
          }
         }
         $155 = $$lcssa + -1 | 0;
         HEAP32[4251] = $155;
         $170 = $155;
         $172 = $42;
         $178 = $$lcssa44;
         break L14;
        }
       }
       $160 = (HEAP32[4511] | 0) + $158 | 0;
       HEAP32[4387] = $160;
       $170 = $35;
       $172 = $42;
       $178 = $160;
       break;
      }
     case 125:
      {
       _zdecrbracelevel(HEAP32[4345] | 0);
       $164 = (HEAP32[4513] | 0) + (HEAP32[4387] | 0) | 0;
       HEAP32[4387] = $164;
       $170 = HEAP32[4251] | 0;
       $172 = HEAP32[4333] | 0;
       $178 = $164;
       break;
      }
     default:
      {
       $168 = (HEAP32[17552 + (($36 & 255) << 2) >> 2] | 0) + $158 | 0;
       HEAP32[4387] = $168;
       $170 = $35;
       $172 = $42;
       $178 = $168;
      }
     } while (0);
     $169 = $170 + 1 | 0;
     HEAP32[4251] = $169;
     if (($169 | 0) < ($172 | 0)) {
      $158 = $178;
      $35 = $169;
      $42 = $172;
     } else break L11;
    }
   } while (0);
   _zcheckbracelevel(HEAP32[4345] | 0);
   _zpushlitstk(HEAP32[4387] | 0, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _bststringscommand() {
 var $$lcssa = 0, $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i3 = 0, $$lcssa174 = 0, $$lcssa175 = 0, $$lcssa176 = 0, $$lcssa180 = 0, $$lcssa182 = 0, $$lcssa184 = 0, $$lcssa186 = 0, $$lcssa188 = 0, $$lcssa194 = 0, $$lcssa196 = 0, $$lcssa198 = 0, $$lcssa200 = 0, $$lcssa205 = 0, $$lcssa207 = 0, $$lcssa209 = 0, $$lcssa211 = 0, $$lcssa28 = 0, $0 = 0, $105 = 0, $106 = 0, $11 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $12 = 0, $122 = 0, $127 = 0, $128 = 0, $135 = 0, $138 = 0, $14 = 0, $145 = 0, $147 = 0, $148 = 0, $157 = 0, $158 = 0, $164 = 0, $166 = 0, $167 = 0, $169 = 0, $174 = 0, $178 = 0, $179 = 0, $181 = 0, $182 = 0, $187 = 0, $188 = 0, $19 = 0, $190 = 0, $191 = 0, $193 = 0, $198 = 0, $2 = 0, $200 = 0, $21 = 0, $212 = 0, $213 = 0, $214 = 0, $3 = 0, $33 = 0, $35 = 0, $36 = 0, $38 = 0, $43 = 0, $44 = 0, $49 = 0, $50 = 0, $52 = 0, $53 = 0, $55 = 0, $60 = 0, $62 = 0, $75 = 0, $77 = 0, $79 = 0, $8 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $91 = 0, $92 = 0, $i$0$i = 0, $storemerge21 = 0, $storemerge22 = 0, $storemerge23 = 0, $storemerge38 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer14 = 0, $vararg_buffer20 = 0, $vararg_buffer26 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $vararg_buffer26 = sp + 80 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $2 = HEAP32[4045] | 0;
 while (1) {
  $0 = HEAP32[3993] | 0;
  $3 = HEAP8[$0 + $2 >> 0] | 0;
  $8 = HEAP32[3999] | 0;
  $9 = ($2 | 0) < ($8 | 0);
  if ((HEAP8[25877 + ($3 & 255) >> 0] | 0) == 1 & $9) {
   $12 = $2;
   while (1) {
    $11 = $12 + 1 | 0;
    HEAP32[4045] = $11;
    $14 = HEAP8[$0 + $11 >> 0] | 0;
    $19 = ($11 | 0) < ($8 | 0);
    if ($19 & (HEAP8[25877 + ($14 & 255) >> 0] | 0) == 1) $12 = $11; else {
     $$lcssa$i$i = $19;
     $21 = $14;
     $212 = $11;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $9;
   $21 = $3;
   $212 = $2;
  }
  if (!($21 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa205 = $0;
   $$lcssa207 = $8;
   $$lcssa209 = $212;
   $$lcssa211 = $21;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 7;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $2 = 0;
 }
 if ((label | 0) == 7) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(5509, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5509, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa211 << 24 >> 24 != 123) {
  $33 = HEAP32[3989] | 0;
  $35 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $35;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($33, 1750, $vararg_buffer) | 0;
  $36 = HEAP32[3990] | 0;
  $38 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $38;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($36, 1750, $vararg_buffer3) | 0;
  _fwrite(5509, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5509, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $43 = $$lcssa205;
 $50 = $$lcssa207;
 $storemerge21 = $$lcssa209 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge21;
  $44 = HEAP8[$43 + $storemerge21 >> 0] | 0;
  $49 = ($storemerge21 | 0) < ($50 | 0);
  if ((HEAP8[25877 + ($44 & 255) >> 0] | 0) == 1 & $49) {
   $53 = $storemerge21;
   while (1) {
    $52 = $53 + 1 | 0;
    HEAP32[4045] = $52;
    $55 = HEAP8[$43 + $52 >> 0] | 0;
    $60 = ($52 | 0) < ($50 | 0);
    if ($60 & (HEAP8[25877 + ($55 & 255) >> 0] | 0) == 1) $53 = $52; else {
     $$lcssa$i$i3 = $60;
     $213 = $52;
     $62 = $55;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $49;
   $213 = $storemerge21;
   $62 = $44;
  }
  if (!($62 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa194 = $50;
   $$lcssa196 = $43;
   $$lcssa198 = $213;
   $$lcssa200 = $62;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 17;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $43 = HEAP32[3993] | 0;
  $50 = HEAP32[3999] | 0;
  $storemerge21 = 0;
 }
 if ((label | 0) == 17) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(5509, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5509, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 L29 : do if ($$lcssa200 << 24 >> 24 == 125) $$lcssa28 = $$lcssa198; else {
  $75 = $$lcssa198;
  $77 = $$lcssa196;
  $87 = $$lcssa194;
  L30 : while (1) {
   HEAP32[4044] = $75;
   $79 = HEAPU8[$77 + $75 >> 0] | 0;
   if ((HEAP8[25877 + $79 >> 0] | 0) == 3) {
    $storemerge22 = 0;
    label = 25;
    break;
   }
   if ((HEAP8[26390 + $79 >> 0] | 0) == 1 & ($75 | 0) < ($87 | 0)) $89 = $75; else {
    $storemerge22 = 0;
    label = 25;
    break;
   }
   while (1) {
    $88 = $89 + 1 | 0;
    HEAP32[4045] = $88;
    $91 = HEAP8[$77 + $88 >> 0] | 0;
    $92 = $91 & 255;
    if (($88 | 0) < ($87 | 0) & (HEAP8[26390 + $92 >> 0] | 0) == 1) $89 = $88; else {
     $$lcssa = $89;
     $$lcssa174 = $88;
     $$lcssa175 = $91;
     $$lcssa176 = $92;
     break;
    }
   }
   if (($$lcssa174 | 0) == ($75 | 0)) {
    $storemerge22 = 0;
    label = 25;
    break;
   }
   if ((HEAP8[25877 + $$lcssa176 >> 0] | 0) == 1 | ($$lcssa174 | 0) == ($87 | 0)) $storemerge23 = 3; else switch ($$lcssa175 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge23 = 1;
     break;
    }
   default:
    {
     $storemerge22 = 2;
     label = 25;
     break L30;
    }
   }
   HEAP8[26389] = $storemerge23;
   if (($$lcssa | 0) < ($75 | 0)) {
    $114 = $75;
    $115 = $$lcssa174;
    $116 = $77;
   } else {
    $i$0$i = $75;
    while (1) {
     $105 = $77 + $i$0$i | 0;
     $106 = HEAP8[$105 >> 0] | 0;
     if (($106 + -65 & 255) < 26) HEAP8[$105 >> 0] = ($106 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $114 = HEAP32[4044] | 0;
    $115 = HEAP32[4045] | 0;
    $116 = HEAP32[3993] | 0;
   }
   $117 = _zstrlookup($116, $114, $115 - $114 | 0, 11, 1) | 0;
   HEAP32[4310] = $117;
   if (HEAP32[4241] | 0) {
    $$lcssa188 = $117;
    label = 32;
    break;
   }
   HEAP8[(HEAP32[4144] | 0) + $117 >> 0] = 8;
   HEAP32[(HEAP32[4249] | 0) + (HEAP32[4310] << 2) >> 2] = HEAP32[4693];
   $135 = HEAP32[4693] | 0;
   if (($135 | 0) == (HEAP32[4694] | 0)) {
    $138 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer14 >> 2] = 5517;
    HEAP32[$vararg_buffer14 + 4 >> 2] = 4;
    HEAP32[$vararg_buffer14 + 8 >> 2] = $135 + 10;
    HEAP32[$vararg_buffer14 + 12 >> 2] = $135;
    _fprintf($138, 1023, $vararg_buffer14) | 0;
    HEAP32[4373] = _xrealloc(HEAP32[4373] | 0, (HEAP32[4694] << 2) + 44 | 0) | 0;
    $145 = HEAP32[3989] | 0;
    $147 = (HEAP32[4307] | 0) + 1 | 0;
    $148 = HEAP32[4694] | 0;
    HEAP32[$vararg_buffer20 >> 2] = 5529;
    HEAP32[$vararg_buffer20 + 4 >> 2] = $147;
    HEAP32[$vararg_buffer20 + 8 >> 2] = $148 + 10;
    HEAP32[$vararg_buffer20 + 12 >> 2] = $148;
    _fprintf($145, 1023, $vararg_buffer20) | 0;
    HEAP32[4375] = _xrealloc(HEAP32[4375] | 0, Math_imul((HEAP32[4307] | 0) + 1 | 0, (HEAP32[4694] | 0) + 10 | 0) | 0) | 0;
    $157 = HEAP32[3989] | 0;
    $158 = HEAP32[4694] | 0;
    HEAP32[$vararg_buffer26 >> 2] = 5541;
    HEAP32[$vararg_buffer26 + 4 >> 2] = 4;
    HEAP32[$vararg_buffer26 + 8 >> 2] = $158 + 10;
    HEAP32[$vararg_buffer26 + 12 >> 2] = $158;
    _fprintf($157, 1023, $vararg_buffer26) | 0;
    $164 = _xrealloc(HEAP32[4376] | 0, (HEAP32[4694] << 2) + 44 | 0) | 0;
    HEAP32[4376] = $164;
    $166 = (HEAP32[4694] | 0) + 10 | 0;
    HEAP32[4694] = $166;
    $167 = HEAP32[4693] | 0;
    HEAP32[4372] = $167;
    if (($167 | 0) < ($166 | 0)) {
     $169 = HEAP32[4373] | 0;
     $storemerge38 = $167;
     while (1) {
      HEAP32[$169 + ($storemerge38 << 2) >> 2] = 0;
      HEAP32[$164 + (HEAP32[4372] << 2) >> 2] = 0;
      $174 = (HEAP32[4372] | 0) + 1 | 0;
      HEAP32[4372] = $174;
      if (($174 | 0) < (HEAP32[4694] | 0)) $storemerge38 = $174; else break;
     }
     $178 = HEAP32[4693] | 0;
    } else $178 = $167;
   } else $178 = $135;
   HEAP32[4693] = $178 + 1;
   $181 = HEAP32[4045] | 0;
   while (1) {
    $179 = HEAP32[3993] | 0;
    $182 = HEAP8[$179 + $181 >> 0] | 0;
    $187 = HEAP32[3999] | 0;
    $188 = ($181 | 0) < ($187 | 0);
    if ((HEAP8[25877 + ($182 & 255) >> 0] | 0) == 1 & $188) {
     $191 = $181;
     while (1) {
      $190 = $191 + 1 | 0;
      HEAP32[4045] = $190;
      $193 = HEAP8[$179 + $190 >> 0] | 0;
      $198 = ($190 | 0) < ($187 | 0);
      if ($198 & (HEAP8[25877 + ($193 & 255) >> 0] | 0) == 1) $191 = $190; else {
       $$lcssa$i$i12 = $198;
       $200 = $193;
       $214 = $190;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $188;
     $200 = $182;
     $214 = $181;
    }
    if (!($200 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa180 = $179;
     $$lcssa182 = $187;
     $$lcssa184 = $214;
     $$lcssa186 = $200;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 44;
     break L30;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $181 = 0;
   }
   if ($$lcssa186 << 24 >> 24 == 125) {
    $$lcssa28 = $$lcssa184;
    break L29;
   } else {
    $75 = $$lcssa184;
    $77 = $$lcssa180;
    $87 = $$lcssa182;
   }
  }
  if ((label | 0) == 25) {
   HEAP8[26389] = $storemerge22;
   _bstidprint();
   _fwrite(5509, 7, 1, HEAP32[3989] | 0) | 0;
   _fwrite(5509, 7, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 32) {
   $122 = HEAP32[(HEAP32[4145] | 0) + ($$lcssa188 << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $122);
   _zoutpoolstr(HEAP32[3989] | 0, $122);
   _fwrite(1858, 20, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1858, 20, 1, HEAP32[3990] | 0) | 0;
   _zprintfnclass($$lcssa188);
   $127 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer8 >> 2] = 1879;
   _fprintf($127, 960, $vararg_buffer8) | 0;
   $128 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer11 >> 2] = 1879;
   _fprintf($128, 960, $vararg_buffer11) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 44) {
   _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
   _fwrite(5509, 7, 1, HEAP32[3989] | 0) | 0;
   _fwrite(5509, 7, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  }
 } while (0);
 HEAP32[4045] = $$lcssa28 + 1;
 STACKTOP = sp;
 return;
}

function _auxinputcommand() {
 var $$lcssa = 0, $$lcssa1$i = 0, $$lcssa16 = 0, $$lcssa17 = 0, $$lcssa28 = 0, $$pre3$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $107 = 0, $109 = 0, $117 = 0, $118 = 0, $12 = 0, $121 = 0, $127 = 0, $128 = 0, $130 = 0, $131 = 0, $133 = 0, $14 = 0, $141 = 0, $144 = 0, $148 = 0, $151 = 0, $160 = 0, $168 = 0, $169 = 0, $176 = 0, $177 = 0, $179 = 0, $181 = 0, $188 = 0, $189 = 0, $190 = 0, $192 = 0, $196 = 0, $199 = 0, $2 = 0, $20 = 0, $201 = 0, $202 = 0, $203 = 0, $205 = 0, $207 = 0, $208 = 0, $211 = 0, $213 = 0, $22 = 0, $228 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $24 = 0, $241 = 0, $25 = 0, $27 = 0, $38 = 0, $4 = 0, $40 = 0, $41 = 0, $43 = 0, $45 = 0, $47 = 0, $55 = 0, $56 = 0, $59 = 0, $65 = 0, $66 = 0, $68 = 0, $69 = 0, $71 = 0, $79 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $91 = 0, $93 = 0, $95 = 0, $96 = 0, $i$01$i = 0, $i$01$i1$i = 0, $i$01$i1$i7 = 0, $j$02$i = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer22 = 0, $vararg_buffer26 = 0, $vararg_buffer3 = 0, $vararg_buffer31 = 0, $vararg_buffer8 = 0, $vararg_ptr21 = 0, $vararg_ptr25 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $vararg_buffer31 = sp + 96 | 0;
 $vararg_buffer26 = sp + 80 | 0;
 $vararg_buffer22 = sp + 72 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4045] | 0;
 $1 = $0 + 1 | 0;
 HEAP32[4045] = $1;
 HEAP32[4044] = $1;
 $2 = HEAP32[3993] | 0;
 $4 = HEAP8[$2 + $1 >> 0] | 0;
 $$pre3$pre$i = HEAP32[3999] | 0;
 L1 : do if ($4 << 24 >> 24 == 125 ? 1 : (HEAP8[25877 + ($4 & 255) >> 0] | 0) == 1) $20 = $1; else {
  $10 = $1;
  while (1) {
   if (($10 | 0) >= ($$pre3$pre$i | 0)) {
    $20 = $10;
    break L1;
   }
   $12 = $10 + 1 | 0;
   HEAP32[4045] = $12;
   $14 = HEAP8[$2 + $12 >> 0] | 0;
   if ($14 << 24 >> 24 == 125 ? 1 : (HEAP8[25877 + ($14 & 255) >> 0] | 0) == 1) {
    $20 = $12;
    break;
   } else $10 = $12;
  }
 } while (0);
 if (($20 | 0) >= ($$pre3$pre$i | 0)) {
  $22 = HEAP32[3989] | 0;
  $24 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer >> 2] = 1364;
  HEAP32[$vararg_buffer + 4 >> 2] = $24;
  HEAP32[$vararg_buffer + 8 >> 2] = 34;
  _fprintf($22, 1357, $vararg_buffer) | 0;
  $25 = HEAP32[3990] | 0;
  $27 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 1364;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $27;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 34;
  _fprintf($25, 1357, $vararg_buffer3) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 if ((HEAP8[25877 + (HEAPU8[$2 + $20 >> 0] | 0) >> 0] | 0) == 1) {
  _fwrite(1383, 23, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1383, 23, 1, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 if (($$pre3$pre$i | 0) > ($20 + 1 | 0)) {
  $38 = HEAP32[3989] | 0;
  $40 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer8 >> 2] = 1369;
  HEAP32[$vararg_buffer8 + 4 >> 2] = $40;
  HEAP32[$vararg_buffer8 + 8 >> 2] = 34;
  _fprintf($38, 1357, $vararg_buffer8) | 0;
  $41 = HEAP32[3990] | 0;
  $43 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer13 >> 2] = 1369;
  HEAP32[$vararg_buffer13 + 4 >> 2] = $43;
  HEAP32[$vararg_buffer13 + 8 >> 2] = 34;
  _fprintf($41, 1357, $vararg_buffer13) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 $45 = (HEAP32[4050] | 0) + 1 | 0;
 HEAP32[4050] = $45;
 if (($45 | 0) == 20) {
  $47 = HEAP32[3990] | 0;
  if (($20 | 0) > ($1 | 0)) {
   _putc(HEAPU8[26133 + (HEAPU8[$2 + $1 >> 0] | 0) >> 0] | 0, $47) | 0;
   $55 = $0 + 2 | 0;
   $56 = HEAP32[4045] | 0;
   if (($55 | 0) < ($56 | 0)) {
    $59 = $55;
    while (1) {
     _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $59 >> 0] | 0) >> 0] | 0, $47) | 0;
     $65 = $59 + 1 | 0;
     $66 = HEAP32[4045] | 0;
     if (($65 | 0) < ($66 | 0)) $59 = $65; else {
      $$lcssa = $66;
      break;
     }
    }
   } else $$lcssa = $56;
   $69 = HEAP32[4044] | 0;
   $71 = $$lcssa;
  } else {
   $69 = $1;
   $71 = $20;
  }
  $68 = HEAP32[3989] | 0;
  if (($69 | 0) < ($71 | 0)) $i$01$i1$i = $69; else {
   $82 = $68;
   _fwrite(4429, 2, 1, $82) | 0;
   $83 = HEAP32[3990] | 0;
   _fwrite(4429, 2, 1, $83) | 0;
   $84 = HEAP32[3989] | 0;
   _fwrite(926, 33, 1, $84) | 0;
   $85 = HEAP32[3990] | 0;
   _fwrite(926, 33, 1, $85) | 0;
   HEAP8[25620] = 3;
   $86 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer18 >> 2] = 4432;
   $vararg_ptr21 = $vararg_buffer18 + 4 | 0;
   HEAP32[$vararg_ptr21 >> 2] = 20;
   _fprintf($86, 2854, $vararg_buffer18) | 0;
   $87 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer22 >> 2] = 4432;
   $vararg_ptr25 = $vararg_buffer22 + 4 | 0;
   HEAP32[$vararg_ptr25 >> 2] = 20;
   _fprintf($87, 2854, $vararg_buffer22) | 0;
   _longjmp(16008, 1);
  }
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $68) | 0;
   $79 = $i$01$i1$i + 1 | 0;
   if (($79 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $79; else break;
  }
  $82 = HEAP32[3989] | 0;
  _fwrite(4429, 2, 1, $82) | 0;
  $83 = HEAP32[3990] | 0;
  _fwrite(4429, 2, 1, $83) | 0;
  $84 = HEAP32[3989] | 0;
  _fwrite(926, 33, 1, $84) | 0;
  $85 = HEAP32[3990] | 0;
  _fwrite(926, 33, 1, $85) | 0;
  HEAP8[25620] = 3;
  $86 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer18 >> 2] = 4432;
  $vararg_ptr21 = $vararg_buffer18 + 4 | 0;
  HEAP32[$vararg_ptr21 >> 2] = 20;
  _fprintf($86, 2854, $vararg_buffer18) | 0;
  $87 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer22 >> 2] = 4432;
  $vararg_ptr25 = $vararg_buffer22 + 4 | 0;
  HEAP32[$vararg_ptr25 >> 2] = 20;
  _fprintf($87, 2854, $vararg_buffer22) | 0;
  _longjmp(16008, 1);
 }
 $88 = $20 - $1 | 0;
 $89 = HEAP32[4259] | 0;
 $91 = HEAP32[4041] | 0;
 $93 = HEAP32[$91 + ($89 + 1 << 2) >> 2] | 0;
 $95 = HEAP32[$91 + ($89 << 2) >> 2] | 0;
 $96 = $93 - $95 | 0;
 L34 : do if (($88 | 0) >= ($96 | 0)) {
  if (($93 | 0) > ($95 | 0)) {
   $100 = HEAP32[4042] | 0;
   $i$01$i = $20 - $96 | 0;
   $j$02$i = $95;
   while (1) {
    if ((HEAP8[$100 + $j$02$i >> 0] | 0) != (HEAP8[$2 + $i$01$i >> 0] | 0)) break L34;
    $107 = $j$02$i + 1 | 0;
    if (($107 | 0) < ($93 | 0)) {
     $i$01$i = $i$01$i + 1 | 0;
     $j$02$i = $107;
    } else break;
   }
  }
  $148 = _zstrlookup($2, $1, $88, 3, 1) | 0;
  $151 = HEAP32[(HEAP32[4145] | 0) + ($148 << 2) >> 2] | 0;
  HEAP32[16204 + (HEAP32[4050] << 2) >> 2] = $151;
  if (HEAP32[4241] | 0) {
   _fwrite(4477, 25, 1, HEAP32[3989] | 0) | 0;
   _fwrite(4477, 25, 1, HEAP32[3990] | 0) | 0;
   $160 = HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $160);
   _zoutpoolstr(HEAP32[3989] | 0, $160);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   HEAP32[4050] = (HEAP32[4050] | 0) + -1;
   _auxerrprint();
   STACKTOP = sp;
   return;
  }
  _free(HEAP32[4048] | 0);
  $168 = $151 + 1 | 0;
  $169 = HEAP32[4041] | 0;
  $176 = _xmalloc((HEAP32[$169 + ($168 << 2) >> 2] | 0) + 2 - (HEAP32[$169 + ($151 << 2) >> 2] | 0) | 0) | 0;
  HEAP32[4048] = $176;
  HEAP32[4046] = 1;
  $177 = HEAP32[4041] | 0;
  $179 = HEAP32[$177 + ($151 << 2) >> 2] | 0;
  $181 = HEAP32[$177 + ($168 << 2) >> 2] | 0;
  if (($179 | 0) < ($181 | 0)) {
   HEAP8[$176 + 1 >> 0] = HEAP8[(HEAP32[4042] | 0) + $179 >> 0] | 0;
   $188 = (HEAP32[4046] | 0) + 1 | 0;
   HEAP32[4046] = $188;
   $189 = $179 + 1 | 0;
   $190 = HEAP32[4041] | 0;
   $192 = HEAP32[$190 + ($168 << 2) >> 2] | 0;
   if (($189 | 0) < ($192 | 0)) {
    $196 = $189;
    $199 = $188;
    while (1) {
     HEAP8[(HEAP32[4048] | 0) + $199 >> 0] = HEAP8[(HEAP32[4042] | 0) + $196 >> 0] | 0;
     $201 = (HEAP32[4046] | 0) + 1 | 0;
     HEAP32[4046] = $201;
     $202 = $196 + 1 | 0;
     $203 = HEAP32[4041] | 0;
     $205 = HEAP32[$203 + ($168 << 2) >> 2] | 0;
     if (($202 | 0) < ($205 | 0)) {
      $196 = $202;
      $199 = $201;
     } else {
      $$lcssa16 = $203;
      $$lcssa17 = $205;
      break;
     }
    }
   } else {
    $$lcssa16 = $190;
    $$lcssa17 = $192;
   }
   $$lcssa1$i = $$lcssa17;
   $208 = HEAP32[$$lcssa16 + ($151 << 2) >> 2] | 0;
   $211 = HEAP32[4048] | 0;
  } else {
   $$lcssa1$i = $181;
   $208 = $179;
   $211 = $176;
  }
  $207 = $$lcssa1$i - $208 | 0;
  HEAP32[4049] = $207;
  HEAP8[$211 + ($207 + 1) >> 0] = 0;
  $213 = (HEAP32[4049] | 0) + 1 | 0;
  HEAP32[4046] = $213;
  HEAP8[(HEAP32[4048] | 0) + $213 >> 0] = 0;
  if (_kpse_in_name_ok((HEAP32[4048] | 0) + 1 | 0) | 0) if (_open_input(18576 + (HEAP32[4050] << 2) | 0, -1, 4127) | 0) {
   $235 = HEAP32[3989] | 0;
   $236 = HEAP32[4050] | 0;
   HEAP32[$vararg_buffer26 >> 2] = 4535;
   HEAP32[$vararg_buffer26 + 4 >> 2] = $236;
   HEAP32[$vararg_buffer26 + 8 >> 2] = 4544;
   _fprintf($235, 1280, $vararg_buffer26) | 0;
   $237 = HEAP32[3990] | 0;
   $238 = HEAP32[4050] | 0;
   HEAP32[$vararg_buffer31 >> 2] = 4535;
   HEAP32[$vararg_buffer31 + 4 >> 2] = $238;
   HEAP32[$vararg_buffer31 + 8 >> 2] = 4544;
   _fprintf($237, 1280, $vararg_buffer31) | 0;
   $241 = HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $241);
   _zoutpoolstr(HEAP32[3989] | 0, $241);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   HEAP32[16288 + (HEAP32[4050] << 2) >> 2] = 0;
   STACKTOP = sp;
   return;
  }
  _fwrite(4503, 31, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4503, 31, 1, HEAP32[3990] | 0) | 0;
  $228 = HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $228);
  _zoutpoolstr(HEAP32[3989] | 0, $228);
  _putc(10, HEAP32[3989] | 0) | 0;
  _putc(10, HEAP32[3990] | 0) | 0;
  HEAP32[4050] = (HEAP32[4050] | 0) + -1;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } while (0);
 $109 = HEAP32[3990] | 0;
 if (($20 | 0) > ($1 | 0)) {
  _putc(HEAPU8[26133 + (HEAPU8[$2 + $1 >> 0] | 0) >> 0] | 0, $109) | 0;
  $117 = $0 + 2 | 0;
  $118 = HEAP32[4045] | 0;
  if (($117 | 0) < ($118 | 0)) {
   $121 = $117;
   while (1) {
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $121 >> 0] | 0) >> 0] | 0, $109) | 0;
    $127 = $121 + 1 | 0;
    $128 = HEAP32[4045] | 0;
    if (($127 | 0) < ($128 | 0)) $121 = $127; else {
     $$lcssa28 = $128;
     break;
    }
   }
  } else $$lcssa28 = $118;
  $131 = HEAP32[4044] | 0;
  $133 = $$lcssa28;
 } else {
  $131 = $1;
  $133 = $20;
 }
 $130 = HEAP32[3989] | 0;
 if (($131 | 0) < ($133 | 0)) {
  $i$01$i1$i7 = $131;
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i7 >> 0] | 0) >> 0] | 0, $130) | 0;
   $141 = $i$01$i1$i7 + 1 | 0;
   if (($141 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i7 = $141; else break;
  }
  $144 = HEAP32[3989] | 0;
 } else $144 = $130;
 _fwrite(4454, 22, 1, $144) | 0;
 _fwrite(4454, 22, 1, HEAP32[3990] | 0) | 0;
 HEAP32[4050] = (HEAP32[4050] | 0) + -1;
 _auxerrprint();
 STACKTOP = sp;
 return;
}

function _expand_symlinks($kpse, $s) {
 $kpse = $kpse | 0;
 $s = $s | 0;
 var $$0 = 0, $$0$i = 0, $$0$i$i = 0, $1 = 0, $100 = 0, $103 = 0, $104 = 0, $108 = 0, $121 = 0, $127 = 0, $130 = 0, $131 = 0, $132 = 0, $135 = 0, $136 = 0, $138 = 0, $143 = 0, $15 = 0, $17 = 0, $19 = 0, $2 = 0, $25 = 0, $3 = 0, $30 = 0, $34 = 0, $4 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $50 = 0, $6 = 0, $62 = 0, $65 = 0, $66 = 0, $67 = 0, $70 = 0, $73 = 0, $74 = 0, $75 = 0, $84 = 0, $94 = 0, $before = 0, $cp$056 = 0, $done$045 = 0, $done$045$lcssa = 0, $endptr = 0, $post = 0, $s1$0$i = 0, $s1$0$i$i = 0, $s1$0$i$i$lcssa = 0, $s1$0$i$lcssa = 0, $s1$0$lcssa$i = 0, $s1$0$lcssa$i26 = 0, $s1$01$i = 0, $s1$01$i24 = 0, $s1$1$i = 0, $s1$1$i$i = 0, $st = 0, $strlenfirst = 0, $strlenfirst10 = 0, $strlenfirst17 = 0, $strlenfirst58 = 0, $sym = 0, $tmp = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer16 = 0, $vararg_buffer24 = 0, $vararg_buffer32 = 0, $vararg_buffer9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 8464 | 0;
 $vararg_buffer32 = sp + 248 | 0;
 $vararg_buffer24 = sp + 224 | 0;
 $vararg_buffer16 = sp + 200 | 0;
 $vararg_buffer9 = sp + 176 | 0;
 $vararg_buffer1 = sp + 152 | 0;
 $vararg_buffer = sp + 144 | 0;
 $post = sp + 6408 | 0;
 $sym = sp + 4360 | 0;
 $tmp = sp + 2312 | 0;
 $before = sp + 264 | 0;
 $st = sp;
 _memset($post | 0, 0, 2048) | 0;
 _memset($sym | 0, 0, 2048) | 0;
 _memset(23572, 0, 2048) | 0;
 _memset($tmp | 0, 0, 2048) | 0;
 _memset($before | 0, 0, 2048) | 0;
 _strcpy($post, $s) | 0;
 HEAP8[23572] = 0;
 $strlenfirst58 = HEAP8[$post >> 0] | 0;
 if (!($strlenfirst58 << 24 >> 24)) {
  $$0 = 23572;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $1 = $post;
 $2 = $st + 24 | 0;
 $3 = $kpse + 116 | 0;
 $4 = $sym + 2 | 0;
 $5 = $sym;
 $143 = $strlenfirst58;
 while (1) {
  $6 = _strlen(23572) | 0;
  if (($6 | 0) > 0) if ((HEAP8[23572 + ($6 + -1) >> 0] | 0) == 47) {
   $15 = $143;
   $s1$0$i$i = $post;
  } else {
   HEAP8[23572 + $6 >> 0] = 47;
   HEAP8[23572 + ($6 + 1) >> 0] = 0;
   $15 = $143;
   $s1$0$i$i = $post;
  } else {
   $15 = $143;
   $s1$0$i$i = $post;
  }
  L9 : while (1) {
   switch ($15 << 24 >> 24) {
   case 0:
    {
     $s1$0$i$i$lcssa = $s1$0$i$i;
     break L9;
     break;
    }
   case 47:
    {
     if (($s1$0$i$i | 0) != ($post | 0)) {
      $s1$0$i$i$lcssa = $s1$0$i$i;
      break L9;
     }
     break;
    }
   default:
    {}
   }
   $17 = $s1$0$i$i + 1 | 0;
   $15 = HEAP8[$17 >> 0] | 0;
   $s1$0$i$i = $17;
  }
  $19 = $s1$0$i$i$lcssa - $1 | 0;
  _strncpy(26652, $post, $19) | 0;
  HEAP8[26652 + $19 >> 0] = 0;
  $$0$i$i = $post;
  $s1$1$i$i = (HEAP8[$s1$0$i$i$lcssa >> 0] | 0) == 47 ? $s1$0$i$i$lcssa + 1 | 0 : $s1$0$i$i$lcssa;
  while (1) {
   $25 = HEAP8[$s1$1$i$i >> 0] | 0;
   HEAP8[$$0$i$i >> 0] = $25;
   if (!($25 << 24 >> 24)) break; else {
    $$0$i$i = $$0$i$i + 1 | 0;
    $s1$1$i$i = $s1$1$i$i + 1 | 0;
   }
  }
  _strcat(23572, 26652) | 0;
  if (_lstat(23572, $st) | 0) {
   label = 12;
   break;
  }
  if ((HEAP32[$2 >> 2] & 61440 | 0) == 40960) {
   $34 = _readlink(23572, $sym, 2048) | 0;
   if (($34 | 0) < 0) {
    label = 15;
    break;
   }
   HEAP8[$sym + $34 >> 0] = 0;
   if ((HEAP8[$sym >> 0] | 0) == 47) {
    if (HEAP32[$3 >> 2] | 0) {
     if (!(HEAP8[$post >> 0] | 0)) $43 = 30748; else {
      $42 = (_strcmp($post, 13340) | 0) != 0;
      $43 = $42 ? 13340 : 30748;
     }
     HEAP32[$vararg_buffer1 >> 2] = 23572;
     HEAP32[$vararg_buffer1 + 4 >> 2] = $43;
     HEAP32[$vararg_buffer1 + 8 >> 2] = $post;
     HEAP32[$vararg_buffer1 + 12 >> 2] = $sym;
     HEAP32[$vararg_buffer1 + 16 >> 2] = $43;
     HEAP32[$vararg_buffer1 + 20 >> 2] = $post;
     _printf(11180, $vararg_buffer1) | 0;
    }
    HEAP8[23572] = 0;
   } else {
    $44 = HEAP8[23572] | 0;
    $45 = _strlen(23572) | 0;
    $46 = 23572 + $45 | 0;
    L31 : do if (($45 | 0) > 0) {
     $s1$01$i = $46;
     while (1) {
      if ((HEAP8[$s1$01$i >> 0] | 0) == 47) {
       $s1$0$lcssa$i = $s1$01$i;
       break L31;
      }
      $50 = $s1$01$i + -1 | 0;
      if ($50 >>> 0 > 23572 >>> 0) $s1$01$i = $50; else {
       $s1$0$lcssa$i = $50;
       break;
      }
     }
    } else $s1$0$lcssa$i = $46; while (0);
    _strcpy(28700, $s1$0$lcssa$i + ((HEAP8[$s1$0$lcssa$i >> 0] | 0) == 47 & 1) | 0) | 0;
    HEAP8[$s1$0$lcssa$i >> 0] = 0;
    _strcpy($tmp, 28700) | 0;
    $strlenfirst10 = HEAP8[23572] | 0;
    if ($44 << 24 >> 24 == 47 & $strlenfirst10 << 24 >> 24 == 0) {
     HEAP16[11786] = 47;
     $strlenfirst17 = 47;
    } else $strlenfirst17 = $strlenfirst10;
    if (!(HEAP32[$3 >> 2] | 0)) $138 = $strlenfirst17; else {
     if (!($strlenfirst17 << 24 >> 24)) $66 = 30748; else {
      $62 = (_strcmp(23572, 13340) | 0) != 0;
      $66 = $62 ? 13340 : 30748;
     }
     if (!(HEAP8[$post >> 0] | 0)) $67 = 30748; else {
      $65 = (_strcmp($post, 13340) | 0) != 0;
      $67 = $65 ? 13340 : 30748;
     }
     HEAP32[$vararg_buffer9 >> 2] = 23572;
     HEAP32[$vararg_buffer9 + 4 >> 2] = $66;
     HEAP32[$vararg_buffer9 + 8 >> 2] = $tmp;
     HEAP32[$vararg_buffer9 + 12 >> 2] = $67;
     HEAP32[$vararg_buffer9 + 16 >> 2] = $post;
     _sprintf($before, 11202, $vararg_buffer9) | 0;
     if (!(HEAP8[23572] | 0)) $74 = 30748; else {
      $70 = (_strcmp(23572, 13340) | 0) != 0;
      $74 = $70 ? 13340 : 30748;
     }
     if (!(HEAP8[$post >> 0] | 0)) $75 = 30748; else {
      $73 = (_strcmp($post, 13340) | 0) != 0;
      $75 = $73 ? 13340 : 30748;
     }
     HEAP32[$vararg_buffer16 >> 2] = $before;
     HEAP32[$vararg_buffer16 + 4 >> 2] = 23572;
     HEAP32[$vararg_buffer16 + 8 >> 2] = $74;
     HEAP32[$vararg_buffer16 + 12 >> 2] = $sym;
     HEAP32[$vararg_buffer16 + 16 >> 2] = $75;
     HEAP32[$vararg_buffer16 + 20 >> 2] = $post;
     _printf(11215, $vararg_buffer16) | 0;
     $138 = HEAP8[23572] | 0;
    }
    do if (!(_strncmp($sym, 11235, 2) | 0)) {
     $done$045 = 0;
     L55 : while (1) {
      switch (HEAP8[$4 >> 0] | 0) {
      case 47:
      case 0:
       break;
      default:
       {
        $done$045$lcssa = $done$045;
        label = 53;
        break L55;
       }
      }
      if (!(HEAP8[23572] | 0)) {
       $done$045$lcssa = $done$045;
       label = 53;
       break;
      }
      if (!(_strcmp(23572, 15912) | 0)) {
       $done$045$lcssa = $done$045;
       label = 53;
       break;
      }
      if (!(_strcmp(23572, 11235) | 0)) {
       $done$045$lcssa = $done$045;
       label = 53;
       break;
      }
      $84 = _strlen(23572) | 0;
      if ($84 >>> 0 < 3) $s1$0$i = $sym; else if (!(_strcmp(23572 + $84 + -3 | 0, 11238) | 0)) {
       $done$045$lcssa = $done$045;
       label = 53;
       break;
      } else $s1$0$i = $sym;
      L63 : while (1) {
       switch (HEAP8[$s1$0$i >> 0] | 0) {
       case 0:
        {
         $s1$0$i$lcssa = $s1$0$i;
         break L63;
         break;
        }
       case 47:
        {
         if (($s1$0$i | 0) != ($sym | 0)) {
          $s1$0$i$lcssa = $s1$0$i;
          break L63;
         }
         break;
        }
       default:
        {}
       }
       $s1$0$i = $s1$0$i + 1 | 0;
      }
      $94 = $s1$0$i$lcssa - $5 | 0;
      _strncpy(26652, $sym, $94) | 0;
      HEAP8[26652 + $94 >> 0] = 0;
      $$0$i = $sym;
      $s1$1$i = (HEAP8[$s1$0$i$lcssa >> 0] | 0) == 47 ? $s1$0$i$lcssa + 1 | 0 : $s1$0$i$lcssa;
      while (1) {
       $100 = HEAP8[$s1$1$i >> 0] | 0;
       HEAP8[$$0$i >> 0] = $100;
       if (!($100 << 24 >> 24)) break; else {
        $$0$i = $$0$i + 1 | 0;
        $s1$1$i = $s1$1$i + 1 | 0;
       }
      }
      $103 = _strlen(23572) | 0;
      $104 = 23572 + $103 | 0;
      L72 : do if (($103 | 0) > 0) {
       $s1$01$i24 = $104;
       while (1) {
        if ((HEAP8[$s1$01$i24 >> 0] | 0) == 47) {
         $s1$0$lcssa$i26 = $s1$01$i24;
         break L72;
        }
        $108 = $s1$01$i24 + -1 | 0;
        if ($108 >>> 0 > 23572 >>> 0) $s1$01$i24 = $108; else {
         $s1$0$lcssa$i26 = $108;
         break;
        }
       }
      } else $s1$0$lcssa$i26 = $104; while (0);
      _strcpy(28700, $s1$0$lcssa$i26 + ((HEAP8[$s1$0$lcssa$i26 >> 0] | 0) == 47 & 1) | 0) | 0;
      HEAP8[$s1$0$lcssa$i26 >> 0] = 0;
      if (!(_strncmp($sym, 11235, 2) | 0)) $done$045 = 1; else break;
     }
     if ((label | 0) == 53) {
      label = 0;
      if (!$done$045$lcssa) break;
     }
     if (HEAP32[$3 >> 2] | 0) {
      if (HEAP8[$before >> 0] | 0) {
       $cp$056 = $before;
       while (1) {
        $121 = $cp$056 + 1 | 0;
        HEAP8[$cp$056 >> 0] = 32;
        if (!(HEAP8[$121 >> 0] | 0)) break; else $cp$056 = $121;
       }
      }
      if (!(HEAP8[$sym >> 0] | 0)) {
       if (!(HEAP8[$post >> 0] | 0)) $136 = 30748; else {
        $135 = (_strcmp($post, 13340) | 0) != 0;
        $136 = $135 ? 13340 : 30748;
       }
       HEAP32[$vararg_buffer32 >> 2] = $before;
       HEAP32[$vararg_buffer32 + 4 >> 2] = 23572;
       HEAP32[$vararg_buffer32 + 8 >> 2] = $136;
       HEAP32[$vararg_buffer32 + 12 >> 2] = $post;
       _printf(11260, $vararg_buffer32) | 0;
       break;
      }
      if (!(HEAP8[23572] | 0)) $131 = 30748; else {
       $127 = (_strcmp(23572, 13340) | 0) != 0;
       $131 = $127 ? 13340 : 30748;
      }
      if (!(HEAP8[$post >> 0] | 0)) $132 = 30748; else {
       $130 = (_strcmp($post, 13340) | 0) != 0;
       $132 = $130 ? 13340 : 30748;
      }
      HEAP32[$vararg_buffer24 >> 2] = $before;
      HEAP32[$vararg_buffer24 + 4 >> 2] = 23572;
      HEAP32[$vararg_buffer24 + 8 >> 2] = $131;
      HEAP32[$vararg_buffer24 + 12 >> 2] = $sym;
      HEAP32[$vararg_buffer24 + 16 >> 2] = $132;
      HEAP32[$vararg_buffer24 + 20 >> 2] = $post;
      _printf(11242, $vararg_buffer24) | 0;
     }
    } while (0);
    if ($138 << 24 >> 24 == 47 & (HEAP8[23572] | 0) == 0) HEAP16[11786] = 47;
   }
   if (!((HEAP8[$post >> 0] | 0) == 0 | (HEAP8[$sym >> 0] | 0) == 0)) {
    $endptr = $sym + (_strlen($sym) | 0) | 0;
    HEAP8[$endptr >> 0] = 47;
    HEAP8[$endptr + 1 >> 0] = 0;
   }
   _strcat($sym, $post) | 0;
   _strcpy($post, $sym) | 0;
  }
  $strlenfirst = HEAP8[$post >> 0] | 0;
  if (!($strlenfirst << 24 >> 24)) {
   $$0 = 23572;
   label = 72;
   break;
  } else $143 = $strlenfirst;
 }
 if ((label | 0) == 12) {
  $30 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = 23572;
  _fprintf($30, 11158, $vararg_buffer) | 0;
  _perror(23572);
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 } else if ((label | 0) == 15) {
  _perror(23572);
  _exit(1);
 } else if ((label | 0) == 72) {
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0;
}

function _search($kpse, $path, $original_name, $must_exist, $all) {
 $kpse = $kpse | 0;
 $path = $path | 0;
 $original_name = $original_name | 0;
 $must_exist = $must_exist | 0;
 $all = $all | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $102 = 0, $104 = 0, $11 = 0, $110 = 0, $116 = 0, $121 = 0, $122 = 0, $18 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $28 = 0, $35 = 0, $36 = 0, $40 = 0, $45 = 0, $46 = 0, $48 = 0, $49 = 0, $51 = 0, $57 = 0, $58 = 0, $6 = 0, $60 = 0, $62 = 0, $64 = 0, $65 = 0, $72 = 0, $77 = 0, $78 = 0, $8 = 0, $85 = 0, $88 = 0, $91 = 0, $97 = 0, $99 = 0, $allocated$010$i$i = 0, $allocated$010$us$i$i = 0, $allocated$1$lcssa$i$i = 0, $allocated$1$lcssa$us$i$i = 0, $allocated$16$i$i = 0, $allocated$16$us$i$i = 0, $allocated$3$ph$i$i = 0, $allow_disk_search$0$i = 0, $done$16$i = 0, $done$18$i = 0, $elt$0$i$i = 0, $elt$0$us$i$i = 0, $elt$011$i$i = 0, $elt$011$us$i$i = 0, $elt$011$us$i$i$lcssa = 0, $elt$017$i = 0, $elt$08$i$i = 0, $elt$1$i = 0, $found$0$i = 0, $found$2$ph$i = 0, $found$23$i = 0, $found$23$i$byval_copy = 0, $potential$0$lcssa$i$i = 0, $potential$09$i$i = 0, $potential$09$us$i$i = 0, $potential$1$lcssa$i$i = 0, $potential$1$lcssa$us$i$i = 0, $potential$1$lcssa$us$i$i$lcssa = 0, $potential$15$i$i = 0, $potential$15$us$i$i = 0, $potential$3$ph$i$i = 0, $ret_list = 0, $ret_list$i3 = 0, $tmpcast$1 = 0, $vararg_buffer = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $found$23$i$byval_copy = sp + 40 | 0;
 $vararg_buffer4 = sp + 32 | 0;
 $vararg_buffer = sp + 16 | 0;
 $ret_list$i3 = sp + 8 | 0;
 $ret_list = sp;
 $0 = _kpathsea_expand($kpse, $original_name) | 0;
 $1 = _kpathsea_absolute_p($kpse, $0, 1) | 0;
 $2 = $kpse + 44 | 0;
 if (HEAP32[$2 >> 2] & 32 | 0) {
  $6 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $6) | 0;
  HEAP32[$vararg_buffer >> 2] = $0;
  HEAP32[$vararg_buffer + 4 >> 2] = $must_exist;
  HEAP32[$vararg_buffer + 8 >> 2] = $all;
  HEAP32[$vararg_buffer + 12 >> 2] = $path;
  _fprintf($6, 11083, $vararg_buffer) | 0;
  _fflush($6) | 0;
 }
 if (!$1) {
  HEAP32[$ret_list$i3 >> 2] = 0;
  HEAP32[$ret_list$i3 + 4 >> 2] = 0;
  $18 = _kpathsea_path_element($kpse, $path) | 0;
  if ($18 | 0) {
   $20 = $kpse + 92 | 0;
   $21 = ($all | 0) == 0;
   $22 = ($must_exist | 0) == 0;
   $23 = $found$23$i$byval_copy + 4 | 0;
   $elt$017$i = $18;
   while (1) {
    if ((HEAP8[$elt$017$i >> 0] | 0) == 33) {
     $28 = (HEAP8[$elt$017$i + 1 >> 0] | 0) == 33;
     $allow_disk_search$0$i = $28 & 1 ^ 1;
     $elt$1$i = $28 ? $elt$017$i + 2 | 0 : $elt$017$i;
    } else {
     $allow_disk_search$0$i = 1;
     $elt$1$i = $elt$017$i;
    }
    _kpathsea_normalize_path($kpse, $elt$1$i) | 0;
    if (!(HEAP32[$20 >> 2] | 0)) $35 = 0; else $35 = _kpathsea_db_search($kpse, $0, $elt$1$i, $all) | 0;
    do if (!$allow_disk_search$0$i) label = 36; else {
     $36 = ($35 | 0) != 0;
     if ($36) if ($22) $found$2$ph$i = $35; else if (!(HEAP32[$35 + 4 >> 2] | 0)) label = 17; else $found$2$ph$i = $35; else label = 17;
     if ((label | 0) == 17) {
      label = 0;
      $40 = _kpathsea_element_dirs($kpse, $elt$1$i) | 0;
      if (!$40) {
       label = 36;
       break;
      }
      if (!(HEAP32[$40 >> 2] | 0)) {
       label = 36;
       break;
      }
      if ($36) $found$0$i = $35; else $found$0$i = _xmalloc(8) | 0;
      $45 = _strlen($0) | 0;
      $46 = _xmalloc(75) | 0;
      HEAP32[$found$23$i$byval_copy >> 2] = 0;
      HEAP32[$23 >> 2] = 0;
      $elt$08$i$i = HEAP32[$40 >> 2] | 0;
      L28 : do if (!$elt$08$i$i) {
       $potential$0$lcssa$i$i = $46;
       label = 33;
      } else {
       $48 = $45 + 1 | 0;
       if ($21) {
        $allocated$010$us$i$i = 75;
        $elt$011$us$i$i = $elt$08$i$i;
        $potential$09$us$i$i = $46;
        while (1) {
         $49 = HEAP32[$elt$011$us$i$i >> 2] | 0;
         $51 = (_strlen($49) | 0) + $48 | 0;
         if ($51 >>> 0 > $allocated$010$us$i$i >>> 0) {
          $allocated$16$us$i$i = $allocated$010$us$i$i;
          $potential$15$us$i$i = $potential$09$us$i$i;
          while (1) {
           $57 = $allocated$16$us$i$i << 1;
           $58 = _xrealloc($potential$15$us$i$i, $57) | 0;
           if ($51 >>> 0 > $57 >>> 0) {
            $allocated$16$us$i$i = $57;
            $potential$15$us$i$i = $58;
           } else {
            $allocated$1$lcssa$us$i$i = $57;
            $potential$1$lcssa$us$i$i = $58;
            break;
           }
          }
         } else {
          $allocated$1$lcssa$us$i$i = $allocated$010$us$i$i;
          $potential$1$lcssa$us$i$i = $potential$09$us$i$i;
         }
         _strcpy($potential$1$lcssa$us$i$i, $49) | 0;
         _strcat($potential$1$lcssa$us$i$i, $0) | 0;
         if (_kpathsea_readable_file($kpse, $potential$1$lcssa$us$i$i) | 0) {
          $elt$011$us$i$i$lcssa = $elt$011$us$i$i;
          $potential$1$lcssa$us$i$i$lcssa = $potential$1$lcssa$us$i$i;
          break;
         }
         $elt$0$us$i$i = HEAP32[$elt$011$us$i$i + 8 >> 2] | 0;
         if (!$elt$0$us$i$i) {
          $potential$0$lcssa$i$i = $potential$1$lcssa$us$i$i;
          label = 33;
          break L28;
         } else {
          $allocated$010$us$i$i = $allocated$1$lcssa$us$i$i;
          $elt$011$us$i$i = $elt$0$us$i$i;
          $potential$09$us$i$i = $potential$1$lcssa$us$i$i;
         }
        }
        _str_list_add($found$23$i$byval_copy, $potential$1$lcssa$us$i$i$lcssa);
        _str_llist_float($40, $elt$011$us$i$i$lcssa);
        break;
       } else {
        $allocated$010$i$i = 75;
        $elt$011$i$i = $elt$08$i$i;
        $potential$09$i$i = $46;
        while (1) {
         $60 = HEAP32[$elt$011$i$i >> 2] | 0;
         $62 = (_strlen($60) | 0) + $48 | 0;
         if ($62 >>> 0 > $allocated$010$i$i >>> 0) {
          $allocated$16$i$i = $allocated$010$i$i;
          $potential$15$i$i = $potential$09$i$i;
          while (1) {
           $64 = $allocated$16$i$i << 1;
           $65 = _xrealloc($potential$15$i$i, $64) | 0;
           if ($62 >>> 0 > $64 >>> 0) {
            $allocated$16$i$i = $64;
            $potential$15$i$i = $65;
           } else {
            $allocated$1$lcssa$i$i = $64;
            $potential$1$lcssa$i$i = $65;
            break;
           }
          }
         } else {
          $allocated$1$lcssa$i$i = $allocated$010$i$i;
          $potential$1$lcssa$i$i = $potential$09$i$i;
         }
         _strcpy($potential$1$lcssa$i$i, $60) | 0;
         _strcat($potential$1$lcssa$i$i, $0) | 0;
         if (!(_kpathsea_readable_file($kpse, $potential$1$lcssa$i$i) | 0)) {
          $allocated$3$ph$i$i = $allocated$1$lcssa$i$i;
          $potential$3$ph$i$i = $potential$1$lcssa$i$i;
         } else {
          _str_list_add($found$23$i$byval_copy, $potential$1$lcssa$i$i);
          _str_llist_float($40, $elt$011$i$i);
          $allocated$3$ph$i$i = 75;
          $potential$3$ph$i$i = _xmalloc(75) | 0;
         }
         $elt$0$i$i = HEAP32[$elt$011$i$i + 8 >> 2] | 0;
         if (!$elt$0$i$i) {
          $potential$0$lcssa$i$i = $potential$3$ph$i$i;
          label = 33;
          break;
         } else {
          $allocated$010$i$i = $allocated$3$ph$i$i;
          $elt$011$i$i = $elt$0$i$i;
          $potential$09$i$i = $potential$3$ph$i$i;
         }
        }
       }
      } while (0);
      if ((label | 0) == 33) {
       label = 0;
       _free($potential$0$lcssa$i$i);
      }
      $72 = $found$23$i$byval_copy;
      $77 = HEAP32[$72 + 4 >> 2] | 0;
      $78 = $found$0$i;
      HEAP32[$78 >> 2] = HEAP32[$72 >> 2];
      HEAP32[$78 + 4 >> 2] = $77;
      $found$2$ph$i = $found$0$i;
     }
     $122 = ($found$2$ph$i | 0) != 0;
     $found$23$i = $found$2$ph$i;
     label = 37;
    } while (0);
    if ((label | 0) == 36) {
     label = 0;
     if (!$35) $done$16$i = 0; else {
      $122 = 1;
      $found$23$i = $35;
      label = 37;
     }
    }
    L54 : do if ((label | 0) == 37) {
     label = 0;
     $85 = HEAP32[$found$23$i + 4 >> 2] | 0;
     do if (!$85) if ($122) $done$18$i = 0; else {
      $done$16$i = 0;
      break L54;
     } else if ($21) {
      _str_list_add($ret_list$i3, HEAP32[$85 >> 2] | 0);
      if ($122) {
       $done$18$i = 1;
       break;
      } else {
       $done$16$i = 1;
       break L54;
      }
     } else {
      HEAP32[$found$23$i$byval_copy >> 2] = HEAP32[$found$23$i >> 2];
      HEAP32[$found$23$i$byval_copy + 4 >> 2] = HEAP32[$found$23$i + 4 >> 2];
      _str_list_concat($ret_list$i3, $found$23$i$byval_copy);
      if ($122) {
       $done$18$i = 0;
       break;
      } else {
       $done$16$i = 0;
       break L54;
      }
     } while (0);
     _str_list_free($found$23$i);
     _free($found$23$i);
     $done$16$i = $done$18$i;
    } while (0);
    $88 = _kpathsea_path_element($kpse, 0) | 0;
    if (($done$16$i | 0) == 0 & ($88 | 0) != 0) $elt$017$i = $88; else break;
   }
  }
  _free($0);
  $91 = $ret_list$i3;
  $102 = HEAP32[$91 + 4 >> 2] | 0;
  $99 = HEAP32[$91 >> 2] | 0;
 } else {
  $8 = _kpathsea_readable_file($kpse, $0) | 0;
  HEAP32[$found$23$i$byval_copy >> 2] = 0;
  HEAP32[$found$23$i$byval_copy + 4 >> 2] = 0;
  if (($8 | 0) != ($0 | 0)) _free($0);
  _str_list_add($found$23$i$byval_copy, $8);
  $11 = $found$23$i$byval_copy;
  $102 = HEAP32[$11 + 4 >> 2] | 0;
  $99 = HEAP32[$11 >> 2] | 0;
 }
 $97 = $ret_list;
 HEAP32[$97 >> 2] = $99;
 HEAP32[$97 + 4 >> 2] = $102;
 $104 = $102;
 if (!$99) label = 48; else if ($all | 0) if (HEAP32[$104 + ($99 + -1 << 2) >> 2] | 0) label = 48;
 if ((label | 0) == 48) _str_list_add($ret_list, 0);
 $110 = $kpse + 92 | 0;
 if (!(HEAP32[$110 >> 2] | 0)) {
  HEAP32[$110 >> 2] = 1;
  $$pre$phiZ2D = $ret_list + 4 | 0;
  $121 = HEAP32[$$pre$phiZ2D >> 2] | 0;
  STACKTOP = sp;
  return $121 | 0;
 }
 if (HEAP32[$2 >> 2] & 32 | 0) {
  $116 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $116) | 0;
  HEAP32[$vararg_buffer4 >> 2] = $original_name;
  _fprintf($116, 11144, $vararg_buffer4) | 0;
  _fflush($116) | 0;
 }
 $tmpcast$1 = $ret_list + 4 | 0;
 _log_search($kpse, HEAP32[$ret_list >> 2] | 0, HEAP32[$tmpcast$1 >> 2] | 0);
 if (!(HEAP32[$2 >> 2] & 32)) {
  $$pre$phiZ2D = $tmpcast$1;
  $121 = HEAP32[$$pre$phiZ2D >> 2] | 0;
  STACKTOP = sp;
  return $121 | 0;
 }
 _putc(10, HEAP32[21] | 0) | 0;
 $$pre$phiZ2D = $tmpcast$1;
 $121 = HEAP32[$$pre$phiZ2D >> 2] | 0;
 STACKTOP = sp;
 return $121 | 0;
}

function _xpurify() {
 var $$lcssa = 0, $$lcssa46 = 0, $$pre = 0, $0 = 0, $102 = 0, $104 = 0, $11 = 0, $114 = 0, $120 = 0, $125 = 0, $127 = 0, $134 = 0, $139 = 0, $140 = 0, $141 = 0, $143 = 0, $145 = 0, $147 = 0, $148 = 0, $15 = 0, $155 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $164 = 0, $165 = 0, $169 = 0, $173 = 0, $174 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $21 = 0, $25 = 0, $27 = 0, $29 = 0, $32 = 0, $34 = 0, $36 = 0, $37 = 0, $43 = 0, $45 = 0, $48 = 0, $5 = 0, $50 = 0, $53 = 0, $55 = 0, $59 = 0, $6 = 0, $61 = 0, $62 = 0, $65 = 0, $66 = 0, $68 = 0, $70 = 0, $76 = 0, $78 = 0, $79 = 0, $8 = 0, $81 = 0, $89 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $98 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$01$i$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa45 = 0, label = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   HEAP32[4333] = 0;
   $5 = HEAP32[4345] | 0;
   $6 = HEAP32[4041] | 0;
   $8 = HEAP32[$6 + ($5 << 2) >> 2] | 0;
   HEAP32[4238] = $8;
   $11 = HEAP32[$6 + ($5 + 1 << 2) >> 2] | 0;
   HEAP32[4239] = $11;
   if (($11 - $8 | 0) > (HEAP32[3992] | 0)) {
    _bufferoverflow();
    $15 = HEAP32[4333] | 0;
    $16 = HEAP32[4238] | 0;
    $18 = HEAP32[4239] | 0;
   } else {
    $15 = 0;
    $16 = $8;
    $18 = $11;
   }
   HEAP32[4251] = $15;
   if (($16 | 0) < ($18 | 0)) {
    $21 = $16;
    $25 = $15;
    while (1) {
     HEAP8[(HEAP32[3995] | 0) + $25 >> 0] = HEAP8[(HEAP32[4042] | 0) + $21 >> 0] | 0;
     $27 = (HEAP32[4251] | 0) + 1 | 0;
     HEAP32[4251] = $27;
     $29 = (HEAP32[4238] | 0) + 1 | 0;
     HEAP32[4238] = $29;
     if (($29 | 0) < (HEAP32[4239] | 0)) {
      $21 = $29;
      $25 = $27;
     } else {
      $32 = $27;
      break;
     }
    }
   } else $32 = $15;
   HEAP32[4333] = $32;
   HEAP32[4330] = 0;
   HEAP32[4323] = 0;
   HEAP32[4251] = 0;
   L11 : do if (($32 | 0) > 0) {
    $36 = 0;
    $43 = 0;
    $55 = $32;
    while (1) {
     $34 = HEAP32[3995] | 0;
     $37 = HEAP8[$34 + $36 >> 0] | 0;
     L14 : do switch (HEAPU8[25877 + ($37 & 255) >> 0] | 0) {
     case 4:
     case 1:
      {
       HEAP8[$34 + $43 >> 0] = 32;
       $45 = (HEAP32[4323] | 0) + 1 | 0;
       HEAP32[4323] = $45;
       $177 = $45;
       break;
      }
     case 3:
     case 2:
      {
       HEAP8[$34 + $43 >> 0] = $37;
       $48 = (HEAP32[4323] | 0) + 1 | 0;
       HEAP32[4323] = $48;
       $177 = $48;
       break;
      }
     default:
      {
       if ($37 << 24 >> 24 != 123) {
        $169 = HEAP32[4330] | 0;
        if (!($37 << 24 >> 24 == 125 & ($169 | 0) > 0)) {
         $177 = $43;
         break L14;
        }
        HEAP32[4330] = $169 + -1;
        $177 = $43;
        break L14;
       }
       $50 = HEAP32[4330] | 0;
       HEAP32[4330] = $50 + 1;
       if (!$50) {
        $53 = $36 + 1 | 0;
        if (($53 | 0) < ($55 | 0)) if ((HEAP8[$34 + $53 >> 0] | 0) == 92) {
         HEAP32[4251] = $53;
         $125 = $43;
         $66 = $53;
         $68 = $55;
         while (1) {
          $65 = $66 + 1 | 0;
          HEAP32[4251] = $65;
          HEAP32[4347] = $65;
          $$pre = HEAP32[3995] | 0;
          L25 : do if (($65 | 0) < ($68 | 0)) {
           $70 = $65;
           while (1) {
            if ((HEAP8[25877 + (HEAPU8[$$pre + $70 >> 0] | 0) >> 0] | 0) != 2) {
             $79 = $70;
             break L25;
            }
            $76 = $70 + 1 | 0;
            HEAP32[4251] = $76;
            if (($76 | 0) < ($68 | 0)) $70 = $76; else {
             $79 = $76;
             break;
            }
           }
          } else $79 = $65; while (0);
          $78 = $79 - $65 | 0;
          if (($78 | 0) > 0) {
           $81 = HEAP32[4240] | 0;
           $h$06$i = 0;
           $k$07$i = $65;
           while (1) {
            $h$1$i = (HEAPU8[$$pre + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
            while (1) if (($h$1$i | 0) < ($81 | 0)) {
             $h$1$i$lcssa = $h$1$i;
             break;
            } else $h$1$i = $h$1$i - $81 | 0;
            $89 = $k$07$i + 1 | 0;
            if (($89 | 0) < ($79 | 0)) {
             $h$06$i = $h$1$i$lcssa;
             $k$07$i = $89;
            } else {
             $h$0$lcssa$i = $h$1$i$lcssa;
             break;
            }
           }
          } else $h$0$lcssa$i = 0;
          HEAP32[4241] = 0;
          $92 = HEAP32[4145] | 0;
          $93 = HEAP32[4041] | 0;
          $94 = HEAP32[4042] | 0;
          $95 = HEAP32[4242] | 0;
          $96 = HEAP32[4243] | 0;
          $p$0$i = $h$0$lcssa$i + 1 | 0;
          L38 : while (1) {
           $98 = HEAP32[$92 + ($p$0$i << 2) >> 2] | 0;
           L40 : do if (($98 | 0) > 0) {
            $102 = HEAP32[$93 + ($98 + 1 << 2) >> 2] | 0;
            $104 = HEAP32[$93 + ($98 << 2) >> 2] | 0;
            if (($102 - $104 | 0) == ($78 | 0)) {
             if (($102 | 0) > ($104 | 0)) {
              $i$01$i$i = $65;
              $j$02$i$i = $104;
              while (1) {
               if ((HEAP8[$94 + $j$02$i$i >> 0] | 0) != (HEAP8[$$pre + $i$01$i$i >> 0] | 0)) break L40;
               $114 = $j$02$i$i + 1 | 0;
               if (($114 | 0) < ($102 | 0)) {
                $i$01$i$i = $i$01$i$i + 1 | 0;
                $j$02$i$i = $114;
               } else break;
              }
             }
             if ((HEAP8[$95 + $p$0$i >> 0] | 0) == 14) {
              $p$0$i$lcssa = $p$0$i;
              label = 35;
              break L38;
             }
            }
           } while (0);
           $120 = HEAP32[$96 + ($p$0$i << 2) >> 2] | 0;
           if (!$120) {
            $p$0$i$lcssa45 = $p$0$i;
            label = 34;
            break;
           } else $p$0$i = $120;
          }
          L49 : do if ((label | 0) == 34) {
           label = 0;
           HEAP32[4338] = $p$0$i$lcssa45;
           $179 = $125;
          } else if ((label | 0) == 35) {
           label = 0;
           HEAP32[4241] = 1;
           HEAP32[4338] = $p$0$i$lcssa;
           HEAP8[$$pre + $125 >> 0] = HEAP8[$$pre + $65 >> 0] | 0;
           $127 = (HEAP32[4323] | 0) + 1 | 0;
           HEAP32[4323] = $127;
           switch (HEAP32[(HEAP32[4249] | 0) + (HEAP32[4338] << 2) >> 2] | 0) {
           case 12:
           case 5:
           case 4:
           case 3:
           case 2:
            break;
           default:
            {
             $179 = $127;
             break L49;
            }
           }
           $134 = HEAP32[3995] | 0;
           HEAP8[$134 + $127 >> 0] = HEAP8[$134 + ((HEAP32[4347] | 0) + 1) >> 0] | 0;
           $139 = (HEAP32[4323] | 0) + 1 | 0;
           HEAP32[4323] = $139;
           $179 = $139;
          } while (0);
          $140 = HEAP32[4251] | 0;
          $141 = HEAP32[4333] | 0;
          $143 = HEAP32[4330] | 0;
          L54 : do if (($140 | 0) < ($141 | 0) & ($143 | 0) > 0) {
           $147 = $140;
           $155 = $179;
           $159 = $143;
           $180 = $141;
           while (1) {
            $145 = HEAP32[3995] | 0;
            $148 = HEAP8[$145 + $147 >> 0] | 0;
            if ($148 << 24 >> 24 == 92) {
             $178 = $155;
             $59 = $147;
             $61 = $180;
             $62 = $159;
             break L54;
            }
            L58 : do if ((HEAP8[25877 + ($148 & 255) >> 0] & -2) << 24 >> 24 == 2) {
             HEAP8[$145 + $155 >> 0] = $148;
             $157 = (HEAP32[4323] | 0) + 1 | 0;
             HEAP32[4323] = $157;
             $162 = HEAP32[4251] | 0;
             $164 = HEAP32[4333] | 0;
             $165 = HEAP32[4330] | 0;
             $181 = $157;
            } else switch ($148 << 24 >> 24) {
            case 125:
             {
              $158 = $159 + -1 | 0;
              HEAP32[4330] = $158;
              $162 = $147;
              $164 = $180;
              $165 = $158;
              $181 = $155;
              break L58;
              break;
             }
            case 123:
             {
              $160 = $159 + 1 | 0;
              HEAP32[4330] = $160;
              $162 = $147;
              $164 = $180;
              $165 = $160;
              $181 = $155;
              break L58;
              break;
             }
            default:
             {
              $162 = $147;
              $164 = $180;
              $165 = $159;
              $181 = $155;
              break L58;
             }
            } while (0);
            $161 = $162 + 1 | 0;
            HEAP32[4251] = $161;
            if (($161 | 0) < ($164 | 0) & ($165 | 0) > 0) {
             $147 = $161;
             $155 = $181;
             $159 = $165;
             $180 = $164;
            } else {
             $178 = $181;
             $59 = $161;
             $61 = $164;
             $62 = $165;
             break;
            }
           }
          } else {
           $178 = $179;
           $59 = $140;
           $61 = $141;
           $62 = $143;
          } while (0);
          if (($59 | 0) < ($61 | 0) & ($62 | 0) > 0) {
           $125 = $178;
           $66 = $59;
           $68 = $61;
          } else {
           $$lcssa = $59;
           $$lcssa46 = $178;
           break;
          }
         }
         HEAP32[4251] = $$lcssa + -1;
         $177 = $$lcssa46;
        } else $177 = $43; else $177 = $43;
       } else $177 = $43;
      }
     } while (0);
     $173 = (HEAP32[4251] | 0) + 1 | 0;
     HEAP32[4251] = $173;
     $174 = HEAP32[4333] | 0;
     if (($173 | 0) < ($174 | 0)) {
      $36 = $173;
      $43 = $177;
      $55 = $174;
     } else {
      $176 = $177;
      break L11;
     }
    }
   } else $176 = 0; while (0);
   HEAP32[4333] = $176;
   _addpoolbufandpush();
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 return;
}

function _auxcitationcommand() {
 var $$lcssa = 0, $$lcssa32 = 0, $$lcssa7 = 0, $0 = 0, $1 = 0, $106 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $115 = 0, $119 = 0, $121 = 0, $131 = 0, $137 = 0, $141 = 0, $142 = 0, $143 = 0, $15 = 0, $152 = 0, $153 = 0, $155 = 0, $156 = 0, $158 = 0, $16 = 0, $166 = 0, $169 = 0, $172 = 0, $179 = 0, $18 = 0, $197 = 0, $20 = 0, $205 = 0, $206 = 0, $209 = 0, $21 = 0, $23 = 0, $24 = 0, $26 = 0, $27 = 0, $29 = 0, $31 = 0, $41 = 0, $43 = 0, $44 = 0, $46 = 0, $5 = 0, $53 = 0, $54 = 0, $6 = 0, $62 = 0, $63 = 0, $66 = 0, $7 = 0, $71 = 0, $72 = 0, $74 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $98 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$0$i = 0, $i$01$i$i = 0, $i$01$i$i1 = 0, $i$01$i1$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa43 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer21 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $vararg_buffer21 = sp + 72 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[4670] = 1;
 $0 = HEAP32[4045] | 0;
 $1 = HEAP32[3993] | 0;
 if ((HEAP8[$1 + $0 >> 0] | 0) == 125) {
  STACKTOP = sp;
  return;
 } else {
  $6 = $0;
  $8 = $1;
 }
 L3 : while (1) {
  $5 = $6 + 1 | 0;
  HEAP32[4045] = $5;
  HEAP32[4044] = $5;
  $7 = $8 + $5 | 0;
  $9 = HEAP8[$7 >> 0] | 0;
  L5 : do switch ($9 << 24 >> 24) {
  case 44:
  case 125:
   {
    $209 = $5;
    label = 4;
    break;
   }
  default:
   {
    $11 = $9;
    $16 = $5;
    while (1) {
     if ((HEAP8[25877 + ($11 & 255) >> 0] | 0) == 1) {
      $209 = $16;
      label = 4;
      break L5;
     }
     $15 = HEAP32[3999] | 0;
     if (($16 | 0) >= ($15 | 0)) {
      $21 = $16;
      $23 = $15;
      break L5;
     }
     $18 = $16 + 1 | 0;
     HEAP32[4045] = $18;
     $20 = HEAP8[$8 + $18 >> 0] | 0;
     switch ($20 << 24 >> 24) {
     case 44:
     case 125:
      {
       $209 = $18;
       label = 4;
       break L5;
       break;
      }
     default:
      {
       $11 = $20;
       $16 = $18;
      }
     }
    }
   }
  } while (0);
  if ((label | 0) == 4) {
   label = 0;
   $21 = $209;
   $23 = HEAP32[3999] | 0;
  }
  if (($21 | 0) >= ($23 | 0)) {
   label = 8;
   break;
  }
  $31 = HEAP8[$8 + $21 >> 0] | 0;
  if ((HEAP8[25877 + ($31 & 255) >> 0] | 0) == 1) {
   label = 10;
   break;
  }
  if ($31 << 24 >> 24 == 125 & ($23 | 0) > ($21 + 1 | 0)) {
   label = 12;
   break;
  }
  if (($21 - $5 | 0) == 1) if ((HEAP8[$7 >> 0] | 0) == 42) {
   if (HEAP32[4328] | 0) {
    label = 16;
    break;
   }
   HEAP32[4328] = 1;
   HEAP32[4671] = HEAP32[4150];
   $205 = $8;
   $206 = $21;
  } else label = 18; else label = 18;
  do if ((label | 0) == 18) {
   label = 0;
   HEAP32[4252] = $5;
   if (($21 | 0) > ($5 | 0)) {
    HEAP8[(HEAP32[3995] | 0) + $5 >> 0] = HEAP8[$8 + $5 >> 0] | 0;
    $62 = (HEAP32[4252] | 0) + 1 | 0;
    HEAP32[4252] = $62;
    $63 = HEAP32[4045] | 0;
    if (($62 | 0) < ($63 | 0)) {
     $66 = $62;
     while (1) {
      HEAP8[(HEAP32[3995] | 0) + $66 >> 0] = HEAP8[(HEAP32[3993] | 0) + $66 >> 0] | 0;
      $71 = (HEAP32[4252] | 0) + 1 | 0;
      HEAP32[4252] = $71;
      $72 = HEAP32[4045] | 0;
      if (($71 | 0) < ($72 | 0)) $66 = $71; else {
       $$lcssa32 = $72;
       break;
      }
     }
    } else $$lcssa32 = $63;
    $$lcssa7 = $$lcssa32;
    $76 = HEAP32[4044] | 0;
   } else {
    $$lcssa7 = $21;
    $76 = $5;
   }
   $74 = HEAP32[3995] | 0;
   if (($$lcssa7 | 0) > ($76 | 0)) {
    $77 = $$lcssa7 + -1 | 0;
    $i$0$i = $76;
    while (1) {
     $78 = $74 + $i$0$i | 0;
     $79 = HEAP8[$78 >> 0] | 0;
     if (($79 + -65 & 255) < 26) HEAP8[$78 >> 0] = ($79 & 255) + 32;
     if (($i$0$i | 0) < ($77 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $87 = HEAP32[4044] | 0;
    $88 = HEAP32[4045] | 0;
    $89 = HEAP32[3995] | 0;
   } else {
    $87 = $76;
    $88 = $$lcssa7;
    $89 = $74;
   }
   HEAP32[4250] = _zstrlookup($89, $87, $88 - $87 | 0, 10, 1) | 0;
   $93 = HEAP32[3993] | 0;
   $94 = HEAP32[4044] | 0;
   $95 = HEAP32[4045] | 0;
   $96 = $95 - $94 | 0;
   if (!(HEAP32[4241] | 0)) {
    HEAP32[4248] = _zstrlookup($93, $94, $96, 9, 1) | 0;
    if (HEAP32[4241] | 0) {
     label = 51;
     break L3;
    }
    _zcheckciteoverflow(HEAP32[4150] | 0);
    HEAP32[(HEAP32[4099] | 0) + (HEAP32[4150] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4248] << 2) >> 2];
    $197 = HEAP32[4249] | 0;
    HEAP32[$197 + (HEAP32[4248] << 2) >> 2] = HEAP32[4150];
    HEAP32[$197 + (HEAP32[4250] << 2) >> 2] = HEAP32[4248];
    HEAP32[4150] = (HEAP32[4150] | 0) + 1;
    $205 = HEAP32[3993] | 0;
    $206 = HEAP32[4045] | 0;
    break;
   }
   if (($96 | 0) > 0) {
    $98 = HEAP32[4240] | 0;
    $h$06$i = 0;
    $k$07$i = $94;
    while (1) {
     $h$1$i = (HEAPU8[$93 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
     while (1) if (($h$1$i | 0) < ($98 | 0)) {
      $h$1$i$lcssa = $h$1$i;
      break;
     } else $h$1$i = $h$1$i - $98 | 0;
     $106 = $k$07$i + 1 | 0;
     if (($106 | 0) < ($95 | 0)) {
      $h$06$i = $h$1$i$lcssa;
      $k$07$i = $106;
     } else {
      $h$0$lcssa$i = $h$1$i$lcssa;
      break;
     }
    }
   } else $h$0$lcssa$i = 0;
   HEAP32[4241] = 0;
   $109 = HEAP32[4145] | 0;
   $110 = HEAP32[4041] | 0;
   $111 = HEAP32[4042] | 0;
   $112 = HEAP32[4242] | 0;
   $113 = HEAP32[4243] | 0;
   $p$0$i = $h$0$lcssa$i + 1 | 0;
   L50 : while (1) {
    $115 = HEAP32[$109 + ($p$0$i << 2) >> 2] | 0;
    L52 : do if (($115 | 0) > 0) {
     $119 = HEAP32[$110 + ($115 + 1 << 2) >> 2] | 0;
     $121 = HEAP32[$110 + ($115 << 2) >> 2] | 0;
     if (($119 - $121 | 0) == ($96 | 0)) {
      if (($119 | 0) > ($121 | 0)) {
       $i$01$i$i = $94;
       $j$02$i$i = $121;
       while (1) {
        if ((HEAP8[$111 + $j$02$i$i >> 0] | 0) != (HEAP8[$93 + $i$01$i$i >> 0] | 0)) break L52;
        $131 = $j$02$i$i + 1 | 0;
        if (($131 | 0) < ($119 | 0)) {
         $i$01$i$i = $i$01$i$i + 1 | 0;
         $j$02$i$i = $131;
        } else break;
       }
      }
      if ((HEAP8[$112 + $p$0$i >> 0] | 0) == 9) {
       $p$0$i$lcssa = $p$0$i;
       break L50;
      }
     }
    } while (0);
    $137 = HEAP32[$113 + ($p$0$i << 2) >> 2] | 0;
    if (!$137) {
     $p$0$i$lcssa43 = $p$0$i;
     label = 43;
     break L3;
    } else $p$0$i = $137;
   }
   HEAP32[4241] = 1;
   HEAP32[4672] = $p$0$i$lcssa;
   $205 = $93;
   $206 = $95;
  } while (0);
  if ((HEAP8[$205 + $206 >> 0] | 0) == 125) {
   label = 54;
   break;
  } else {
   $6 = $206;
   $8 = $205;
  }
 }
 if ((label | 0) == 8) {
  $24 = HEAP32[3989] | 0;
  $26 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer >> 2] = 1364;
  HEAP32[$vararg_buffer + 4 >> 2] = $26;
  HEAP32[$vararg_buffer + 8 >> 2] = 34;
  _fprintf($24, 1357, $vararg_buffer) | 0;
  $27 = HEAP32[3990] | 0;
  $29 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 1364;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $29;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 34;
  _fprintf($27, 1357, $vararg_buffer3) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 10) {
  _fwrite(1383, 23, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1383, 23, 1, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 12) {
  $41 = HEAP32[3989] | 0;
  $43 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer8 >> 2] = 1369;
  HEAP32[$vararg_buffer8 + 4 >> 2] = $43;
  HEAP32[$vararg_buffer8 + 8 >> 2] = 34;
  _fprintf($41, 1357, $vararg_buffer8) | 0;
  $44 = HEAP32[3990] | 0;
  $46 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer13 >> 2] = 1369;
  HEAP32[$vararg_buffer13 + 4 >> 2] = $46;
  HEAP32[$vararg_buffer13 + 8 >> 2] = 34;
  _fprintf($44, 1357, $vararg_buffer13) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 16) {
  $53 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer18 >> 2] = 4345;
  _fprintf($53, 960, $vararg_buffer18) | 0;
  $54 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer21 >> 2] = 4345;
  _fprintf($54, 960, $vararg_buffer21) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 43) {
  HEAP32[4672] = $p$0$i$lcssa43;
  _fwrite(4384, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4384, 38, 1, HEAP32[3990] | 0) | 0;
  $141 = HEAP32[3990] | 0;
  $142 = HEAP32[4044] | 0;
  $143 = HEAP32[4045] | 0;
  if (($142 | 0) < ($143 | 0)) {
   $i$01$i$i1 = $142;
   while (1) {
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i$i1 >> 0] | 0) >> 0] | 0, $141) | 0;
    $152 = $i$01$i$i1 + 1 | 0;
    $153 = HEAP32[4045] | 0;
    if (($152 | 0) < ($153 | 0)) $i$01$i$i1 = $152; else {
     $$lcssa = $153;
     break;
    }
   }
   $156 = HEAP32[4044] | 0;
   $158 = $$lcssa;
  } else {
   $156 = $142;
   $158 = $143;
  }
  $155 = HEAP32[3989] | 0;
  if (($156 | 0) < ($158 | 0)) {
   $i$01$i1$i = $156;
   while (1) {
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $155) | 0;
    $166 = $i$01$i1$i + 1 | 0;
    if (($166 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $166; else break;
   }
   $169 = HEAP32[3989] | 0;
  } else $169 = $155;
  _fwrite(4423, 5, 1, $169) | 0;
  _fwrite(4423, 5, 1, HEAP32[3990] | 0) | 0;
  $172 = HEAP32[4249] | 0;
  $179 = HEAP32[(HEAP32[4099] | 0) + (HEAP32[$172 + (HEAP32[$172 + (HEAP32[4250] << 2) >> 2] << 2) >> 2] << 2) >> 2] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $179);
  _zoutpoolstr(HEAP32[3989] | 0, $179);
  _putc(10, HEAP32[3989] | 0) | 0;
  _putc(10, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 51) _hashciteconfusion(); else if ((label | 0) == 54) {
  STACKTOP = sp;
  return;
 }
}

function _getthetoplevelauxfilename() {
 var $$lcssa = 0, $$lcssa1$i = 0, $$lcssa1$i19 = 0, $$lcssa1$i30 = 0, $$lcssa1$i8 = 0, $$lcssa61 = 0, $$lcssa62 = 0, $$lcssa71 = 0, $$lcssa72 = 0, $$lcssa73 = 0, $$lcssa74 = 0, $$lcssa75 = 0, $10 = 0, $100 = 0, $103 = 0, $104 = 0, $105 = 0, $123 = 0, $124 = 0, $129 = 0, $130 = 0, $131 = 0, $132 = 0, $134 = 0, $135 = 0, $137 = 0, $144 = 0, $146 = 0, $147 = 0, $148 = 0, $150 = 0, $153 = 0, $154 = 0, $155 = 0, $16 = 0, $17 = 0, $173 = 0, $174 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $184 = 0, $185 = 0, $187 = 0, $194 = 0, $196 = 0, $197 = 0, $198 = 0, $20 = 0, $200 = 0, $203 = 0, $204 = 0, $205 = 0, $21 = 0, $219 = 0, $220 = 0, $225 = 0, $23 = 0, $231 = 0, $235 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $30 = 0, $31 = 0, $32 = 0, $34 = 0, $38 = 0, $4 = 0, $41 = 0, $43 = 0, $44 = 0, $45 = 0, $47 = 0, $50 = 0, $51 = 0, $52 = 0, $55 = 0, $58 = 0, $73 = 0, $74 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $84 = 0, $85 = 0, $87 = 0, $9 = 0, $94 = 0, $96 = 0, $97 = 0, $98 = 0, $pptr$02$i13 = 0, $pptr$02$i2 = 0, $pptr$02$i24 = 0, $storemerge1$i = 0, $storemerge1$i10 = 0, $storemerge1$i21 = 0, $storemerge39 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _parsearguments();
 $4 = _xmalloc((_strlen(_cmdline(HEAP32[18] | 0) | 0) | 0) + 6 | 0) | 0;
 HEAP32[4048] = $4;
 _strcpy($4 + 1 | 0, _cmdline(HEAP32[18] | 0) | 0) | 0;
 $8 = HEAP32[4048] | 0;
 $9 = $8 + 1 | 0;
 $10 = _strlen($9) | 0;
 HEAP32[4047] = $10;
 HEAP32[4049] = $10;
 if (($10 | 0) < 4) label = 3; else if (!(_strcmp($9 + $10 + -4 | 0, 8203) | 0)) {
  HEAP32[4047] = $10 + -4;
  $58 = $8;
 } else label = 3;
 if ((label | 0) == 3) {
  $16 = HEAP32[4259] | 0;
  $17 = $10 + 1 | 0;
  HEAP32[4046] = $17;
  $18 = HEAP32[4041] | 0;
  $20 = HEAP32[$18 + ($16 << 2) >> 2] | 0;
  $21 = $16 + 1 | 0;
  $23 = HEAP32[$18 + ($21 << 2) >> 2] | 0;
  if (($20 | 0) < ($23 | 0)) {
   HEAP8[$8 + $17 >> 0] = HEAP8[(HEAP32[4042] | 0) + $20 >> 0] | 0;
   $30 = (HEAP32[4046] | 0) + 1 | 0;
   HEAP32[4046] = $30;
   $31 = $20 + 1 | 0;
   $32 = HEAP32[4041] | 0;
   $34 = HEAP32[$32 + ($21 << 2) >> 2] | 0;
   if (($31 | 0) < ($34 | 0)) {
    $38 = $31;
    $41 = $30;
    while (1) {
     HEAP8[(HEAP32[4048] | 0) + $41 >> 0] = HEAP8[(HEAP32[4042] | 0) + $38 >> 0] | 0;
     $43 = (HEAP32[4046] | 0) + 1 | 0;
     HEAP32[4046] = $43;
     $44 = $38 + 1 | 0;
     $45 = HEAP32[4041] | 0;
     $47 = HEAP32[$45 + ($21 << 2) >> 2] | 0;
     if (($44 | 0) < ($47 | 0)) {
      $38 = $44;
      $41 = $43;
     } else {
      $$lcssa61 = $45;
      $$lcssa62 = $47;
      break;
     }
    }
   } else {
    $$lcssa61 = $32;
    $$lcssa62 = $34;
   }
   $$lcssa1$i = $$lcssa62;
   $50 = HEAP32[$$lcssa61 + ($16 << 2) >> 2] | 0;
   $52 = HEAP32[4049] | 0;
   $55 = HEAP32[4048] | 0;
  } else {
   $$lcssa1$i = $23;
   $50 = $20;
   $52 = $10;
   $55 = $8;
  }
  $51 = $$lcssa1$i - $50 + $52 | 0;
  HEAP32[4049] = $51;
  HEAP8[$55 + ($51 + 1) >> 0] = 0;
  $58 = HEAP32[4048] | 0;
 }
 HEAP32[4050] = 0;
 if (_kpse_in_name_ok($58 + 1 | 0) | 0) if (_open_input(18576 + (HEAP32[4050] << 2) | 0, -1, 4127) | 0) {
  $79 = HEAP32[4047] | 0;
  HEAP32[4049] = $79;
  $80 = HEAP32[4261] | 0;
  $81 = $79 + 1 | 0;
  HEAP32[4046] = $81;
  $82 = HEAP32[4041] | 0;
  $84 = HEAP32[$82 + ($80 << 2) >> 2] | 0;
  $85 = $80 + 1 | 0;
  $87 = HEAP32[$82 + ($85 << 2) >> 2] | 0;
  if (($84 | 0) < ($87 | 0)) {
   $94 = $81;
   $pptr$02$i2 = $84;
   while (1) {
    HEAP8[(HEAP32[4048] | 0) + $94 >> 0] = HEAP8[(HEAP32[4042] | 0) + $pptr$02$i2 >> 0] | 0;
    $96 = (HEAP32[4046] | 0) + 1 | 0;
    HEAP32[4046] = $96;
    $97 = $pptr$02$i2 + 1 | 0;
    $98 = HEAP32[4041] | 0;
    $100 = HEAP32[$98 + ($85 << 2) >> 2] | 0;
    if (($97 | 0) < ($100 | 0)) {
     $94 = $96;
     $pptr$02$i2 = $97;
    } else {
     $$lcssa74 = $98;
     $$lcssa75 = $100;
     break;
    }
   }
   $$lcssa1$i8 = $$lcssa75;
   $103 = HEAP32[$$lcssa74 + ($80 << 2) >> 2] | 0;
   $105 = HEAP32[4049] | 0;
  } else {
   $$lcssa1$i8 = $87;
   $103 = $84;
   $105 = $79;
  }
  $104 = $$lcssa1$i8 - $103 + $105 | 0;
  HEAP32[4049] = $104;
  HEAP8[(HEAP32[4048] | 0) + ($104 + 1) >> 0] = 0;
  if (_kpse_out_name_ok((HEAP32[4048] | 0) + 1 | 0) | 0) if (_open_output(15956, 6125) | 0) {
   $129 = HEAP32[4047] | 0;
   HEAP32[4049] = $129;
   $130 = HEAP32[4260] | 0;
   $131 = $129 + 1 | 0;
   HEAP32[4046] = $131;
   $132 = HEAP32[4041] | 0;
   $134 = HEAP32[$132 + ($130 << 2) >> 2] | 0;
   $135 = $130 + 1 | 0;
   $137 = HEAP32[$132 + ($135 << 2) >> 2] | 0;
   if (($134 | 0) < ($137 | 0)) {
    $144 = $131;
    $pptr$02$i13 = $134;
    while (1) {
     HEAP8[(HEAP32[4048] | 0) + $144 >> 0] = HEAP8[(HEAP32[4042] | 0) + $pptr$02$i13 >> 0] | 0;
     $146 = (HEAP32[4046] | 0) + 1 | 0;
     HEAP32[4046] = $146;
     $147 = $pptr$02$i13 + 1 | 0;
     $148 = HEAP32[4041] | 0;
     $150 = HEAP32[$148 + ($135 << 2) >> 2] | 0;
     if (($147 | 0) < ($150 | 0)) {
      $144 = $146;
      $pptr$02$i13 = $147;
     } else {
      $$lcssa72 = $148;
      $$lcssa73 = $150;
      break;
     }
    }
    $$lcssa1$i19 = $$lcssa73;
    $153 = HEAP32[$$lcssa72 + ($130 << 2) >> 2] | 0;
    $155 = HEAP32[4049] | 0;
   } else {
    $$lcssa1$i19 = $137;
    $153 = $134;
    $155 = $129;
   }
   $154 = $$lcssa1$i19 - $153 + $155 | 0;
   HEAP32[4049] = $154;
   HEAP8[(HEAP32[4048] | 0) + ($154 + 1) >> 0] = 0;
   if (_kpse_out_name_ok((HEAP32[4048] | 0) + 1 | 0) | 0) if (_open_output(16620, 6125) | 0) {
    $179 = HEAP32[4047] | 0;
    HEAP32[4049] = $179;
    $180 = HEAP32[4259] | 0;
    $181 = $179 + 1 | 0;
    HEAP32[4046] = $181;
    $182 = HEAP32[4041] | 0;
    $184 = HEAP32[$182 + ($180 << 2) >> 2] | 0;
    $185 = $180 + 1 | 0;
    $187 = HEAP32[$182 + ($185 << 2) >> 2] | 0;
    if (($184 | 0) < ($187 | 0)) {
     $194 = $181;
     $pptr$02$i24 = $184;
     while (1) {
      HEAP8[(HEAP32[4048] | 0) + $194 >> 0] = HEAP8[(HEAP32[4042] | 0) + $pptr$02$i24 >> 0] | 0;
      $196 = (HEAP32[4046] | 0) + 1 | 0;
      HEAP32[4046] = $196;
      $197 = $pptr$02$i24 + 1 | 0;
      $198 = HEAP32[4041] | 0;
      $200 = HEAP32[$198 + ($185 << 2) >> 2] | 0;
      if (($197 | 0) < ($200 | 0)) {
       $194 = $196;
       $pptr$02$i24 = $197;
      } else {
       $$lcssa = $198;
       $$lcssa71 = $200;
       break;
      }
     }
     $$lcssa1$i30 = $$lcssa71;
     $203 = HEAP32[$$lcssa + ($180 << 2) >> 2] | 0;
     $205 = HEAP32[4049] | 0;
    } else {
     $$lcssa1$i30 = $187;
     $203 = $184;
     $205 = $179;
    }
    $204 = $$lcssa1$i30 - $203 + $205 | 0;
    HEAP32[4049] = $204;
    HEAP8[(HEAP32[4048] | 0) + ($204 + 1) >> 0] = 0;
    HEAP32[4046] = 1;
    if ((HEAP32[4049] | 0) >= 1) {
     $storemerge39 = 1;
     while (1) {
      HEAP8[(HEAP32[3993] | 0) + $storemerge39 >> 0] = HEAP8[25621 + (HEAPU8[(HEAP32[4048] | 0) + $storemerge39 >> 0] | 0) >> 0] | 0;
      $219 = HEAP32[4046] | 0;
      $220 = $219 + 1 | 0;
      HEAP32[4046] = $220;
      if (($219 | 0) < (HEAP32[4049] | 0)) $storemerge39 = $220; else break;
     }
    }
    $225 = _zstrlookup(HEAP32[3993] | 0, 1, HEAP32[4047] | 0, 0, 1) | 0;
    HEAP32[4665] = HEAP32[(HEAP32[4145] | 0) + ($225 << 2) >> 2];
    $231 = _zstrlookup(HEAP32[3993] | 0, 1, HEAP32[4049] | 0, 3, 1) | 0;
    $235 = HEAP32[4050] | 0;
    HEAP32[16204 + ($235 << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + ($231 << 2) >> 2];
    if (!(HEAP32[4241] | 0)) {
     HEAP32[16288 + ($235 << 2) >> 2] = 0;
     STACKTOP = sp;
     return;
    } else {
     _fwrite(4130, 34, 1, HEAP32[3989] | 0) | 0;
     _fwrite(4130, 34, 1, HEAP32[3990] | 0) | 0;
     $241 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer >> 2] = 964;
     _fprintf($241, 960, $vararg_buffer) | 0;
     $242 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer1 >> 2] = 964;
     _fprintf($242, 960, $vararg_buffer1) | 0;
     $243 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer4 >> 2] = 985;
     _fprintf($243, 960, $vararg_buffer4) | 0;
     $244 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer7 >> 2] = 985;
     _fprintf($244, 960, $vararg_buffer7) | 0;
     HEAP8[25620] = 3;
     _longjmp(16008, 1);
    }
   }
   _fwrite(1252, 27, 1, HEAP32[3990] | 0) | 0;
   HEAP32[4046] = 1;
   if ((HEAP32[4049] | 0) >= 1) {
    $storemerge1$i21 = 1;
    while (1) {
     _putc(HEAPU8[(HEAP32[4048] | 0) + $storemerge1$i21 >> 0] | 0, HEAP32[3990] | 0) | 0;
     $173 = HEAP32[4046] | 0;
     $174 = $173 + 1 | 0;
     HEAP32[4046] = $174;
     if (($173 | 0) < (HEAP32[4049] | 0)) $storemerge1$i21 = $174; else break;
    }
   }
   _putc(39, HEAP32[3990] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   _uexit(1);
  }
  _fwrite(1252, 27, 1, HEAP32[3990] | 0) | 0;
  HEAP32[4046] = 1;
  if ((HEAP32[4049] | 0) >= 1) {
   $storemerge1$i10 = 1;
   while (1) {
    _putc(HEAPU8[(HEAP32[4048] | 0) + $storemerge1$i10 >> 0] | 0, HEAP32[3990] | 0) | 0;
    $123 = HEAP32[4046] | 0;
    $124 = $123 + 1 | 0;
    HEAP32[4046] = $124;
    if (($123 | 0) < (HEAP32[4049] | 0)) $storemerge1$i10 = $124; else break;
   }
  }
  _putc(39, HEAP32[3990] | 0) | 0;
  _putc(10, HEAP32[3990] | 0) | 0;
  _uexit(1);
 }
 _fwrite(1252, 27, 1, HEAP32[3990] | 0) | 0;
 HEAP32[4046] = 1;
 if ((HEAP32[4049] | 0) >= 1) {
  $storemerge1$i = 1;
  while (1) {
   _putc(HEAPU8[(HEAP32[4048] | 0) + $storemerge1$i >> 0] | 0, HEAP32[3990] | 0) | 0;
   $73 = HEAP32[4046] | 0;
   $74 = $73 + 1 | 0;
   HEAP32[4046] = $74;
   if (($73 | 0) < (HEAP32[4049] | 0)) $storemerge1$i = $74; else break;
  }
 }
 _putc(39, HEAP32[3990] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _uexit(1);
}

function _xgets() {
 var $$pre12 = 0, $$pre14 = 0, $$pre15 = 0, $0 = 0, $101 = 0, $102 = 0, $106 = 0, $107 = 0, $108 = 0, $110 = 0, $113 = 0, $115 = 0, $119 = 0, $121 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $132 = 0, $135 = 0, $139 = 0, $14 = 0, $141 = 0, $142 = 0, $146 = 0, $148 = 0, $154 = 0, $160 = 0, $161 = 0, $19 = 0, $26 = 0, $37 = 0, $38 = 0, $40 = 0, $43 = 0, $45 = 0, $49 = 0, $51 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $62 = 0, $65 = 0, $69 = 0, $71 = 0, $72 = 0, $76 = 0, $78 = 0, $83 = 0, $85 = 0, $86 = 0, $89 = 0, $9 = 0, $90 = 0, $95 = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer16 = 0, $vararg_buffer2 = 0, $vararg_buffer20 = 0, $vararg_buffer23 = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer23 = sp + 56 | 0;
 $vararg_buffer20 = sp + 48 | 0;
 $vararg_buffer16 = sp + 40 | 0;
 $vararg_buffer12 = sp + 32 | 0;
 $vararg_buffer9 = sp + 24 | 0;
 $vararg_buffer6 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 2:
  {
   $6 = HEAP32[4345] | 0;
   $9 = HEAP8[(HEAP32[4144] | 0) + $6 >> 0] | 0;
   if ((HEAP32[4152] | 0) == 0 & ($9 + -5 & 255) < 2) {
    _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
    _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
    _bstexwarnprint();
    STACKTOP = sp;
    return;
   }
   switch ($9 & 255 | 0) {
   case 5:
    {
     $13 = HEAP8[26649] | 0;
     $14 = HEAP32[4365] | 0;
     switch ($13 << 24 >> 24) {
     case 0:
      {
       $19 = Math_imul(HEAP32[4368] | 0, HEAP32[4150] | 0) | 0;
       HEAP32[(HEAP32[4369] | 0) + ((HEAP32[(HEAP32[4249] | 0) + ($6 << 2) >> 2] | 0) + $19 << 2) >> 2] = $14;
       STACKTOP = sp;
       return;
      }
     case 4:
      {
       STACKTOP = sp;
       return;
      }
     default:
      {
       _zprintstklit($14, $13);
       _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
       STACKTOP = sp;
       return;
      }
     }
     break;
    }
   case 6:
    {
     $26 = HEAP8[26649] | 0;
     switch ($26 << 24 >> 24) {
     case 1:
      {
       HEAP32[4370] = (Math_imul(HEAP32[4255] | 0, HEAP32[4150] | 0) | 0) + (HEAP32[(HEAP32[4249] | 0) + ($6 << 2) >> 2] | 0);
       HEAP32[4371] = 0;
       $37 = HEAP32[4365] | 0;
       $38 = HEAP32[4041] | 0;
       $40 = HEAP32[$38 + ($37 << 2) >> 2] | 0;
       HEAP32[4343] = $40;
       $43 = HEAP32[$38 + ($37 + 1 << 2) >> 2] | 0;
       HEAP32[4348] = $43;
       $45 = HEAP32[4257] | 0;
       if (($43 - $40 | 0) > ($45 | 0)) {
        _fwrite(2519, 25, 1, HEAP32[3989] | 0) | 0;
        _fwrite(2519, 25, 1, HEAP32[3990] | 0) | 0;
        $49 = HEAP32[3989] | 0;
        HEAP32[$vararg_buffer >> 2] = HEAP32[4257];
        HEAP32[$vararg_buffer + 4 >> 2] = 3727;
        _fprintf($49, 2418, $vararg_buffer) | 0;
        $51 = HEAP32[3990] | 0;
        HEAP32[$vararg_buffer2 >> 2] = HEAP32[4257];
        HEAP32[$vararg_buffer2 + 4 >> 2] = 3727;
        _fprintf($51, 2418, $vararg_buffer2) | 0;
        _fwrite(2545, 13, 1, HEAP32[3989] | 0) | 0;
        _fwrite(2545, 13, 1, HEAP32[3990] | 0) | 0;
        _bstmildexwarnprint();
        $55 = HEAP32[3989] | 0;
        HEAP32[$vararg_buffer6 >> 2] = 2559;
        _fprintf($55, 960, $vararg_buffer6) | 0;
        $56 = HEAP32[3990] | 0;
        HEAP32[$vararg_buffer9 >> 2] = 2559;
        _fprintf($56, 960, $vararg_buffer9) | 0;
        $57 = HEAP32[4343] | 0;
        $58 = HEAP32[4257] | 0;
        $59 = $58 + $57 | 0;
        HEAP32[4348] = $59;
        $160 = $58;
        $60 = $57;
        $62 = $59;
       } else {
        $160 = $45;
        $60 = $40;
        $62 = $43;
       }
       $$pre15 = HEAP32[4371] | 0;
       if (($60 | 0) < ($62 | 0)) {
        $65 = $60;
        $69 = $160;
        $72 = $$pre15;
        while (1) {
         $71 = (Math_imul($69 + 1 | 0, HEAP32[4370] | 0) | 0) + $72 | 0;
         HEAP8[(HEAP32[4258] | 0) + $71 >> 0] = HEAP8[(HEAP32[4042] | 0) + $65 >> 0] | 0;
         $76 = (HEAP32[4371] | 0) + 1 | 0;
         HEAP32[4371] = $76;
         $78 = (HEAP32[4343] | 0) + 1 | 0;
         HEAP32[4343] = $78;
         $$pre14 = HEAP32[4257] | 0;
         if (($78 | 0) < (HEAP32[4348] | 0)) {
          $65 = $78;
          $69 = $$pre14;
          $72 = $76;
         } else {
          $83 = $$pre14;
          $86 = $76;
          break;
         }
        }
       } else {
        $83 = $160;
        $86 = $$pre15;
       }
       $85 = (Math_imul($83 + 1 | 0, HEAP32[4370] | 0) | 0) + $86 | 0;
       HEAP8[(HEAP32[4258] | 0) + $85 >> 0] = 127;
       STACKTOP = sp;
       return;
      }
     case 4:
      {
       STACKTOP = sp;
       return;
      }
     default:
      {
       _zprintstklit(HEAP32[4365] | 0, $26);
       _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
       STACKTOP = sp;
       return;
      }
     }
     break;
    }
   case 7:
    {
     $89 = HEAP8[26649] | 0;
     $90 = HEAP32[4365] | 0;
     switch ($89 << 24 >> 24) {
     case 0:
      {
       HEAP32[(HEAP32[4249] | 0) + ($6 << 2) >> 2] = $90;
       STACKTOP = sp;
       return;
      }
     case 4:
      {
       STACKTOP = sp;
       return;
      }
     default:
      {
       _zprintstklit($90, $89);
       _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
       STACKTOP = sp;
       return;
      }
     }
     break;
    }
   case 8:
    {
     $95 = HEAP8[26649] | 0;
     switch ($95 << 24 >> 24) {
     case 1:
      {
       $101 = HEAP32[(HEAP32[4249] | 0) + ($6 << 2) >> 2] | 0;
       HEAP32[4372] = $101;
       $102 = HEAP32[4365] | 0;
       $106 = (HEAP32[4373] | 0) + ($101 << 2) | 0;
       if (($102 | 0) < (HEAP32[4364] | 0)) {
        HEAP32[$106 >> 2] = $102;
        STACKTOP = sp;
        return;
       }
       HEAP32[$106 >> 2] = 0;
       HEAP32[4374] = 0;
       $107 = HEAP32[4365] | 0;
       $108 = HEAP32[4041] | 0;
       $110 = HEAP32[$108 + ($107 << 2) >> 2] | 0;
       HEAP32[4343] = $110;
       $113 = HEAP32[$108 + ($107 + 1 << 2) >> 2] | 0;
       HEAP32[4344] = $113;
       $115 = HEAP32[4307] | 0;
       if (($113 - $110 | 0) > ($115 | 0)) {
        _fwrite(2519, 25, 1, HEAP32[3989] | 0) | 0;
        _fwrite(2519, 25, 1, HEAP32[3990] | 0) | 0;
        $119 = HEAP32[3989] | 0;
        HEAP32[$vararg_buffer12 >> 2] = HEAP32[4307];
        HEAP32[$vararg_buffer12 + 4 >> 2] = 3739;
        _fprintf($119, 2418, $vararg_buffer12) | 0;
        $121 = HEAP32[3990] | 0;
        HEAP32[$vararg_buffer16 >> 2] = HEAP32[4307];
        HEAP32[$vararg_buffer16 + 4 >> 2] = 3739;
        _fprintf($121, 2418, $vararg_buffer16) | 0;
        _fwrite(2545, 13, 1, HEAP32[3989] | 0) | 0;
        _fwrite(2545, 13, 1, HEAP32[3990] | 0) | 0;
        _bstmildexwarnprint();
        $125 = HEAP32[3989] | 0;
        HEAP32[$vararg_buffer20 >> 2] = 2559;
        _fprintf($125, 960, $vararg_buffer20) | 0;
        $126 = HEAP32[3990] | 0;
        HEAP32[$vararg_buffer23 >> 2] = 2559;
        _fprintf($126, 960, $vararg_buffer23) | 0;
        $127 = HEAP32[4343] | 0;
        $128 = HEAP32[4307] | 0;
        $129 = $128 + $127 | 0;
        HEAP32[4344] = $129;
        $130 = $127;
        $132 = $129;
        $161 = $128;
       } else {
        $130 = $110;
        $132 = $113;
        $161 = $115;
       }
       $$pre12 = HEAP32[4374] | 0;
       L52 : do if (($130 | 0) < ($132 | 0)) {
        $135 = $130;
        $139 = $161;
        $142 = $$pre12;
        while (1) {
         $141 = (Math_imul($139 + 1 | 0, HEAP32[4372] | 0) | 0) + $142 | 0;
         HEAP8[(HEAP32[4375] | 0) + $141 >> 0] = HEAP8[(HEAP32[4042] | 0) + $135 >> 0] | 0;
         $146 = (HEAP32[4374] | 0) + 1 | 0;
         HEAP32[4374] = $146;
         $148 = (HEAP32[4343] | 0) + 1 | 0;
         HEAP32[4343] = $148;
         if (($148 | 0) >= (HEAP32[4344] | 0)) {
          $154 = $146;
          break L52;
         }
         $135 = $148;
         $139 = HEAP32[4307] | 0;
         $142 = $146;
        }
       } else $154 = $$pre12; while (0);
       HEAP32[(HEAP32[4376] | 0) + (HEAP32[4372] << 2) >> 2] = $154;
       STACKTOP = sp;
       return;
      }
     case 4:
      {
       STACKTOP = sp;
       return;
      }
     default:
      {
       _zprintstklit(HEAP32[4365] | 0, $95);
       _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
       STACKTOP = sp;
       return;
      }
     }
     break;
    }
   default:
    {
     _fwrite(3752, 25, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3752, 25, 1, HEAP32[3990] | 0) | 0;
     _zprintfnclass(HEAP32[4345] | 0);
     _fwrite(3778, 30, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3778, 30, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
     STACKTOP = sp;
     return;
    }
   }
   break;
  }
 case 4:
  {
   STACKTOP = sp;
   return;
  }
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3549, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3549, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
   STACKTOP = sp;
   return;
  }
 }
}

function _kpathsea_find_file_generic($kpse, $const_name, $format, $must_exist, $all) {
 $kpse = $kpse | 0;
 $const_name = $const_name | 0;
 $format = $format | 0;
 $must_exist = $must_exist | 0;
 $all = $all | 0;
 var $$in = 0, $$in51 = 0, $$lcssa = 0, $$lcssa76 = 0, $$lcssa77 = 0, $$lcssa78 = 0, $$lcssa79 = 0, $101 = 0, $102 = 0, $105 = 0, $106 = 0, $109 = 0, $113 = 0, $116 = 0, $117 = 0, $119 = 0, $120 = 0, $121 = 0, $123 = 0, $125 = 0, $128 = 0, $129 = 0, $131 = 0, $133 = 0, $134 = 0, $136 = 0, $137 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $145 = 0, $148 = 0, $150 = 0, $151 = 0, $152 = 0, $154 = 0, $158 = 0, $159 = 0, $16 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $29 = 0, $30 = 0, $32 = 0, $33 = 0, $36 = 0, $40 = 0, $43 = 0, $45 = 0, $46 = 0, $48 = 0, $49 = 0, $5 = 0, $52 = 0, $56 = 0, $58 = 0, $66 = 0, $67 = 0, $69 = 0, $7 = 0, $71 = 0, $72 = 0, $75 = 0, $76 = 0, $79 = 0, $80 = 0, $85 = 0, $86 = 0, $87 = 0, $89 = 0, $92 = 0, $93 = 0, $95 = 0, $97 = 0, $98 = 0, $count = 0, $ext$032$be = 0, $ext$03269 = 0, $ext$131$be = 0, $ext$13166 = 0, $ext$225 = 0, $has_any_suffix$1 = 0, $has_potential_suffix$3 = 0, $has_potential_suffix$3$shrunk = 0, $mapped_names$01$i = 0, $mapped_names$01$i15 = 0, $ret$0 = 0, $ret$1 = 0, $target = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer = sp;
 $target = sp + 16 | 0;
 $count = sp + 12 | 0;
 $2 = ($format | 2 | 0) == 3;
 $5 = (($format | 0) == 20 | (($format | 0) == 0 | $2)) & 1;
 if (!$const_name) ___assert_fail(9784, 9795, 1028, 9829);
 $7 = $kpse + 132 + ($format * 68 | 0) + 4 | 0;
 if (!(HEAP32[$7 >> 2] | 0)) _kpathsea_init_format_return_varlist($kpse, $format) | 0;
 if (HEAP32[$kpse + 44 >> 2] & 32 | 0) {
  $14 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $14) | 0;
  $16 = HEAP32[$kpse + 132 + ($format * 68 | 0) >> 2] | 0;
  $18 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 12 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $const_name;
  HEAP32[$vararg_buffer + 4 >> 2] = $16;
  HEAP32[$vararg_buffer + 8 >> 2] = $18;
  _fprintf($14, 9856, $vararg_buffer) | 0;
  _fflush($14) | 0;
 }
 $19 = _kpathsea_expand($kpse, $const_name) | 0;
 $20 = _kpathsea_var_value($kpse, 9911) | 0;
 $21 = _strrchr($19, 46) | 0;
 if (!$21) $has_any_suffix$1 = 0; else {
  $24 = (_strchr($21, 47) | 0) == 0;
  $has_any_suffix$1 = $24 ? $21 : 0;
 }
 $25 = _strlen($19) | 0;
 $26 = $kpse + 132 + ($format * 68 | 0) + 32 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 L13 : do if (!$27) label = 15; else {
  $29 = $19 + $25 | 0;
  $30 = HEAP32[$27 >> 2] | 0;
  if (!$30) label = 15; else {
   $32 = $30;
   $ext$03269 = $27;
   while (1) {
    $33 = _strlen($32) | 0;
    if ($25 >>> 0 >= $33 >>> 0) {
     $36 = $29 + (0 - $33) | 0;
     if ($36 | 0) if (!(_strcmp($32, $36) | 0)) {
      $has_potential_suffix$3$shrunk = 1;
      break L13;
     }
    }
    $ext$032$be = $ext$03269 + 4 | 0;
    $40 = HEAP32[$ext$032$be >> 2] | 0;
    if (!$40) {
     label = 15;
     break;
    } else {
     $32 = $40;
     $ext$03269 = $ext$032$be;
    }
   }
  }
 } while (0);
 L21 : do if ((label | 0) == 15) {
  $43 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 36 >> 2] | 0;
  if (!$43) $has_potential_suffix$3$shrunk = 0; else {
   $45 = $19 + $25 | 0;
   $46 = HEAP32[$43 >> 2] | 0;
   if (!$46) $has_potential_suffix$3$shrunk = 0; else {
    $48 = $46;
    $ext$13166 = $43;
    while (1) {
     $49 = _strlen($48) | 0;
     if ($25 >>> 0 >= $49 >>> 0) {
      $52 = $45 + (0 - $49) | 0;
      if ($52 | 0) if (!(_strcmp($48, $52) | 0)) {
       $has_potential_suffix$3$shrunk = 1;
       break L21;
      }
     }
     $ext$131$be = $ext$13166 + 4 | 0;
     $56 = HEAP32[$ext$131$be >> 2] | 0;
     if (!$56) {
      $has_potential_suffix$3$shrunk = 0;
      break;
     } else {
      $48 = $56;
      $ext$13166 = $ext$131$be;
     }
    }
   }
  }
 } while (0);
 $has_potential_suffix$3 = $has_potential_suffix$3$shrunk & 1;
 HEAP32[$count >> 2] = 0;
 $58 = _xmalloc(4) | 0;
 HEAP32[$target >> 2] = $58;
 L31 : do if (!$has_any_suffix$1) label = 33; else {
  if ($20 | 0) switch (HEAP8[$20 >> 0] | 0) {
  case 48:
  case 102:
   break;
  default:
   {
    label = 33;
    break L31;
   }
  }
  if ($has_potential_suffix$3$shrunk) label = 26; else if (!(HEAP32[$kpse + 132 + ($format * 68 | 0) + 40 >> 2] | 0)) label = 26;
  L38 : do if ((label | 0) == 26) {
   HEAP32[$58 >> 2] = _xstrdup($19) | 0;
   HEAP32[$count >> 2] = 1;
   $66 = _xrealloc($58, 8) | 0;
   HEAP32[$target >> 2] = $66;
   if (!$2) switch ($format | 0) {
   case 0:
   case 20:
    break;
   default:
    break L38;
   }
   $67 = _kpathsea_fontmap_lookup($kpse, $19) | 0;
   if ($67 | 0) {
    $69 = HEAP32[$67 >> 2] | 0;
    if ($69 | 0) {
     $$in = $66;
     $72 = $69;
     $75 = 1;
     $mapped_names$01$i = $67;
     while (1) {
      $71 = $mapped_names$01$i + 4 | 0;
      HEAP32[$$in + ($75 << 2) >> 2] = _xstrdup($72) | 0;
      $76 = $75 + 1 | 0;
      $79 = _xrealloc($$in, ($75 << 2) + 8 | 0) | 0;
      HEAP32[$target >> 2] = $79;
      $80 = HEAP32[$71 >> 2] | 0;
      if (!$80) {
       $$lcssa79 = $76;
       break;
      } else {
       $$in = $79;
       $72 = $80;
       $75 = $76;
       $mapped_names$01$i = $71;
      }
     }
     HEAP32[$count >> 2] = $$lcssa79;
    }
   }
  } while (0);
  _target_suffixed_names($kpse, $target, $count, $format, $19, $5, $has_potential_suffix$3);
 } while (0);
 L48 : do if ((label | 0) == 33) {
  _target_suffixed_names($kpse, $target, $count, $format, $19, $5, $has_potential_suffix$3);
  if (!$has_potential_suffix$3$shrunk) if (HEAP32[$kpse + 132 + ($format * 68 | 0) + 40 >> 2] | 0) break;
  $85 = _xstrdup($19) | 0;
  $86 = HEAP32[$count >> 2] | 0;
  $87 = HEAP32[$target >> 2] | 0;
  HEAP32[$87 + ($86 << 2) >> 2] = $85;
  $89 = $86 + 1 | 0;
  HEAP32[$count >> 2] = $89;
  $92 = _xrealloc($87, ($86 << 2) + 8 | 0) | 0;
  HEAP32[$target >> 2] = $92;
  if (!$2) switch ($format | 0) {
  case 0:
  case 20:
   break;
  default:
   break L48;
  }
  $93 = _kpathsea_fontmap_lookup($kpse, $19) | 0;
  if ($93 | 0) {
   $95 = HEAP32[$93 >> 2] | 0;
   if ($95 | 0) {
    $$in51 = $92;
    $101 = $89;
    $98 = $95;
    $mapped_names$01$i15 = $93;
    while (1) {
     $97 = $mapped_names$01$i15 + 4 | 0;
     HEAP32[$$in51 + ($101 << 2) >> 2] = _xstrdup($98) | 0;
     $102 = $101 + 1 | 0;
     $105 = _xrealloc($$in51, ($101 << 2) + 8 | 0) | 0;
     HEAP32[$target >> 2] = $105;
     $106 = HEAP32[$97 >> 2] | 0;
     if (!$106) {
      $$lcssa78 = $102;
      break;
     } else {
      $$in51 = $105;
      $101 = $102;
      $98 = $106;
      $mapped_names$01$i15 = $97;
     }
    }
    HEAP32[$count >> 2] = $$lcssa78;
   }
  }
 } while (0);
 $109 = HEAP32[$target >> 2] | 0;
 HEAP32[$109 + (HEAP32[$count >> 2] << 2) >> 2] = 0;
 if ($20 | 0) _free($20);
 $113 = _kpathsea_path_search_list_generic($kpse, HEAP32[$7 >> 2] | 0, $109, 0, $all) | 0;
 $116 = ($must_exist | 0) != 0;
 if ($116 & (HEAP32[$113 >> 2] | 0) == 0) {
  HEAP32[$count >> 2] = 0;
  $117 = HEAP32[$109 >> 2] | 0;
  if ($117 | 0) {
   $119 = $117;
   $121 = 0;
   while (1) {
    _free($119);
    $120 = $121 + 1 | 0;
    $123 = HEAP32[$109 + ($120 << 2) >> 2] | 0;
    if (!$123) {
     $$lcssa77 = $120;
     break;
    } else {
     $119 = $123;
     $121 = $120;
    }
   }
   HEAP32[$count >> 2] = $$lcssa77;
  }
  HEAP32[$count >> 2] = 0;
  if ($has_potential_suffix$3$shrunk) {
   $142 = 0;
   label = 52;
  } else {
   $125 = $kpse + 132 + ($format * 68 | 0) + 40 | 0;
   if (!(HEAP32[$125 >> 2] | 0)) {
    $142 = 0;
    label = 52;
   } else {
    $128 = HEAP32[$26 >> 2] | 0;
    $129 = HEAP32[$128 >> 2] | 0;
    if (!$129) $145 = 0; else {
     $131 = $129;
     $134 = 0;
     $ext$225 = $128;
     while (1) {
      $133 = $134 + 1 | 0;
      HEAP32[$109 + ($134 << 2) >> 2] = _concat($19, $131) | 0;
      $136 = $ext$225 + 4 | 0;
      $137 = HEAP32[$136 >> 2] | 0;
      if (!$137) {
       $$lcssa76 = $133;
       break;
      } else {
       $131 = $137;
       $134 = $133;
       $ext$225 = $136;
      }
     }
     HEAP32[$count >> 2] = $$lcssa76;
     if (!(HEAP32[$125 >> 2] | 0)) {
      $142 = $$lcssa76;
      label = 52;
     } else $145 = $$lcssa76;
    }
   }
  }
  if ((label | 0) == 52) {
   $140 = _xstrdup($19) | 0;
   $141 = $142 + 1 | 0;
   HEAP32[$count >> 2] = $141;
   HEAP32[$109 + ($142 << 2) >> 2] = $140;
   $145 = $141;
  }
  HEAP32[$109 + ($145 << 2) >> 2] = 0;
  $ret$0 = _kpathsea_path_search_list_generic($kpse, HEAP32[$7 >> 2] | 0, $109, 1, $all) | 0;
 } else $ret$0 = $113;
 HEAP32[$count >> 2] = 0;
 $148 = HEAP32[$109 >> 2] | 0;
 if ($148 | 0) {
  $150 = $148;
  $152 = 0;
  while (1) {
   _free($150);
   $151 = $152 + 1 | 0;
   $154 = HEAP32[$109 + ($151 << 2) >> 2] | 0;
   if (!$154) {
    $$lcssa = $151;
    break;
   } else {
    $150 = $154;
    $152 = $151;
   }
  }
  HEAP32[$count >> 2] = $$lcssa;
 }
 _free($109);
 if (!($116 & (HEAP32[$ret$0 >> 2] | 0) == 0)) {
  $ret$1 = $ret$0;
  _free($19);
  STACKTOP = sp;
  return $ret$1 | 0;
 }
 $158 = _xmalloc(8) | 0;
 $159 = _kpathsea_make_tex($kpse, $format, $19) | 0;
 HEAP32[$158 >> 2] = $159;
 if (!$159) {
  $ret$1 = $158;
  _free($19);
  STACKTOP = sp;
  return $ret$1 | 0;
 }
 HEAP32[$158 + 4 >> 2] = 0;
 $ret$1 = $158;
 _free($19);
 STACKTOP = sp;
 return $ret$1 | 0;
}

function _kpathsea_db_search_list($kpse, $names, $path_elt, $all) {
 $kpse = $kpse | 0;
 $names = $names | 0;
 $path_elt = $path_elt | 0;
 $all = $all | 0;
 var $$0 = 0, $$1$i = 0, $$13$i = 0, $$byval_copy8 = 0, $$lcssa = 0, $$pre13$i = 0, $$pre50 = 0, $0 = 0, $10 = 0, $100 = 0, $107 = 0, $11 = 0, $110 = 0, $111 = 0, $114 = 0, $115 = 0, $119 = 0, $12 = 0, $120 = 0, $126 = 0, $14 = 0, $15 = 0, $17 = 0, $19 = 0, $21 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $28 = 0, $30 = 0, $33 = 0, $35 = 0, $37 = 0, $4 = 0, $42 = 0, $44 = 0, $46 = 0, $50 = 0, $52 = 0, $54 = 0, $55 = 0, $60 = 0, $62 = 0, $67 = 0, $69 = 0, $7 = 0, $70 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $83 = 0, $87 = 0, $88 = 0, $9 = 0, $91 = 0, $92 = 0, $95 = 0, $96 = 0, $98 = 0, $99 = 0, $a$020 = 0, $a$020$us = 0, $aliases$152 = 0, $db_dirs$026$us73 = 0, $db_dirs$02671 = 0, $done$1$lcssa$ph = 0, $done$2$lcssa = 0, $e$04579 = 0, $found$1 = 0, $found$1$us = 0, $found$2 = 0, $found$2$us = 0, $found$2$us$lcssa = 0, $i$014 = 0, $len1$0$lcssa = 0, $len1$013 = 0, $n$042$ph = 0, $n$04269 = 0, $n$04269$lcssa = 0, $name$0 = 0, $path$0 = 0, $r$012 = 0, $r$13575 = 0, $temp_str$044$ph = 0, $temp_str$1 = 0, $temp_str$2 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $$byval_copy8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = $kpse + 20 | 0;
 if (!(HEAP32[$0 >> 2] | 0)) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $4 = HEAP32[$kpse + 36 >> 2] | 0;
 if (!$4) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $7 = HEAP32[$kpse + 40 >> 2] | 0;
 $$pre13$i = HEAP8[$path_elt >> 0] | 0;
 $e$04579 = 0;
 L7 : while (1) {
  $9 = HEAP32[$7 + ($e$04579 << 2) >> 2] | 0;
  $$1$i = $path_elt;
  $$13$i = $9;
  $12 = HEAP8[$9 >> 0] | 0;
  $14 = $$pre13$i;
  while (1) {
   $10 = $$13$i + 1 | 0;
   $11 = $$1$i + 1 | 0;
   if ($12 << 24 >> 24 != $14 << 24 >> 24) break;
   $15 = HEAP8[$10 >> 0] | 0;
   if (!($15 << 24 >> 24)) break L7;
   $17 = HEAP8[$11 >> 0] | 0;
   if (!($17 << 24 >> 24)) break; else {
    $$1$i = $11;
    $$13$i = $10;
    $12 = $15;
    $14 = $17;
   }
  }
  $19 = $e$04579 + 1 | 0;
  if ($19 >>> 0 < $4 >>> 0) $e$04579 = $19; else {
   $$0 = 0;
   label = 59;
   break;
  }
 }
 if ((label | 0) == 59) {
  STACKTOP = sp;
  return $$0 | 0;
 }
 $21 = _xmalloc(8) | 0;
 HEAP32[$21 >> 2] = 0;
 HEAP32[$21 + 4 >> 2] = 0;
 $23 = $kpse + 28 | 0;
 $24 = $kpse + 44 | 0;
 $25 = ($all | 0) == 0;
 $26 = HEAP32[21] | 0;
 $n$042$ph = 0;
 $temp_str$044$ph = 0;
 L17 : while (1) {
  $28 = HEAP32[$names + ($n$042$ph << 2) >> 2] | 0;
  if (!$28) {
   $$0 = $21;
   label = 59;
   break;
  } else {
   $30 = $28;
   $n$04269 = $n$042$ph;
  }
  while (1) {
   if (!(_kpathsea_absolute_p($kpse, $30, 1) | 0)) {
    $$lcssa = $30;
    $n$04269$lcssa = $n$04269;
    break;
   }
   $33 = $n$04269 + 1 | 0;
   $35 = HEAP32[$names + ($33 << 2) >> 2] | 0;
   if (!$35) {
    $$0 = $21;
    label = 59;
    break L17;
   } else {
    $30 = $35;
    $n$04269 = $33;
   }
  }
  $37 = _strrchr($$lcssa, 47) | 0;
  if (($37 | 0) == 0 | ($37 | 0) == ($$lcssa | 0)) {
   $name$0 = $$lcssa;
   $path$0 = $path_elt;
   $temp_str$1 = $temp_str$044$ph;
  } else {
   $42 = $37 - $$lcssa | 0;
   $44 = _xmalloc($42 + 1 | 0) | 0;
   _strncpy($44, $$lcssa, $42) | 0;
   HEAP8[$44 + $42 >> 0] = 0;
   $46 = _concat3($path_elt, 13340, $44) | 0;
   _free($44);
   $name$0 = $37 + 1 | 0;
   $path$0 = $46;
   $temp_str$1 = $46;
  }
  if (!(HEAP32[$23 >> 2] | 0)) label = 17; else {
   HEAP32[$$byval_copy8 >> 2] = HEAP32[$23 >> 2];
   HEAP32[$$byval_copy8 + 4 >> 2] = HEAP32[$23 + 4 >> 2];
   $50 = _hash_lookup($$byval_copy8, $name$0) | 0;
   if (!$50) label = 17; else if (!(HEAP32[$50 >> 2] | 0)) {
    $aliases$152 = $50;
    $len1$0$lcssa = 1;
   } else {
    $len1$013 = 1;
    $r$012 = $50;
    while (1) {
     $54 = $len1$013 + 1 | 0;
     $55 = $r$012 + 4 | 0;
     if (!(HEAP32[$55 >> 2] | 0)) {
      $aliases$152 = $50;
      $len1$0$lcssa = $54;
      break;
     } else {
      $len1$013 = $54;
      $r$012 = $55;
     }
    }
   }
  }
  if ((label | 0) == 17) {
   label = 0;
   $52 = _xmalloc(4) | 0;
   HEAP32[$52 >> 2] = 0;
   $aliases$152 = $52;
   $len1$0$lcssa = 1;
  }
  $60 = _xrealloc($aliases$152, ($len1$0$lcssa << 2) + 4 | 0) | 0;
  if ($len1$0$lcssa | 0) {
   $i$014 = $len1$0$lcssa;
   while (1) {
    $62 = $i$014 + -1 | 0;
    HEAP32[$60 + ($i$014 << 2) >> 2] = HEAP32[$60 + ($62 << 2) >> 2];
    if (!$62) break; else $i$014 = $62;
   }
  }
  HEAP32[$60 >> 2] = $name$0;
  $67 = $60 + 4 | 0;
  L38 : do if (!$name$0) $done$1$lcssa$ph = 0; else {
   $69 = $name$0;
   $r$13575 = $60;
   while (1) {
    HEAP32[$$byval_copy8 >> 2] = HEAP32[$0 >> 2];
    HEAP32[$$byval_copy8 + 4 >> 2] = HEAP32[$0 + 4 >> 2];
    $70 = _hash_lookup($$byval_copy8, $69) | 0;
    if ($70 | 0) {
     $72 = HEAP32[$70 >> 2] | 0;
     $73 = ($72 | 0) == 0;
     L43 : do if ($25) if ($73) $done$2$lcssa = 0; else {
      $74 = $72;
      $db_dirs$026$us73 = $70;
      L45 : while (1) {
       $75 = _concat($74, $69) | 0;
       $76 = _match($75, $path$0) | 0;
       if (HEAP32[$24 >> 2] & 32 | 0) {
        _fwrite(13458, 7, 1, $26) | 0;
        HEAP32[$vararg_buffer >> 2] = $75;
        HEAP32[$vararg_buffer + 4 >> 2] = $path$0;
        HEAP32[$vararg_buffer + 8 >> 2] = $76;
        _fprintf($26, 10494, $vararg_buffer) | 0;
        _fflush($26) | 0;
       }
       do if (!$76) _free($75); else {
        if (!(_kpathsea_readable_file($kpse, $75) | 0)) {
         _free($75);
         $83 = HEAP32[$67 >> 2] | 0;
         if (!$83) break; else {
          $87 = $83;
          $a$020$us = $67;
         }
         while (1) {
          $88 = _concat(HEAP32[$db_dirs$026$us73 >> 2] | 0, $87) | 0;
          if (!(_kpathsea_readable_file($kpse, $88) | 0)) {
           _free($88);
           $found$1$us = 0;
          } else $found$1$us = $88;
          $91 = $a$020$us + 4 | 0;
          $92 = HEAP32[$91 >> 2] | 0;
          if (($found$1$us | 0) == 0 & ($92 | 0) != 0) {
           $87 = $92;
           $a$020$us = $91;
          } else {
           $found$2$us = $found$1$us;
           break;
          }
         }
        } else $found$2$us = $75;
        if ($found$2$us | 0) {
         $found$2$us$lcssa = $found$2$us;
         break L45;
        }
       } while (0);
       $95 = $db_dirs$026$us73 + 4 | 0;
       $96 = HEAP32[$95 >> 2] | 0;
       if (!$96) {
        $done$2$lcssa = 0;
        break L43;
       } else {
        $74 = $96;
        $db_dirs$026$us73 = $95;
       }
      }
      _str_list_add($21, $found$2$us$lcssa);
      $done$2$lcssa = 1;
     } else if ($73) $done$2$lcssa = 0; else {
      $98 = $72;
      $db_dirs$02671 = $70;
      while (1) {
       $99 = _concat($98, $69) | 0;
       $100 = _match($99, $path$0) | 0;
       if (HEAP32[$24 >> 2] & 32 | 0) {
        _fwrite(13458, 7, 1, $26) | 0;
        HEAP32[$vararg_buffer3 >> 2] = $99;
        HEAP32[$vararg_buffer3 + 4 >> 2] = $path$0;
        HEAP32[$vararg_buffer3 + 8 >> 2] = $100;
        _fprintf($26, 10494, $vararg_buffer3) | 0;
        _fflush($26) | 0;
       }
       do if (!$100) _free($99); else {
        if (!(_kpathsea_readable_file($kpse, $99) | 0)) {
         _free($99);
         $107 = HEAP32[$67 >> 2] | 0;
         if (!$107) break; else {
          $110 = $107;
          $a$020 = $67;
         }
         while (1) {
          $111 = _concat(HEAP32[$db_dirs$02671 >> 2] | 0, $110) | 0;
          if (!(_kpathsea_readable_file($kpse, $111) | 0)) {
           _free($111);
           $found$1 = 0;
          } else $found$1 = $111;
          $114 = $a$020 + 4 | 0;
          $115 = HEAP32[$114 >> 2] | 0;
          if (($found$1 | 0) == 0 & ($115 | 0) != 0) {
           $110 = $115;
           $a$020 = $114;
          } else {
           $found$2 = $found$1;
           break;
          }
         }
        } else $found$2 = $99;
        if (!$found$2) break;
        _str_list_add($21, $found$2);
       } while (0);
       $119 = $db_dirs$02671 + 4 | 0;
       $120 = HEAP32[$119 >> 2] | 0;
       if (!$120) {
        $done$2$lcssa = 0;
        break;
       } else {
        $98 = $120;
        $db_dirs$02671 = $119;
       }
      }
     } while (0);
     if ($70 | 0) if (HEAP32[$70 >> 2] | 0) _free($70);
     if ($done$2$lcssa | 0) {
      $done$1$lcssa$ph = 1;
      break L38;
     }
    }
    $126 = $r$13575 + 4 | 0;
    $$pre50 = HEAP32[$126 >> 2] | 0;
    if (!$$pre50) {
     $done$1$lcssa$ph = 0;
     break;
    } else {
     $69 = $$pre50;
     $r$13575 = $126;
    }
   }
  } while (0);
  _free($60);
  if (!$temp_str$1) $temp_str$2 = 0; else {
   _free($temp_str$1);
   $temp_str$2 = $temp_str$1;
  }
  if (!$done$1$lcssa$ph) {
   $n$042$ph = $n$04269$lcssa + 1 | 0;
   $temp_str$044$ph = $temp_str$2;
  } else {
   $$0 = $21;
   label = 59;
   break;
  }
 }
 if ((label | 0) == 59) {
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0;
}

function _initialize() {
 var $$ = 0, $10 = 0, $11 = 0, $14 = 0, $15 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $23 = 0, $26 = 0, $32 = 0, $33 = 0, $35 = 0, $36 = 0, $41 = 0, $46 = 0, $47 = 0, $5 = 0, $52 = 0, $6 = 0, $9 = 0, $i$1 = 0, $i$2 = 0, $k$0 = 0, $storemerge10 = 0, $vararg_buffer = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $$ = (HEAP32[3992] | 0) < 80 ? 3 : 0;
 HEAP32[4696] = $$;
 $2 = HEAP32[4240] | 0;
 if (($2 | 0) < 128) {
  $5 = ($$ * 10 | 0) + 4 | 0;
  HEAP32[4696] = $5;
  $9 = $5;
 } else $9 = $$;
 $6 = HEAP32[4245] | 0;
 if (($2 | 0) > ($6 | 0)) {
  $10 = ($9 * 10 | 0) + 5 | 0;
  HEAP32[4696] = $10;
  $14 = $10;
 } else $14 = $9;
 $11 = HEAP32[4001] | 0;
 if (($11 | 0) > ($6 | 0)) {
  $15 = ($14 * 10 | 0) + 7 | 0;
  HEAP32[4696] = $15;
  $19 = $15;
 } else $19 = $14;
 if ((HEAP32[4098] | 0) > ($11 | 0)) {
  $20 = ($19 * 10 | 0) + 8 | 0;
  HEAP32[4696] = $20;
  $21 = $20;
 } else $21 = $19;
 if (($21 | 0) > 0) {
  $23 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer >> 2] = $21;
  HEAP32[$vararg_buffer + 4 >> 2] = 5702;
  _fprintf($23, 5695, $vararg_buffer) | 0;
  _uexit(1);
 }
 HEAP8[25620] = 0;
 HEAP8[26165] = 32;
 HEAP8[26166] = 33;
 HEAP8[26167] = 34;
 HEAP8[26168] = 35;
 HEAP8[26169] = 36;
 HEAP8[26170] = 37;
 HEAP8[26171] = 38;
 HEAP8[26172] = 39;
 HEAP8[26173] = 40;
 HEAP8[26174] = 41;
 HEAP8[26175] = 42;
 HEAP8[26176] = 43;
 HEAP8[26177] = 44;
 HEAP8[26178] = 45;
 HEAP8[26179] = 46;
 HEAP8[26180] = 47;
 HEAP8[26181] = 48;
 HEAP8[26182] = 49;
 HEAP8[26183] = 50;
 HEAP8[26184] = 51;
 HEAP8[26185] = 52;
 HEAP8[26186] = 53;
 HEAP8[26187] = 54;
 HEAP8[26188] = 55;
 HEAP8[26189] = 56;
 HEAP8[26190] = 57;
 HEAP8[26191] = 58;
 HEAP8[26192] = 59;
 HEAP8[26193] = 60;
 HEAP8[26194] = 61;
 HEAP8[26195] = 62;
 HEAP8[26196] = 63;
 HEAP8[26197] = 64;
 HEAP8[26198] = 65;
 HEAP8[26199] = 66;
 HEAP8[26200] = 67;
 HEAP8[26201] = 68;
 HEAP8[26202] = 69;
 HEAP8[26203] = 70;
 HEAP8[26204] = 71;
 HEAP8[26205] = 72;
 HEAP8[26206] = 73;
 HEAP8[26207] = 74;
 HEAP8[26208] = 75;
 HEAP8[26209] = 76;
 HEAP8[26210] = 77;
 HEAP8[26211] = 78;
 HEAP8[26212] = 79;
 HEAP8[26213] = 80;
 HEAP8[26214] = 81;
 HEAP8[26215] = 82;
 HEAP8[26216] = 83;
 HEAP8[26217] = 84;
 HEAP8[26218] = 85;
 HEAP8[26219] = 86;
 HEAP8[26220] = 87;
 HEAP8[26221] = 88;
 HEAP8[26222] = 89;
 HEAP8[26223] = 90;
 HEAP8[26224] = 91;
 HEAP8[26225] = 92;
 HEAP8[26226] = 93;
 HEAP8[26227] = 94;
 HEAP8[26228] = 95;
 HEAP8[26229] = 96;
 HEAP8[26230] = 97;
 HEAP8[26231] = 98;
 HEAP8[26232] = 99;
 HEAP8[26233] = 100;
 HEAP8[26234] = 101;
 HEAP8[26235] = 102;
 HEAP8[26236] = 103;
 HEAP8[26237] = 104;
 HEAP8[26238] = 105;
 HEAP8[26239] = 106;
 HEAP8[26240] = 107;
 HEAP8[26241] = 108;
 HEAP8[26242] = 109;
 HEAP8[26243] = 110;
 HEAP8[26244] = 111;
 HEAP8[26245] = 112;
 HEAP8[26246] = 113;
 HEAP8[26247] = 114;
 HEAP8[26248] = 115;
 HEAP8[26249] = 116;
 HEAP8[26250] = 117;
 HEAP8[26251] = 118;
 HEAP8[26252] = 119;
 HEAP8[26253] = 120;
 HEAP8[26254] = 121;
 HEAP8[26255] = 122;
 HEAP8[26256] = 123;
 HEAP8[26257] = 124;
 HEAP8[26258] = 125;
 HEAP8[26259] = 126;
 HEAP8[26260] = 32;
 HEAP8[26133] = 0;
 HEAP8[26134] = 1;
 HEAP8[26135] = 2;
 HEAP8[26136] = 3;
 HEAP8[26137] = 4;
 HEAP8[26138] = 5;
 HEAP8[26139] = 6;
 HEAP8[26140] = 7;
 HEAP8[26141] = 8;
 HEAP8[26142] = 9;
 HEAP8[26143] = 10;
 HEAP8[26144] = 11;
 HEAP8[26145] = 12;
 HEAP8[26146] = 13;
 HEAP8[26147] = 14;
 HEAP8[26148] = 15;
 HEAP8[26149] = 16;
 HEAP8[26150] = 17;
 HEAP8[26151] = 18;
 HEAP8[26152] = 19;
 HEAP8[26153] = 20;
 HEAP8[26154] = 21;
 HEAP8[26155] = 22;
 HEAP8[26156] = 23;
 HEAP8[26157] = 24;
 HEAP8[26158] = 25;
 HEAP8[26159] = 26;
 HEAP8[26160] = 27;
 HEAP8[26161] = 28;
 HEAP8[26162] = 29;
 HEAP8[26163] = 30;
 HEAP8[26164] = 31;
 $i$1 = 127;
 while (1) {
  HEAP8[26133 + $i$1 >> 0] = $i$1;
  $26 = $i$1 + 1 | 0;
  if (($26 | 0) == 256) {
   $i$2 = 0;
   break;
  } else $i$1 = $26;
 }
 while (1) {
  HEAP8[25621 + (HEAPU8[26133 + $i$2 >> 0] | 0) >> 0] = $i$2;
  $32 = $i$2 + 1 | 0;
  if (($32 | 0) == 256) break; else $i$2 = $32;
 }
 dest = 25877;
 stop = dest + 126 | 0;
 do {
  HEAP8[dest >> 0] = 5;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 dest = 26005;
 stop = dest + 128 | 0;
 do {
  HEAP8[dest >> 0] = 2;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 dest = 25877;
 stop = dest + 32 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP8[26004] = 0;
 HEAP8[25886] = 1;
 HEAP8[25890] = 1;
 HEAP8[25909] = 1;
 HEAP8[26003] = 4;
 HEAP8[25922] = 4;
 dest = 25925;
 stop = dest + 10 | 0;
 do {
  HEAP8[dest >> 0] = 3;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 dest = 25942;
 stop = dest + 26 | 0;
 do {
  HEAP8[dest >> 0] = 2;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 dest = 25974;
 stop = dest + 26 | 0;
 do {
  HEAP8[dest >> 0] = 2;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 _memset(26390, 1, 256) | 0;
 HEAP8[26424] = 0;
 HEAP8[26425] = 0;
 HEAP8[26427] = 0;
 HEAP8[26429] = 0;
 HEAP8[26430] = 0;
 HEAP8[26431] = 0;
 HEAP8[26434] = 0;
 HEAP8[26451] = 0;
 HEAP8[26513] = 0;
 HEAP8[26515] = 0;
 dest = 26390;
 stop = dest + 33 | 0;
 do {
  HEAP8[dest >> 0] = 0;
  dest = dest + 1 | 0;
 } while ((dest | 0) < (stop | 0));
 _memset(17552, 0, 512) | 0;
 HEAP32[4420] = 278;
 HEAP32[4421] = 278;
 HEAP32[4422] = 500;
 HEAP32[4423] = 833;
 HEAP32[4424] = 500;
 HEAP32[4425] = 833;
 HEAP32[4426] = 778;
 HEAP32[4427] = 278;
 HEAP32[4428] = 389;
 HEAP32[4429] = 389;
 HEAP32[4430] = 500;
 HEAP32[4431] = 778;
 HEAP32[4432] = 278;
 HEAP32[4433] = 333;
 HEAP32[4434] = 278;
 HEAP32[4435] = 500;
 HEAP32[4436] = 500;
 HEAP32[4437] = 500;
 HEAP32[4438] = 500;
 HEAP32[4439] = 500;
 HEAP32[4440] = 500;
 HEAP32[4441] = 500;
 HEAP32[4442] = 500;
 HEAP32[4443] = 500;
 HEAP32[4444] = 500;
 HEAP32[4445] = 500;
 HEAP32[4446] = 278;
 HEAP32[4447] = 278;
 HEAP32[4448] = 278;
 HEAP32[4449] = 778;
 HEAP32[4450] = 472;
 HEAP32[4451] = 472;
 HEAP32[4452] = 778;
 HEAP32[4453] = 750;
 HEAP32[4454] = 708;
 HEAP32[4455] = 722;
 HEAP32[4456] = 764;
 HEAP32[4457] = 681;
 HEAP32[4458] = 653;
 HEAP32[4459] = 785;
 HEAP32[4460] = 750;
 HEAP32[4461] = 361;
 HEAP32[4462] = 514;
 HEAP32[4463] = 778;
 HEAP32[4464] = 625;
 HEAP32[4465] = 917;
 HEAP32[4466] = 750;
 HEAP32[4467] = 778;
 HEAP32[4468] = 681;
 HEAP32[4469] = 778;
 HEAP32[4470] = 736;
 HEAP32[4471] = 556;
 HEAP32[4472] = 722;
 HEAP32[4473] = 750;
 HEAP32[4474] = 750;
 HEAP32[4475] = 1028;
 HEAP32[4476] = 750;
 HEAP32[4477] = 750;
 HEAP32[4478] = 611;
 HEAP32[4479] = 278;
 HEAP32[4480] = 500;
 HEAP32[4481] = 278;
 HEAP32[4482] = 500;
 HEAP32[4483] = 278;
 HEAP32[4484] = 278;
 HEAP32[4485] = 500;
 HEAP32[4486] = 556;
 HEAP32[4487] = 444;
 HEAP32[4488] = 556;
 HEAP32[4489] = 444;
 HEAP32[4490] = 306;
 HEAP32[4491] = 500;
 HEAP32[4492] = 556;
 HEAP32[4493] = 278;
 HEAP32[4494] = 306;
 HEAP32[4495] = 528;
 HEAP32[4496] = 278;
 HEAP32[4497] = 833;
 HEAP32[4498] = 556;
 HEAP32[4499] = 500;
 HEAP32[4500] = 556;
 HEAP32[4501] = 528;
 HEAP32[4502] = 392;
 HEAP32[4503] = 394;
 HEAP32[4504] = 389;
 HEAP32[4505] = 556;
 HEAP32[4506] = 528;
 HEAP32[4507] = 722;
 HEAP32[4508] = 528;
 HEAP32[4509] = 528;
 HEAP32[4510] = 444;
 HEAP32[4511] = 500;
 HEAP32[4512] = 1e3;
 HEAP32[4513] = 500;
 HEAP32[4514] = 500;
 $33 = HEAP32[4695] | 0;
 if (($33 | 0) > 0) {
  $35 = HEAP32[4243] | 0;
  $36 = HEAP32[4145] | 0;
  $k$0 = 1;
  while (1) {
   HEAP32[$35 + ($k$0 << 2) >> 2] = 0;
   HEAP32[$36 + ($k$0 << 2) >> 2] = 0;
   if (($k$0 | 0) == ($33 | 0)) break; else $k$0 = $k$0 + 1 | 0;
  }
  $41 = HEAP32[4695] | 0;
 } else $41 = $33;
 HEAP32[4244] = $41 + 1;
 HEAP32[4237] = 0;
 HEAP32[4e3] = 1;
 HEAP32[(HEAP32[4041] | 0) + 4 >> 2] = 0;
 HEAP32[4093] = 0;
 HEAP32[4666] = 0;
 HEAP32[4096] = 0;
 HEAP32[4668] = 0;
 HEAP32[4150] = 0;
 HEAP32[4670] = 0;
 HEAP32[4328] = 0;
 HEAP32[4158] = 0;
 HEAP32[4368] = 0;
 HEAP32[4255] = 0;
 HEAP32[4247] = 0;
 HEAP32[4372] = 0;
 if ((HEAP32[4694] | 0) <= 0) {
  HEAP32[4693] = 0;
  HEAP32[4674] = 0;
  HEAP32[4675] = 0;
  HEAP32[4684] = 0;
  HEAP32[4685] = 0;
  HEAP32[4692] = 0;
  HEAP32[4312] = 0;
  HEAP32[4153] = 0;
  _predefcertainstrings();
  _getthetoplevelauxfilename();
  STACKTOP = sp;
  return;
 }
 $46 = HEAP32[4373] | 0;
 $47 = HEAP32[4376] | 0;
 $storemerge10 = 0;
 while (1) {
  HEAP32[$46 + ($storemerge10 << 2) >> 2] = 0;
  HEAP32[$47 + (HEAP32[4372] << 2) >> 2] = 0;
  $52 = (HEAP32[4372] | 0) + 1 | 0;
  HEAP32[4372] = $52;
  if (($52 | 0) < (HEAP32[4694] | 0)) $storemerge10 = $52; else break;
 }
 HEAP32[4693] = 0;
 HEAP32[4674] = 0;
 HEAP32[4675] = 0;
 HEAP32[4684] = 0;
 HEAP32[4685] = 0;
 HEAP32[4692] = 0;
 HEAP32[4312] = 0;
 HEAP32[4153] = 0;
 _predefcertainstrings();
 _getthetoplevelauxfilename();
 STACKTOP = sp;
 return;
}

function _bstintegerscommand() {
 var $$lcssa = 0, $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i3 = 0, $$lcssa170 = 0, $$lcssa171 = 0, $$lcssa172 = 0, $$lcssa176 = 0, $$lcssa178 = 0, $$lcssa180 = 0, $$lcssa182 = 0, $$lcssa184 = 0, $$lcssa190 = 0, $$lcssa192 = 0, $$lcssa194 = 0, $$lcssa196 = 0, $$lcssa201 = 0, $$lcssa203 = 0, $$lcssa205 = 0, $$lcssa207 = 0, $$lcssa27 = 0, $0 = 0, $105 = 0, $106 = 0, $11 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $12 = 0, $122 = 0, $127 = 0, $128 = 0, $134 = 0, $136 = 0, $137 = 0, $14 = 0, $142 = 0, $143 = 0, $145 = 0, $146 = 0, $148 = 0, $153 = 0, $155 = 0, $167 = 0, $168 = 0, $169 = 0, $19 = 0, $2 = 0, $21 = 0, $3 = 0, $33 = 0, $35 = 0, $36 = 0, $38 = 0, $43 = 0, $44 = 0, $49 = 0, $50 = 0, $52 = 0, $53 = 0, $55 = 0, $60 = 0, $62 = 0, $75 = 0, $77 = 0, $79 = 0, $8 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $91 = 0, $92 = 0, $i$0$i = 0, $storemerge = 0, $storemerge21 = 0, $storemerge22 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $2 = HEAP32[4045] | 0;
 while (1) {
  $0 = HEAP32[3993] | 0;
  $3 = HEAP8[$0 + $2 >> 0] | 0;
  $8 = HEAP32[3999] | 0;
  $9 = ($2 | 0) < ($8 | 0);
  if ((HEAP8[25877 + ($3 & 255) >> 0] | 0) == 1 & $9) {
   $12 = $2;
   while (1) {
    $11 = $12 + 1 | 0;
    HEAP32[4045] = $11;
    $14 = HEAP8[$0 + $11 >> 0] | 0;
    $19 = ($11 | 0) < ($8 | 0);
    if ($19 & (HEAP8[25877 + ($14 & 255) >> 0] | 0) == 1) $12 = $11; else {
     $$lcssa$i$i = $19;
     $167 = $11;
     $21 = $14;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $9;
   $167 = $2;
   $21 = $3;
  }
  if (!($21 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa201 = $0;
   $$lcssa203 = $8;
   $$lcssa205 = $167;
   $$lcssa207 = $21;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 7;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $2 = 0;
 }
 if ((label | 0) == 7) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4825, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4825, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa207 << 24 >> 24 != 123) {
  $33 = HEAP32[3989] | 0;
  $35 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $35;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($33, 1750, $vararg_buffer) | 0;
  $36 = HEAP32[3990] | 0;
  $38 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $38;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($36, 1750, $vararg_buffer3) | 0;
  _fwrite(4825, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4825, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $43 = $$lcssa201;
 $50 = $$lcssa203;
 $storemerge = $$lcssa205 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge;
  $44 = HEAP8[$43 + $storemerge >> 0] | 0;
  $49 = ($storemerge | 0) < ($50 | 0);
  if ((HEAP8[25877 + ($44 & 255) >> 0] | 0) == 1 & $49) {
   $53 = $storemerge;
   while (1) {
    $52 = $53 + 1 | 0;
    HEAP32[4045] = $52;
    $55 = HEAP8[$43 + $52 >> 0] | 0;
    $60 = ($52 | 0) < ($50 | 0);
    if ($60 & (HEAP8[25877 + ($55 & 255) >> 0] | 0) == 1) $53 = $52; else {
     $$lcssa$i$i3 = $60;
     $168 = $52;
     $62 = $55;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $49;
   $168 = $storemerge;
   $62 = $44;
  }
  if (!($62 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa190 = $50;
   $$lcssa192 = $43;
   $$lcssa194 = $168;
   $$lcssa196 = $62;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 17;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $43 = HEAP32[3993] | 0;
  $50 = HEAP32[3999] | 0;
  $storemerge = 0;
 }
 if ((label | 0) == 17) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4825, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4825, 8, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 L29 : do if ($$lcssa196 << 24 >> 24 == 125) $$lcssa27 = $$lcssa194; else {
  $75 = $$lcssa194;
  $77 = $$lcssa192;
  $87 = $$lcssa190;
  L30 : while (1) {
   HEAP32[4044] = $75;
   $79 = HEAPU8[$77 + $75 >> 0] | 0;
   if ((HEAP8[25877 + $79 >> 0] | 0) == 3) {
    $storemerge21 = 0;
    label = 25;
    break;
   }
   if ((HEAP8[26390 + $79 >> 0] | 0) == 1 & ($75 | 0) < ($87 | 0)) $89 = $75; else {
    $storemerge21 = 0;
    label = 25;
    break;
   }
   while (1) {
    $88 = $89 + 1 | 0;
    HEAP32[4045] = $88;
    $91 = HEAP8[$77 + $88 >> 0] | 0;
    $92 = $91 & 255;
    if (($88 | 0) < ($87 | 0) & (HEAP8[26390 + $92 >> 0] | 0) == 1) $89 = $88; else {
     $$lcssa = $89;
     $$lcssa170 = $88;
     $$lcssa171 = $91;
     $$lcssa172 = $92;
     break;
    }
   }
   if (($$lcssa170 | 0) == ($75 | 0)) {
    $storemerge21 = 0;
    label = 25;
    break;
   }
   if ((HEAP8[25877 + $$lcssa172 >> 0] | 0) == 1 | ($$lcssa170 | 0) == ($87 | 0)) $storemerge22 = 3; else switch ($$lcssa171 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge22 = 1;
     break;
    }
   default:
    {
     $storemerge21 = 2;
     label = 25;
     break L30;
    }
   }
   HEAP8[26389] = $storemerge22;
   if (($$lcssa | 0) < ($75 | 0)) {
    $114 = $75;
    $115 = $$lcssa170;
    $116 = $77;
   } else {
    $i$0$i = $75;
    while (1) {
     $105 = $77 + $i$0$i | 0;
     $106 = HEAP8[$105 >> 0] | 0;
     if (($106 + -65 & 255) < 26) HEAP8[$105 >> 0] = ($106 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $114 = HEAP32[4044] | 0;
    $115 = HEAP32[4045] | 0;
    $116 = HEAP32[3993] | 0;
   }
   $117 = _zstrlookup($116, $114, $115 - $114 | 0, 11, 1) | 0;
   HEAP32[4310] = $117;
   if (HEAP32[4241] | 0) {
    $$lcssa184 = $117;
    label = 32;
    break;
   }
   HEAP8[(HEAP32[4144] | 0) + $117 >> 0] = 7;
   HEAP32[(HEAP32[4249] | 0) + (HEAP32[4310] << 2) >> 2] = 0;
   $136 = HEAP32[4045] | 0;
   while (1) {
    $134 = HEAP32[3993] | 0;
    $137 = HEAP8[$134 + $136 >> 0] | 0;
    $142 = HEAP32[3999] | 0;
    $143 = ($136 | 0) < ($142 | 0);
    if ((HEAP8[25877 + ($137 & 255) >> 0] | 0) == 1 & $143) {
     $146 = $136;
     while (1) {
      $145 = $146 + 1 | 0;
      HEAP32[4045] = $145;
      $148 = HEAP8[$134 + $145 >> 0] | 0;
      $153 = ($145 | 0) < ($142 | 0);
      if ($153 & (HEAP8[25877 + ($148 & 255) >> 0] | 0) == 1) $146 = $145; else {
       $$lcssa$i$i12 = $153;
       $155 = $148;
       $169 = $145;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $143;
     $155 = $137;
     $169 = $136;
    }
    if (!($155 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa176 = $134;
     $$lcssa178 = $142;
     $$lcssa180 = $169;
     $$lcssa182 = $155;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 39;
     break L30;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $136 = 0;
   }
   if ($$lcssa182 << 24 >> 24 == 125) {
    $$lcssa27 = $$lcssa180;
    break L29;
   } else {
    $75 = $$lcssa180;
    $77 = $$lcssa176;
    $87 = $$lcssa178;
   }
  }
  if ((label | 0) == 25) {
   HEAP8[26389] = $storemerge21;
   _bstidprint();
   _fwrite(4825, 8, 1, HEAP32[3989] | 0) | 0;
   _fwrite(4825, 8, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 32) {
   $122 = HEAP32[(HEAP32[4145] | 0) + ($$lcssa184 << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $122);
   _zoutpoolstr(HEAP32[3989] | 0, $122);
   _fwrite(1858, 20, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1858, 20, 1, HEAP32[3990] | 0) | 0;
   _zprintfnclass($$lcssa184);
   $127 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer8 >> 2] = 1879;
   _fprintf($127, 960, $vararg_buffer8) | 0;
   $128 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer11 >> 2] = 1879;
   _fprintf($128, 960, $vararg_buffer11) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 39) {
   _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
   _fwrite(4825, 8, 1, HEAP32[3989] | 0) | 0;
   _fwrite(4825, 8, 1, HEAP32[3990] | 0) | 0;
   _bsterrprintandlookforblankline();
   STACKTOP = sp;
   return;
  }
 } while (0);
 HEAP32[4045] = $$lcssa27 + 1;
 STACKTOP = sp;
 return;
}

function ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 $rem = $rem | 0;
 var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $147 = 0, $149 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $152 = 0, $r_sroa_0_0_extract_trunc = 0, $r_sroa_1_4_extract_trunc = 0, $155 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $_0$0 = 0, $_0$1 = 0;
 $n_sroa_0_0_extract_trunc = $a$0;
 $n_sroa_1_4_extract_shift$0 = $a$1;
 $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0;
 $d_sroa_0_0_extract_trunc = $b$0;
 $d_sroa_1_4_extract_shift$0 = $b$1;
 $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0;
 if (!$n_sroa_1_4_extract_trunc) {
  $4 = ($rem | 0) != 0;
  if (!$d_sroa_1_4_extract_trunc) {
   if ($4) {
    HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
    HEAP32[$rem + 4 >> 2] = 0;
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  } else {
   if (!$4) {
    $_0$1 = 0;
    $_0$0 = 0;
    return (tempRet0 = $_0$1, $_0$0) | 0;
   }
   HEAP32[$rem >> 2] = $a$0 | 0;
   HEAP32[$rem + 4 >> 2] = $a$1 & 0;
   $_0$1 = 0;
   $_0$0 = 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
 }
 $17 = ($d_sroa_1_4_extract_trunc | 0) == 0;
 do if (!$d_sroa_0_0_extract_trunc) {
  if ($17) {
   if ($rem | 0) {
    HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
    HEAP32[$rem + 4 >> 2] = 0;
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  if (!$n_sroa_0_0_extract_trunc) {
   if ($rem | 0) {
    HEAP32[$rem >> 2] = 0;
    HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0);
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  $37 = $d_sroa_1_4_extract_trunc - 1 | 0;
  if (!($37 & $d_sroa_1_4_extract_trunc)) {
   if ($rem | 0) {
    HEAP32[$rem >> 2] = $a$0 | 0;
    HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0;
   }
   $_0$1 = 0;
   $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0);
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  $51 = (Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0) - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
  if ($51 >>> 0 <= 30) {
   $57 = $51 + 1 | 0;
   $58 = 31 - $51 | 0;
   $sr_1_ph = $57;
   $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0);
   $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0);
   $q_sroa_0_1_ph = 0;
   $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58;
   break;
  }
  if (!$rem) {
   $_0$1 = 0;
   $_0$0 = 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  HEAP32[$rem >> 2] = $a$0 | 0;
  HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
  $_0$1 = 0;
  $_0$0 = 0;
  return (tempRet0 = $_0$1, $_0$0) | 0;
 } else {
  if (!$17) {
   $119 = (Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0) - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
   if ($119 >>> 0 <= 31) {
    $125 = $119 + 1 | 0;
    $126 = 31 - $119 | 0;
    $130 = $119 - 31 >> 31;
    $sr_1_ph = $125;
    $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126;
    $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130;
    $q_sroa_0_1_ph = 0;
    $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126;
    break;
   }
   if (!$rem) {
    $_0$1 = 0;
    $_0$0 = 0;
    return (tempRet0 = $_0$1, $_0$0) | 0;
   }
   HEAP32[$rem >> 2] = $a$0 | 0;
   HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
   $_0$1 = 0;
   $_0$0 = 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
  $66 = $d_sroa_0_0_extract_trunc - 1 | 0;
  if ($66 & $d_sroa_0_0_extract_trunc | 0) {
   $88 = (Math_clz32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
   $89 = 64 - $88 | 0;
   $91 = 32 - $88 | 0;
   $92 = $91 >> 31;
   $95 = $88 - 32 | 0;
   $105 = $95 >> 31;
   $sr_1_ph = $88;
   $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105;
   $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0);
   $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92;
   $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31;
   break;
  }
  if ($rem | 0) {
   HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc;
   HEAP32[$rem + 4 >> 2] = 0;
  }
  if (($d_sroa_0_0_extract_trunc | 0) == 1) {
   $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
   $_0$0 = $a$0 | 0 | 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  } else {
   $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0;
   $_0$1 = $n_sroa_1_4_extract_trunc >>> ($78 >>> 0) | 0;
   $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0;
   return (tempRet0 = $_0$1, $_0$0) | 0;
  }
 } while (0);
 if (!$sr_1_ph) {
  $q_sroa_1_1_lcssa = $q_sroa_1_1_ph;
  $q_sroa_0_1_lcssa = $q_sroa_0_1_ph;
  $r_sroa_1_1_lcssa = $r_sroa_1_1_ph;
  $r_sroa_0_1_lcssa = $r_sroa_0_1_ph;
  $carry_0_lcssa$1 = 0;
  $carry_0_lcssa$0 = 0;
 } else {
  $d_sroa_0_0_insert_insert99$0 = $b$0 | 0 | 0;
  $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0;
  $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0 | 0, $d_sroa_0_0_insert_insert99$1 | 0, -1, -1) | 0;
  $137$1 = tempRet0;
  $q_sroa_1_1198 = $q_sroa_1_1_ph;
  $q_sroa_0_1199 = $q_sroa_0_1_ph;
  $r_sroa_1_1200 = $r_sroa_1_1_ph;
  $r_sroa_0_1201 = $r_sroa_0_1_ph;
  $sr_1202 = $sr_1_ph;
  $carry_0203 = 0;
  while (1) {
   $147 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1;
   $149 = $carry_0203 | $q_sroa_0_1199 << 1;
   $r_sroa_0_0_insert_insert42$0 = $r_sroa_0_1201 << 1 | $q_sroa_1_1198 >>> 31 | 0;
   $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0;
   _i64Subtract($137$0 | 0, $137$1 | 0, $r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0) | 0;
   $150$1 = tempRet0;
   $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1;
   $152 = $151$0 & 1;
   $r_sroa_0_0_extract_trunc = _i64Subtract($r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0, $151$0 & $d_sroa_0_0_insert_insert99$0 | 0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1 | 0) | 0;
   $r_sroa_1_4_extract_trunc = tempRet0;
   $155 = $sr_1202 - 1 | 0;
   if (!$155) break; else {
    $q_sroa_1_1198 = $147;
    $q_sroa_0_1199 = $149;
    $r_sroa_1_1200 = $r_sroa_1_4_extract_trunc;
    $r_sroa_0_1201 = $r_sroa_0_0_extract_trunc;
    $sr_1202 = $155;
    $carry_0203 = $152;
   }
  }
  $q_sroa_1_1_lcssa = $147;
  $q_sroa_0_1_lcssa = $149;
  $r_sroa_1_1_lcssa = $r_sroa_1_4_extract_trunc;
  $r_sroa_0_1_lcssa = $r_sroa_0_0_extract_trunc;
  $carry_0_lcssa$1 = 0;
  $carry_0_lcssa$0 = $152;
 }
 $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa;
 $q_sroa_0_0_insert_ext75$1 = 0;
 if ($rem | 0) {
  HEAP32[$rem >> 2] = $r_sroa_0_1_lcssa;
  HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa;
 }
 $_0$1 = ($q_sroa_0_0_insert_ext75$0 | 0) >>> 31 | ($q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1) << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1;
 $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0;
 return (tempRet0 = $_0$1, $_0$0) | 0;
}

function _auxbibdatacommand() {
 var $$lcssa1$i = 0, $$lcssa4 = 0, $$lcssa5 = 0, $101 = 0, $104 = 0, $111 = 0, $113 = 0, $114 = 0, $121 = 0, $122 = 0, $124 = 0, $126 = 0, $13 = 0, $133 = 0, $134 = 0, $135 = 0, $137 = 0, $14 = 0, $141 = 0, $144 = 0, $146 = 0, $147 = 0, $148 = 0, $150 = 0, $152 = 0, $153 = 0, $156 = 0, $16 = 0, $17 = 0, $171 = 0, $174 = 0, $181 = 0, $182 = 0, $186 = 0, $19 = 0, $23 = 0, $24 = 0, $26 = 0, $28 = 0, $29 = 0, $31 = 0, $32 = 0, $34 = 0, $35 = 0, $37 = 0, $39 = 0, $49 = 0, $51 = 0, $52 = 0, $54 = 0, $55 = 0, $58 = 0, $65 = 0, $66 = 0, $73 = 0, $74 = 0, $8 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $9 = 0, $92 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer24 = 0, $vararg_buffer3 = 0, $vararg_buffer30 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $vararg_buffer30 = sp + 96 | 0;
 $vararg_buffer24 = sp + 80 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (HEAP32[4666] | 0) {
  _fwrite(1315, 21, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1315, 21, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1337, 4, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1337, 4, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1348, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1348, 8, 1, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 HEAP32[4666] = 1;
 $8 = HEAP32[4045] | 0;
 $9 = HEAP32[3993] | 0;
 if ((HEAP8[$9 + $8 >> 0] | 0) == 125) {
  STACKTOP = sp;
  return;
 } else {
  $14 = $8;
  $16 = $9;
 }
 while (1) {
  $13 = $14 + 1 | 0;
  HEAP32[4045] = $13;
  HEAP32[4044] = $13;
  $17 = HEAP8[$16 + $13 >> 0] | 0;
  L9 : do switch ($17 << 24 >> 24) {
  case 44:
  case 125:
   {
    $186 = $13;
    label = 6;
    break;
   }
  default:
   {
    $19 = $17;
    $24 = $13;
    while (1) {
     if ((HEAP8[25877 + ($19 & 255) >> 0] | 0) == 1) {
      $186 = $24;
      label = 6;
      break L9;
     }
     $23 = HEAP32[3999] | 0;
     if (($24 | 0) >= ($23 | 0)) {
      $29 = $24;
      $31 = $23;
      break L9;
     }
     $26 = $24 + 1 | 0;
     HEAP32[4045] = $26;
     $28 = HEAP8[$16 + $26 >> 0] | 0;
     switch ($28 << 24 >> 24) {
     case 44:
     case 125:
      {
       $186 = $26;
       label = 6;
       break L9;
       break;
      }
     default:
      {
       $19 = $28;
       $24 = $26;
      }
     }
    }
   }
  } while (0);
  if ((label | 0) == 6) {
   label = 0;
   $29 = $186;
   $31 = HEAP32[3999] | 0;
  }
  if (($29 | 0) >= ($31 | 0)) {
   label = 10;
   break;
  }
  $39 = HEAP8[$16 + $29 >> 0] | 0;
  if ((HEAP8[25877 + ($39 & 255) >> 0] | 0) == 1) {
   label = 12;
   break;
  }
  if ($39 << 24 >> 24 == 125 & ($31 | 0) > ($29 + 1 | 0)) {
   label = 14;
   break;
  }
  $55 = HEAP32[4093] | 0;
  if (($55 | 0) == (HEAP32[4667] | 0)) {
   $58 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer18 >> 2] = 4165;
   HEAP32[$vararg_buffer18 + 4 >> 2] = 4;
   HEAP32[$vararg_buffer18 + 8 >> 2] = $55 + 20;
   HEAP32[$vararg_buffer18 + 12 >> 2] = $55;
   _fprintf($58, 1023, $vararg_buffer18) | 0;
   HEAP32[4094] = _xrealloc(HEAP32[4094] | 0, (HEAP32[4667] << 2) + 84 | 0) | 0;
   $65 = HEAP32[3989] | 0;
   $66 = HEAP32[4667] | 0;
   HEAP32[$vararg_buffer24 >> 2] = 4174;
   HEAP32[$vararg_buffer24 + 4 >> 2] = 4;
   HEAP32[$vararg_buffer24 + 8 >> 2] = $66 + 20;
   HEAP32[$vararg_buffer24 + 12 >> 2] = $66;
   _fprintf($65, 1023, $vararg_buffer24) | 0;
   HEAP32[4316] = _xrealloc(HEAP32[4316] | 0, (HEAP32[4667] << 2) + 84 | 0) | 0;
   $73 = HEAP32[3989] | 0;
   $74 = HEAP32[4667] | 0;
   HEAP32[$vararg_buffer30 >> 2] = 4183;
   HEAP32[$vararg_buffer30 + 4 >> 2] = 4;
   HEAP32[$vararg_buffer30 + 8 >> 2] = $74 + 20;
   HEAP32[$vararg_buffer30 + 12 >> 2] = $74;
   _fprintf($73, 1023, $vararg_buffer30) | 0;
   HEAP32[4325] = _xrealloc(HEAP32[4325] | 0, (HEAP32[4667] << 2) + 84 | 0) | 0;
   HEAP32[4667] = (HEAP32[4667] | 0) + 20;
   $84 = HEAP32[4044] | 0;
   $85 = HEAP32[4045] | 0;
   $86 = HEAP32[3993] | 0;
  } else {
   $84 = $13;
   $85 = $29;
   $86 = $16;
  }
  $87 = _zstrlookup($86, $84, $85 - $84 | 0, 6, 1) | 0;
  $92 = HEAP32[4094] | 0;
  HEAP32[$92 + (HEAP32[4093] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + ($87 << 2) >> 2];
  if (HEAP32[4241] | 0) {
   label = 18;
   break;
  }
  $111 = HEAP32[$92 + (HEAP32[4093] << 2) >> 2] | 0;
  _free(HEAP32[4048] | 0);
  $113 = $111 + 1 | 0;
  $114 = HEAP32[4041] | 0;
  $121 = _xmalloc((HEAP32[$114 + ($113 << 2) >> 2] | 0) + 2 - (HEAP32[$114 + ($111 << 2) >> 2] | 0) | 0) | 0;
  HEAP32[4048] = $121;
  HEAP32[4046] = 1;
  $122 = HEAP32[4041] | 0;
  $124 = HEAP32[$122 + ($111 << 2) >> 2] | 0;
  $126 = HEAP32[$122 + ($113 << 2) >> 2] | 0;
  if (($124 | 0) < ($126 | 0)) {
   HEAP8[$121 + 1 >> 0] = HEAP8[(HEAP32[4042] | 0) + $124 >> 0] | 0;
   $133 = (HEAP32[4046] | 0) + 1 | 0;
   HEAP32[4046] = $133;
   $134 = $124 + 1 | 0;
   $135 = HEAP32[4041] | 0;
   $137 = HEAP32[$135 + ($113 << 2) >> 2] | 0;
   if (($134 | 0) < ($137 | 0)) {
    $141 = $134;
    $144 = $133;
    while (1) {
     HEAP8[(HEAP32[4048] | 0) + $144 >> 0] = HEAP8[(HEAP32[4042] | 0) + $141 >> 0] | 0;
     $146 = (HEAP32[4046] | 0) + 1 | 0;
     HEAP32[4046] = $146;
     $147 = $141 + 1 | 0;
     $148 = HEAP32[4041] | 0;
     $150 = HEAP32[$148 + ($113 << 2) >> 2] | 0;
     if (($147 | 0) < ($150 | 0)) {
      $141 = $147;
      $144 = $146;
     } else {
      $$lcssa4 = $148;
      $$lcssa5 = $150;
      break;
     }
    }
   } else {
    $$lcssa4 = $135;
    $$lcssa5 = $137;
   }
   $$lcssa1$i = $$lcssa5;
   $153 = HEAP32[$$lcssa4 + ($111 << 2) >> 2] | 0;
   $156 = HEAP32[4048] | 0;
  } else {
   $$lcssa1$i = $126;
   $153 = $124;
   $156 = $121;
  }
  $152 = $$lcssa1$i - $153 | 0;
  HEAP32[4049] = $152;
  HEAP8[$156 + ($152 + 1) >> 0] = 0;
  if (!(_kpse_in_name_ok((HEAP32[4048] | 0) + 1 | 0) | 0)) {
   label = 25;
   break;
  }
  if (!(_open_input((HEAP32[4316] | 0) + (HEAP32[4093] << 2) | 0, 6, 4127) | 0)) {
   label = 25;
   break;
  }
  HEAP32[4093] = (HEAP32[4093] | 0) + 1;
  $181 = HEAP32[4045] | 0;
  $182 = HEAP32[3993] | 0;
  if ((HEAP8[$182 + $181 >> 0] | 0) == 125) {
   label = 27;
   break;
  } else {
   $14 = $181;
   $16 = $182;
  }
 }
 if ((label | 0) == 10) {
  $32 = HEAP32[3989] | 0;
  $34 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer >> 2] = 1364;
  HEAP32[$vararg_buffer + 4 >> 2] = $34;
  HEAP32[$vararg_buffer + 8 >> 2] = 34;
  _fprintf($32, 1357, $vararg_buffer) | 0;
  $35 = HEAP32[3990] | 0;
  $37 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 1364;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $37;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 34;
  _fprintf($35, 1357, $vararg_buffer3) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 12) {
  _fwrite(1383, 23, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1383, 23, 1, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 14) {
  $49 = HEAP32[3989] | 0;
  $51 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer8 >> 2] = 1369;
  HEAP32[$vararg_buffer8 + 4 >> 2] = $51;
  HEAP32[$vararg_buffer8 + 8 >> 2] = 34;
  _fprintf($49, 1357, $vararg_buffer8) | 0;
  $52 = HEAP32[3990] | 0;
  $54 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer13 >> 2] = 1369;
  HEAP32[$vararg_buffer13 + 4 >> 2] = $54;
  HEAP32[$vararg_buffer13 + 8 >> 2] = 34;
  _fprintf($52, 1357, $vararg_buffer13) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 18) {
  _fwrite(4194, 43, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4194, 43, 1, HEAP32[3990] | 0) | 0;
  $101 = HEAP32[(HEAP32[4094] | 0) + (HEAP32[4093] << 2) >> 2] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $101);
  _zoutpoolstr(HEAP32[3989] | 0, $101);
  $104 = HEAP32[4095] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $104);
  _zoutpoolstr(HEAP32[3989] | 0, $104);
  _putc(10, HEAP32[3989] | 0) | 0;
  _putc(10, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 25) {
  _fwrite(4238, 30, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4238, 30, 1, HEAP32[3990] | 0) | 0;
  $171 = HEAP32[(HEAP32[4094] | 0) + (HEAP32[4093] << 2) >> 2] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $171);
  _zoutpoolstr(HEAP32[3989] | 0, $171);
  $174 = HEAP32[4095] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $174);
  _zoutpoolstr(HEAP32[3989] | 0, $174);
  _putc(10, HEAP32[3989] | 0) | 0;
  _putc(10, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 27) {
  STACKTOP = sp;
  return;
 }
}

function _bstiteratecommand() {
 var $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i3 = 0, $$lcssa131 = 0, $$lcssa133 = 0, $$lcssa135 = 0, $$lcssa136 = 0, $$lcssa137 = 0, $$lcssa141 = 0, $$lcssa143 = 0, $$lcssa145 = 0, $$lcssa150 = 0, $$lcssa152 = 0, $$lcssa154 = 0, $$lcssa156 = 0, $105 = 0, $107 = 0, $108 = 0, $113 = 0, $114 = 0, $116 = 0, $117 = 0, $119 = 0, $12 = 0, $124 = 0, $126 = 0, $13 = 0, $138 = 0, $140 = 0, $141 = 0, $143 = 0, $15 = 0, $155 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $18 = 0, $23 = 0, $25 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $42 = 0, $47 = 0, $48 = 0, $53 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $64 = 0, $66 = 0, $7 = 0, $79 = 0, $87 = 0, $88 = 0, $90 = 0, $91 = 0, $storemerge21 = 0, $storemerge22 = 0, $storemerge23 = 0, $storemerge32 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (!(HEAP32[4675] | 0)) {
  _fwrite(4834, 44, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4834, 44, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $6 = HEAP32[4045] | 0;
 while (1) {
  $4 = HEAP32[3993] | 0;
  $7 = HEAP8[$4 + $6 >> 0] | 0;
  $12 = HEAP32[3999] | 0;
  $13 = ($6 | 0) < ($12 | 0);
  if ((HEAP8[25877 + ($7 & 255) >> 0] | 0) == 1 & $13) {
   $16 = $6;
   while (1) {
    $15 = $16 + 1 | 0;
    HEAP32[4045] = $15;
    $18 = HEAP8[$4 + $15 >> 0] | 0;
    $23 = ($15 | 0) < ($12 | 0);
    if ($23 & (HEAP8[25877 + ($18 & 255) >> 0] | 0) == 1) $16 = $15; else {
     $$lcssa$i$i = $23;
     $158 = $15;
     $25 = $18;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $13;
   $158 = $6;
   $25 = $7;
  }
  if (!($25 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa150 = $4;
   $$lcssa152 = $12;
   $$lcssa154 = $158;
   $$lcssa156 = $25;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 9;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $6 = 0;
 }
 if ((label | 0) == 9) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4879, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4879, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa156 << 24 >> 24 != 123) {
  $37 = HEAP32[3989] | 0;
  $39 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $39;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($37, 1750, $vararg_buffer) | 0;
  $40 = HEAP32[3990] | 0;
  $42 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $42;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($40, 1750, $vararg_buffer3) | 0;
  _fwrite(4879, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4879, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $47 = $$lcssa150;
 $54 = $$lcssa152;
 $storemerge21 = $$lcssa154 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge21;
  $48 = HEAP8[$47 + $storemerge21 >> 0] | 0;
  $53 = ($storemerge21 | 0) < ($54 | 0);
  if ((HEAP8[25877 + ($48 & 255) >> 0] | 0) == 1 & $53) {
   $57 = $storemerge21;
   while (1) {
    $56 = $57 + 1 | 0;
    HEAP32[4045] = $56;
    $59 = HEAP8[$47 + $56 >> 0] | 0;
    $64 = ($56 | 0) < ($54 | 0);
    if ($64 & (HEAP8[25877 + ($59 & 255) >> 0] | 0) == 1) $57 = $56; else {
     $$lcssa$i$i3 = $64;
     $159 = $56;
     $66 = $59;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $53;
   $159 = $storemerge21;
   $66 = $48;
  }
  if (!($66 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa141 = $54;
   $$lcssa143 = $47;
   $$lcssa145 = $159;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 18;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $47 = HEAP32[3993] | 0;
  $54 = HEAP32[3999] | 0;
  $storemerge21 = 0;
 }
 if ((label | 0) == 18) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4879, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4879, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4044] = $$lcssa145;
 $79 = HEAPU8[$$lcssa143 + $$lcssa145 >> 0] | 0;
 L33 : do if ((HEAP8[25877 + $79 >> 0] | 0) == 3) $storemerge22 = 0; else if ((HEAP8[26390 + $79 >> 0] | 0) == 1 & ($$lcssa145 | 0) < ($$lcssa141 | 0)) {
  $88 = $$lcssa145;
  while (1) {
   $87 = $88 + 1 | 0;
   HEAP32[4045] = $87;
   $90 = HEAP8[$$lcssa143 + $87 >> 0] | 0;
   $91 = $90 & 255;
   if (($87 | 0) < ($$lcssa141 | 0) & (HEAP8[26390 + $91 >> 0] | 0) == 1) $88 = $87; else {
    $$lcssa135 = $87;
    $$lcssa136 = $90;
    $$lcssa137 = $91;
    break;
   }
  }
  if (($$lcssa135 | 0) == ($$lcssa145 | 0)) $storemerge22 = 0; else {
   if ((HEAP8[25877 + $$lcssa137 >> 0] | 0) == 1 | ($$lcssa135 | 0) == ($$lcssa141 | 0)) $storemerge23 = 3; else switch ($$lcssa136 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge23 = 1;
     break;
    }
   default:
    {
     $storemerge22 = 2;
     break L33;
    }
   }
   HEAP8[26389] = $storemerge23;
   if (_badargumenttoken() | 0) {
    STACKTOP = sp;
    return;
   }
   $107 = HEAP32[4045] | 0;
   while (1) {
    $105 = HEAP32[3993] | 0;
    $108 = HEAP8[$105 + $107 >> 0] | 0;
    $113 = HEAP32[3999] | 0;
    $114 = ($107 | 0) < ($113 | 0);
    if ((HEAP8[25877 + ($108 & 255) >> 0] | 0) == 1 & $114) {
     $117 = $107;
     while (1) {
      $116 = $117 + 1 | 0;
      HEAP32[4045] = $116;
      $119 = HEAP8[$105 + $116 >> 0] | 0;
      $124 = ($116 | 0) < ($113 | 0);
      if ($124 & (HEAP8[25877 + ($119 & 255) >> 0] | 0) == 1) $117 = $116; else {
       $$lcssa$i$i12 = $124;
       $126 = $119;
       $160 = $116;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $114;
     $126 = $108;
     $160 = $107;
    }
    if (!($126 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa131 = $160;
     $$lcssa133 = $126;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 33;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $107 = 0;
   }
   if ((label | 0) == 33) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(4879, 7, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4879, 7, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa133 << 24 >> 24 != 125) {
    $138 = HEAP32[3989] | 0;
    $140 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer8 >> 2] = 34;
    HEAP32[$vararg_buffer8 + 4 >> 2] = $140;
    HEAP32[$vararg_buffer8 + 8 >> 2] = 1832;
    _fprintf($138, 1750, $vararg_buffer8) | 0;
    $141 = HEAP32[3990] | 0;
    $143 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer13 >> 2] = 34;
    HEAP32[$vararg_buffer13 + 4 >> 2] = $143;
    HEAP32[$vararg_buffer13 + 8 >> 2] = 1832;
    _fprintf($141, 1750, $vararg_buffer13) | 0;
    _fwrite(4879, 7, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4879, 7, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   HEAP32[4045] = $$lcssa131 + 1;
   HEAP32[4360] = 0;
   HEAP32[4364] = HEAP32[4e3];
   HEAP32[4152] = 1;
   HEAP32[4676] = 0;
   if ((HEAP32[4157] | 0) > 0) $storemerge32 = 0; else {
    STACKTOP = sp;
    return;
   }
   while (1) {
    HEAP32[4150] = HEAP32[(HEAP32[4102] | 0) + ($storemerge32 << 2) >> 2];
    _zexecutefn(HEAP32[4310] | 0);
    _checkcommandexecution();
    $155 = (HEAP32[4676] | 0) + 1 | 0;
    HEAP32[4676] = $155;
    if (($155 | 0) < (HEAP32[4157] | 0)) $storemerge32 = $155; else break;
   }
   STACKTOP = sp;
   return;
  }
 } else $storemerge22 = 0; while (0);
 HEAP8[26389] = $storemerge22;
 _bstidprint();
 _fwrite(4879, 7, 1, HEAP32[3989] | 0) | 0;
 _fwrite(4879, 7, 1, HEAP32[3990] | 0) | 0;
 _bsterrprintandlookforblankline();
 STACKTOP = sp;
 return;
}

function _bstreversecommand() {
 var $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i3 = 0, $$lcssa129 = 0, $$lcssa131 = 0, $$lcssa133 = 0, $$lcssa134 = 0, $$lcssa135 = 0, $$lcssa139 = 0, $$lcssa141 = 0, $$lcssa143 = 0, $$lcssa148 = 0, $$lcssa150 = 0, $$lcssa152 = 0, $$lcssa154 = 0, $105 = 0, $107 = 0, $108 = 0, $113 = 0, $114 = 0, $116 = 0, $117 = 0, $119 = 0, $12 = 0, $124 = 0, $126 = 0, $13 = 0, $138 = 0, $140 = 0, $141 = 0, $143 = 0, $148 = 0, $15 = 0, $150 = 0, $151 = 0, $156 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $18 = 0, $23 = 0, $25 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $42 = 0, $47 = 0, $48 = 0, $53 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $64 = 0, $66 = 0, $7 = 0, $79 = 0, $87 = 0, $88 = 0, $90 = 0, $91 = 0, $storemerge = 0, $storemerge21 = 0, $storemerge22 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (!(HEAP32[4675] | 0)) {
  _fwrite(5414, 44, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5414, 44, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $6 = HEAP32[4045] | 0;
 while (1) {
  $4 = HEAP32[3993] | 0;
  $7 = HEAP8[$4 + $6 >> 0] | 0;
  $12 = HEAP32[3999] | 0;
  $13 = ($6 | 0) < ($12 | 0);
  if ((HEAP8[25877 + ($7 & 255) >> 0] | 0) == 1 & $13) {
   $16 = $6;
   while (1) {
    $15 = $16 + 1 | 0;
    HEAP32[4045] = $15;
    $18 = HEAP8[$4 + $15 >> 0] | 0;
    $23 = ($15 | 0) < ($12 | 0);
    if ($23 & (HEAP8[25877 + ($18 & 255) >> 0] | 0) == 1) $16 = $15; else {
     $$lcssa$i$i = $23;
     $158 = $15;
     $25 = $18;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $13;
   $158 = $6;
   $25 = $7;
  }
  if (!($25 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa148 = $4;
   $$lcssa150 = $12;
   $$lcssa152 = $158;
   $$lcssa154 = $25;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 9;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $6 = 0;
 }
 if ((label | 0) == 9) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(5459, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5459, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa154 << 24 >> 24 != 123) {
  $37 = HEAP32[3989] | 0;
  $39 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $39;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($37, 1750, $vararg_buffer) | 0;
  $40 = HEAP32[3990] | 0;
  $42 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $42;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($40, 1750, $vararg_buffer3) | 0;
  _fwrite(5459, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5459, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $47 = $$lcssa148;
 $54 = $$lcssa150;
 $storemerge = $$lcssa152 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge;
  $48 = HEAP8[$47 + $storemerge >> 0] | 0;
  $53 = ($storemerge | 0) < ($54 | 0);
  if ((HEAP8[25877 + ($48 & 255) >> 0] | 0) == 1 & $53) {
   $57 = $storemerge;
   while (1) {
    $56 = $57 + 1 | 0;
    HEAP32[4045] = $56;
    $59 = HEAP8[$47 + $56 >> 0] | 0;
    $64 = ($56 | 0) < ($54 | 0);
    if ($64 & (HEAP8[25877 + ($59 & 255) >> 0] | 0) == 1) $57 = $56; else {
     $$lcssa$i$i3 = $64;
     $159 = $56;
     $66 = $59;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $53;
   $159 = $storemerge;
   $66 = $48;
  }
  if (!($66 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa139 = $54;
   $$lcssa141 = $47;
   $$lcssa143 = $159;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 18;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $47 = HEAP32[3993] | 0;
  $54 = HEAP32[3999] | 0;
  $storemerge = 0;
 }
 if ((label | 0) == 18) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(5459, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(5459, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4044] = $$lcssa143;
 $79 = HEAPU8[$$lcssa141 + $$lcssa143 >> 0] | 0;
 L33 : do if ((HEAP8[25877 + $79 >> 0] | 0) == 3) $storemerge21 = 0; else if ((HEAP8[26390 + $79 >> 0] | 0) == 1 & ($$lcssa143 | 0) < ($$lcssa139 | 0)) {
  $88 = $$lcssa143;
  while (1) {
   $87 = $88 + 1 | 0;
   HEAP32[4045] = $87;
   $90 = HEAP8[$$lcssa141 + $87 >> 0] | 0;
   $91 = $90 & 255;
   if (($87 | 0) < ($$lcssa139 | 0) & (HEAP8[26390 + $91 >> 0] | 0) == 1) $88 = $87; else {
    $$lcssa133 = $87;
    $$lcssa134 = $90;
    $$lcssa135 = $91;
    break;
   }
  }
  if (($$lcssa133 | 0) == ($$lcssa143 | 0)) $storemerge21 = 0; else {
   if ((HEAP8[25877 + $$lcssa135 >> 0] | 0) == 1 | ($$lcssa133 | 0) == ($$lcssa139 | 0)) $storemerge22 = 3; else switch ($$lcssa134 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge22 = 1;
     break;
    }
   default:
    {
     $storemerge21 = 2;
     break L33;
    }
   }
   HEAP8[26389] = $storemerge22;
   if (_badargumenttoken() | 0) {
    STACKTOP = sp;
    return;
   }
   $107 = HEAP32[4045] | 0;
   while (1) {
    $105 = HEAP32[3993] | 0;
    $108 = HEAP8[$105 + $107 >> 0] | 0;
    $113 = HEAP32[3999] | 0;
    $114 = ($107 | 0) < ($113 | 0);
    if ((HEAP8[25877 + ($108 & 255) >> 0] | 0) == 1 & $114) {
     $117 = $107;
     while (1) {
      $116 = $117 + 1 | 0;
      HEAP32[4045] = $116;
      $119 = HEAP8[$105 + $116 >> 0] | 0;
      $124 = ($116 | 0) < ($113 | 0);
      if ($124 & (HEAP8[25877 + ($119 & 255) >> 0] | 0) == 1) $117 = $116; else {
       $$lcssa$i$i12 = $124;
       $126 = $119;
       $160 = $116;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $114;
     $126 = $108;
     $160 = $107;
    }
    if (!($126 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa129 = $160;
     $$lcssa131 = $126;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 33;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $107 = 0;
   }
   if ((label | 0) == 33) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(5459, 7, 1, HEAP32[3989] | 0) | 0;
    _fwrite(5459, 7, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa131 << 24 >> 24 != 125) {
    $138 = HEAP32[3989] | 0;
    $140 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer8 >> 2] = 34;
    HEAP32[$vararg_buffer8 + 4 >> 2] = $140;
    HEAP32[$vararg_buffer8 + 8 >> 2] = 1832;
    _fprintf($138, 1750, $vararg_buffer8) | 0;
    $141 = HEAP32[3990] | 0;
    $143 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer13 >> 2] = 34;
    HEAP32[$vararg_buffer13 + 4 >> 2] = $143;
    HEAP32[$vararg_buffer13 + 8 >> 2] = 1832;
    _fprintf($141, 1750, $vararg_buffer13) | 0;
    _fwrite(5459, 7, 1, HEAP32[3989] | 0) | 0;
    _fwrite(5459, 7, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   HEAP32[4045] = $$lcssa129 + 1;
   HEAP32[4360] = 0;
   HEAP32[4364] = HEAP32[4e3];
   HEAP32[4152] = 1;
   $148 = HEAP32[4157] | 0;
   if (($148 | 0) <= 0) {
    STACKTOP = sp;
    return;
   }
   HEAP32[4676] = $148;
   $151 = $148;
   while (1) {
    $150 = $151 + -1 | 0;
    HEAP32[4676] = $150;
    HEAP32[4150] = HEAP32[(HEAP32[4102] | 0) + ($150 << 2) >> 2];
    _zexecutefn(HEAP32[4310] | 0);
    _checkcommandexecution();
    $156 = HEAP32[4676] | 0;
    if (!$156) break; else $151 = $156;
   }
   STACKTOP = sp;
   return;
  }
 } else $storemerge21 = 0; while (0);
 HEAP8[26389] = $storemerge21;
 _bstidprint();
 _fwrite(5459, 7, 1, HEAP32[3989] | 0) | 0;
 _fwrite(5459, 7, 1, HEAP32[3990] | 0) | 0;
 _bsterrprintandlookforblankline();
 STACKTOP = sp;
 return;
}

function _kpathsea_db_search($kpse, $name, $orig_path_elt, $all) {
 $kpse = $kpse | 0;
 $name = $name | 0;
 $orig_path_elt = $orig_path_elt | 0;
 $all = $all | 0;
 var $$0 = 0, $$07 = 0, $$1$i = 0, $$13$i = 0, $$byval_copy8 = 0, $$pre13$i = 0, $$pre38 = 0, $0 = 0, $10 = 0, $100 = 0, $101 = 0, $104 = 0, $105 = 0, $109 = 0, $110 = 0, $115 = 0, $12 = 0, $15 = 0, $18 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $25 = 0, $26 = 0, $28 = 0, $3 = 0, $30 = 0, $32 = 0, $35 = 0, $37 = 0, $39 = 0, $40 = 0, $45 = 0, $47 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $57 = 0, $58 = 0, $59 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $73 = 0, $77 = 0, $78 = 0, $8 = 0, $81 = 0, $82 = 0, $85 = 0, $86 = 0, $88 = 0, $89 = 0, $90 = 0, $97 = 0, $a$013 = 0, $a$013$us = 0, $aliases$140 = 0, $db_dirs$016$us50 = 0, $db_dirs$01648 = 0, $done$1$lcssa = 0, $e$03456 = 0, $found$1 = 0, $found$1$us = 0, $found$2 = 0, $found$2$us = 0, $found$2$us$lcssa = 0, $i$026 = 0, $len1$0$lcssa = 0, $len1$029 = 0, $path_elt$0 = 0, $r$028 = 0, $r$12552 = 0, $ret$0$lcssa = 0, $temp_str$0 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $$byval_copy8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = $kpse + 20 | 0;
 if (!(HEAP32[$0 >> 2] | 0)) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $3 = _strrchr($name, 47) | 0;
 if (($3 | 0) == 0 | ($3 | 0) == ($name | 0)) {
  $$07 = $name;
  $path_elt$0 = $orig_path_elt;
  $temp_str$0 = 0;
 } else {
  $8 = $3 - $name | 0;
  $10 = _xmalloc($8 + 1 | 0) | 0;
  _strncpy($10, $name, $8) | 0;
  HEAP8[$10 + $8 >> 0] = 0;
  $12 = _concat3($orig_path_elt, 13340, $10) | 0;
  _free($10);
  $$07 = $3 + 1 | 0;
  $path_elt$0 = $12;
  $temp_str$0 = $12;
 }
 $15 = HEAP32[$kpse + 36 >> 2] | 0;
 if (!$15) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $18 = HEAP32[$kpse + 40 >> 2] | 0;
 $$pre13$i = HEAP8[$path_elt$0 >> 0] | 0;
 $e$03456 = 0;
 L10 : while (1) {
  $20 = HEAP32[$18 + ($e$03456 << 2) >> 2] | 0;
  $$1$i = $path_elt$0;
  $$13$i = $20;
  $23 = HEAP8[$20 >> 0] | 0;
  $25 = $$pre13$i;
  while (1) {
   $21 = $$13$i + 1 | 0;
   $22 = $$1$i + 1 | 0;
   if ($23 << 24 >> 24 != $25 << 24 >> 24) break;
   $26 = HEAP8[$21 >> 0] | 0;
   if (!($26 << 24 >> 24)) break L10;
   $28 = HEAP8[$22 >> 0] | 0;
   if (!($28 << 24 >> 24)) break; else {
    $$1$i = $22;
    $$13$i = $21;
    $23 = $26;
    $25 = $28;
   }
  }
  $30 = $e$03456 + 1 | 0;
  if ($30 >>> 0 < $15 >>> 0) $e$03456 = $30; else {
   $$0 = 0;
   label = 54;
   break;
  }
 }
 if ((label | 0) == 54) {
  STACKTOP = sp;
  return $$0 | 0;
 }
 $32 = $kpse + 28 | 0;
 if (!(HEAP32[$32 >> 2] | 0)) label = 13; else {
  HEAP32[$$byval_copy8 >> 2] = HEAP32[$32 >> 2];
  HEAP32[$$byval_copy8 + 4 >> 2] = HEAP32[$32 + 4 >> 2];
  $35 = _hash_lookup($$byval_copy8, $$07) | 0;
  if (!$35) label = 13; else if (!(HEAP32[$35 >> 2] | 0)) {
   $aliases$140 = $35;
   $len1$0$lcssa = 1;
  } else {
   $len1$029 = 1;
   $r$028 = $35;
   while (1) {
    $39 = $len1$029 + 1 | 0;
    $40 = $r$028 + 4 | 0;
    if (!(HEAP32[$40 >> 2] | 0)) {
     $aliases$140 = $35;
     $len1$0$lcssa = $39;
     break;
    } else {
     $len1$029 = $39;
     $r$028 = $40;
    }
   }
  }
 }
 if ((label | 0) == 13) {
  $37 = _xmalloc(4) | 0;
  HEAP32[$37 >> 2] = 0;
  $aliases$140 = $37;
  $len1$0$lcssa = 1;
 }
 $45 = _xrealloc($aliases$140, ($len1$0$lcssa << 2) + 4 | 0) | 0;
 if ($len1$0$lcssa | 0) {
  $i$026 = $len1$0$lcssa;
  while (1) {
   $47 = $i$026 + -1 | 0;
   HEAP32[$45 + ($i$026 << 2) >> 2] = HEAP32[$45 + ($47 << 2) >> 2];
   if (!$47) break; else $i$026 = $47;
  }
 }
 HEAP32[$45 >> 2] = $$07;
 $52 = $kpse + 44 | 0;
 $53 = $45 + 4 | 0;
 $54 = ($all | 0) == 0;
 $55 = HEAP32[21] | 0;
 L32 : do if (!$$07) $ret$0$lcssa = 0; else {
  $57 = $$07;
  $r$12552 = $45;
  while (1) {
   HEAP32[$$byval_copy8 >> 2] = HEAP32[$0 >> 2];
   HEAP32[$$byval_copy8 + 4 >> 2] = HEAP32[$0 + 4 >> 2];
   $58 = _hash_lookup($$byval_copy8, $57) | 0;
   $59 = _xmalloc(8) | 0;
   HEAP32[$59 >> 2] = 0;
   HEAP32[$59 + 4 >> 2] = 0;
   $61 = ($58 | 0) == 0;
   if (!$61) {
    $62 = HEAP32[$58 >> 2] | 0;
    $63 = ($62 | 0) == 0;
    L37 : do if ($54) if ($63) $done$1$lcssa = 0; else {
     $64 = $62;
     $db_dirs$016$us50 = $58;
     L39 : while (1) {
      $65 = _concat($64, $57) | 0;
      $66 = _match($65, $path_elt$0) | 0;
      if (HEAP32[$52 >> 2] & 32 | 0) {
       _fwrite(13458, 7, 1, $55) | 0;
       HEAP32[$vararg_buffer >> 2] = $65;
       HEAP32[$vararg_buffer + 4 >> 2] = $path_elt$0;
       HEAP32[$vararg_buffer + 8 >> 2] = $66;
       _fprintf($55, 10494, $vararg_buffer) | 0;
       _fflush($55) | 0;
      }
      do if (!$66) _free($65); else {
       if (!(_kpathsea_readable_file($kpse, $65) | 0)) {
        _free($65);
        $73 = HEAP32[$53 >> 2] | 0;
        if (!$73) break; else {
         $77 = $73;
         $a$013$us = $53;
        }
        while (1) {
         $78 = _concat(HEAP32[$db_dirs$016$us50 >> 2] | 0, $77) | 0;
         if (!(_kpathsea_readable_file($kpse, $78) | 0)) {
          _free($78);
          $found$1$us = 0;
         } else $found$1$us = $78;
         $81 = $a$013$us + 4 | 0;
         $82 = HEAP32[$81 >> 2] | 0;
         if (($found$1$us | 0) == 0 & ($82 | 0) != 0) {
          $77 = $82;
          $a$013$us = $81;
         } else {
          $found$2$us = $found$1$us;
          break;
         }
        }
       } else $found$2$us = $65;
       if ($found$2$us | 0) {
        $found$2$us$lcssa = $found$2$us;
        break L39;
       }
      } while (0);
      $85 = $db_dirs$016$us50 + 4 | 0;
      $86 = HEAP32[$85 >> 2] | 0;
      if (!$86) {
       $done$1$lcssa = 0;
       break L37;
      } else {
       $64 = $86;
       $db_dirs$016$us50 = $85;
      }
     }
     _str_list_add($59, $found$2$us$lcssa);
     $done$1$lcssa = 1;
    } else if ($63) $done$1$lcssa = 0; else {
     $88 = $62;
     $db_dirs$01648 = $58;
     while (1) {
      $89 = _concat($88, $57) | 0;
      $90 = _match($89, $path_elt$0) | 0;
      if (HEAP32[$52 >> 2] & 32 | 0) {
       _fwrite(13458, 7, 1, $55) | 0;
       HEAP32[$vararg_buffer3 >> 2] = $89;
       HEAP32[$vararg_buffer3 + 4 >> 2] = $path_elt$0;
       HEAP32[$vararg_buffer3 + 8 >> 2] = $90;
       _fprintf($55, 10494, $vararg_buffer3) | 0;
       _fflush($55) | 0;
      }
      do if (!$90) _free($89); else {
       if (!(_kpathsea_readable_file($kpse, $89) | 0)) {
        _free($89);
        $97 = HEAP32[$53 >> 2] | 0;
        if (!$97) break; else {
         $100 = $97;
         $a$013 = $53;
        }
        while (1) {
         $101 = _concat(HEAP32[$db_dirs$01648 >> 2] | 0, $100) | 0;
         if (!(_kpathsea_readable_file($kpse, $101) | 0)) {
          _free($101);
          $found$1 = 0;
         } else $found$1 = $101;
         $104 = $a$013 + 4 | 0;
         $105 = HEAP32[$104 >> 2] | 0;
         if (($found$1 | 0) == 0 & ($105 | 0) != 0) {
          $100 = $105;
          $a$013 = $104;
         } else {
          $found$2 = $found$1;
          break;
         }
        }
       } else $found$2 = $89;
       if ($found$2 | 0) _str_list_add($59, $found$2);
      } while (0);
      $109 = $db_dirs$01648 + 4 | 0;
      $110 = HEAP32[$109 >> 2] | 0;
      if (!$110) {
       $done$1$lcssa = 0;
       break;
      } else {
       $88 = $110;
       $db_dirs$01648 = $109;
      }
     }
    } while (0);
    if (!$61) if (HEAP32[$58 >> 2] | 0) _free($58);
    if ($done$1$lcssa | 0) {
     $ret$0$lcssa = $59;
     break L32;
    }
   }
   $115 = $r$12552 + 4 | 0;
   $$pre38 = HEAP32[$115 >> 2] | 0;
   if (!$$pre38) {
    $ret$0$lcssa = $59;
    break;
   } else {
    $57 = $$pre38;
    $r$12552 = $115;
   }
  }
 } while (0);
 _free($45);
 if (!$temp_str$0) {
  $$0 = $ret$0$lcssa;
  STACKTOP = sp;
  return $$0 | 0;
 }
 _free($temp_str$0);
 $$0 = $ret$0$lcssa;
 STACKTOP = sp;
 return $$0 | 0;
}

function _scanandstorethefieldvalueandeatwhite() {
 var $$lcssa = 0, $$lcssa$i$i = 0, $$lcssa25 = 0, $104 = 0, $112 = 0, $115 = 0, $116 = 0, $131 = 0, $132 = 0, $140 = 0, $141 = 0, $143 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $15 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $162 = 0, $164 = 0, $166 = 0, $170 = 0, $174 = 0, $18 = 0, $19 = 0, $2 = 0, $26 = 0, $3 = 0, $43 = 0, $44 = 0, $46 = 0, $51 = 0, $54 = 0, $57 = 0, $81 = 0, $83 = 0, $86 = 0, $9 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $96 = 0, $Result$0 = 0, $i$0$i = 0, $storemerge = 0, $storemerge69 = 0, $storemerge7 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer10 = 0, $vararg_buffer13 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer13 = sp + 40 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 HEAP32[4251] = 0;
 if (!(_scanafieldtokenandeatwhite() | 0)) {
  $Result$0 = 0;
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 L3 : while (1) {
  $2 = HEAP32[4045] | 0;
  $3 = HEAP32[3993] | 0;
  if ((HEAP8[$3 + $2 >> 0] | 0) != 35) {
   label = 11;
   break;
  }
  $9 = $3;
  $storemerge7 = $2 + 1 | 0;
  while (1) {
   HEAP32[4045] = $storemerge7;
   $15 = HEAP32[3999] | 0;
   $16 = ($storemerge7 | 0) < ($15 | 0);
   if ((HEAP8[25877 + (HEAPU8[$9 + $storemerge7 >> 0] | 0) >> 0] | 0) == 1 & $16) {
    $19 = $storemerge7;
    while (1) {
     $18 = $19 + 1 | 0;
     HEAP32[4045] = $18;
     $26 = ($18 | 0) < ($15 | 0);
     if ($26 & (HEAP8[25877 + (HEAPU8[$9 + $18 >> 0] | 0) >> 0] | 0) == 1) $19 = $18; else {
      $$lcssa$i$i = $26;
      break;
     }
    }
   } else $$lcssa$i$i = $16;
   if ($$lcssa$i$i) break;
   if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) {
    label = 9;
    break L3;
   }
   HEAP32[4146] = (HEAP32[4146] | 0) + 1;
   $9 = HEAP32[3993] | 0;
   $storemerge7 = 0;
  }
  if (!(_scanafieldtokenandeatwhite() | 0)) {
   $Result$0 = 0;
   label = 45;
   break;
  }
 }
 if ((label | 0) == 9) {
  _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
  _biberrprint();
  $Result$0 = 0;
  STACKTOP = sp;
  return $Result$0 | 0;
 } else if ((label | 0) == 11) {
  if (!(HEAP32[4318] | 0)) {
   $Result$0 = 1;
   STACKTOP = sp;
   return $Result$0 | 0;
  }
  $43 = (HEAP32[4147] | 0) == 0;
  $44 = HEAP32[4251] | 0;
  if ($43 & ($44 | 0) > 0) {
   $46 = $44 + -1 | 0;
   if ((HEAP8[(HEAP32[3995] | 0) + $46 >> 0] | 0) == 32) {
    HEAP32[4251] = $46;
    $54 = $46;
   } else $54 = $44;
  } else $54 = $44;
  $51 = HEAP32[3995] | 0;
  if ($43) if ((HEAP8[$51 >> 0] | 0) == 32 & ($54 | 0) > 0) $storemerge = 1; else label = 17; else label = 17;
  if ((label | 0) == 17) $storemerge = 0;
  HEAP32[4323] = $storemerge;
  $57 = _zstrlookup($51, $storemerge, $54 - $storemerge | 0, 0, 1) | 0;
  HEAP32[4324] = $57;
  HEAP8[(HEAP32[4144] | 0) + $57 >> 0] = 3;
  if (HEAP32[4147] | 0) switch (HEAP32[4321] | 0) {
  case 1:
   {
    HEAP32[(HEAP32[4325] | 0) + (HEAP32[4304] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4324] << 2) >> 2];
    HEAP32[4304] = (HEAP32[4304] | 0) + 1;
    $Result$0 = 1;
    STACKTOP = sp;
    return $Result$0 | 0;
   }
  case 2:
   {
    HEAP32[(HEAP32[4249] | 0) + (HEAP32[4322] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4324] << 2) >> 2];
    $Result$0 = 1;
    STACKTOP = sp;
    return $Result$0 | 0;
   }
  default:
   _bibcmdconfusion();
  }
  $81 = Math_imul(HEAP32[4247] | 0, HEAP32[4326] | 0) | 0;
  $83 = HEAP32[4249] | 0;
  $86 = (HEAP32[$83 + (HEAP32[4327] << 2) >> 2] | 0) + $81 | 0;
  HEAP32[4151] = $86;
  if (($86 | 0) >= (HEAP32[4148] | 0)) {
   _fwrite(3267, 32, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3267, 32, 1, HEAP32[3990] | 0) | 0;
   $91 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = 964;
   _fprintf($91, 960, $vararg_buffer) | 0;
   $92 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer1 >> 2] = 964;
   _fprintf($92, 960, $vararg_buffer1) | 0;
   $93 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer4 >> 2] = 985;
   _fprintf($93, 960, $vararg_buffer4) | 0;
   $94 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer7 >> 2] = 985;
   _fprintf($94, 960, $vararg_buffer7) | 0;
   HEAP8[25620] = 3;
   _longjmp(16008, 1);
  }
  $96 = (HEAP32[4149] | 0) + ($86 << 2) | 0;
  if (HEAP32[$96 >> 2] | 0) {
   _fwrite(3300, 22, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3300, 22, 1, HEAP32[3990] | 0) | 0;
   $104 = HEAP32[(HEAP32[4099] | 0) + (HEAP32[4326] << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $104);
   _zoutpoolstr(HEAP32[3989] | 0, $104);
   _fwrite(3323, 10, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3323, 10, 1, HEAP32[3990] | 0) | 0;
   $112 = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4327] << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $112);
   _zoutpoolstr(HEAP32[3989] | 0, $112);
   $115 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer10 >> 2] = 3334;
   _fprintf($115, 960, $vararg_buffer10) | 0;
   $116 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer13 >> 2] = 3334;
   _fprintf($116, 960, $vararg_buffer13) | 0;
   _biblnnumprint();
   switch (HEAP8[25620] | 0) {
   case 1:
    {
     HEAP32[3991] = (HEAP32[3991] | 0) + 1;
     $Result$0 = 1;
     STACKTOP = sp;
     return $Result$0 | 0;
    }
   case 0:
    {
     HEAP8[25620] = 1;
     HEAP32[3991] = 1;
     $Result$0 = 1;
     STACKTOP = sp;
     return $Result$0 | 0;
    }
   default:
    {
     $Result$0 = 1;
     STACKTOP = sp;
     return $Result$0 | 0;
    }
   }
  }
  HEAP32[$96 >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4324] << 2) >> 2];
  if (HEAP32[4328] | 0 ? 1 : (HEAP32[$83 + (HEAP32[4327] << 2) >> 2] | 0) != (HEAP32[4305] | 0)) {
   $Result$0 = 1;
   STACKTOP = sp;
   return $Result$0 | 0;
  }
  $131 = HEAP32[4323] | 0;
  HEAP32[4252] = $131;
  $132 = HEAP32[4251] | 0;
  if (($131 | 0) < ($132 | 0)) {
   $storemerge69 = $131;
   while (1) {
    HEAP8[(HEAP32[3996] | 0) + $storemerge69 >> 0] = HEAP8[(HEAP32[3995] | 0) + $storemerge69 >> 0] | 0;
    $140 = (HEAP32[4252] | 0) + 1 | 0;
    HEAP32[4252] = $140;
    $141 = HEAP32[4251] | 0;
    if (($140 | 0) < ($141 | 0)) $storemerge69 = $140; else {
     $$lcssa25 = $141;
     break;
    }
   }
   $$lcssa = $$lcssa25;
   $145 = HEAP32[4323] | 0;
  } else {
   $$lcssa = $132;
   $145 = $131;
  }
  $143 = HEAP32[3996] | 0;
  if (($$lcssa | 0) > ($145 | 0)) {
   $146 = $$lcssa + -1 | 0;
   $i$0$i = $145;
   while (1) {
    $147 = $143 + $i$0$i | 0;
    $148 = HEAP8[$147 >> 0] | 0;
    if (($148 + -65 & 255) < 26) HEAP8[$147 >> 0] = ($148 & 255) + 32;
    if (($i$0$i | 0) < ($146 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
   }
   $156 = HEAP32[4323] | 0;
   $157 = HEAP32[4251] | 0;
   $158 = HEAP32[3996] | 0;
  } else {
   $156 = $145;
   $157 = $$lcssa;
   $158 = $143;
  }
  $159 = _zstrlookup($158, $156, $157 - $156 | 0, 10, 1) | 0;
  HEAP32[4250] = $159;
  if (!(HEAP32[4241] | 0)) {
   $174 = HEAP32[4323] | 0;
   HEAP32[4248] = _zstrlookup(HEAP32[3995] | 0, $174, (HEAP32[4251] | 0) - $174 | 0, 9, 1) | 0;
   if (HEAP32[4241] | 0) _hashciteconfusion();
   _zzadddatabasecite(16600);
   HEAP32[(HEAP32[4102] | 0) + (HEAP32[(HEAP32[4249] | 0) + (HEAP32[4248] << 2) >> 2] << 2) >> 2] = 1;
   $Result$0 = 1;
   STACKTOP = sp;
   return $Result$0 | 0;
  } else {
   $162 = HEAP32[4249] | 0;
   $164 = HEAP32[$162 + ($159 << 2) >> 2] | 0;
   HEAP32[4248] = $164;
   $166 = HEAP32[$162 + ($164 << 2) >> 2] | 0;
   if (($166 | 0) < (HEAP32[4329] | 0)) {
    $Result$0 = 1;
    STACKTOP = sp;
    return $Result$0 | 0;
   }
   $170 = (HEAP32[4102] | 0) + ($166 << 2) | 0;
   HEAP32[$170 >> 2] = (HEAP32[$170 >> 2] | 0) + 1;
   $Result$0 = 1;
   STACKTOP = sp;
   return $Result$0 | 0;
  }
 } else if ((label | 0) == 45) {
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 return 0;
}

function _bstexecutecommand() {
 var $$lcssa$i$i = 0, $$lcssa$i$i12 = 0, $$lcssa$i$i3 = 0, $$lcssa129 = 0, $$lcssa131 = 0, $$lcssa133 = 0, $$lcssa134 = 0, $$lcssa135 = 0, $$lcssa139 = 0, $$lcssa141 = 0, $$lcssa143 = 0, $$lcssa148 = 0, $$lcssa150 = 0, $$lcssa152 = 0, $$lcssa154 = 0, $105 = 0, $107 = 0, $108 = 0, $113 = 0, $114 = 0, $116 = 0, $117 = 0, $119 = 0, $12 = 0, $124 = 0, $126 = 0, $13 = 0, $138 = 0, $140 = 0, $141 = 0, $143 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $16 = 0, $18 = 0, $23 = 0, $25 = 0, $37 = 0, $39 = 0, $4 = 0, $40 = 0, $42 = 0, $47 = 0, $48 = 0, $53 = 0, $54 = 0, $56 = 0, $57 = 0, $59 = 0, $6 = 0, $64 = 0, $66 = 0, $7 = 0, $79 = 0, $87 = 0, $88 = 0, $90 = 0, $91 = 0, $storemerge = 0, $storemerge21 = 0, $storemerge22 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (!(HEAP32[4675] | 0)) {
  _fwrite(4772, 44, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4772, 44, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $6 = HEAP32[4045] | 0;
 while (1) {
  $4 = HEAP32[3993] | 0;
  $7 = HEAP8[$4 + $6 >> 0] | 0;
  $12 = HEAP32[3999] | 0;
  $13 = ($6 | 0) < ($12 | 0);
  if ((HEAP8[25877 + ($7 & 255) >> 0] | 0) == 1 & $13) {
   $16 = $6;
   while (1) {
    $15 = $16 + 1 | 0;
    HEAP32[4045] = $15;
    $18 = HEAP8[$4 + $15 >> 0] | 0;
    $23 = ($15 | 0) < ($12 | 0);
    if ($23 & (HEAP8[25877 + ($18 & 255) >> 0] | 0) == 1) $16 = $15; else {
     $$lcssa$i$i = $23;
     $149 = $15;
     $25 = $18;
     break;
    }
   }
  } else {
   $$lcssa$i$i = $13;
   $149 = $6;
   $25 = $7;
  }
  if (!($25 << 24 >> 24 == 37 | $$lcssa$i$i ^ 1)) {
   $$lcssa148 = $4;
   $$lcssa150 = $12;
   $$lcssa152 = $149;
   $$lcssa154 = $25;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 9;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  HEAP32[4045] = 0;
  $6 = 0;
 }
 if ((label | 0) == 9) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4817, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4817, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 if ($$lcssa154 << 24 >> 24 != 123) {
  $37 = HEAP32[3989] | 0;
  $39 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer >> 2] = 34;
  HEAP32[$vararg_buffer + 4 >> 2] = $39;
  HEAP32[$vararg_buffer + 8 >> 2] = 1832;
  _fprintf($37, 1750, $vararg_buffer) | 0;
  $40 = HEAP32[3990] | 0;
  $42 = HEAPU8[26256] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 34;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $42;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 1832;
  _fprintf($40, 1750, $vararg_buffer3) | 0;
  _fwrite(4817, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4817, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 $47 = $$lcssa148;
 $54 = $$lcssa150;
 $storemerge = $$lcssa152 + 1 | 0;
 while (1) {
  HEAP32[4045] = $storemerge;
  $48 = HEAP8[$47 + $storemerge >> 0] | 0;
  $53 = ($storemerge | 0) < ($54 | 0);
  if ((HEAP8[25877 + ($48 & 255) >> 0] | 0) == 1 & $53) {
   $57 = $storemerge;
   while (1) {
    $56 = $57 + 1 | 0;
    HEAP32[4045] = $56;
    $59 = HEAP8[$47 + $56 >> 0] | 0;
    $64 = ($56 | 0) < ($54 | 0);
    if ($64 & (HEAP8[25877 + ($59 & 255) >> 0] | 0) == 1) $57 = $56; else {
     $$lcssa$i$i3 = $64;
     $150 = $56;
     $66 = $59;
     break;
    }
   }
  } else {
   $$lcssa$i$i3 = $53;
   $150 = $storemerge;
   $66 = $48;
  }
  if (!($66 << 24 >> 24 == 37 | $$lcssa$i$i3 ^ 1)) {
   $$lcssa139 = $54;
   $$lcssa141 = $47;
   $$lcssa143 = $150;
   break;
  }
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 18;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  $47 = HEAP32[3993] | 0;
  $54 = HEAP32[3999] | 0;
  $storemerge = 0;
 }
 if ((label | 0) == 18) {
  _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4817, 7, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4817, 7, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  STACKTOP = sp;
  return;
 }
 HEAP32[4044] = $$lcssa143;
 $79 = HEAPU8[$$lcssa141 + $$lcssa143 >> 0] | 0;
 L33 : do if ((HEAP8[25877 + $79 >> 0] | 0) == 3) $storemerge21 = 0; else if ((HEAP8[26390 + $79 >> 0] | 0) == 1 & ($$lcssa143 | 0) < ($$lcssa139 | 0)) {
  $88 = $$lcssa143;
  while (1) {
   $87 = $88 + 1 | 0;
   HEAP32[4045] = $87;
   $90 = HEAP8[$$lcssa141 + $87 >> 0] | 0;
   $91 = $90 & 255;
   if (($87 | 0) < ($$lcssa139 | 0) & (HEAP8[26390 + $91 >> 0] | 0) == 1) $88 = $87; else {
    $$lcssa133 = $87;
    $$lcssa134 = $90;
    $$lcssa135 = $91;
    break;
   }
  }
  if (($$lcssa133 | 0) == ($$lcssa143 | 0)) $storemerge21 = 0; else {
   if ((HEAP8[25877 + $$lcssa135 >> 0] | 0) == 1 | ($$lcssa133 | 0) == ($$lcssa139 | 0)) $storemerge22 = 3; else switch ($$lcssa134 << 24 >> 24) {
   case 37:
   case 125:
    {
     $storemerge22 = 1;
     break;
    }
   default:
    {
     $storemerge21 = 2;
     break L33;
    }
   }
   HEAP8[26389] = $storemerge22;
   if (_badargumenttoken() | 0) {
    STACKTOP = sp;
    return;
   }
   $107 = HEAP32[4045] | 0;
   while (1) {
    $105 = HEAP32[3993] | 0;
    $108 = HEAP8[$105 + $107 >> 0] | 0;
    $113 = HEAP32[3999] | 0;
    $114 = ($107 | 0) < ($113 | 0);
    if ((HEAP8[25877 + ($108 & 255) >> 0] | 0) == 1 & $114) {
     $117 = $107;
     while (1) {
      $116 = $117 + 1 | 0;
      HEAP32[4045] = $116;
      $119 = HEAP8[$105 + $116 >> 0] | 0;
      $124 = ($116 | 0) < ($113 | 0);
      if ($124 & (HEAP8[25877 + ($119 & 255) >> 0] | 0) == 1) $117 = $116; else {
       $$lcssa$i$i12 = $124;
       $126 = $119;
       $151 = $116;
       break;
      }
     }
    } else {
     $$lcssa$i$i12 = $114;
     $126 = $108;
     $151 = $107;
    }
    if (!($126 << 24 >> 24 == 37 | $$lcssa$i$i12 ^ 1)) {
     $$lcssa129 = $151;
     $$lcssa131 = $126;
     break;
    }
    if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
     label = 33;
     break;
    }
    HEAP32[4103] = (HEAP32[4103] | 0) + 1;
    HEAP32[4045] = 0;
    $107 = 0;
   }
   if ((label | 0) == 33) {
    _fwrite(1509, 38, 1, HEAP32[3989] | 0) | 0;
    _fwrite(1509, 38, 1, HEAP32[3990] | 0) | 0;
    _fwrite(4817, 7, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4817, 7, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   if ($$lcssa131 << 24 >> 24 == 125) {
    HEAP32[4045] = $$lcssa129 + 1;
    HEAP32[4360] = 0;
    HEAP32[4364] = HEAP32[4e3];
    HEAP32[4152] = 0;
    _zexecutefn(HEAP32[4310] | 0);
    _checkcommandexecution();
    STACKTOP = sp;
    return;
   } else {
    $138 = HEAP32[3989] | 0;
    $140 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer8 >> 2] = 34;
    HEAP32[$vararg_buffer8 + 4 >> 2] = $140;
    HEAP32[$vararg_buffer8 + 8 >> 2] = 1832;
    _fprintf($138, 1750, $vararg_buffer8) | 0;
    $141 = HEAP32[3990] | 0;
    $143 = HEAPU8[26258] | 0;
    HEAP32[$vararg_buffer13 >> 2] = 34;
    HEAP32[$vararg_buffer13 + 4 >> 2] = $143;
    HEAP32[$vararg_buffer13 + 8 >> 2] = 1832;
    _fprintf($141, 1750, $vararg_buffer13) | 0;
    _fwrite(4817, 7, 1, HEAP32[3989] | 0) | 0;
    _fwrite(4817, 7, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
  }
 } else $storemerge21 = 0; while (0);
 HEAP8[26389] = $storemerge21;
 _bstidprint();
 _fwrite(4817, 7, 1, HEAP32[3989] | 0) | 0;
 _fwrite(4817, 7, 1, HEAP32[3990] | 0) | 0;
 _bsterrprintandlookforblankline();
 STACKTOP = sp;
 return;
}

function _getbstcommandandprocess() {
 var $$lcssa = 0, $$lcssa26 = 0, $$lcssa27 = 0, $$lcssa28 = 0, $0 = 0, $1 = 0, $102 = 0, $103 = 0, $106 = 0, $11 = 0, $112 = 0, $113 = 0, $115 = 0, $116 = 0, $118 = 0, $12 = 0, $126 = 0, $129 = 0, $133 = 0, $138 = 0, $14 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $21 = 0, $23 = 0, $26 = 0, $27 = 0, $3 = 0, $35 = 0, $37 = 0, $38 = 0, $45 = 0, $46 = 0, $47 = 0, $49 = 0, $52 = 0, $58 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $67 = 0, $71 = 0, $73 = 0, $8 = 0, $83 = 0, $89 = 0, $94 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$0$i = 0, $i$01$i$i = 0, $i$01$i1$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa25 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer14 = 0, $vararg_buffer17 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer17 = sp + 56 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4045] | 0;
 HEAP32[4044] = $0;
 $1 = HEAP32[3993] | 0;
 $3 = HEAP8[$1 + $0 >> 0] | 0;
 $8 = HEAP32[3999] | 0;
 if (($0 | 0) < ($8 | 0) ? (HEAP8[25877 + ($3 & 255) >> 0] | 0) == 2 : 0) {
  $12 = $0;
  while (1) {
   $11 = $12 + 1 | 0;
   HEAP32[4045] = $11;
   $14 = HEAP8[$1 + $11 >> 0] | 0;
   if (($11 | 0) < ($8 | 0) ? (HEAP8[25877 + ($14 & 255) >> 0] | 0) == 2 : 0) $12 = $11; else {
    $$lcssa26 = $12;
    $$lcssa27 = $11;
    $$lcssa28 = $14;
    break;
   }
  }
  if (($$lcssa27 | 0) == ($0 | 0)) $23 = $$lcssa28; else {
   if (($$lcssa26 | 0) < ($0 | 0)) {
    $46 = $0;
    $47 = $$lcssa27;
    $52 = $1;
   } else {
    $i$0$i = $0;
    while (1) {
     $37 = $1 + $i$0$i | 0;
     $38 = HEAP8[$37 >> 0] | 0;
     if (($38 + -65 & 255) < 26) HEAP8[$37 >> 0] = ($38 & 255) + 32;
     if (($i$0$i | 0) < ($$lcssa26 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
    }
    $46 = HEAP32[4044] | 0;
    $47 = HEAP32[4045] | 0;
    $52 = HEAP32[3993] | 0;
   }
   $45 = $47 - $46 | 0;
   if (($45 | 0) > 0) {
    $49 = HEAP32[4240] | 0;
    $h$06$i = 0;
    $k$07$i = $46;
    while (1) {
     $h$1$i = (HEAPU8[$52 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
     while (1) if (($h$1$i | 0) < ($49 | 0)) {
      $h$1$i$lcssa = $h$1$i;
      break;
     } else $h$1$i = $h$1$i - $49 | 0;
     $58 = $k$07$i + 1 | 0;
     if (($58 | 0) < ($47 | 0)) {
      $h$06$i = $h$1$i$lcssa;
      $k$07$i = $58;
     } else {
      $h$0$lcssa$i = $h$1$i$lcssa;
      break;
     }
    }
   } else $h$0$lcssa$i = 0;
   HEAP32[4241] = 0;
   $61 = HEAP32[4145] | 0;
   $62 = HEAP32[4041] | 0;
   $63 = HEAP32[4042] | 0;
   $64 = HEAP32[4242] | 0;
   $65 = HEAP32[4243] | 0;
   $p$0$i = $h$0$lcssa$i + 1 | 0;
   L22 : while (1) {
    $67 = HEAP32[$61 + ($p$0$i << 2) >> 2] | 0;
    L24 : do if (($67 | 0) > 0) {
     $71 = HEAP32[$62 + ($67 + 1 << 2) >> 2] | 0;
     $73 = HEAP32[$62 + ($67 << 2) >> 2] | 0;
     if (($71 - $73 | 0) == ($45 | 0)) {
      if (($71 | 0) > ($73 | 0)) {
       $i$01$i$i = $46;
       $j$02$i$i = $73;
       while (1) {
        if ((HEAP8[$63 + $j$02$i$i >> 0] | 0) != (HEAP8[$52 + $i$01$i$i >> 0] | 0)) break L24;
        $83 = $j$02$i$i + 1 | 0;
        if (($83 | 0) < ($71 | 0)) {
         $i$01$i$i = $i$01$i$i + 1 | 0;
         $j$02$i$i = $83;
        } else break;
       }
      }
      if ((HEAP8[$64 + $p$0$i >> 0] | 0) == 4) {
       $p$0$i$lcssa = $p$0$i;
       break L22;
      }
     }
    } while (0);
    $89 = HEAP32[$65 + ($p$0$i << 2) >> 2] | 0;
    if (!$89) {
     $p$0$i$lcssa25 = $p$0$i;
     label = 23;
     break;
    } else $p$0$i = $89;
   }
   if ((label | 0) == 23) {
    HEAP32[4321] = HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa25 << 2) >> 2];
    $94 = HEAP32[3990] | 0;
    if (($47 | 0) > ($46 | 0)) {
     _putc(HEAPU8[26133 + (HEAPU8[$52 + $46 >> 0] | 0) >> 0] | 0, $94) | 0;
     $102 = $46 + 1 | 0;
     $103 = HEAP32[4045] | 0;
     if (($102 | 0) < ($103 | 0)) {
      $106 = $102;
      while (1) {
       _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $106 >> 0] | 0) >> 0] | 0, $94) | 0;
       $112 = $106 + 1 | 0;
       $113 = HEAP32[4045] | 0;
       if (($112 | 0) < ($113 | 0)) $106 = $112; else {
        $$lcssa = $113;
        break;
       }
      }
     } else $$lcssa = $103;
     $116 = HEAP32[4044] | 0;
     $118 = $$lcssa;
    } else {
     $116 = $46;
     $118 = $47;
    }
    $115 = HEAP32[3989] | 0;
    if (($116 | 0) < ($118 | 0)) {
     $i$01$i1$i = $116;
     while (1) {
      _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $115) | 0;
      $126 = $i$01$i1$i + 1 | 0;
      if (($126 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $126; else break;
     }
     $129 = HEAP32[3989] | 0;
    } else $129 = $115;
    _fwrite(5588, 33, 1, $129) | 0;
    _fwrite(5588, 33, 1, HEAP32[3990] | 0) | 0;
    _bsterrprintandlookforblankline();
    STACKTOP = sp;
    return;
   }
   HEAP32[4241] = 1;
   $133 = HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0;
   HEAP32[4321] = $133;
   do switch ($133 | 0) {
   case 0:
    {
     _bstentrycommand();
     STACKTOP = sp;
     return;
    }
   case 1:
    {
     _bstexecutecommand();
     STACKTOP = sp;
     return;
    }
   case 2:
    {
     _bstfunctioncommand();
     STACKTOP = sp;
     return;
    }
   case 3:
    {
     _bstintegerscommand();
     STACKTOP = sp;
     return;
    }
   case 4:
    {
     _bstiteratecommand();
     STACKTOP = sp;
     return;
    }
   case 5:
    {
     _bstmacrocommand();
     STACKTOP = sp;
     return;
    }
   case 6:
    {
     _bstreadcommand();
     STACKTOP = sp;
     return;
    }
   case 7:
    {
     _bstreversecommand();
     STACKTOP = sp;
     return;
    }
   case 8:
    {
     if (!(HEAP32[4675] | 0)) {
      _fwrite(5467, 41, 1, HEAP32[3989] | 0) | 0;
      _fwrite(5467, 41, 1, HEAP32[3990] | 0) | 0;
      _bsterrprintandlookforblankline();
      STACKTOP = sp;
      return;
     }
     $138 = HEAP32[4157] | 0;
     if (($138 | 0) <= 1) {
      STACKTOP = sp;
      return;
     }
     _zquicksort(0, $138 + -1 | 0);
     STACKTOP = sp;
     return;
    }
   case 9:
    {
     _bststringscommand();
     STACKTOP = sp;
     return;
    }
   default:
    {
     _fwrite(5622, 26, 1, HEAP32[3989] | 0) | 0;
     _fwrite(5622, 26, 1, HEAP32[3990] | 0) | 0;
     $143 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer8 >> 2] = 964;
     _fprintf($143, 960, $vararg_buffer8) | 0;
     $144 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer11 >> 2] = 964;
     _fprintf($144, 960, $vararg_buffer11) | 0;
     $145 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer14 >> 2] = 985;
     _fprintf($145, 960, $vararg_buffer14) | 0;
     $146 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer17 >> 2] = 985;
     _fprintf($146, 960, $vararg_buffer17) | 0;
     HEAP8[25620] = 3;
     _longjmp(16008, 1);
    }
   } while (0);
  }
 } else $23 = $3;
 $21 = HEAP32[3989] | 0;
 $26 = HEAPU8[26133 + ($23 & 255) >> 0] | 0;
 HEAP32[$vararg_buffer >> 2] = 34;
 HEAP32[$vararg_buffer + 4 >> 2] = $26;
 HEAP32[$vararg_buffer + 8 >> 2] = 5553;
 _fprintf($21, 1750, $vararg_buffer) | 0;
 $27 = HEAP32[3990] | 0;
 $35 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 34;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $35;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 5553;
 _fprintf($27, 1750, $vararg_buffer3) | 0;
 _bsterrprintandlookforblankline();
 STACKTOP = sp;
 return;
}
function _xtextprefix() {
 var $$lcssa = 0, $$lcssa38 = 0, $$lcssa39 = 0, $$lcssa40 = 0, $$lcssa41 = 0, $$pr = 0, $$pr19 = 0, $0 = 0, $10 = 0, $100 = 0, $101 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $110 = 0, $13 = 0, $14 = 0, $16 = 0, $19 = 0, $21 = 0, $23 = 0, $24 = 0, $25 = 0, $28 = 0, $29 = 0, $37 = 0, $39 = 0, $40 = 0, $41 = 0, $43 = 0, $46 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $52 = 0, $53 = 0, $55 = 0, $58 = 0, $60 = 0, $62 = 0, $68 = 0, $69 = 0, $70 = 0, $72 = 0, $74 = 0, $78 = 0, $80 = 0, $82 = 0, $83 = 0, $85 = 0, $88 = 0, $90 = 0, $92 = 0, $98 = 0, $storemerge = 0, $storemerge9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $5 = HEAP8[26649] | 0;
   switch ($5 << 24 >> 24) {
   case 1:
    {
     $10 = HEAP32[4345] | 0;
     if (($10 | 0) < 1) {
      _zpushlitstk(HEAP32[4301] | 0, 1);
      STACKTOP = sp;
      return;
     }
     $13 = HEAP32[4365] | 0;
     $14 = HEAP32[4041] | 0;
     $16 = HEAP32[$14 + ($13 << 2) >> 2] | 0;
     HEAP32[4343] = $16;
     $19 = HEAP32[$14 + ($13 + 1 << 2) >> 2] | 0;
     HEAP32[4344] = $19;
     HEAP32[4346] = 0;
     HEAP32[4342] = 0;
     HEAP32[4348] = $16;
     L11 : do if (($16 | 0) < ($19 | 0)) {
      $21 = 0;
      $24 = $16;
      $29 = 0;
      while (1) {
       if (($21 | 0) >= ($10 | 0)) {
        $52 = $24;
        $55 = $29;
        break L11;
       }
       $23 = $24 + 1 | 0;
       HEAP32[4348] = $23;
       $25 = HEAP32[4042] | 0;
       switch (HEAP8[$25 + $24 >> 0] | 0) {
       case 123:
        {
         $28 = $29 + 1 | 0;
         HEAP32[4342] = $28;
         if (($29 | 0) == 0 & ($23 | 0) < ($19 | 0)) if ((HEAP8[$25 + $23 >> 0] | 0) == 92) {
          $storemerge9 = $24 + 2 | 0;
          HEAP32[4348] = $storemerge9;
          L20 : do if (($storemerge9 | 0) < ($19 | 0)) {
           $37 = $storemerge9;
           $40 = $28;
           while (1) {
            switch (HEAP8[$25 + $37 >> 0] | 0) {
            case 125:
             {
              $39 = $40 + -1 | 0;
              HEAP32[4342] = $39;
              $43 = $39;
              break;
             }
            case 123:
             {
              $41 = $40 + 1 | 0;
              HEAP32[4342] = $41;
              $43 = $41;
              break;
             }
            default:
             $43 = $40;
            }
            $storemerge = $37 + 1 | 0;
            HEAP32[4348] = $storemerge;
            if (($storemerge | 0) < ($19 | 0) & ($43 | 0) > 0) {
             $37 = $storemerge;
             $40 = $43;
            } else {
             $107 = $storemerge;
             $108 = $43;
             break L20;
            }
           }
          } else {
           $107 = $storemerge9;
           $108 = $28;
          } while (0);
          $46 = $21 + 1 | 0;
          HEAP32[4346] = $46;
          $105 = $108;
          $106 = $46;
          $50 = $107;
         } else {
          $105 = $28;
          $106 = $21;
          $50 = $23;
         } else {
          $105 = $28;
          $106 = $21;
          $50 = $23;
         }
         break;
        }
       case 125:
        {
         if (($29 | 0) > 0) {
          $48 = $29 + -1 | 0;
          HEAP32[4342] = $48;
          $105 = $48;
          $106 = $21;
          $50 = $23;
         } else {
          $105 = $29;
          $106 = $21;
          $50 = $23;
         }
         break;
        }
       default:
        {
         $49 = $21 + 1 | 0;
         HEAP32[4346] = $49;
         $105 = $29;
         $106 = $49;
         $50 = $23;
        }
       }
       if (($50 | 0) < ($19 | 0)) {
        $21 = $106;
        $24 = $50;
        $29 = $105;
       } else {
        $52 = $50;
        $55 = $105;
        break L11;
       }
      }
     } else {
      $52 = $16;
      $55 = 0;
     } while (0);
     HEAP32[4344] = $52;
     $53 = HEAP32[4237] | 0;
     $58 = HEAP32[4043] | 0;
     if (($55 + $53 + $52 - $16 | 0) > ($58 | 0)) {
      $62 = $58;
      while (1) {
       $60 = HEAP32[3989] | 0;
       HEAP32[$vararg_buffer >> 2] = 1161;
       HEAP32[$vararg_buffer + 4 >> 2] = 1;
       HEAP32[$vararg_buffer + 8 >> 2] = $62 + 65e3;
       HEAP32[$vararg_buffer + 12 >> 2] = $62;
       _fprintf($60, 1023, $vararg_buffer) | 0;
       HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
       $68 = (HEAP32[4043] | 0) + 65e3 | 0;
       HEAP32[4043] = $68;
       $69 = HEAP32[4237] | 0;
       $70 = HEAP32[4342] | 0;
       $72 = HEAP32[4344] | 0;
       $74 = HEAP32[4343] | 0;
       if (($70 + $69 + $72 - $74 | 0) > ($68 | 0)) $62 = $68; else {
        $$lcssa38 = $69;
        $$lcssa39 = $70;
        $$lcssa40 = $72;
        $$lcssa41 = $74;
        break;
       }
      }
      $$pr19 = $$lcssa39;
      $109 = $$lcssa38;
      $78 = HEAP32[4365] | 0;
      $80 = $$lcssa41;
      $82 = $$lcssa40;
     } else {
      $$pr19 = $55;
      $109 = $53;
      $78 = $13;
      $80 = $16;
      $82 = $52;
     }
     if (($78 | 0) < (HEAP32[4364] | 0)) if (($80 | 0) < ($82 | 0)) {
      $85 = $80;
      $88 = $109;
      while (1) {
       $83 = HEAP32[4042] | 0;
       HEAP8[$83 + $88 >> 0] = HEAP8[$83 + $85 >> 0] | 0;
       $90 = (HEAP32[4237] | 0) + 1 | 0;
       HEAP32[4237] = $90;
       $92 = (HEAP32[4343] | 0) + 1 | 0;
       HEAP32[4343] = $92;
       if (($92 | 0) < (HEAP32[4344] | 0)) {
        $85 = $92;
        $88 = $90;
       } else {
        $$lcssa = $90;
        break;
       }
      }
      $$pr = HEAP32[4342] | 0;
      $110 = $$lcssa;
     } else {
      $$pr = $$pr19;
      $110 = $109;
     } else {
      HEAP32[4237] = $82;
      $$pr = $$pr19;
      $110 = $82;
     }
     if (($$pr | 0) > 0) {
      $98 = $110;
      while (1) {
       HEAP8[(HEAP32[4042] | 0) + $98 >> 0] = 125;
       $100 = (HEAP32[4237] | 0) + 1 | 0;
       HEAP32[4237] = $100;
       $101 = HEAP32[4342] | 0;
       HEAP32[4342] = $101 + -1;
       if (($101 | 0) > 1) $98 = $100; else break;
      }
     }
     _zpushlitstk(_makestring() | 0, 1);
     STACKTOP = sp;
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit(HEAP32[4365] | 0, $5);
     _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(HEAP32[4301] | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 STACKTOP = sp;
 return;
}

function _vontokenfound() {
 var $$lcssa = 0, $$lcssa52 = 0, $$lcssa53 = 0, $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $108 = 0, $109 = 0, $11 = 0, $111 = 0, $18 = 0, $21 = 0, $27 = 0, $29 = 0, $30 = 0, $32 = 0, $4 = 0, $40 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $49 = 0, $5 = 0, $53 = 0, $55 = 0, $65 = 0, $71 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $86 = 0, $87 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $95 = 0, $98 = 0, $Result$0 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$01$i$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa51 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 HEAP32[4334] = 0;
 $0 = HEAP32[4335] | 0;
 $1 = HEAP32[4336] | 0;
 if (($0 | 0) >= ($1 | 0)) {
  $Result$0 = 0;
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 $$pre = HEAP32[3994] | 0;
 $10 = 0;
 $4 = $0;
 L4 : while (1) {
  $5 = HEAP8[$$pre + $4 >> 0] | 0;
  if (($5 + -65 & 255) < 26) {
   $Result$0 = 0;
   label = 42;
   break;
  }
  if (($5 + -97 & 255) < 26) {
   $Result$0 = 1;
   label = 42;
   break;
  }
  L8 : do if ($5 << 24 >> 24 == 123) {
   $9 = $10 + 1 | 0;
   HEAP32[4334] = $9;
   $11 = $4 + 1 | 0;
   HEAP32[4335] = $11;
   if (($4 + 3 | 0) < ($1 | 0)) if ((HEAP8[$$pre + $11 >> 0] | 0) == 92) {
    $$lcssa = $9;
    $$lcssa52 = $10;
    $$lcssa53 = $4;
    label = 9;
    break L4;
   }
   if (($10 | 0) > -1) {
    $103 = $9;
    $98 = $11;
    while (1) {
     if (($98 | 0) >= ($1 | 0)) {
      $109 = $98;
      $111 = $103;
      break L8;
     }
     switch (HEAP8[$$pre + $98 >> 0] | 0) {
     case 125:
      {
       $102 = $103 + -1 | 0;
       HEAP32[4334] = $102;
       $106 = $102;
       break;
      }
     case 123:
      {
       $104 = $103 + 1 | 0;
       HEAP32[4334] = $104;
       $106 = $104;
       break;
      }
     default:
      $106 = $103;
     }
     $105 = $98 + 1 | 0;
     HEAP32[4335] = $105;
     if (($106 | 0) > 0) {
      $103 = $106;
      $98 = $105;
     } else {
      $109 = $105;
      $111 = $106;
      break L8;
     }
    }
   } else {
    $109 = $11;
    $111 = $9;
   }
  } else {
   $108 = $4 + 1 | 0;
   HEAP32[4335] = $108;
   $109 = $108;
   $111 = $10;
  } while (0);
  if (($109 | 0) < ($1 | 0)) {
   $10 = $111;
   $4 = $109;
  } else {
   $Result$0 = 0;
   label = 42;
   break;
  }
 }
 if ((label | 0) == 9) {
  $18 = $$lcssa53 + 2 | 0;
  HEAP32[4335] = $18;
  HEAP32[4337] = $18;
  L26 : do if (($18 | 0) < ($1 | 0)) {
   $21 = $18;
   while (1) {
    if ((HEAP8[25877 + (HEAPU8[$$pre + $21 >> 0] | 0) >> 0] | 0) != 2) {
     $30 = $21;
     break L26;
    }
    $27 = $21 + 1 | 0;
    HEAP32[4335] = $27;
    if (($27 | 0) < ($1 | 0)) $21 = $27; else {
     $30 = $27;
     break;
    }
   }
  } else $30 = $18; while (0);
  $29 = $30 - $18 | 0;
  if (($29 | 0) > 0) {
   $32 = HEAP32[4240] | 0;
   $h$06$i = 0;
   $k$07$i = $18;
   while (1) {
    $h$1$i = (HEAPU8[$$pre + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
    while (1) if (($h$1$i | 0) < ($32 | 0)) {
     $h$1$i$lcssa = $h$1$i;
     break;
    } else $h$1$i = $h$1$i - $32 | 0;
    $40 = $k$07$i + 1 | 0;
    if (($40 | 0) < ($30 | 0)) {
     $h$06$i = $h$1$i$lcssa;
     $k$07$i = $40;
    } else {
     $h$0$lcssa$i = $h$1$i$lcssa;
     break;
    }
   }
  } else $h$0$lcssa$i = 0;
  HEAP32[4241] = 0;
  $43 = HEAP32[4145] | 0;
  $44 = HEAP32[4041] | 0;
  $45 = HEAP32[4042] | 0;
  $46 = HEAP32[4242] | 0;
  $47 = HEAP32[4243] | 0;
  $p$0$i = $h$0$lcssa$i + 1 | 0;
  L39 : while (1) {
   $49 = HEAP32[$43 + ($p$0$i << 2) >> 2] | 0;
   L41 : do if (($49 | 0) > 0) {
    $53 = HEAP32[$44 + ($49 + 1 << 2) >> 2] | 0;
    $55 = HEAP32[$44 + ($49 << 2) >> 2] | 0;
    if (($53 - $55 | 0) == ($29 | 0)) {
     if (($53 | 0) > ($55 | 0)) {
      $i$01$i$i = $18;
      $j$02$i$i = $55;
      while (1) {
       if ((HEAP8[$45 + $j$02$i$i >> 0] | 0) != (HEAP8[$$pre + $i$01$i$i >> 0] | 0)) break L41;
       $65 = $j$02$i$i + 1 | 0;
       if (($65 | 0) < ($53 | 0)) {
        $i$01$i$i = $i$01$i$i + 1 | 0;
        $j$02$i$i = $65;
       } else break;
      }
     }
     if ((HEAP8[$46 + $p$0$i >> 0] | 0) == 14) {
      $p$0$i$lcssa = $p$0$i;
      label = 26;
      break L39;
     }
    }
   } while (0);
   $71 = HEAP32[$47 + ($p$0$i << 2) >> 2] | 0;
   if (!$71) {
    $p$0$i$lcssa51 = $p$0$i;
    break;
   } else $p$0$i = $71;
  }
  if ((label | 0) == 26) {
   HEAP32[4241] = 1;
   HEAP32[4338] = $p$0$i$lcssa;
   switch (HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0) {
   case 12:
   case 10:
   case 8:
   case 6:
   case 4:
   case 2:
   case 1:
   case 0:
    {
     $Result$0 = 1;
     STACKTOP = sp;
     return $Result$0 | 0;
    }
   case 11:
   case 9:
   case 7:
   case 5:
   case 3:
    {
     $Result$0 = 0;
     STACKTOP = sp;
     return $Result$0 | 0;
    }
   default:
    {
     _fwrite(3342, 27, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3342, 27, 1, HEAP32[3990] | 0) | 0;
     $81 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer >> 2] = 964;
     _fprintf($81, 960, $vararg_buffer) | 0;
     $82 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer1 >> 2] = 964;
     _fprintf($82, 960, $vararg_buffer1) | 0;
     $83 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer4 >> 2] = 985;
     _fprintf($83, 960, $vararg_buffer4) | 0;
     $84 = HEAP32[3990] | 0;
     HEAP32[$vararg_buffer7 >> 2] = 985;
     _fprintf($84, 960, $vararg_buffer7) | 0;
     HEAP8[25620] = 3;
     _longjmp(16008, 1);
    }
   }
  }
  HEAP32[4338] = $p$0$i$lcssa51;
  if (($30 | 0) < ($1 | 0) & ($$lcssa52 | 0) > -1) {
   $86 = $30;
   $91 = $$lcssa;
  } else {
   $Result$0 = 0;
   STACKTOP = sp;
   return $Result$0 | 0;
  }
  while (1) {
   $87 = HEAP8[$$pre + $86 >> 0] | 0;
   if (($87 + -65 & 255) < 26) {
    $Result$0 = 0;
    label = 42;
    break;
   }
   if (($87 + -97 & 255) < 26) {
    $Result$0 = 1;
    label = 42;
    break;
   }
   switch ($87 << 24 >> 24) {
   case 125:
    {
     $90 = $91 + -1 | 0;
     HEAP32[4334] = $90;
     $95 = $90;
     break;
    }
   case 123:
    {
     $92 = $91 + 1 | 0;
     HEAP32[4334] = $92;
     $95 = $92;
     break;
    }
   default:
    $95 = $91;
   }
   $93 = $86 + 1 | 0;
   HEAP32[4335] = $93;
   if (($93 | 0) < ($1 | 0) & ($95 | 0) > 0) {
    $86 = $93;
    $91 = $95;
   } else {
    $Result$0 = 0;
    label = 42;
    break;
   }
  }
  if ((label | 0) == 42) {
   STACKTOP = sp;
   return $Result$0 | 0;
  }
 } else if ((label | 0) == 42) {
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 return 0;
}

function _auxbibstylecommand() {
 var $$lcssa = 0, $$lcssa1$i = 0, $$lcssa2 = 0, $$pre3$pre$i = 0, $10 = 0, $100 = 0, $101 = 0, $103 = 0, $105 = 0, $106 = 0, $109 = 0, $118 = 0, $12 = 0, $121 = 0, $127 = 0, $130 = 0, $133 = 0, $18 = 0, $20 = 0, $22 = 0, $28 = 0, $30 = 0, $32 = 0, $33 = 0, $35 = 0, $46 = 0, $48 = 0, $49 = 0, $51 = 0, $53 = 0, $56 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $66 = 0, $67 = 0, $74 = 0, $75 = 0, $77 = 0, $79 = 0, $86 = 0, $87 = 0, $88 = 0, $9 = 0, $90 = 0, $94 = 0, $97 = 0, $99 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer18 = 0, $vararg_buffer21 = 0, $vararg_buffer24 = 0, $vararg_buffer27 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $vararg_buffer27 = sp + 88 | 0;
 $vararg_buffer24 = sp + 80 | 0;
 $vararg_buffer21 = sp + 72 | 0;
 $vararg_buffer18 = sp + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (HEAP32[4668] | 0) {
  _fwrite(1315, 21, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1315, 21, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1342, 5, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1342, 5, 1, HEAP32[3990] | 0) | 0;
  _fwrite(1348, 8, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1348, 8, 1, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 HEAP32[4668] = 1;
 $9 = (HEAP32[4045] | 0) + 1 | 0;
 HEAP32[4045] = $9;
 HEAP32[4044] = $9;
 $10 = HEAP32[3993] | 0;
 $12 = HEAP8[$10 + $9 >> 0] | 0;
 $$pre3$pre$i = HEAP32[3999] | 0;
 L5 : do if ($12 << 24 >> 24 == 125 ? 1 : (HEAP8[25877 + ($12 & 255) >> 0] | 0) == 1) $28 = $9; else {
  $18 = $9;
  while (1) {
   if (($18 | 0) >= ($$pre3$pre$i | 0)) {
    $28 = $18;
    break L5;
   }
   $20 = $18 + 1 | 0;
   HEAP32[4045] = $20;
   $22 = HEAP8[$10 + $20 >> 0] | 0;
   if ($22 << 24 >> 24 == 125 ? 1 : (HEAP8[25877 + ($22 & 255) >> 0] | 0) == 1) {
    $28 = $20;
    break;
   } else $18 = $20;
  }
 } while (0);
 if (($28 | 0) >= ($$pre3$pre$i | 0)) {
  $30 = HEAP32[3989] | 0;
  $32 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer >> 2] = 1364;
  HEAP32[$vararg_buffer + 4 >> 2] = $32;
  HEAP32[$vararg_buffer + 8 >> 2] = 34;
  _fprintf($30, 1357, $vararg_buffer) | 0;
  $33 = HEAP32[3990] | 0;
  $35 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 1364;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $35;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 34;
  _fprintf($33, 1357, $vararg_buffer3) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 if ((HEAP8[25877 + (HEAPU8[$10 + $28 >> 0] | 0) >> 0] | 0) == 1) {
  _fwrite(1383, 23, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1383, 23, 1, HEAP32[3990] | 0) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 if (($$pre3$pre$i | 0) > ($28 + 1 | 0)) {
  $46 = HEAP32[3989] | 0;
  $48 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer8 >> 2] = 1369;
  HEAP32[$vararg_buffer8 + 4 >> 2] = $48;
  HEAP32[$vararg_buffer8 + 8 >> 2] = 34;
  _fprintf($46, 1357, $vararg_buffer8) | 0;
  $49 = HEAP32[3990] | 0;
  $51 = HEAPU8[26258] | 0;
  HEAP32[$vararg_buffer13 >> 2] = 1369;
  HEAP32[$vararg_buffer13 + 4 >> 2] = $51;
  HEAP32[$vararg_buffer13 + 8 >> 2] = 34;
  _fprintf($49, 1357, $vararg_buffer13) | 0;
  _auxerrprint();
  STACKTOP = sp;
  return;
 }
 $53 = _zstrlookup($10, $9, $28 - $9 | 0, 5, 1) | 0;
 $56 = HEAP32[(HEAP32[4145] | 0) + ($53 << 2) >> 2] | 0;
 HEAP32[4096] = $56;
 if (HEAP32[4241] | 0) {
  _fwrite(4269, 30, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4269, 30, 1, HEAP32[3990] | 0) | 0;
  $61 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer18 >> 2] = 964;
  _fprintf($61, 960, $vararg_buffer18) | 0;
  $62 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer21 >> 2] = 964;
  _fprintf($62, 960, $vararg_buffer21) | 0;
  $63 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer24 >> 2] = 985;
  _fprintf($63, 960, $vararg_buffer24) | 0;
  $64 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer27 >> 2] = 985;
  _fprintf($64, 960, $vararg_buffer27) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
 _free(HEAP32[4048] | 0);
 $66 = $56 + 1 | 0;
 $67 = HEAP32[4041] | 0;
 $74 = _xmalloc((HEAP32[$67 + ($66 << 2) >> 2] | 0) + 2 - (HEAP32[$67 + ($56 << 2) >> 2] | 0) | 0) | 0;
 HEAP32[4048] = $74;
 HEAP32[4046] = 1;
 $75 = HEAP32[4041] | 0;
 $77 = HEAP32[$75 + ($56 << 2) >> 2] | 0;
 $79 = HEAP32[$75 + ($66 << 2) >> 2] | 0;
 if (($77 | 0) < ($79 | 0)) {
  HEAP8[$74 + 1 >> 0] = HEAP8[(HEAP32[4042] | 0) + $77 >> 0] | 0;
  $86 = (HEAP32[4046] | 0) + 1 | 0;
  HEAP32[4046] = $86;
  $87 = $77 + 1 | 0;
  $88 = HEAP32[4041] | 0;
  $90 = HEAP32[$88 + ($66 << 2) >> 2] | 0;
  if (($87 | 0) < ($90 | 0)) {
   $94 = $87;
   $97 = $86;
   while (1) {
    HEAP8[(HEAP32[4048] | 0) + $97 >> 0] = HEAP8[(HEAP32[4042] | 0) + $94 >> 0] | 0;
    $99 = (HEAP32[4046] | 0) + 1 | 0;
    HEAP32[4046] = $99;
    $100 = $94 + 1 | 0;
    $101 = HEAP32[4041] | 0;
    $103 = HEAP32[$101 + ($66 << 2) >> 2] | 0;
    if (($100 | 0) < ($103 | 0)) {
     $94 = $100;
     $97 = $99;
    } else {
     $$lcssa = $101;
     $$lcssa2 = $103;
     break;
    }
   }
  } else {
   $$lcssa = $88;
   $$lcssa2 = $90;
  }
  $$lcssa1$i = $$lcssa2;
  $106 = HEAP32[$$lcssa + ($56 << 2) >> 2] | 0;
  $109 = HEAP32[4048] | 0;
 } else {
  $$lcssa1$i = $79;
  $106 = $77;
  $109 = $74;
 }
 $105 = $$lcssa1$i - $106 | 0;
 HEAP32[4049] = $105;
 HEAP8[$109 + ($105 + 1) >> 0] = 0;
 if (_kpse_in_name_ok((HEAP32[4048] | 0) + 1 | 0) | 0) if (_open_input(16416, 7, 4127) | 0) {
  $127 = (HEAP32[4669] | 0) == 0;
  _fwrite(4328, 16, 1, HEAP32[3989] | 0) | 0;
  if ($127) {
   _zoutpoolstr(HEAP32[3989] | 0, HEAP32[4096] | 0);
   _zoutpoolstr(HEAP32[3989] | 0, HEAP32[4097] | 0);
   _putc(10, HEAP32[3989] | 0) | 0;
   STACKTOP = sp;
   return;
  } else {
   _fwrite(4328, 16, 1, HEAP32[3990] | 0) | 0;
   $130 = HEAP32[4096] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $130);
   _zoutpoolstr(HEAP32[3989] | 0, $130);
   $133 = HEAP32[4097] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $133);
   _zoutpoolstr(HEAP32[3989] | 0, $133);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 }
 _fwrite(4300, 27, 1, HEAP32[3989] | 0) | 0;
 _fwrite(4300, 27, 1, HEAP32[3990] | 0) | 0;
 $118 = HEAP32[4096] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $118);
 _zoutpoolstr(HEAP32[3989] | 0, $118);
 $121 = HEAP32[4097] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $121);
 _zoutpoolstr(HEAP32[3989] | 0, $121);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 HEAP32[4096] = 0;
 _auxerrprint();
 STACKTOP = sp;
 return;
}

function _init_path($kpse, $info, $default_path, $varargs) {
 $kpse = $kpse | 0;
 $info = $info | 0;
 $default_path = $default_path | 0;
 $varargs = $varargs | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $10 = 0, $100 = 0, $101 = 0, $15 = 0, $16 = 0, $17 = 0, $22 = 0, $23 = 0, $27 = 0, $39 = 0, $40 = 0, $44 = 0, $45 = 0, $46 = 0, $51 = 0, $52 = 0, $56 = 0, $6 = 0, $60 = 0, $62 = 0, $69 = 0, $7 = 0, $70 = 0, $72 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $83 = 0, $85 = 0, $88 = 0, $9 = 0, $92 = 0, $96 = 0, $98 = 0, $ap = 0, $env_value$02 = 0, $env_value$02$us = 0, $env_value$2 = 0, $env_value$2$us = 0, $env_value$2$us10 = 0, $env_value$2$us15 = 0, $env_value$3 = 0, $loc$0 = 0, $var$0$be = 0, $var$0$be$us = 0, $var$03 = 0, $var$03$us = 0, $var$2 = 0, $var$2$us = 0, $var$2$us16 = 0, $var$3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 $0 = $info + 28 | 0;
 HEAP32[$0 >> 2] = $default_path;
 HEAP32[$ap >> 2] = $varargs;
 $6 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
 $7 = HEAP32[$6 >> 2] | 0;
 HEAP32[$ap >> 2] = $6 + 4;
 L1 : do if (!$7) {
  $$pre$phiZ2D = $info + 24 | 0;
  $env_value$3 = 0;
  $var$3 = 0;
 } else {
  $9 = $kpse + 112 | 0;
  $10 = $info + 24 | 0;
  if (($kpse + 676 | 0) == ($info | 0)) {
   $15 = $7;
   $env_value$02$us = 0;
   $var$03$us = 0;
   while (1) {
    L7 : do if (!$var$03$us) {
     $16 = _concat3($15, 15912, HEAP32[$9 >> 2] | 0) | 0;
     $17 = _getenv($16 | 0) | 0;
     if (!$17) label = 7; else if (!(HEAP8[$17 >> 0] | 0)) label = 7; else {
      $env_value$2$us = $17;
      $var$2$us = $16;
     }
     do if ((label | 0) == 7) {
      label = 0;
      _free($16);
      $22 = _concat3($15, 12372, HEAP32[$9 >> 2] | 0) | 0;
      $23 = _getenv($22 | 0) | 0;
      if ($23 | 0) if (HEAP8[$23 >> 0] | 0) {
       $env_value$2$us = $23;
       $var$2$us = $22;
       break;
      }
      _free($22);
      $27 = _getenv($15 | 0) | 0;
      if (!$27) {
       $env_value$2$us10 = 0;
       $var$0$be$us = 0;
       break L7;
      }
      if (!(HEAP8[$27 >> 0] | 0)) {
       $env_value$2$us10 = $27;
       $var$0$be$us = 0;
       break L7;
      } else {
       $env_value$2$us15 = $27;
       $var$2$us16 = $15;
       label = 12;
       break L7;
      }
     } while (0);
     if (!$var$2$us) {
      $env_value$2$us10 = $env_value$2$us;
      $var$0$be$us = 0;
     } else {
      $env_value$2$us15 = $env_value$2$us;
      $var$2$us16 = $var$2$us;
      label = 12;
     }
    } else {
     $env_value$2$us15 = $env_value$02$us;
     $var$2$us16 = $var$03$us;
     label = 12;
    } while (0);
    if ((label | 0) == 12) {
     label = 0;
     if (!(HEAP32[$10 >> 2] | 0)) {
      $env_value$2$us10 = $env_value$2$us15;
      $var$0$be$us = $var$2$us16;
     } else {
      $$pre$phiZ2D = $10;
      $env_value$3 = $env_value$2$us15;
      $var$3 = $var$2$us16;
      break L1;
     }
    }
    $39 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
    $40 = HEAP32[$39 >> 2] | 0;
    HEAP32[$ap >> 2] = $39 + 4;
    if (!$40) {
     $$pre$phiZ2D = $10;
     $env_value$3 = $env_value$2$us10;
     $var$3 = $var$0$be$us;
     break L1;
    } else {
     $15 = $40;
     $env_value$02$us = $env_value$2$us10;
     $var$03$us = $var$0$be$us;
    }
   }
  } else {
   $44 = $7;
   $env_value$02 = 0;
   $var$03 = 0;
  }
  while (1) {
   do if (!$var$03) {
    $45 = _concat3($44, 15912, HEAP32[$9 >> 2] | 0) | 0;
    $46 = _getenv($45 | 0) | 0;
    if ($46 | 0) if (HEAP8[$46 >> 0] | 0) {
     $env_value$2 = $46;
     $var$2 = $45;
     break;
    }
    _free($45);
    $51 = _concat3($44, 12372, HEAP32[$9 >> 2] | 0) | 0;
    $52 = _getenv($51 | 0) | 0;
    if ($52 | 0) if (HEAP8[$52 >> 0] | 0) {
     $env_value$2 = $52;
     $var$2 = $51;
     break;
    }
    _free($51);
    $56 = _getenv($44 | 0) | 0;
    if (!$56) {
     $env_value$2 = 0;
     $var$2 = 0;
    } else {
     $env_value$2 = $56;
     $var$2 = (HEAP8[$56 >> 0] | 0) == 0 ? 0 : $44;
    }
   } else {
    $env_value$2 = $env_value$02;
    $var$2 = $var$03;
   } while (0);
   $60 = HEAP32[$10 >> 2] | 0;
   if (!$60) {
    $62 = _kpathsea_cnf_get($kpse, $44) | 0;
    HEAP32[$10 >> 2] = $62;
    $72 = $62;
   } else $72 = $60;
   if (!$var$2) $var$0$be = 0; else if (!$72) $var$0$be = $var$2; else {
    $$pre$phiZ2D = $10;
    $env_value$3 = $env_value$2;
    $var$3 = $var$2;
    break L1;
   }
   $69 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $70 = HEAP32[$69 >> 2] | 0;
   HEAP32[$ap >> 2] = $69 + 4;
   if (!$70) {
    $$pre$phiZ2D = $10;
    $env_value$3 = $env_value$2;
    $var$3 = $var$0$be;
    break;
   } else {
    $44 = $70;
    $env_value$02 = $env_value$2;
    $var$03 = $var$0$be;
   }
  }
 } while (0);
 $74 = HEAP32[$0 >> 2] | 0;
 $75 = $info + 8 | 0;
 HEAP32[$75 >> 2] = $74;
 $76 = _xstrdup($74) | 0;
 $77 = $info + 4 | 0;
 HEAP32[$77 >> 2] = $76;
 $78 = $info + 12 | 0;
 HEAP32[$78 >> 2] = 6785;
 $79 = HEAP32[$$pre$phiZ2D >> 2] | 0;
 if ($79 | 0) {
  HEAP32[$75 >> 2] = $79;
  HEAP32[$77 >> 2] = _kpathsea_expand_default($kpse, $79, $76) | 0;
  _free($76);
  HEAP32[$78 >> 2] = 10011;
 }
 $83 = HEAP32[$info + 20 >> 2] | 0;
 if ($83 | 0) {
  HEAP32[$75 >> 2] = $83;
  $85 = HEAP32[$77 >> 2] | 0;
  HEAP32[$77 >> 2] = _kpathsea_expand_default($kpse, $83, $85) | 0;
  _free($85);
  HEAP32[$78 >> 2] = 6806;
 }
 if ($var$3 | 0) {
  $88 = _xstrdup($env_value$3) | 0;
  $loc$0 = $88;
  L48 : while (1) {
   switch (HEAP8[$loc$0 >> 0] | 0) {
   case 0:
    {
     break L48;
     break;
    }
   case 59:
    {
     HEAP8[$loc$0 >> 0] = 58;
     break;
    }
   default:
    {}
   }
   $loc$0 = $loc$0 + 1 | 0;
  }
  if ($88 | 0) {
   HEAP32[$75 >> 2] = $88;
   $92 = HEAP32[$77 >> 2] | 0;
   HEAP32[$77 >> 2] = _kpathsea_expand_default($kpse, $88, $92) | 0;
   _free($92);
   HEAP32[$78 >> 2] = _concat($var$3, 6826) | 0;
  }
 }
 $96 = HEAP32[$info + 16 >> 2] | 0;
 if (!$96) {
  $100 = HEAP32[$77 >> 2] | 0;
  $101 = _kpathsea_brace_expand($kpse, $100) | 0;
  HEAP32[$77 >> 2] = $101;
  _free($100);
  STACKTOP = sp;
  return;
 }
 HEAP32[$75 >> 2] = $96;
 $98 = HEAP32[$77 >> 2] | 0;
 HEAP32[$77 >> 2] = _kpathsea_expand_default($kpse, $96, $98) | 0;
 _free($98);
 HEAP32[$78 >> 2] = 6848;
 $100 = HEAP32[$77 >> 2] | 0;
 $101 = _kpathsea_brace_expand($kpse, $100) | 0;
 HEAP32[$77 >> 2] = $101;
 _free($100);
 STACKTOP = sp;
 return;
}

function _try_realloc_chunk($p, $nb) {
 $p = $p | 0;
 $nb = $nb | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $101 = 0, $104 = 0, $106 = 0, $109 = 0, $112 = 0, $113 = 0, $114 = 0, $116 = 0, $118 = 0, $119 = 0, $121 = 0, $122 = 0, $127 = 0, $128 = 0, $137 = 0, $142 = 0, $145 = 0, $146 = 0, $152 = 0, $163 = 0, $166 = 0, $173 = 0, $2 = 0, $20 = 0, $22 = 0, $29 = 0, $3 = 0, $35 = 0, $37 = 0, $38 = 0, $4 = 0, $47 = 0, $49 = 0, $5 = 0, $51 = 0, $52 = 0, $58 = 0, $65 = 0, $71 = 0, $73 = 0, $74 = 0, $77 = 0, $79 = 0, $8 = 0, $81 = 0, $94 = 0, $99 = 0, $R$1 = 0, $R$1$lcssa = 0, $R$3 = 0, $RP$1 = 0, $RP$1$lcssa = 0, $newp$2 = 0, $storemerge = 0, $storemerge1 = 0;
 $0 = $p + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $1 & -8;
 $3 = $p + $2 | 0;
 $4 = HEAP32[5773] | 0;
 $5 = $1 & 3;
 if (!(($5 | 0) != 1 & $p >>> 0 >= $4 >>> 0 & $p >>> 0 < $3 >>> 0)) _abort();
 $8 = HEAP32[$3 + 4 >> 2] | 0;
 if (!($8 & 1)) _abort();
 if (!$5) {
  if ($nb >>> 0 < 256) {
   $newp$2 = 0;
   return $newp$2 | 0;
  }
  if ($2 >>> 0 >= ($nb + 4 | 0) >>> 0) if (($2 - $nb | 0) >>> 0 <= HEAP32[5889] << 1 >>> 0) {
   $newp$2 = $p;
   return $newp$2 | 0;
  }
  $newp$2 = 0;
  return $newp$2 | 0;
 }
 if ($2 >>> 0 >= $nb >>> 0) {
  $20 = $2 - $nb | 0;
  if ($20 >>> 0 <= 15) {
   $newp$2 = $p;
   return $newp$2 | 0;
  }
  $22 = $p + $nb | 0;
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
  HEAP32[$22 + 4 >> 2] = $20 | 3;
  $29 = $22 + $20 + 4 | 0;
  HEAP32[$29 >> 2] = HEAP32[$29 >> 2] | 1;
  _dispose_chunk($22, $20);
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 if (($3 | 0) == (HEAP32[5775] | 0)) {
  $35 = (HEAP32[5772] | 0) + $2 | 0;
  if ($35 >>> 0 <= $nb >>> 0) {
   $newp$2 = 0;
   return $newp$2 | 0;
  }
  $37 = $35 - $nb | 0;
  $38 = $p + $nb | 0;
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
  HEAP32[$38 + 4 >> 2] = $37 | 1;
  HEAP32[5775] = $38;
  HEAP32[5772] = $37;
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 if (($3 | 0) == (HEAP32[5774] | 0)) {
  $47 = (HEAP32[5771] | 0) + $2 | 0;
  if ($47 >>> 0 < $nb >>> 0) {
   $newp$2 = 0;
   return $newp$2 | 0;
  }
  $49 = $47 - $nb | 0;
  if ($49 >>> 0 > 15) {
   $51 = $p + $nb | 0;
   $52 = $51 + $49 | 0;
   HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
   HEAP32[$51 + 4 >> 2] = $49 | 1;
   HEAP32[$52 >> 2] = $49;
   $58 = $52 + 4 | 0;
   HEAP32[$58 >> 2] = HEAP32[$58 >> 2] & -2;
   $storemerge = $51;
   $storemerge1 = $49;
  } else {
   HEAP32[$0 >> 2] = $1 & 1 | $47 | 2;
   $65 = $p + $47 + 4 | 0;
   HEAP32[$65 >> 2] = HEAP32[$65 >> 2] | 1;
   $storemerge = 0;
   $storemerge1 = 0;
  }
  HEAP32[5771] = $storemerge1;
  HEAP32[5774] = $storemerge;
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 if ($8 & 2 | 0) {
  $newp$2 = 0;
  return $newp$2 | 0;
 }
 $71 = ($8 & -8) + $2 | 0;
 if ($71 >>> 0 < $nb >>> 0) {
  $newp$2 = 0;
  return $newp$2 | 0;
 }
 $73 = $71 - $nb | 0;
 $74 = $8 >>> 3;
 do if ($8 >>> 0 < 256) {
  $77 = HEAP32[$3 + 8 >> 2] | 0;
  $79 = HEAP32[$3 + 12 >> 2] | 0;
  $81 = 23116 + ($74 << 1 << 2) | 0;
  if (($77 | 0) != ($81 | 0)) {
   if ($77 >>> 0 < $4 >>> 0) _abort();
   if ((HEAP32[$77 + 12 >> 2] | 0) != ($3 | 0)) _abort();
  }
  if (($79 | 0) == ($77 | 0)) {
   HEAP32[5769] = HEAP32[5769] & ~(1 << $74);
   break;
  }
  if (($79 | 0) == ($81 | 0)) $$pre$phiZ2D = $79 + 8 | 0; else {
   if ($79 >>> 0 < $4 >>> 0) _abort();
   $94 = $79 + 8 | 0;
   if ((HEAP32[$94 >> 2] | 0) == ($3 | 0)) $$pre$phiZ2D = $94; else _abort();
  }
  HEAP32[$77 + 12 >> 2] = $79;
  HEAP32[$$pre$phiZ2D >> 2] = $77;
 } else {
  $99 = HEAP32[$3 + 24 >> 2] | 0;
  $101 = HEAP32[$3 + 12 >> 2] | 0;
  do if (($101 | 0) == ($3 | 0)) {
   $112 = $3 + 16 | 0;
   $113 = $112 + 4 | 0;
   $114 = HEAP32[$113 >> 2] | 0;
   if (!$114) {
    $116 = HEAP32[$112 >> 2] | 0;
    if (!$116) {
     $R$3 = 0;
     break;
    } else {
     $R$1 = $116;
     $RP$1 = $112;
    }
   } else {
    $R$1 = $114;
    $RP$1 = $113;
   }
   while (1) {
    $118 = $R$1 + 20 | 0;
    $119 = HEAP32[$118 >> 2] | 0;
    if ($119 | 0) {
     $R$1 = $119;
     $RP$1 = $118;
     continue;
    }
    $121 = $R$1 + 16 | 0;
    $122 = HEAP32[$121 >> 2] | 0;
    if (!$122) {
     $R$1$lcssa = $R$1;
     $RP$1$lcssa = $RP$1;
     break;
    } else {
     $R$1 = $122;
     $RP$1 = $121;
    }
   }
   if ($RP$1$lcssa >>> 0 < $4 >>> 0) _abort(); else {
    HEAP32[$RP$1$lcssa >> 2] = 0;
    $R$3 = $R$1$lcssa;
    break;
   }
  } else {
   $104 = HEAP32[$3 + 8 >> 2] | 0;
   if ($104 >>> 0 < $4 >>> 0) _abort();
   $106 = $104 + 12 | 0;
   if ((HEAP32[$106 >> 2] | 0) != ($3 | 0)) _abort();
   $109 = $101 + 8 | 0;
   if ((HEAP32[$109 >> 2] | 0) == ($3 | 0)) {
    HEAP32[$106 >> 2] = $101;
    HEAP32[$109 >> 2] = $104;
    $R$3 = $101;
    break;
   } else _abort();
  } while (0);
  if ($99 | 0) {
   $127 = HEAP32[$3 + 28 >> 2] | 0;
   $128 = 23380 + ($127 << 2) | 0;
   if (($3 | 0) == (HEAP32[$128 >> 2] | 0)) {
    HEAP32[$128 >> 2] = $R$3;
    if (!$R$3) {
     HEAP32[5770] = HEAP32[5770] & ~(1 << $127);
     break;
    }
   } else {
    if ($99 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort();
    $137 = $99 + 16 | 0;
    if ((HEAP32[$137 >> 2] | 0) == ($3 | 0)) HEAP32[$137 >> 2] = $R$3; else HEAP32[$99 + 20 >> 2] = $R$3;
    if (!$R$3) break;
   }
   $142 = HEAP32[5773] | 0;
   if ($R$3 >>> 0 < $142 >>> 0) _abort();
   HEAP32[$R$3 + 24 >> 2] = $99;
   $145 = $3 + 16 | 0;
   $146 = HEAP32[$145 >> 2] | 0;
   do if ($146 | 0) if ($146 >>> 0 < $142 >>> 0) _abort(); else {
    HEAP32[$R$3 + 16 >> 2] = $146;
    HEAP32[$146 + 24 >> 2] = $R$3;
    break;
   } while (0);
   $152 = HEAP32[$145 + 4 >> 2] | 0;
   if ($152 | 0) if ($152 >>> 0 < (HEAP32[5773] | 0) >>> 0) _abort(); else {
    HEAP32[$R$3 + 20 >> 2] = $152;
    HEAP32[$152 + 24 >> 2] = $R$3;
    break;
   }
  }
 } while (0);
 if ($73 >>> 0 < 16) {
  HEAP32[$0 >> 2] = $71 | $1 & 1 | 2;
  $163 = $p + $71 + 4 | 0;
  HEAP32[$163 >> 2] = HEAP32[$163 >> 2] | 1;
  $newp$2 = $p;
  return $newp$2 | 0;
 } else {
  $166 = $p + $nb | 0;
  HEAP32[$0 >> 2] = $1 & 1 | $nb | 2;
  HEAP32[$166 + 4 >> 2] = $73 | 3;
  $173 = $166 + $73 + 4 | 0;
  HEAP32[$173 >> 2] = HEAP32[$173 >> 2] | 1;
  _dispose_chunk($166, $73);
  $newp$2 = $p;
  return $newp$2 | 0;
 }
 return 0;
}

function _map_file_parse($kpse, $map_filename) {
 $kpse = $kpse | 0;
 $map_filename = $map_filename | 0;
 var $$0$lcssa$i = 0, $$0$lcssa$i6 = 0, $$06$i = 0, $$06$i$lcssa = 0, $$06$i2 = 0, $$06$i2$lcssa = 0, $$1$lcssa$i = 0, $$1$lcssa$i12 = 0, $$14$i = 0, $$14$i8 = 0, $$pr = 0, $0 = 0, $1 = 0, $11 = 0, $13 = 0, $14 = 0, $17 = 0, $20 = 0, $21 = 0, $25 = 0, $28 = 0, $3 = 0, $30 = 0, $31 = 0, $33 = 0, $37 = 0, $38 = 0, $42 = 0, $44 = 0, $48 = 0, $49 = 0, $5 = 0, $52 = 0, $55 = 0, $57 = 0, $58 = 0, $6 = 0, $60 = 0, $64 = 0, $65 = 0, $69 = 0, $7 = 0, $71 = 0, $75 = 0, $77 = 0, $8 = 0, $80 = 0, $9 = 0, $comment_loc$014 = 0, $l$01636 = 0, $l$024 = 0, $l$024$lcssa = 0, $map_lineno$026 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = _xfopen($map_filename, 10611) | 0;
 $1 = HEAP32[$kpse >> 2] | 0;
 if ($1 | 0) FUNCTION_TABLE_vi[$1 & 7]($map_filename);
 $3 = _read_line($0) | 0;
 if (!$3) {
  _xfclose($0, $map_filename);
  STACKTOP = sp;
  return;
 }
 $5 = HEAP32[21] | 0;
 $6 = $kpse + 72 | 0;
 $7 = $kpse + 64 | 0;
 $8 = $3;
 $map_lineno$026 = 0;
 while (1) {
  $9 = _strrchr($8, 37) | 0;
  if (!$9) {
   $11 = _strstr($8, 10613) | 0;
   if ($11 | 0) {
    $comment_loc$014 = $11;
    label = 7;
   }
  } else {
   $comment_loc$014 = $9;
   label = 7;
  }
  if ((label | 0) == 7) {
   label = 0;
   HEAP8[$comment_loc$014 >> 0] = 0;
  }
  $13 = $map_lineno$026 + 1 | 0;
  $14 = HEAP8[$8 >> 0] | 0;
  L14 : do if ($14 << 24 >> 24 > 0) {
   $17 = $14;
   $l$024 = $8;
   while (1) {
    if (!(_isspace($17 & 255) | 0)) {
     $l$024$lcssa = $l$024;
     break;
    }
    $20 = $l$024 + 1 | 0;
    $21 = HEAP8[$20 >> 0] | 0;
    if ($21 << 24 >> 24 > 0) {
     $17 = $21;
     $l$024 = $20;
    } else {
     $$0$lcssa$i = $20;
     $28 = $21;
     $l$01636 = $20;
     break L14;
    }
   }
   $$pr = HEAP8[$l$024$lcssa >> 0] | 0;
   if ($$pr << 24 >> 24 > 0) {
    $$06$i = $l$024$lcssa;
    $25 = $$pr;
    while (1) {
     if (!(_isspace($25 & 255) | 0)) {
      $$06$i$lcssa = $$06$i;
      break;
     }
     $30 = $$06$i + 1 | 0;
     $31 = HEAP8[$30 >> 0] | 0;
     if ($31 << 24 >> 24 > 0) {
      $$06$i = $30;
      $25 = $31;
     } else {
      $$0$lcssa$i = $30;
      $28 = $31;
      $l$01636 = $l$024$lcssa;
      break L14;
     }
    }
    $$0$lcssa$i = $$06$i$lcssa;
    $28 = HEAP8[$$06$i$lcssa >> 0] | 0;
    $l$01636 = $l$024$lcssa;
   } else {
    $$0$lcssa$i = $l$024$lcssa;
    $28 = $$pr;
    $l$01636 = $l$024$lcssa;
   }
  } else {
   $$0$lcssa$i = $8;
   $28 = $14;
   $l$01636 = $8;
  } while (0);
  L24 : do if (!($28 << 24 >> 24)) $$1$lcssa$i = $$0$lcssa$i; else {
   $$14$i = $$0$lcssa$i;
   $33 = $28;
   while (1) {
    if ($33 << 24 >> 24 > -1) if (_isspace($33 & 255) | 0) {
     $$1$lcssa$i = $$14$i;
     break L24;
    }
    $37 = $$14$i + 1 | 0;
    $38 = HEAP8[$37 >> 0] | 0;
    if (!($38 << 24 >> 24)) {
     $$1$lcssa$i = $37;
     break;
    } else {
     $$14$i = $37;
     $33 = $38;
    }
   }
  } while (0);
  $42 = $$1$lcssa$i - $$0$lcssa$i | 0;
  $44 = _xmalloc($42 + 1 | 0) | 0;
  _strncpy($44, $$0$lcssa$i, $42) | 0;
  HEAP8[$44 + $42 >> 0] = 0;
  do if ($44 | 0) {
   $48 = $l$01636 + (_strlen($44) | 0) | 0;
   $49 = HEAP8[$48 >> 0] | 0;
   L33 : do if ($49 << 24 >> 24 > 0) {
    $$06$i2 = $48;
    $52 = $49;
    while (1) {
     if (!(_isspace($52 & 255) | 0)) {
      $$06$i2$lcssa = $$06$i2;
      break;
     }
     $57 = $$06$i2 + 1 | 0;
     $58 = HEAP8[$57 >> 0] | 0;
     if ($58 << 24 >> 24 > 0) {
      $$06$i2 = $57;
      $52 = $58;
     } else {
      $$0$lcssa$i6 = $57;
      $55 = $58;
      break L33;
     }
    }
    $$0$lcssa$i6 = $$06$i2$lcssa;
    $55 = HEAP8[$$06$i2$lcssa >> 0] | 0;
   } else {
    $$0$lcssa$i6 = $48;
    $55 = $49;
   } while (0);
   L39 : do if (!($55 << 24 >> 24)) $$1$lcssa$i12 = $$0$lcssa$i6; else {
    $$14$i8 = $$0$lcssa$i6;
    $60 = $55;
    while (1) {
     if ($60 << 24 >> 24 > -1) if (_isspace($60 & 255) | 0) {
      $$1$lcssa$i12 = $$14$i8;
      break L39;
     }
     $64 = $$14$i8 + 1 | 0;
     $65 = HEAP8[$64 >> 0] | 0;
     if (!($65 << 24 >> 24)) {
      $$1$lcssa$i12 = $64;
      break;
     } else {
      $$14$i8 = $64;
      $60 = $65;
     }
    }
   } while (0);
   $69 = $$1$lcssa$i12 - $$0$lcssa$i6 | 0;
   $71 = _xmalloc($69 + 1 | 0) | 0;
   _strncpy($71, $$0$lcssa$i6, $69) | 0;
   HEAP8[$71 + $69 >> 0] = 0;
   $75 = ($71 | 0) == 0;
   if (_strcmp($44, 10616) | 0) if ($75) {
    _fwrite(12399, 9, 1, $5) | 0;
    HEAP32[$vararg_buffer7 >> 2] = $map_filename;
    HEAP32[$vararg_buffer7 + 4 >> 2] = $13;
    HEAP32[$vararg_buffer7 + 8 >> 2] = $44;
    _fprintf($5, 10744, $vararg_buffer7) | 0;
    _fwrite(12726, 2, 1, $5) | 0;
    _fflush($5) | 0;
    _free($44);
    break;
   } else {
    _hash_insert_normalized($7, $71, $44);
    break;
   }
   if ($75) {
    _fwrite(12399, 9, 1, $5) | 0;
    HEAP32[$vararg_buffer >> 2] = $map_filename;
    HEAP32[$vararg_buffer + 4 >> 2] = $13;
    _fprintf($5, 10624, $vararg_buffer) | 0;
    _fwrite(12726, 2, 1, $5) | 0;
    _fflush($5) | 0;
    break;
   }
   $77 = _kpathsea_path_search($kpse, HEAP32[$6 >> 2] | 0, $71, 0) | 0;
   if (!$77) {
    _fwrite(12399, 9, 1, $5) | 0;
    HEAP32[$vararg_buffer2 >> 2] = $map_filename;
    HEAP32[$vararg_buffer2 + 4 >> 2] = $13;
    HEAP32[$vararg_buffer2 + 8 >> 2] = $71;
    _fprintf($5, 10689, $vararg_buffer2) | 0;
    _fwrite(12726, 2, 1, $5) | 0;
    _fflush($5) | 0;
   } else {
    _map_file_parse($kpse, $77);
    if (($77 | 0) != ($71 | 0)) _free($77);
   }
   _free($71);
   _free($44);
  } while (0);
  _free($8);
  $80 = _read_line($0) | 0;
  if (!$80) break; else {
   $8 = $80;
   $map_lineno$026 = $13;
  }
 }
 _xfclose($0, $map_filename);
 STACKTOP = sp;
 return;
}

function _zquicksort($leftend, $rightend) {
 $leftend = $leftend | 0;
 $rightend = $rightend | 0;
 var $$lcssa = 0, $$lcssa9 = 0, $$pre = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $21 = 0, $23 = 0, $24 = 0, $3 = 0, $30 = 0, $31 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $88 = 0, $91 = 0, $97 = 0, $99 = 0, $insertptr$0 = 0, $left$0 = 0, $left$0$lcssa = 0, $left$0$ph = 0, $left$1 = 0, $left$1$lcssa = 0, $leftend$tr$lcssa = 0, $leftend$tr4 = 0, $right$0 = 0, $right$1$ph = 0, $right$2 = 0, $right$2$lcssa = 0, $right$3 = 0, $right$3$lcssa = 0;
 if (($rightend - $leftend | 0) < 10) $leftend$tr$lcssa = $leftend; else {
  $2 = $rightend + -4 | 0;
  $leftend$tr4 = $leftend;
  while (1) {
   $21 = $leftend$tr4 + 4 | 0;
   $23 = ($leftend$tr4 + $rightend | 0) / 2 | 0;
   $24 = HEAP32[4102] | 0;
   $30 = (_zlessthan(HEAP32[$24 + ($21 << 2) >> 2] | 0, HEAP32[$24 + ($23 << 2) >> 2] | 0) | 0) == 0;
   $31 = HEAP32[4102] | 0;
   do if ($30) {
    $63 = (_zlessthan(HEAP32[$31 + ($2 << 2) >> 2] | 0, HEAP32[$31 + ($23 << 2) >> 2] | 0) | 0) == 0;
    $64 = HEAP32[4102] | 0;
    if (!$63) {
     $65 = $64 + ($23 << 2) | 0;
     $66 = HEAP32[$65 >> 2] | 0;
     $67 = $64 + ($leftend$tr4 << 2) | 0;
     HEAP32[$65 >> 2] = HEAP32[$67 >> 2];
     HEAP32[$67 >> 2] = $66;
     $88 = $66;
     break;
    }
    $74 = (_zlessthan(HEAP32[$64 + ($2 << 2) >> 2] | 0, HEAP32[$64 + ($21 << 2) >> 2] | 0) | 0) == 0;
    $75 = HEAP32[4102] | 0;
    if ($74) {
     $80 = $75 + ($21 << 2) | 0;
     $81 = HEAP32[$80 >> 2] | 0;
     $82 = $75 + ($leftend$tr4 << 2) | 0;
     HEAP32[$80 >> 2] = HEAP32[$82 >> 2];
     HEAP32[$82 >> 2] = $81;
     $88 = $81;
     break;
    } else {
     $76 = $75 + ($2 << 2) | 0;
     $77 = HEAP32[$76 >> 2] | 0;
     $78 = $75 + ($leftend$tr4 << 2) | 0;
     HEAP32[$76 >> 2] = HEAP32[$78 >> 2];
     HEAP32[$78 >> 2] = $77;
     $88 = $77;
     break;
    }
   } else {
    $37 = (_zlessthan(HEAP32[$31 + ($23 << 2) >> 2] | 0, HEAP32[$31 + ($2 << 2) >> 2] | 0) | 0) == 0;
    $38 = HEAP32[4102] | 0;
    if (!$37) {
     $39 = $38 + ($23 << 2) | 0;
     $40 = HEAP32[$39 >> 2] | 0;
     $41 = $38 + ($leftend$tr4 << 2) | 0;
     HEAP32[$39 >> 2] = HEAP32[$41 >> 2];
     HEAP32[$41 >> 2] = $40;
     $88 = $40;
     break;
    }
    $48 = (_zlessthan(HEAP32[$38 + ($21 << 2) >> 2] | 0, HEAP32[$38 + ($2 << 2) >> 2] | 0) | 0) == 0;
    $49 = HEAP32[4102] | 0;
    if ($48) {
     $54 = $49 + ($21 << 2) | 0;
     $55 = HEAP32[$54 >> 2] | 0;
     $56 = $49 + ($leftend$tr4 << 2) | 0;
     HEAP32[$54 >> 2] = HEAP32[$56 >> 2];
     HEAP32[$56 >> 2] = $55;
     $88 = $55;
     break;
    } else {
     $50 = $49 + ($2 << 2) | 0;
     $51 = HEAP32[$50 >> 2] | 0;
     $52 = $49 + ($leftend$tr4 << 2) | 0;
     HEAP32[$50 >> 2] = HEAP32[$52 >> 2];
     HEAP32[$52 >> 2] = $51;
     $88 = $51;
     break;
    }
   } while (0);
   $left$0$ph = $leftend$tr4 + 1 | 0;
   $right$1$ph = $rightend;
   while (1) {
    $left$0 = $left$0$ph;
    while (1) {
     $91 = $left$0 + 1 | 0;
     if (!(_zlessthan(HEAP32[(HEAP32[4102] | 0) + ($left$0 << 2) >> 2] | 0, $88) | 0)) {
      $$lcssa = $91;
      $left$0$lcssa = $left$0;
      break;
     } else $left$0 = $91;
    }
    $right$2 = $right$1$ph;
    while (1) {
     $97 = $right$2 + -1 | 0;
     if (!(_zlessthan($88, HEAP32[(HEAP32[4102] | 0) + ($right$2 << 2) >> 2] | 0) | 0)) {
      $$lcssa9 = $97;
      $right$2$lcssa = $right$2;
      break;
     } else $right$2 = $97;
    }
    if (($left$0$lcssa | 0) < ($right$2$lcssa | 0)) {
     $99 = HEAP32[4102] | 0;
     $100 = $99 + ($right$2$lcssa << 2) | 0;
     $101 = HEAP32[$100 >> 2] | 0;
     $102 = $99 + ($left$0$lcssa << 2) | 0;
     HEAP32[$100 >> 2] = HEAP32[$102 >> 2];
     HEAP32[$102 >> 2] = $101;
     $left$1 = $$lcssa;
     $right$3 = $$lcssa9;
    } else {
     $left$1 = $left$0$lcssa;
     $right$3 = $right$2$lcssa;
    }
    if (($left$1 | 0) == ($right$3 + 1 | 0)) {
     $left$1$lcssa = $left$1;
     $right$3$lcssa = $right$3;
     break;
    } else {
     $left$0$ph = $left$1;
     $right$1$ph = $right$3;
    }
   }
   $106 = HEAP32[4102] | 0;
   $107 = $106 + ($right$3$lcssa << 2) | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   $109 = $106 + ($leftend$tr4 << 2) | 0;
   HEAP32[$107 >> 2] = HEAP32[$109 >> 2];
   HEAP32[$109 >> 2] = $108;
   _zquicksort($leftend$tr4, $right$3$lcssa + -1 | 0);
   if (($rightend - $left$1$lcssa | 0) < 10) {
    $leftend$tr$lcssa = $left$1$lcssa;
    break;
   } else $leftend$tr4 = $left$1$lcssa;
  }
 }
 $3 = $leftend$tr$lcssa + 1 | 0;
 if (($leftend$tr$lcssa | 0) < ($rightend | 0)) $insertptr$0 = $3; else return;
 while (1) {
  L38 : do if (($insertptr$0 | 0) > ($leftend$tr$lcssa | 0)) {
   $$pre = HEAP32[4102] | 0;
   $10 = HEAP32[$$pre + ($insertptr$0 << 2) >> 2] | 0;
   $8 = $$pre;
   $right$0 = $insertptr$0;
   while (1) {
    $6 = $right$0 + -1 | 0;
    if (_zlessthan(HEAP32[$8 + ($6 << 2) >> 2] | 0, $10) | 0) break L38;
    $13 = HEAP32[4102] | 0;
    $14 = $13 + ($right$0 << 2) | 0;
    $15 = HEAP32[$14 >> 2] | 0;
    $16 = $13 + ($6 << 2) | 0;
    HEAP32[$14 >> 2] = HEAP32[$16 >> 2];
    HEAP32[$16 >> 2] = $15;
    if (($right$0 | 0) > ($3 | 0)) {
     $10 = $15;
     $8 = $13;
     $right$0 = $6;
    } else break;
   }
  } while (0);
  if (($insertptr$0 | 0) < ($rightend | 0)) $insertptr$0 = $insertptr$0 + 1 | 0; else break;
 }
 return;
}

function _zfindcitelocsforthiscitekey($citestr) {
 $citestr = $citestr | 0;
 var $$pre27 = 0, $0 = 0, $101 = 0, $105 = 0, $106 = 0, $108 = 0, $118 = 0, $124 = 0, $126 = 0, $13 = 0, $15 = 0, $17 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $24 = 0, $26 = 0, $28 = 0, $3 = 0, $36 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $43 = 0, $47 = 0, $49 = 0, $5 = 0, $59 = 0, $65 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $72 = 0, $73 = 0, $74 = 0, $81 = 0, $82 = 0, $83 = 0, $85 = 0, $88 = 0, $9 = 0, $94 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $h$0$lcssa$i = 0, $h$0$lcssa$i5 = 0, $h$06$i = 0, $h$06$i3 = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $h$1$i4 = 0, $h$1$i4$lcssa = 0, $i$0$i = 0, $i$01$i$i = 0, $i$01$i$i11 = 0, $j$02$i$i = 0, $j$02$i$i10 = 0, $k$07$i = 0, $k$07$i2 = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i46 = 0, $p$0$i7 = 0, $p$0$i7$lcssa = 0, $p$0$i744 = 0, label = 0;
 HEAP32[4251] = 0;
 $0 = HEAP32[4041] | 0;
 $2 = HEAP32[$0 + ($citestr << 2) >> 2] | 0;
 HEAP32[4252] = $2;
 $3 = $citestr + 1 | 0;
 $5 = HEAP32[$0 + ($3 << 2) >> 2] | 0;
 HEAP32[4253] = $5;
 if (($2 | 0) < ($5 | 0)) {
  $13 = 0;
  $9 = $2;
  while (1) {
   HEAP8[(HEAP32[3995] | 0) + $13 >> 0] = HEAP8[(HEAP32[4042] | 0) + $9 >> 0] | 0;
   $15 = (HEAP32[4251] | 0) + 1 | 0;
   HEAP32[4251] = $15;
   $17 = (HEAP32[4252] | 0) + 1 | 0;
   HEAP32[4252] = $17;
   if (($17 | 0) < (HEAP32[4253] | 0)) {
    $13 = $15;
    $9 = $17;
   } else break;
  }
  $22 = HEAP32[4041] | 0;
 } else $22 = $0;
 $20 = HEAP32[3995] | 0;
 $21 = $22 + ($3 << 2) | 0;
 $24 = $22 + ($citestr << 2) | 0;
 $26 = (HEAP32[$21 >> 2] | 0) - (HEAP32[$24 >> 2] | 0) | 0;
 if (($26 | 0) > 0) {
  $28 = HEAP32[4240] | 0;
  $h$06$i = 0;
  $k$07$i = 0;
  while (1) {
   $h$1$i = (HEAPU8[$20 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
   while (1) if (($h$1$i | 0) < ($28 | 0)) {
    $h$1$i$lcssa = $h$1$i;
    break;
   } else $h$1$i = $h$1$i - $28 | 0;
   $36 = $k$07$i + 1 | 0;
   if (($36 | 0) == ($26 | 0)) {
    $h$0$lcssa$i = $h$1$i$lcssa;
    break;
   } else {
    $h$06$i = $h$1$i$lcssa;
    $k$07$i = $36;
   }
  }
 } else $h$0$lcssa$i = 0;
 HEAP32[4241] = 0;
 $38 = HEAP32[4145] | 0;
 $39 = HEAP32[4042] | 0;
 $40 = HEAP32[4242] | 0;
 $41 = HEAP32[4243] | 0;
 $p$0$i = $h$0$lcssa$i + 1 | 0;
 L14 : while (1) {
  $43 = HEAP32[$38 + ($p$0$i << 2) >> 2] | 0;
  L16 : do if (($43 | 0) > 0) {
   $47 = HEAP32[$22 + ($43 + 1 << 2) >> 2] | 0;
   $49 = HEAP32[$22 + ($43 << 2) >> 2] | 0;
   if (($47 - $49 | 0) == ($26 | 0)) {
    if (($47 | 0) > ($49 | 0)) {
     $i$01$i$i = 0;
     $j$02$i$i = $49;
     while (1) {
      if ((HEAP8[$39 + $j$02$i$i >> 0] | 0) != (HEAP8[$20 + $i$01$i$i >> 0] | 0)) break L16;
      $59 = $j$02$i$i + 1 | 0;
      if (($59 | 0) < ($47 | 0)) {
       $i$01$i$i = $i$01$i$i + 1 | 0;
       $j$02$i$i = $59;
      } else break;
     }
    }
    if ((HEAP8[$40 + $p$0$i >> 0] | 0) == 9) {
     $p$0$i$lcssa = $p$0$i;
     label = 16;
     break L14;
    }
   }
  } while (0);
  $65 = HEAP32[$41 + ($p$0$i << 2) >> 2] | 0;
  if (!$65) {
   $67 = 0;
   $p$0$i46 = $p$0$i;
   break;
  } else $p$0$i = $65;
 }
 if ((label | 0) == 16) {
  HEAP32[4241] = 1;
  $67 = 1;
  $p$0$i46 = $p$0$i$lcssa;
 }
 HEAP32[4248] = $p$0$i46;
 HEAP32[4254] = $67;
 $68 = HEAP32[$21 >> 2] | 0;
 $69 = HEAP32[$24 >> 2] | 0;
 $70 = $68 - $69 | 0;
 if (($70 | 0) > 0) {
  $72 = $70 + -1 | 0;
  $i$0$i = 0;
  while (1) {
   $73 = $20 + $i$0$i | 0;
   $74 = HEAP8[$73 >> 0] | 0;
   if (($74 + -65 & 255) < 26) HEAP8[$73 >> 0] = ($74 & 255) + 32;
   if (($i$0$i | 0) < ($72 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
  }
  $$pre27 = HEAP32[4041] | 0;
  $105 = $$pre27;
  $82 = HEAP32[$$pre27 + ($citestr << 2) >> 2] | 0;
  $83 = HEAP32[$$pre27 + ($3 << 2) >> 2] | 0;
  $88 = HEAP32[3995] | 0;
 } else {
  $105 = $22;
  $82 = $69;
  $83 = $68;
  $88 = $20;
 }
 $81 = $83 - $82 | 0;
 if (($81 | 0) > 0) {
  $85 = HEAP32[4240] | 0;
  $h$06$i3 = 0;
  $k$07$i2 = 0;
  while (1) {
   $h$1$i4 = (HEAPU8[$88 + $k$07$i2 >> 0] | 0) + ($h$06$i3 << 1) | 0;
   while (1) if (($h$1$i4 | 0) < ($85 | 0)) {
    $h$1$i4$lcssa = $h$1$i4;
    break;
   } else $h$1$i4 = $h$1$i4 - $85 | 0;
   $94 = $k$07$i2 + 1 | 0;
   if (($94 | 0) == ($81 | 0)) {
    $h$0$lcssa$i5 = $h$1$i4$lcssa;
    break;
   } else {
    $h$06$i3 = $h$1$i4$lcssa;
    $k$07$i2 = $94;
   }
  }
 } else $h$0$lcssa$i5 = 0;
 HEAP32[4241] = 0;
 $96 = HEAP32[4145] | 0;
 $97 = HEAP32[4042] | 0;
 $98 = HEAP32[4242] | 0;
 $99 = HEAP32[4243] | 0;
 $p$0$i7 = $h$0$lcssa$i5 + 1 | 0;
 L45 : while (1) {
  $101 = HEAP32[$96 + ($p$0$i7 << 2) >> 2] | 0;
  L47 : do if (($101 | 0) > 0) {
   $106 = HEAP32[$105 + ($101 + 1 << 2) >> 2] | 0;
   $108 = HEAP32[$105 + ($101 << 2) >> 2] | 0;
   if (($106 - $108 | 0) == ($81 | 0)) {
    if (($106 | 0) > ($108 | 0)) {
     $i$01$i$i11 = 0;
     $j$02$i$i10 = $108;
     while (1) {
      if ((HEAP8[$97 + $j$02$i$i10 >> 0] | 0) != (HEAP8[$88 + $i$01$i$i11 >> 0] | 0)) break L47;
      $118 = $j$02$i$i10 + 1 | 0;
      if (($118 | 0) < ($106 | 0)) {
       $i$01$i$i11 = $i$01$i$i11 + 1 | 0;
       $j$02$i$i10 = $118;
      } else break;
     }
    }
    if ((HEAP8[$98 + $p$0$i7 >> 0] | 0) == 10) {
     $p$0$i7$lcssa = $p$0$i7;
     break L45;
    }
   }
  } while (0);
  $124 = HEAP32[$99 + ($p$0$i7 << 2) >> 2] | 0;
  if (!$124) {
   $126 = 0;
   $p$0$i744 = $p$0$i7;
   label = 38;
   break;
  } else $p$0$i7 = $124;
 }
 if ((label | 0) == 38) {
  HEAP32[4250] = $p$0$i744;
  return $126 | 0;
 }
 HEAP32[4241] = 1;
 $126 = 1;
 $p$0$i744 = $p$0$i7$lcssa;
 HEAP32[4250] = $p$0$i744;
 return $126 | 0;
}

function _xsubstring() {
 var $$pr = 0, $0 = 0, $10 = 0, $100 = 0, $104 = 0, $11 = 0, $16 = 0, $17 = 0, $19 = 0, $21 = 0, $22 = 0, $24 = 0, $25 = 0, $32 = 0, $43 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $54 = 0, $60 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $68 = 0, $70 = 0, $71 = 0, $73 = 0, $75 = 0, $76 = 0, $78 = 0, $84 = 0, $85 = 0, $86 = 0, $88 = 0, $91 = 0, $93 = 0, $96 = 0, $98 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 _zzpoplitstk(17512, 26651);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $5 = HEAP8[26649] | 0;
   switch ($5 << 24 >> 24) {
   case 0:
    {
     $10 = HEAP8[26651] | 0;
     $11 = HEAP32[4378] | 0;
     switch ($10 << 24 >> 24) {
     case 1:
      {
       $16 = HEAP32[4041] | 0;
       $17 = $16 + ($11 + 1 << 2) | 0;
       $19 = $16 + ($11 << 2) | 0;
       $21 = (HEAP32[$17 >> 2] | 0) - (HEAP32[$19 >> 2] | 0) | 0;
       HEAP32[4366] = $21;
       $22 = HEAP32[4345] | 0;
       $$pr = HEAP32[4365] | 0;
       $24 = 0 - $$pr | 0;
       L10 : do if (($22 | 0) >= ($21 | 0)) {
        switch ($$pr | 0) {
        case 1:
        case -1:
         break;
        default:
         break L10;
        }
        $25 = HEAP32[4360] | 0;
        if ((HEAP32[(HEAP32[4361] | 0) + ($25 << 2) >> 2] | 0) >= (HEAP32[4364] | 0)) {
         $32 = (HEAP32[4e3] | 0) + 1 | 0;
         HEAP32[4e3] = $32;
         HEAP32[4237] = HEAP32[$16 + ($32 << 2) >> 2];
        }
        HEAP32[4360] = $25 + 1;
        STACKTOP = sp;
        return;
       } while (0);
       if (!(($$pr | 0) == 0 | ($22 | 0) < 1)) if (!(($$pr | 0) > ($21 | 0) | ($$pr | 0) < (0 - $21 | 0))) {
        if (($$pr | 0) > 0) {
         $43 = 1 - $$pr + $21 | 0;
         if (($22 | 0) > ($43 | 0)) {
          HEAP32[4345] = $43;
          $49 = $43;
         } else $49 = $22;
         $47 = (HEAP32[$19 >> 2] | 0) + -1 + $$pr | 0;
         HEAP32[4343] = $47;
         $48 = $47 + $49 | 0;
         HEAP32[4344] = $48;
         if (($$pr | 0) != 1 | ($11 | 0) < (HEAP32[4364] | 0)) {
          $68 = $48;
          $70 = $47;
         } else {
          HEAP32[$17 >> 2] = $48;
          $54 = (HEAP32[4e3] | 0) + 1 | 0;
          HEAP32[4e3] = $54;
          HEAP32[4237] = HEAP32[$16 + ($54 << 2) >> 2];
          HEAP32[4360] = (HEAP32[4360] | 0) + 1;
          STACKTOP = sp;
          return;
         }
        } else {
         HEAP32[4365] = $24;
         $60 = $21 - ~$$pr | 0;
         if (($22 | 0) > ($60 | 0)) {
          HEAP32[4345] = $60;
          $65 = $60;
         } else $65 = $22;
         $63 = (HEAP32[$17 >> 2] | 0) + 1 + $$pr | 0;
         HEAP32[4344] = $63;
         $64 = $63 - $65 | 0;
         HEAP32[4343] = $64;
         $68 = $63;
         $70 = $64;
        }
        $66 = HEAP32[4237] | 0;
        $71 = HEAP32[4043] | 0;
        if (($68 + $66 - $70 | 0) > ($71 | 0)) {
         $78 = $71;
         while (1) {
          $76 = HEAP32[3989] | 0;
          HEAP32[$vararg_buffer >> 2] = 1161;
          HEAP32[$vararg_buffer + 4 >> 2] = 1;
          HEAP32[$vararg_buffer + 8 >> 2] = $78 + 65e3;
          HEAP32[$vararg_buffer + 12 >> 2] = $78;
          _fprintf($76, 1023, $vararg_buffer) | 0;
          HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
          $84 = (HEAP32[4043] | 0) + 65e3 | 0;
          HEAP32[4043] = $84;
          $85 = HEAP32[4237] | 0;
          $86 = HEAP32[4344] | 0;
          $88 = HEAP32[4343] | 0;
          if (($86 + $85 - $88 | 0) > ($84 | 0)) $78 = $84; else {
           $104 = $85;
           $73 = $88;
           $75 = $86;
           break;
          }
         }
        } else {
         $104 = $66;
         $73 = $70;
         $75 = $68;
        }
        if (($73 | 0) < ($75 | 0)) {
         $93 = $73;
         $96 = $104;
         while (1) {
          $91 = HEAP32[4042] | 0;
          HEAP8[$91 + $96 >> 0] = HEAP8[$91 + $93 >> 0] | 0;
          $98 = (HEAP32[4237] | 0) + 1 | 0;
          HEAP32[4237] = $98;
          $100 = (HEAP32[4343] | 0) + 1 | 0;
          HEAP32[4343] = $100;
          if (($100 | 0) < (HEAP32[4344] | 0)) {
           $93 = $100;
           $96 = $98;
          } else break;
         }
        }
        _zpushlitstk(_makestring() | 0, 1);
        STACKTOP = sp;
        return;
       }
       _zpushlitstk(HEAP32[4301] | 0, 1);
       STACKTOP = sp;
       return;
      }
     case 4:
      break;
     default:
      {
       _zprintstklit($11, $10);
       _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
       _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
       _bstexwarnprint();
      }
     }
     _zpushlitstk(HEAP32[4301] | 0, 1);
     STACKTOP = sp;
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit(HEAP32[4365] | 0, $5);
     _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(HEAP32[4301] | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 STACKTOP = sp;
 return;
}

function _xaddperiod() {
 var $$lcssa = 0, $$lcssa27 = 0, $$lcssa60 = 0, $$pre = 0, $$pre10 = 0, $0 = 0, $1 = 0, $100 = 0, $102 = 0, $103 = 0, $106 = 0, $107 = 0, $111 = 0, $13 = 0, $14 = 0, $16 = 0, $17 = 0, $19 = 0, $22 = 0, $23 = 0, $30 = 0, $36 = 0, $38 = 0, $41 = 0, $43 = 0, $45 = 0, $49 = 0, $51 = 0, $52 = 0, $53 = 0, $55 = 0, $59 = 0, $6 = 0, $64 = 0, $66 = 0, $67 = 0, $7 = 0, $70 = 0, $73 = 0, $75 = 0, $77 = 0, $8 = 0, $81 = 0, $84 = 0, $86 = 0, $88 = 0, $9 = 0, $91 = 0, $92 = 0, $94 = 0, $96 = 0, $vararg_buffer = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 $1 = HEAP32[4345] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   $6 = HEAP32[4041] | 0;
   $7 = $6 + ($1 + 1 << 2) | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   $9 = $6 + ($1 << 2) | 0;
   if (($8 | 0) == (HEAP32[$9 >> 2] | 0)) {
    _zpushlitstk(HEAP32[4301] | 0, 1);
    STACKTOP = sp;
    return;
   }
   HEAP32[4343] = $8;
   $13 = HEAP32[$9 >> 2] | 0;
   HEAP32[4344] = $13;
   $14 = $8;
   while (1) {
    if (($14 | 0) <= ($13 | 0)) {
     $$lcssa60 = $14;
     label = 8;
     break;
    }
    $16 = $14 + -1 | 0;
    HEAP32[4343] = $16;
    $17 = HEAP32[4042] | 0;
    $19 = HEAP8[$17 + $16 >> 0] | 0;
    if ($19 << 24 >> 24 == 125) $14 = $16; else {
     $111 = $17;
     $22 = $19;
     break;
    }
   }
   if ((label | 0) == 8) {
    $$pre = HEAP32[4042] | 0;
    $111 = $$pre;
    $22 = HEAP8[$$pre + $$lcssa60 >> 0] | 0;
   }
   switch ($22 & 255 | 0) {
   case 33:
   case 63:
   case 46:
    {
     $23 = HEAP32[4360] | 0;
     if ((HEAP32[(HEAP32[4361] | 0) + ($23 << 2) >> 2] | 0) >= (HEAP32[4364] | 0)) {
      $30 = (HEAP32[4e3] | 0) + 1 | 0;
      HEAP32[4e3] = $30;
      HEAP32[4237] = HEAP32[$6 + ($30 << 2) >> 2];
     }
     HEAP32[4360] = $23 + 1;
     STACKTOP = sp;
     return;
    }
   default:
    {}
   }
   if (($1 | 0) < (HEAP32[4364] | 0)) {
    $36 = HEAP32[4237] | 0;
    $38 = HEAP32[$9 >> 2] | 0;
    $41 = HEAP32[4043] | 0;
    if (((HEAP32[$7 >> 2] | 0) + $36 - $38 | 0) < ($41 | 0)) {
     $$lcssa = $38;
     $64 = $1;
     $66 = $6;
     $70 = $111;
     $73 = $36;
    } else {
     $45 = $41;
     while (1) {
      $43 = HEAP32[3989] | 0;
      HEAP32[$vararg_buffer >> 2] = 1161;
      HEAP32[$vararg_buffer + 4 >> 2] = 1;
      HEAP32[$vararg_buffer + 8 >> 2] = $45 + 65e3;
      HEAP32[$vararg_buffer + 12 >> 2] = $45;
      _fprintf($43, 1023, $vararg_buffer) | 0;
      $49 = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
      HEAP32[4042] = $49;
      $51 = (HEAP32[4043] | 0) + 65e3 | 0;
      HEAP32[4043] = $51;
      $52 = HEAP32[4237] | 0;
      $53 = HEAP32[4345] | 0;
      $55 = HEAP32[4041] | 0;
      $59 = HEAP32[$55 + ($53 << 2) >> 2] | 0;
      if (((HEAP32[$55 + ($53 + 1 << 2) >> 2] | 0) + $52 - $59 | 0) < ($51 | 0)) {
       $$lcssa = $59;
       $64 = $53;
       $66 = $55;
       $70 = $49;
       $73 = $52;
       break;
      } else $45 = $51;
     }
    }
    HEAP32[4343] = $$lcssa;
    $67 = HEAP32[$66 + ($64 + 1 << 2) >> 2] | 0;
    HEAP32[4344] = $67;
    if (($$lcssa | 0) < ($67 | 0)) {
     HEAP8[$70 + $73 >> 0] = HEAP8[$70 + $$lcssa >> 0] | 0;
     $75 = (HEAP32[4237] | 0) + 1 | 0;
     HEAP32[4237] = $75;
     $77 = (HEAP32[4343] | 0) + 1 | 0;
     HEAP32[4343] = $77;
     if (($77 | 0) < (HEAP32[4344] | 0)) {
      $81 = $77;
      $84 = $75;
      while (1) {
       $$pre10 = HEAP32[4042] | 0;
       HEAP8[$$pre10 + $84 >> 0] = HEAP8[$$pre10 + $81 >> 0] | 0;
       $86 = (HEAP32[4237] | 0) + 1 | 0;
       HEAP32[4237] = $86;
       $88 = (HEAP32[4343] | 0) + 1 | 0;
       HEAP32[4343] = $88;
       if (($88 | 0) < (HEAP32[4344] | 0)) {
        $81 = $88;
        $84 = $86;
       } else {
        $$lcssa27 = $86;
        break;
       }
      }
     } else $$lcssa27 = $75;
     $106 = HEAP32[4042] | 0;
     $107 = $$lcssa27;
    } else {
     $106 = $70;
     $107 = $73;
    }
   } else {
    $91 = HEAP32[$7 >> 2] | 0;
    HEAP32[4237] = $91;
    $92 = HEAP32[4043] | 0;
    if (($91 | 0) < ($92 | 0)) {
     $106 = $111;
     $107 = $91;
    } else {
     $96 = $92;
     while (1) {
      $94 = HEAP32[3989] | 0;
      HEAP32[$vararg_buffer4 >> 2] = 1161;
      HEAP32[$vararg_buffer4 + 4 >> 2] = 1;
      HEAP32[$vararg_buffer4 + 8 >> 2] = $96 + 65e3;
      HEAP32[$vararg_buffer4 + 12 >> 2] = $96;
      _fprintf($94, 1023, $vararg_buffer4) | 0;
      $100 = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
      HEAP32[4042] = $100;
      $102 = (HEAP32[4043] | 0) + 65e3 | 0;
      HEAP32[4043] = $102;
      $103 = HEAP32[4237] | 0;
      if (($103 | 0) < ($102 | 0)) {
       $106 = $100;
       $107 = $103;
       break;
      } else $96 = $102;
     }
    }
   }
   HEAP8[$106 + $107 >> 0] = 46;
   HEAP32[4237] = (HEAP32[4237] | 0) + 1;
   _zpushlitstk(_makestring() | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit($1, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 STACKTOP = sp;
 return;
}

function _badargumenttoken() {
 var $$lcssa = 0, $$lcssa25 = 0, $0 = 0, $1 = 0, $107 = 0, $108 = 0, $111 = 0, $117 = 0, $118 = 0, $120 = 0, $121 = 0, $123 = 0, $13 = 0, $131 = 0, $134 = 0, $14 = 0, $15 = 0, $17 = 0, $2 = 0, $20 = 0, $26 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $35 = 0, $39 = 0, $4 = 0, $41 = 0, $5 = 0, $51 = 0, $57 = 0, $59 = 0, $6 = 0, $67 = 0, $68 = 0, $71 = 0, $77 = 0, $78 = 0, $80 = 0, $81 = 0, $83 = 0, $91 = 0, $94 = 0, $99 = 0, $Result$0 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$0$i = 0, $i$01$i$i = 0, $i$01$i1$i = 0, $i$01$i1$i8 = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa33 = 0, label = 0;
 $0 = HEAP32[3993] | 0;
 $1 = HEAP32[4044] | 0;
 $2 = HEAP32[4045] | 0;
 if (($2 | 0) > ($1 | 0)) {
  $4 = $2 + -1 | 0;
  $i$0$i = $1;
  while (1) {
   $5 = $0 + $i$0$i | 0;
   $6 = HEAP8[$5 >> 0] | 0;
   if (($6 + -65 & 255) < 26) HEAP8[$5 >> 0] = ($6 & 255) + 32;
   if (($i$0$i | 0) < ($4 | 0)) $i$0$i = $i$0$i + 1 | 0; else break;
  }
  $14 = HEAP32[4044] | 0;
  $15 = HEAP32[4045] | 0;
  $20 = HEAP32[3993] | 0;
 } else {
  $14 = $1;
  $15 = $2;
  $20 = $0;
 }
 $13 = $15 - $14 | 0;
 if (($13 | 0) > 0) {
  $17 = HEAP32[4240] | 0;
  $h$06$i = 0;
  $k$07$i = $14;
  while (1) {
   $h$1$i = (HEAPU8[$20 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
   while (1) if (($h$1$i | 0) < ($17 | 0)) {
    $h$1$i$lcssa = $h$1$i;
    break;
   } else $h$1$i = $h$1$i - $17 | 0;
   $26 = $k$07$i + 1 | 0;
   if (($26 | 0) < ($15 | 0)) {
    $h$06$i = $h$1$i$lcssa;
    $k$07$i = $26;
   } else {
    $h$0$lcssa$i = $h$1$i$lcssa;
    break;
   }
  }
 } else $h$0$lcssa$i = 0;
 HEAP32[4241] = 0;
 $29 = HEAP32[4145] | 0;
 $30 = HEAP32[4041] | 0;
 $31 = HEAP32[4042] | 0;
 $32 = HEAP32[4242] | 0;
 $33 = HEAP32[4243] | 0;
 $p$0$i = $h$0$lcssa$i + 1 | 0;
 L18 : while (1) {
  $35 = HEAP32[$29 + ($p$0$i << 2) >> 2] | 0;
  L20 : do if (($35 | 0) > 0) {
   $39 = HEAP32[$30 + ($35 + 1 << 2) >> 2] | 0;
   $41 = HEAP32[$30 + ($35 << 2) >> 2] | 0;
   if (($39 - $41 | 0) == ($13 | 0)) {
    if (($39 | 0) > ($41 | 0)) {
     $i$01$i$i = $14;
     $j$02$i$i = $41;
     while (1) {
      if ((HEAP8[$31 + $j$02$i$i >> 0] | 0) != (HEAP8[$20 + $i$01$i$i >> 0] | 0)) break L20;
      $51 = $j$02$i$i + 1 | 0;
      if (($51 | 0) < ($39 | 0)) {
       $i$01$i$i = $i$01$i$i + 1 | 0;
       $j$02$i$i = $51;
      } else break;
     }
    }
    if ((HEAP8[$32 + $p$0$i >> 0] | 0) == 11) {
     $p$0$i$lcssa = $p$0$i;
     break L18;
    }
   }
  } while (0);
  $57 = HEAP32[$33 + ($p$0$i << 2) >> 2] | 0;
  if (!$57) {
   $p$0$i$lcssa33 = $p$0$i;
   label = 20;
   break;
  } else $p$0$i = $57;
 }
 if ((label | 0) == 20) {
  HEAP32[4310] = $p$0$i$lcssa33;
  $59 = HEAP32[3990] | 0;
  if (($15 | 0) > ($14 | 0)) {
   _putc(HEAPU8[26133 + (HEAPU8[$20 + $14 >> 0] | 0) >> 0] | 0, $59) | 0;
   $67 = $14 + 1 | 0;
   $68 = HEAP32[4045] | 0;
   if (($67 | 0) < ($68 | 0)) {
    $71 = $67;
    while (1) {
     _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $71 >> 0] | 0) >> 0] | 0, $59) | 0;
     $77 = $71 + 1 | 0;
     $78 = HEAP32[4045] | 0;
     if (($77 | 0) < ($78 | 0)) $71 = $77; else {
      $$lcssa25 = $78;
      break;
     }
    }
   } else $$lcssa25 = $68;
   $81 = HEAP32[4044] | 0;
   $83 = $$lcssa25;
  } else {
   $81 = $14;
   $83 = $15;
  }
  $80 = HEAP32[3989] | 0;
  if (($81 | 0) < ($83 | 0)) {
   $i$01$i1$i = $81;
   while (1) {
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $80) | 0;
    $91 = $i$01$i1$i + 1 | 0;
    if (($91 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $91; else break;
   }
   $94 = HEAP32[3989] | 0;
  } else $94 = $80;
  _fwrite(3001, 23, 1, $94) | 0;
  _fwrite(3001, 23, 1, HEAP32[3990] | 0) | 0;
  _bsterrprintandlookforblankline();
  $Result$0 = 1;
  return $Result$0 | 0;
 }
 HEAP32[4241] = 1;
 HEAP32[4310] = $p$0$i$lcssa;
 if ((HEAPU8[(HEAP32[4144] | 0) + $p$0$i$lcssa >> 0] | 0) < 2) {
  $Result$0 = 0;
  return $Result$0 | 0;
 }
 $99 = HEAP32[3990] | 0;
 if (($15 | 0) > ($14 | 0)) {
  _putc(HEAPU8[26133 + (HEAPU8[$20 + $14 >> 0] | 0) >> 0] | 0, $99) | 0;
  $107 = $14 + 1 | 0;
  $108 = HEAP32[4045] | 0;
  if (($107 | 0) < ($108 | 0)) {
   $111 = $107;
   while (1) {
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $111 >> 0] | 0) >> 0] | 0, $99) | 0;
    $117 = $111 + 1 | 0;
    $118 = HEAP32[4045] | 0;
    if (($117 | 0) < ($118 | 0)) $111 = $117; else {
     $$lcssa = $118;
     break;
    }
   }
  } else $$lcssa = $108;
  $121 = HEAP32[4044] | 0;
  $123 = $$lcssa;
 } else {
  $121 = $14;
  $123 = $15;
 }
 $120 = HEAP32[3989] | 0;
 if (($121 | 0) < ($123 | 0)) {
  $i$01$i1$i8 = $121;
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i8 >> 0] | 0) >> 0] | 0, $120) | 0;
   $131 = $i$01$i1$i8 + 1 | 0;
   if (($131 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i8 = $131; else break;
  }
  $134 = HEAP32[3989] | 0;
 } else $134 = $120;
 _fwrite(4748, 23, 1, $134) | 0;
 _fwrite(4748, 23, 1, HEAP32[3990] | 0) | 0;
 _zprintfnclass(HEAP32[4310] | 0);
 _bsterrprintandlookforblankline();
 $Result$0 = 1;
 return $Result$0 | 0;
}

function _zstrlookup($buf, $j, $l, $ilk, $insertit) {
 $buf = $buf | 0;
 $j = $j | 0;
 $l = $l | 0;
 $ilk = $ilk | 0;
 $insertit = $insertit | 0;
 var $$lcssa28 = 0, $$lcssa31 = 0, $$lcssa32 = 0, $0 = 0, $1 = 0, $10 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $19 = 0, $2 = 0, $20 = 0, $23 = 0, $25 = 0, $35 = 0, $40 = 0, $41 = 0, $44 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $58 = 0, $60 = 0, $64 = 0, $66 = 0, $72 = 0, $73 = 0, $80 = 0, $82 = 0, $83 = 0, $85 = 0, $90 = 0, $h$0$lcssa = 0, $h$06 = 0, $h$1 = 0, $h$1$lcssa = 0, $i$01$i = 0, $j$02$i = 0, $k$07 = 0, $k$14 = 0, $p$0 = 0, $p$0$lcssa = 0, $p$0$lcssa29 = 0, $p$1 = 0, $p$2 = 0, $strnum$0 = 0, $strnum$1 = 0, $strnum$1$lcssa = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer6 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = $l + $j | 0;
 $1 = ($l | 0) > 0;
 if ($1) {
  $2 = HEAP32[4240] | 0;
  $h$06 = 0;
  $k$07 = $j;
  while (1) {
   $h$1 = (HEAPU8[$buf + $k$07 >> 0] | 0) + ($h$06 << 1) | 0;
   while (1) if (($h$1 | 0) < ($2 | 0)) {
    $h$1$lcssa = $h$1;
    break;
   } else $h$1 = $h$1 - $2 | 0;
   $10 = $k$07 + 1 | 0;
   if (($10 | 0) < ($0 | 0)) {
    $h$06 = $h$1$lcssa;
    $k$07 = $10;
   } else {
    $h$0$lcssa = $h$1$lcssa;
    break;
   }
  }
 } else $h$0$lcssa = 0;
 HEAP32[4241] = 0;
 $13 = HEAP32[4145] | 0;
 $14 = HEAP32[4041] | 0;
 $15 = HEAP32[4042] | 0;
 $16 = HEAP32[4242] | 0;
 $17 = HEAP32[4243] | 0;
 $p$0 = $h$0$lcssa + 1 | 0;
 $strnum$0 = 0;
 L9 : while (1) {
  $19 = HEAP32[$13 + ($p$0 << 2) >> 2] | 0;
  $20 = ($19 | 0) > 0;
  L11 : do if ($20) {
   $23 = HEAP32[$14 + ($19 + 1 << 2) >> 2] | 0;
   $25 = HEAP32[$14 + ($19 << 2) >> 2] | 0;
   if (($23 - $25 | 0) == ($l | 0)) {
    if (($23 | 0) > ($25 | 0)) {
     $i$01$i = $j;
     $j$02$i = $25;
     while (1) {
      if ((HEAP8[$15 + $j$02$i >> 0] | 0) != (HEAP8[$buf + $i$01$i >> 0] | 0)) {
       $strnum$1 = $strnum$0;
       break L11;
      }
      $35 = $j$02$i + 1 | 0;
      if (($35 | 0) < ($23 | 0)) {
       $i$01$i = $i$01$i + 1 | 0;
       $j$02$i = $35;
      } else break;
     }
    }
    if ((HEAP8[$16 + $p$0 >> 0] | 0) == $ilk << 24 >> 24) {
     $p$0$lcssa = $p$0;
     label = 13;
     break L9;
    } else $strnum$1 = $19;
   } else $strnum$1 = $strnum$0;
  } else $strnum$1 = $strnum$0; while (0);
  $40 = $17 + ($p$0 << 2) | 0;
  $41 = HEAP32[$40 >> 2] | 0;
  if (!$41) {
   $$lcssa31 = $20;
   $$lcssa32 = $40;
   $p$0$lcssa29 = $p$0;
   $strnum$1$lcssa = $strnum$1;
   break;
  } else {
   $p$0 = $41;
   $strnum$0 = $strnum$1;
  }
 }
 if ((label | 0) == 13) {
  HEAP32[4241] = 1;
  $p$2 = $p$0$lcssa;
  STACKTOP = sp;
  return $p$2 | 0;
 }
 if (!$insertit) {
  $p$2 = $p$0$lcssa29;
  STACKTOP = sp;
  return $p$2 | 0;
 }
 do if ($$lcssa31) {
  $44 = HEAP32[4244] | 0;
  while (1) {
   if (($44 | 0) == 1) {
    label = 19;
    break;
   }
   $52 = $44 + -1 | 0;
   HEAP32[4244] = $52;
   if (!(HEAP32[$13 + ($52 << 2) >> 2] | 0)) {
    $$lcssa28 = $52;
    label = 21;
    break;
   } else $44 = $52;
  }
  if ((label | 0) == 19) {
   _fwrite(926, 33, 1, HEAP32[3989] | 0) | 0;
   _fwrite(926, 33, 1, HEAP32[3990] | 0) | 0;
   HEAP8[25620] = 3;
   $48 = HEAP32[3989] | 0;
   $49 = HEAP32[4245] | 0;
   HEAP32[$vararg_buffer >> 2] = 2885;
   HEAP32[$vararg_buffer + 4 >> 2] = $49;
   _fprintf($48, 2854, $vararg_buffer) | 0;
   $50 = HEAP32[3990] | 0;
   $51 = HEAP32[4245] | 0;
   HEAP32[$vararg_buffer2 >> 2] = 2885;
   HEAP32[$vararg_buffer2 + 4 >> 2] = $51;
   _fprintf($50, 2854, $vararg_buffer2) | 0;
   _longjmp(16008, 1);
  } else if ((label | 0) == 21) {
   HEAP32[$$lcssa32 >> 2] = $$lcssa28;
   $p$1 = HEAP32[4244] | 0;
   break;
  }
 } else $p$1 = $p$0$lcssa29; while (0);
 if (($strnum$1$lcssa | 0) > 0) HEAP32[(HEAP32[4145] | 0) + ($p$1 << 2) >> 2] = $strnum$1$lcssa; else {
  $58 = HEAP32[4237] | 0;
  $60 = HEAP32[4043] | 0;
  if (($58 + $l | 0) > ($60 | 0)) {
   $66 = $60;
   while (1) {
    $64 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer6 >> 2] = 1161;
    HEAP32[$vararg_buffer6 + 4 >> 2] = 1;
    HEAP32[$vararg_buffer6 + 8 >> 2] = $66 + 65e3;
    HEAP32[$vararg_buffer6 + 12 >> 2] = $66;
    _fprintf($64, 1023, $vararg_buffer6) | 0;
    HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
    $72 = (HEAP32[4043] | 0) + 65e3 | 0;
    HEAP32[4043] = $72;
    $73 = HEAP32[4237] | 0;
    if (($73 + $l | 0) > ($72 | 0)) $66 = $72; else {
     $90 = $73;
     break;
    }
   }
  } else $90 = $58;
  if ($1) {
   $80 = $90;
   $k$14 = $j;
   while (1) {
    HEAP8[(HEAP32[4042] | 0) + $80 >> 0] = HEAP8[$buf + $k$14 >> 0] | 0;
    $82 = (HEAP32[4237] | 0) + 1 | 0;
    HEAP32[4237] = $82;
    $83 = $k$14 + 1 | 0;
    if (($83 | 0) < ($0 | 0)) {
     $80 = $82;
     $k$14 = $83;
    } else break;
   }
  }
  $85 = _makestring() | 0;
  HEAP32[(HEAP32[4145] | 0) + ($p$1 << 2) >> 2] = $85;
 }
 HEAP8[(HEAP32[4242] | 0) + $p$1 >> 0] = $ilk;
 $p$2 = $p$1;
 STACKTOP = sp;
 return $p$2 | 0;
}

function _brace_expand($agg$result, $text) {
 $agg$result = $agg$result | 0;
 $text = $text | 0;
 var $$lcssa = 0, $$lcssa19 = 0, $0 = 0, $10 = 0, $12 = 0, $13 = 0, $15 = 0, $17 = 0, $19 = 0, $2 = 0, $21 = 0, $23 = 0, $26 = 0, $3 = 0, $31 = 0, $32 = 0, $36 = 0, $4 = 0, $40 = 0, $48 = 0, $49 = 0, $5 = 0, $53 = 0, $55 = 0, $57 = 0, $6 = 0, $62 = 0, $63 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $9 = 0, $p = 0, $partial = 0, $recurse = 0, $result = 0, $storemerge = 0, $tmp$i9 = 0, $tmpcast2$byval_copy1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $tmpcast2$byval_copy1 = sp + 48 | 0;
 $vararg_buffer = sp + 40 | 0;
 $tmp$i9 = sp + 24 | 0;
 $result = sp + 16 | 0;
 $partial = sp + 8 | 0;
 $recurse = sp;
 $p = sp + 44 | 0;
 $0 = sp + 32 | 0;
 HEAP32[$result >> 2] = 0;
 HEAP32[$result + 4 >> 2] = 0;
 HEAP32[$partial >> 2] = 0;
 $2 = $partial + 4 | 0;
 HEAP32[$2 >> 2] = 0;
 $3 = HEAP32[$text >> 2] | 0;
 HEAP32[$p >> 2] = $3;
 $4 = $tmp$i9 + 4 | 0;
 $5 = $tmp$i9 + 4 | 0;
 $6 = HEAP32[21] | 0;
 $7 = $3;
 $10 = $7;
 $13 = $3;
 $19 = $7;
 $67 = $7;
 $9 = $7;
 L1 : while (1) {
  switch (HEAP8[$9 >> 0] | 0) {
  case 125:
  case 0:
   {
    $$lcssa = $13;
    $$lcssa19 = $67;
    break L1;
    break;
   }
  case 44:
  case 58:
   {
    HEAP32[$tmp$i9 >> 2] = 0;
    HEAP32[$4 >> 2] = 0;
    $12 = $13 - $10 | 0;
    $15 = _xmalloc($12 + 1 | 0) | 0;
    _strncpy($15, $10, $12) | 0;
    HEAP8[$15 + $12 >> 0] = 0;
    _str_list_add($tmp$i9, $15);
    HEAP32[$tmpcast2$byval_copy1 >> 2] = HEAP32[$tmp$i9 >> 2];
    HEAP32[$tmpcast2$byval_copy1 + 4 >> 2] = HEAP32[$tmp$i9 + 4 >> 2];
    _str_list_concat_elements($partial, $tmpcast2$byval_copy1);
    HEAP32[$tmpcast2$byval_copy1 >> 2] = HEAP32[$partial >> 2];
    HEAP32[$tmpcast2$byval_copy1 + 4 >> 2] = HEAP32[$partial + 4 >> 2];
    _str_list_concat($result, $tmpcast2$byval_copy1);
    _str_list_free($partial);
    $17 = $9 + 1 | 0;
    HEAP32[$text >> 2] = $17;
    HEAP32[$partial >> 2] = 0;
    HEAP32[$2 >> 2] = 0;
    $49 = $9;
    $68 = $17;
    $69 = $17;
    $70 = $17;
    break;
   }
  case 123:
   {
    HEAP32[$tmp$i9 >> 2] = 0;
    HEAP32[$5 >> 2] = 0;
    $21 = $9 - $19 | 0;
    $23 = _xmalloc($21 + 1 | 0) | 0;
    _strncpy($23, $19, $21) | 0;
    HEAP8[$23 + $21 >> 0] = 0;
    _str_list_add($tmp$i9, $23);
    HEAP32[$tmpcast2$byval_copy1 >> 2] = HEAP32[$tmp$i9 >> 2];
    HEAP32[$tmpcast2$byval_copy1 + 4 >> 2] = HEAP32[$tmp$i9 + 4 >> 2];
    _str_list_concat_elements($partial, $tmpcast2$byval_copy1);
    HEAP32[$p >> 2] = $9 + 1;
    _brace_expand($0, $p);
    $26 = $0;
    $31 = HEAP32[$26 + 4 >> 2] | 0;
    $32 = $recurse;
    HEAP32[$32 >> 2] = HEAP32[$26 >> 2];
    HEAP32[$32 + 4 >> 2] = $31;
    HEAP32[$tmpcast2$byval_copy1 >> 2] = HEAP32[$recurse >> 2];
    HEAP32[$tmpcast2$byval_copy1 + 4 >> 2] = HEAP32[$recurse + 4 >> 2];
    _str_list_concat_elements($partial, $tmpcast2$byval_copy1);
    _str_list_free($recurse);
    $36 = HEAP32[$p >> 2] | 0;
    if ((HEAP8[$36 >> 0] | 0) != 125) {
     _fwrite(12399, 9, 1, $6) | 0;
     HEAP32[$vararg_buffer >> 2] = HEAP32[$text >> 2];
     _fprintf($6, 10561, $vararg_buffer) | 0;
     _fwrite(12726, 2, 1, $6) | 0;
     _fflush($6) | 0;
    }
    $40 = $36 + 1 | 0;
    HEAP32[$text >> 2] = $40;
    $49 = $36;
    $68 = $40;
    $69 = $40;
    $70 = $40;
    break;
   }
  case 36:
   {
    if ((HEAP8[$9 + 1 >> 0] | 0) == 123) {
     $storemerge = $9 + 2 | 0;
     while (1) {
      HEAP32[$p >> 2] = $storemerge;
      if ((HEAP8[$storemerge >> 0] | 0) == 125) {
       $49 = $storemerge;
       $68 = $67;
       $69 = $10;
       $70 = $19;
       break;
      } else $storemerge = $storemerge + 1 | 0;
     }
    } else {
     $49 = $9;
     $68 = $67;
     $69 = $10;
     $70 = $19;
    }
    break;
   }
  default:
   {
    $49 = $9;
    $68 = $67;
    $69 = $10;
    $70 = $19;
   }
  }
  $48 = $49 + 1 | 0;
  HEAP32[$p >> 2] = $48;
  $10 = $69;
  $13 = $48;
  $19 = $70;
  $67 = $68;
  $9 = $48;
 }
 HEAP32[$tmp$i9 >> 2] = 0;
 HEAP32[$tmp$i9 + 4 >> 2] = 0;
 $53 = $$lcssa - $$lcssa19 | 0;
 $55 = _xmalloc($53 + 1 | 0) | 0;
 _strncpy($55, $$lcssa19, $53) | 0;
 HEAP8[$55 + $53 >> 0] = 0;
 _str_list_add($tmp$i9, $55);
 HEAP32[$tmpcast2$byval_copy1 >> 2] = HEAP32[$tmp$i9 >> 2];
 HEAP32[$tmpcast2$byval_copy1 + 4 >> 2] = HEAP32[$tmp$i9 + 4 >> 2];
 _str_list_concat_elements($partial, $tmpcast2$byval_copy1);
 HEAP32[$tmpcast2$byval_copy1 >> 2] = HEAP32[$partial >> 2];
 HEAP32[$tmpcast2$byval_copy1 + 4 >> 2] = HEAP32[$partial + 4 >> 2];
 _str_list_concat($result, $tmpcast2$byval_copy1);
 _str_list_free($partial);
 HEAP32[$text >> 2] = $$lcssa;
 $57 = $result;
 $62 = HEAP32[$57 + 4 >> 2] | 0;
 $63 = $agg$result;
 HEAP32[$63 >> 2] = HEAP32[$57 >> 2];
 HEAP32[$63 + 4 >> 2] = $62;
 STACKTOP = sp;
 return;
}

function _hash_print($table, $summary_only) {
 $table = $table | 0;
 $summary_only = $summary_only | 0;
 var $$lcssa116 = 0, $$pn = 0, $$pn$us = 0, $$pre14 = 0, $1 = 0, $12 = 0, $15 = 0, $19 = 0, $20 = 0, $23 = 0, $25 = 0, $27 = 0, $30 = 0, $35 = 0, $36 = 0.0, $37 = 0, $4 = 0, $6 = 0, $b$05 = 0, $b$05$us = 0, $len$0 = 0, $len$0$lcssa = 0, $len$0$us = 0, $len$0$us$lcssa = 0, $tb$0 = 0, $tb$0$us = 0, $tb$12 = 0, $total_buckets$0$lcssa = 0, $total_buckets$0$lcssa17 = 0, $total_buckets$04 = 0, $total_buckets$04$us = 0, $total_buckets$1 = 0, $total_buckets$1$us = 0, $total_elements$0$lcssa = 0, $total_elements$0$lcssa18 = 0, $total_elements$03 = 0, $total_elements$03$us = 0, $total_elements$1 = 0, $total_elements$1$us = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer8 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $1 = HEAP32[$table + 4 >> 2] | 0;
 if (!$1) {
  $$lcssa116 = 0;
  $35 = 0;
  $36 = 0.0;
  $37 = HEAP32[21] | 0;
  $total_buckets$0$lcssa17 = 0;
  $total_elements$0$lcssa18 = 0;
 } else {
  $4 = HEAP32[21] | 0;
  $$pre14 = HEAP32[$table >> 2] | 0;
  if (!$summary_only) {
   $b$05 = 0;
   $total_buckets$04 = 0;
   $total_elements$03 = 0;
   while (1) {
    $15 = HEAP32[$$pre14 + ($b$05 << 2) >> 2] | 0;
    if (!$15) {
     $total_buckets$1 = $total_buckets$04;
     $total_elements$1 = $total_elements$03;
    } else {
     HEAP32[$vararg_buffer >> 2] = $b$05;
     _fprintf($4, 10833, $vararg_buffer) | 0;
     $$pn = $15;
     $len$0 = 1;
     while (1) {
      $tb$0 = HEAP32[$$pn + 8 >> 2] | 0;
      if (!$tb$0) {
       $len$0$lcssa = $len$0;
       break;
      } else {
       $$pn = $tb$0;
       $len$0 = $len$0 + 1 | 0;
      }
     }
     $19 = $total_buckets$04 + 1 | 0;
     HEAP32[$vararg_buffer1 >> 2] = $len$0$lcssa;
     _fprintf($4, 10838, $vararg_buffer1) | 0;
     $20 = $len$0$lcssa + $total_elements$03 | 0;
     $tb$12 = $15;
     while (1) {
      $23 = HEAP32[$tb$12 + 4 >> 2] | 0;
      HEAP32[$vararg_buffer4 >> 2] = HEAP32[$tb$12 >> 2];
      HEAP32[$vararg_buffer4 + 4 >> 2] = $23;
      _fprintf($4, 10844, $vararg_buffer4) | 0;
      $25 = HEAP32[$tb$12 + 8 >> 2] | 0;
      if (!$25) break; else $tb$12 = $25;
     }
     _putc(10, $4) | 0;
     $total_buckets$1 = $19;
     $total_elements$1 = $20;
    }
    $27 = $b$05 + 1 | 0;
    if ($27 >>> 0 < $1 >>> 0) {
     $b$05 = $27;
     $total_buckets$04 = $total_buckets$1;
     $total_elements$03 = $total_elements$1;
    } else {
     $total_buckets$0$lcssa = $total_buckets$1;
     $total_elements$0$lcssa = $total_elements$1;
     break;
    }
   }
  } else {
   $b$05$us = 0;
   $total_buckets$04$us = 0;
   $total_elements$03$us = 0;
   while (1) {
    $6 = HEAP32[$$pre14 + ($b$05$us << 2) >> 2] | 0;
    if (!$6) {
     $total_buckets$1$us = $total_buckets$04$us;
     $total_elements$1$us = $total_elements$03$us;
    } else {
     $$pn$us = $6;
     $len$0$us = 1;
     while (1) {
      $tb$0$us = HEAP32[$$pn$us + 8 >> 2] | 0;
      if (!$tb$0$us) {
       $len$0$us$lcssa = $len$0$us;
       break;
      } else {
       $$pn$us = $tb$0$us;
       $len$0$us = $len$0$us + 1 | 0;
      }
     }
     $total_buckets$1$us = $total_buckets$04$us + 1 | 0;
     $total_elements$1$us = $len$0$us$lcssa + $total_elements$03$us | 0;
    }
    $12 = $b$05$us + 1 | 0;
    if ($12 >>> 0 < $1 >>> 0) {
     $b$05$us = $12;
     $total_buckets$04$us = $total_buckets$1$us;
     $total_elements$03$us = $total_elements$1$us;
    } else {
     $total_buckets$0$lcssa = $total_buckets$1$us;
     $total_elements$0$lcssa = $total_elements$1$us;
     break;
    }
   }
  }
  $30 = (($total_buckets$0$lcssa * 100 | 0) >>> 0) / ($1 >>> 0) | 0;
  if (!$total_buckets$0$lcssa) {
   $$lcssa116 = $1;
   $35 = $30;
   $36 = 0.0;
   $37 = $4;
   $total_buckets$0$lcssa17 = 0;
   $total_elements$0$lcssa18 = $total_elements$0$lcssa;
  } else {
   $$lcssa116 = $1;
   $35 = $30;
   $36 = +($total_elements$0$lcssa >>> 0) / +($total_buckets$0$lcssa >>> 0);
   $37 = $4;
   $total_buckets$0$lcssa17 = $total_buckets$0$lcssa;
   $total_elements$0$lcssa18 = $total_elements$0$lcssa;
  }
 }
 HEAP32[$vararg_buffer8 >> 2] = $$lcssa116;
 HEAP32[$vararg_buffer8 + 4 >> 2] = $total_buckets$0$lcssa17;
 HEAP32[$vararg_buffer8 + 8 >> 2] = $35;
 HEAP32[$vararg_buffer8 + 12 >> 2] = $total_elements$0$lcssa18;
 HEAPF64[$vararg_buffer8 + 16 >> 3] = $36;
 _fprintf($37, 10852, $vararg_buffer8) | 0;
 STACKTOP = sp;
 return;
}

function _expand($kpse, $expansion, $start, $end) {
 $kpse = $kpse | 0;
 $expansion = $expansion | 0;
 $start = $start | 0;
 $end = $end | 0;
 var $$lcssa4$i = 0, $$lcssa4$i15 = 0, $$phi$trans$insert$i = 0, $11 = 0, $14 = 0, $18 = 0, $2 = 0, $23 = 0, $26 = 0, $27 = 0, $3 = 0, $31 = 0, $34 = 0, $36 = 0, $38 = 0, $41 = 0, $45 = 0, $48 = 0, $5 = 0, $50 = 0, $52 = 0, $54 = 0, $55 = 0, $58 = 0, $59 = 0, $61 = 0, $64 = 0, $68 = 0, $7 = 0, $71 = 0, $73 = 0, $75 = 0, $77 = 0, $78 = 0, $8 = 0, $e$03$us$i = 0, $e$03$us$i$lcssa = 0, $e$07$us$i = 0, $e$07$us$i$lcssa = 0, $e$07$us$i10 = 0, $e$07$us$i10$lcssa = 0, $ret$1 = 0, $value$120 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $2 = $end - $start | 0;
 $3 = $2 + 1 | 0;
 $5 = _xmalloc($2 + 2 | 0) | 0;
 _strncpy($5, $start, $3) | 0;
 HEAP8[$5 + $3 >> 0] = 0;
 $7 = $kpse + 4156 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 L1 : do if ($8 | 0) {
  $11 = HEAP32[$kpse + 4152 >> 2] | 0;
  if ($5 | 0) {
   $e$03$us$i = 0;
   while (1) {
    $14 = HEAP32[$11 + ($e$03$us$i << 3) >> 2] | 0;
    if ($14 | 0) if (!(_strcmp($14, $5) | 0)) {
     $e$03$us$i$lcssa = $e$03$us$i;
     break;
    }
    $18 = $e$03$us$i + 1 | 0;
    if ($18 >>> 0 < $8 >>> 0) $e$03$us$i = $18; else break L1;
   }
   if (HEAP32[$11 + ($e$03$us$i$lcssa << 3) + 4 >> 2] | 0) {
    $23 = HEAP32[21] | 0;
    _fwrite(12399, 9, 1, $23) | 0;
    HEAP32[$vararg_buffer >> 2] = $5;
    _fprintf($23, 12409, $vararg_buffer) | 0;
    _fwrite(12726, 2, 1, $23) | 0;
    _fflush($23) | 0;
    $ret$1 = 0;
    _free($5);
    STACKTOP = sp;
    return $ret$1 | 0;
   }
  }
 } while (0);
 $26 = _concat3($5, 12372, HEAP32[$kpse + 112 >> 2] | 0) | 0;
 $27 = _getenv($26 | 0) | 0;
 _free($26);
 if (!$27) label = 10; else if (!(HEAP8[$27 >> 0] | 0)) label = 10; else $value$120 = $27;
 do if ((label | 0) == 10) {
  $31 = _getenv($5 | 0) | 0;
  if ($31 | 0) if (HEAP8[$31 >> 0] | 0) {
   $value$120 = $31;
   break;
  }
  $34 = _kpathsea_cnf_get($kpse, $5) | 0;
  if (!$34) {
   $ret$1 = 0;
   _free($5);
   STACKTOP = sp;
   return $ret$1 | 0;
  } else $value$120 = $34;
 } while (0);
 $36 = HEAP32[$7 >> 2] | 0;
 $$phi$trans$insert$i = $kpse + 4152 | 0;
 L21 : do if (!$36) {
  $$lcssa4$i = 0;
  $50 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
  label = 20;
 } else {
  $38 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
  if (!$5) {
   $$lcssa4$i = $36;
   $50 = $38;
   label = 20;
  } else {
   $e$07$us$i = 0;
   while (1) {
    $41 = HEAP32[$38 + ($e$07$us$i << 3) >> 2] | 0;
    if ($41 | 0) if (!(_strcmp($41, $5) | 0)) {
     $e$07$us$i$lcssa = $e$07$us$i;
     break;
    }
    $45 = $e$07$us$i + 1 | 0;
    if ($45 >>> 0 < $36 >>> 0) $e$07$us$i = $45; else {
     $$lcssa4$i = $36;
     $50 = $38;
     label = 20;
     break L21;
    }
   }
   HEAP32[$38 + ($e$07$us$i$lcssa << 3) + 4 >> 2] = 1;
  }
 } while (0);
 if ((label | 0) == 20) {
  $48 = $$lcssa4$i + 1 | 0;
  HEAP32[$7 >> 2] = $48;
  HEAP32[$$phi$trans$insert$i >> 2] = _xrealloc($50, $48 << 3) | 0;
  $52 = _xstrdup($5) | 0;
  $54 = (HEAP32[$7 >> 2] | 0) + -1 | 0;
  $55 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
  HEAP32[$55 + ($54 << 3) >> 2] = $52;
  HEAP32[$55 + ($54 << 3) + 4 >> 2] = 1;
 }
 $58 = _kpathsea_expand($kpse, $value$120) | 0;
 $59 = HEAP32[$7 >> 2] | 0;
 L33 : do if (!$59) {
  $$lcssa4$i15 = 0;
  $73 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
  label = 28;
 } else {
  $61 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
  if (!$5) {
   $$lcssa4$i15 = $59;
   $73 = $61;
   label = 28;
  } else {
   $e$07$us$i10 = 0;
   while (1) {
    $64 = HEAP32[$61 + ($e$07$us$i10 << 3) >> 2] | 0;
    if ($64 | 0) if (!(_strcmp($64, $5) | 0)) {
     $e$07$us$i10$lcssa = $e$07$us$i10;
     break;
    }
    $68 = $e$07$us$i10 + 1 | 0;
    if ($68 >>> 0 < $59 >>> 0) $e$07$us$i10 = $68; else {
     $$lcssa4$i15 = $59;
     $73 = $61;
     label = 28;
     break L33;
    }
   }
   HEAP32[$61 + ($e$07$us$i10$lcssa << 3) + 4 >> 2] = 0;
  }
 } while (0);
 if ((label | 0) == 28) {
  $71 = $$lcssa4$i15 + 1 | 0;
  HEAP32[$7 >> 2] = $71;
  HEAP32[$$phi$trans$insert$i >> 2] = _xrealloc($73, $71 << 3) | 0;
  $75 = _xstrdup($5) | 0;
  $77 = (HEAP32[$7 >> 2] | 0) + -1 | 0;
  $78 = HEAP32[$$phi$trans$insert$i >> 2] | 0;
  HEAP32[$78 + ($77 << 3) >> 2] = $75;
  HEAP32[$78 + ($77 << 3) + 4 >> 2] = 0;
 }
 _fn_grow($expansion, $58, _strlen($58) | 0);
 _free($58);
 $ret$1 = 1;
 _free($5);
 STACKTOP = sp;
 return $ret$1 | 0;
}

function _getauxcommandandprocess() {
 var $$lcssa$i = 0, $0 = 0, $11 = 0, $13 = 0, $2 = 0, $21 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $30 = 0, $34 = 0, $36 = 0, $46 = 0, $5 = 0, $52 = 0, $59 = 0, $6 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $9 = 0, $h$0$lcssa$i = 0, $h$06$i = 0, $h$1$i = 0, $h$1$i$lcssa = 0, $i$01$i$i = 0, $j$02$i$i = 0, $k$07$i = 0, $p$0$i = 0, $p$0$i$lcssa = 0, $p$0$i$lcssa9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 HEAP32[4045] = 0;
 HEAP32[4044] = 0;
 $0 = HEAP32[3993] | 0;
 $2 = HEAP32[3999] | 0;
 $3 = ($2 | 0) > 0;
 if ((HEAP8[$0 >> 0] | 0) != 123 & $3) {
  $6 = 0;
  while (1) {
   $5 = $6 + 1 | 0;
   HEAP32[4045] = $5;
   $9 = ($5 | 0) < ($2 | 0);
   if ($9 & (HEAP8[$0 + $5 >> 0] | 0) != 123) $6 = $5; else {
    $$lcssa$i = $9;
    $11 = $5;
    break;
   }
  }
 } else {
  $$lcssa$i = $3;
  $11 = 0;
 }
 if (!$$lcssa$i) {
  STACKTOP = sp;
  return;
 }
 if (($11 | 0) > 0) {
  $13 = HEAP32[4240] | 0;
  $h$06$i = 0;
  $k$07$i = 0;
  while (1) {
   $h$1$i = (HEAPU8[$0 + $k$07$i >> 0] | 0) + ($h$06$i << 1) | 0;
   while (1) if (($h$1$i | 0) < ($13 | 0)) {
    $h$1$i$lcssa = $h$1$i;
    break;
   } else $h$1$i = $h$1$i - $13 | 0;
   $21 = $k$07$i + 1 | 0;
   if (($21 | 0) < ($11 | 0)) {
    $h$06$i = $h$1$i$lcssa;
    $k$07$i = $21;
   } else {
    $h$0$lcssa$i = $h$1$i$lcssa;
    break;
   }
  }
 } else $h$0$lcssa$i = 0;
 HEAP32[4241] = 0;
 $24 = HEAP32[4145] | 0;
 $25 = HEAP32[4041] | 0;
 $26 = HEAP32[4042] | 0;
 $27 = HEAP32[4242] | 0;
 $28 = HEAP32[4243] | 0;
 $p$0$i = $h$0$lcssa$i + 1 | 0;
 L16 : while (1) {
  $30 = HEAP32[$24 + ($p$0$i << 2) >> 2] | 0;
  L18 : do if (($30 | 0) > 0) {
   $34 = HEAP32[$25 + ($30 + 1 << 2) >> 2] | 0;
   $36 = HEAP32[$25 + ($30 << 2) >> 2] | 0;
   if (($34 - $36 | 0) == ($11 | 0)) {
    if (($34 | 0) > ($36 | 0)) {
     $i$01$i$i = 0;
     $j$02$i$i = $36;
     while (1) {
      if ((HEAP8[$26 + $j$02$i$i >> 0] | 0) != (HEAP8[$0 + $i$01$i$i >> 0] | 0)) break L18;
      $46 = $j$02$i$i + 1 | 0;
      if (($46 | 0) < ($34 | 0)) {
       $i$01$i$i = $i$01$i$i + 1 | 0;
       $j$02$i$i = $46;
      } else break;
     }
    }
    if ((HEAP8[$27 + $p$0$i >> 0] | 0) == 2) {
     $p$0$i$lcssa = $p$0$i;
     break L16;
    }
   }
  } while (0);
  $52 = HEAP32[$28 + ($p$0$i << 2) >> 2] | 0;
  if (!$52) {
   $p$0$i$lcssa9 = $p$0$i;
   label = 17;
   break;
  } else $p$0$i = $52;
 }
 if ((label | 0) == 17) {
  HEAP32[4321] = HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa9 << 2) >> 2];
  STACKTOP = sp;
  return;
 }
 HEAP32[4241] = 1;
 $59 = HEAP32[(HEAP32[4249] | 0) + ($p$0$i$lcssa << 2) >> 2] | 0;
 HEAP32[4321] = $59;
 switch ($59 | 0) {
 case 0:
  {
   _auxbibdatacommand();
   STACKTOP = sp;
   return;
  }
 case 1:
  {
   _auxbibstylecommand();
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   _auxcitationcommand();
   STACKTOP = sp;
   return;
  }
 case 3:
  {
   _auxinputcommand();
   STACKTOP = sp;
   return;
  }
 default:
  {
   _fwrite(4562, 30, 1, HEAP32[3989] | 0) | 0;
   _fwrite(4562, 30, 1, HEAP32[3990] | 0) | 0;
   $62 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = 964;
   _fprintf($62, 960, $vararg_buffer) | 0;
   $63 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer1 >> 2] = 964;
   _fprintf($63, 960, $vararg_buffer1) | 0;
   $64 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer4 >> 2] = 985;
   _fprintf($64, 960, $vararg_buffer4) | 0;
   $65 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer7 >> 2] = 985;
   _fprintf($65, 960, $vararg_buffer7) | 0;
   HEAP8[25620] = 3;
   _longjmp(16008, 1);
  }
 }
}

function _zaddoutpool($pstr) {
 $pstr = $pstr | 0;
 var $$lcssa = 0, $$pre = 0, $0 = 0, $11 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $23 = 0, $28 = 0, $30 = 0, $44 = 0, $46 = 0, $5 = 0, $53 = 0, $56 = 0, $6 = 0, $62 = 0, $63 = 0, $69 = 0, $71 = 0, $75 = 0, $77 = 0, $79 = 0, $81 = 0, $83 = 0, $86 = 0, $86$phi = 0, $storemerge$lcssa = 0, $storemerge1$us = 0, $storemerge1$us$lcssa = 0, $storemerge18 = 0, $storemerge213$us = 0, $storemerge39$us = 0, label = 0;
 $0 = HEAP32[4041] | 0;
 $2 = HEAP32[$0 + ($pstr << 2) >> 2] | 0;
 HEAP32[4238] = $2;
 $5 = HEAP32[$0 + ($pstr + 1 << 2) >> 2] | 0;
 HEAP32[4239] = $5;
 $6 = HEAP32[4153] | 0;
 if (($5 + $6 - $2 | 0) > (HEAP32[3992] | 0)) {
  do {
   _bufferoverflow();
   $14 = HEAP32[4153] | 0;
   $15 = HEAP32[4239] | 0;
   $16 = HEAP32[4238] | 0;
  } while (($15 + $14 - $16 | 0) > (HEAP32[3992] | 0));
  $$lcssa = $14;
  $11 = $16;
  $13 = $15;
 } else {
  $$lcssa = $6;
  $11 = $2;
  $13 = $5;
 }
 HEAP32[4154] = $$lcssa;
 if (($11 | 0) < ($13 | 0)) {
  $23 = $11;
  $storemerge18 = $$lcssa;
  while (1) {
   HEAP8[(HEAP32[3996] | 0) + $storemerge18 >> 0] = HEAP8[(HEAP32[4042] | 0) + $23 >> 0] | 0;
   $28 = (HEAP32[4238] | 0) + 1 | 0;
   HEAP32[4238] = $28;
   $30 = (HEAP32[4154] | 0) + 1 | 0;
   HEAP32[4154] = $30;
   if (($28 | 0) < (HEAP32[4239] | 0)) {
    $23 = $28;
    $storemerge18 = $30;
   } else {
    $storemerge$lcssa = $30;
    break;
   }
  }
 } else $storemerge$lcssa = $$lcssa;
 HEAP32[4153] = $storemerge$lcssa;
 if (($storemerge$lcssa | 0) > 79) $46 = $storemerge$lcssa; else return;
 L11 : while (1) {
  $$pre = HEAP32[3996] | 0;
  $storemerge1$us = 79;
  while (1) {
   HEAP32[4154] = $storemerge1$us;
   if (($storemerge1$us | 0) > 2 ? (HEAP8[25877 + (HEAPU8[$$pre + $storemerge1$us >> 0] | 0) >> 0] | 0) != 1 : 0) $storemerge1$us = $storemerge1$us + -1 | 0; else {
    $storemerge1$us$lcssa = $storemerge1$us;
    break;
   }
  }
  L16 : do if (($storemerge1$us$lcssa | 0) == 2) {
   HEAP32[4154] = 80;
   L18 : do if (($46 | 0) > 80) {
    $storemerge39$us = 80;
    while (1) {
     $44 = $storemerge39$us + 1 | 0;
     if ((HEAP8[25877 + (HEAPU8[$$pre + $storemerge39$us >> 0] | 0) >> 0] | 0) == 1) {
      $53 = $storemerge39$us;
      break L18;
     }
     HEAP32[4154] = $44;
     if (($44 | 0) < ($46 | 0)) $storemerge39$us = $44; else {
      $53 = $44;
      break;
     }
    }
   } else $53 = 80; while (0);
   if (($53 | 0) == ($46 | 0)) {
    label = 19;
    break L11;
   }
   $83 = $53 + 1 | 0;
   if (($83 | 0) < ($46 | 0)) {
    $56 = $83;
    $86 = $53;
    while (1) {
     if ((HEAP8[25877 + (HEAPU8[$$pre + $56 >> 0] | 0) >> 0] | 0) != 1) {
      $62 = $86;
      break L16;
     }
     HEAP32[4154] = $56;
     $81 = $56 + 1 | 0;
     if (($81 | 0) < ($46 | 0)) {
      $86$phi = $56;
      $56 = $81;
      $86 = $86$phi;
     } else {
      $62 = $56;
      break;
     }
    }
   } else $62 = $53;
  } else $62 = $storemerge1$us$lcssa; while (0);
  HEAP32[4153] = $62;
  $63 = $62 + 1 | 0;
  _outputbblline();
  HEAP8[HEAP32[3996] >> 0] = 32;
  HEAP8[(HEAP32[3996] | 0) + 1 >> 0] = 32;
  HEAP32[4154] = 2;
  HEAP32[4252] = $63;
  if (($63 | 0) < ($46 | 0)) {
   $75 = 2;
   $storemerge213$us = $63;
   while (1) {
    $71 = HEAP32[3996] | 0;
    HEAP8[$71 + $75 >> 0] = HEAP8[$71 + $storemerge213$us >> 0] | 0;
    $77 = (HEAP32[4154] | 0) + 1 | 0;
    HEAP32[4154] = $77;
    $79 = (HEAP32[4252] | 0) + 1 | 0;
    HEAP32[4252] = $79;
    if (($79 | 0) < ($46 | 0)) {
     $75 = $77;
     $storemerge213$us = $79;
    } else break;
   }
  }
  $69 = $46 + 2 + ~$62 | 0;
  HEAP32[4153] = $69;
  if (($69 | 0) > 79) $46 = $69; else {
   label = 19;
   break;
  }
 }
 if ((label | 0) == 19) return;
}

function _znamescanforand($poplitvar) {
 $poplitvar = $poplitvar | 0;
 var $$be = 0, $$be17 = 0, $$be18 = 0, $$pr = 0, $$pr10 = 0, $$pr3 = 0, $$pre = 0, $0 = 0, $10 = 0, $11 = 0, $14 = 0, $21 = 0, $28 = 0, $29 = 0, $3 = 0, $34 = 0, $35 = 0, $39 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $7 = 0, $9 = 0, $storemerge = 0, $storemerge$in = 0, $storemerge6 = 0, label = 0;
 HEAP32[4330] = 0;
 HEAP32[4331] = 0;
 HEAP32[4332] = 0;
 $$pre = HEAP32[4251] | 0;
 $0 = HEAP32[4333] | 0;
 if (($$pre | 0) < ($0 | 0)) {
  $11 = 0;
  $14 = $0;
  $7 = $$pre;
 } else {
  _zcheckbracelevel($poplitvar);
  return;
 }
 while (1) {
  $5 = HEAP32[3995] | 0;
  $9 = HEAPU8[$5 + $7 >> 0] | 0;
  L5 : do switch ($9 | 0) {
  case 65:
  case 97:
   {
    $10 = $7 + 1 | 0;
    HEAP32[4251] = $10;
    L11 : do if (($11 | 0) != 0 & ($7 | 0) < ($14 + -3 | 0)) {
     switch (HEAP8[$5 + $10 >> 0] | 0) {
     case 78:
     case 110:
      break;
     default:
      {
       $$pr10 = 0;
       $45 = $10;
       break L11;
      }
     }
     switch (HEAP8[$5 + ($7 + 2) >> 0] | 0) {
     case 68:
     case 100:
      break;
     default:
      {
       $$pr10 = 0;
       $45 = $10;
       break L11;
      }
     }
     $21 = $7 + 3 | 0;
     if ((HEAP8[25877 + (HEAPU8[$5 + $21 >> 0] | 0) >> 0] | 0) == 1) {
      HEAP32[4251] = $21;
      HEAP32[4332] = 1;
      $$pr10 = 1;
      $45 = $21;
     } else {
      $$pr10 = 0;
      $45 = $10;
     }
    } else {
     $$pr10 = 0;
     $45 = $10;
    } while (0);
    HEAP32[4331] = 0;
    $$pr = $$pr10;
    $44 = $45;
    label = 2;
    break;
   }
  case 123:
   {
    $28 = HEAP32[4330] | 0;
    $29 = $28 + 1 | 0;
    HEAP32[4330] = $29;
    $storemerge6 = $7 + 1 | 0;
    HEAP32[4251] = $storemerge6;
    L18 : do if (($28 | 0) > -1 & ($storemerge6 | 0) < ($14 | 0)) {
     $$pr3 = $29;
     $storemerge$in = $storemerge6;
     while (1) {
      switch (HEAP8[$5 + $storemerge$in >> 0] | 0) {
      case 125:
       {
        $34 = $$pr3 + -1 | 0;
        HEAP32[4330] = $34;
        $$be = $34;
        break;
       }
      case 123:
       {
        $35 = $$pr3 + 1 | 0;
        HEAP32[4330] = $35;
        $$be = $35;
        break;
       }
      default:
       $$be = $$pr3;
      }
      $storemerge = $storemerge$in + 1 | 0;
      HEAP32[4251] = $storemerge;
      if (($$be | 0) > 0 & ($storemerge | 0) < ($14 | 0)) {
       $$pr3 = $$be;
       $storemerge$in = $storemerge;
      } else {
       $46 = $storemerge;
       break L18;
      }
     }
    } else $46 = $storemerge6; while (0);
    HEAP32[4331] = 0;
    $$be17 = 0;
    $$be18 = $46;
    break;
   }
  case 125:
   {
    _zdecrbracelevel($poplitvar);
    $39 = (HEAP32[4251] | 0) + 1 | 0;
    HEAP32[4251] = $39;
    HEAP32[4331] = 0;
    $$pr = HEAP32[4332] | 0;
    $44 = $39;
    label = 2;
    break;
   }
  default:
   {
    $42 = (HEAP8[25877 + $9 >> 0] | 0) == 1;
    $43 = $7 + 1 | 0;
    HEAP32[4251] = $43;
    if ($42) {
     HEAP32[4331] = 1;
     $$be17 = 1;
     $$be18 = $43;
     break L5;
    } else {
     HEAP32[4331] = 0;
     $$be17 = 0;
     $$be18 = $43;
     break L5;
    }
   }
  } while (0);
  if ((label | 0) == 2) {
   label = 0;
   if (!$$pr) {
    $$be17 = 0;
    $$be18 = $44;
   } else {
    label = 21;
    break;
   }
  }
  $3 = HEAP32[4333] | 0;
  if (($$be18 | 0) < ($3 | 0)) {
   $11 = $$be17;
   $14 = $3;
   $7 = $$be18;
  } else {
   label = 21;
   break;
  }
 }
 if ((label | 0) == 21) {
  _zcheckbracelevel($poplitvar);
  return;
 }
}

function _kpathsea_brace_expand($kpse, $path) {
 $kpse = $kpse | 0;
 $path = $path | 0;
 var $$0$i1 = 0, $0 = 0, $1 = 0, $12 = 0, $14 = 0, $15 = 0, $2 = 0, $24 = 0, $29 = 0, $4 = 0, $5 = 0, $6 = 0, $8 = 0, $elt$03 = 0, $elt$05$i = 0, $ret$0$lcssa = 0, $ret$0$lcssa$i = 0, $ret$02 = 0, $ret$06$i = 0, $ret$1$ph$i = 0, $ret$13$i = 0, $vararg_buffer = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = _kpathsea_var_expand($kpse, $path) | 0;
 $1 = _xmalloc(1) | 0;
 HEAP8[$1 >> 0] = 0;
 $2 = _kpathsea_path_element($kpse, $0) | 0;
 if (!$2) $ret$0$lcssa = $1; else {
  $elt$03 = $2;
  $ret$02 = $1;
  while (1) {
   $4 = _kpathsea_brace_expand_element($kpse, $elt$03) | 0;
   $5 = _concat3($ret$02, $4, 10587) | 0;
   _free($4);
   _free($ret$02);
   $6 = _kpathsea_path_element($kpse, 0) | 0;
   if (!$6) {
    $ret$0$lcssa = $5;
    break;
   } else {
    $elt$03 = $6;
    $ret$02 = $5;
   }
  }
 }
 $8 = _strlen($ret$0$lcssa) | 0;
 if ($8 | 0) HEAP8[$ret$0$lcssa + ($8 + -1) >> 0] = 0;
 _free($0);
 $12 = _getenv(10589) | 0;
 if (!$12) {
  $$0$i1 = $ret$0$lcssa;
  STACKTOP = sp;
  return $$0$i1 | 0;
 }
 $14 = _xmalloc(1) | 0;
 HEAP8[$14 >> 0] = 0;
 $15 = _kpathsea_path_element($kpse, $ret$0$lcssa) | 0;
 if (!$15) $ret$0$lcssa$i = $14; else {
  $elt$05$i = $15;
  $ret$06$i = $14;
  while (1) {
   L14 : do if (!(_kpathsea_absolute_p($kpse, $elt$05$i, 0) | 0)) {
    L16 : do switch (HEAP8[$elt$05$i >> 0] | 0) {
    case 0:
     {
      $ret$13$i = $ret$06$i;
      break L14;
      break;
     }
    case 33:
     {
      if ((HEAP8[$elt$05$i + 1 >> 0] | 0) == 33) {
       label = 10;
       break L14;
      }
      break;
     }
    case 46:
     {
      $24 = $elt$05$i + 1 | 0;
      switch (HEAP8[$24 >> 0] | 0) {
      case 0:
       {
        $ret$1$ph$i = _concat3($ret$06$i, $12, 10587) | 0;
        label = 15;
        break L14;
        break;
       }
      case 47:
       {
        HEAP32[$vararg_buffer >> 2] = $12;
        HEAP32[$vararg_buffer + 4 >> 2] = $24;
        HEAP32[$vararg_buffer + 8 >> 2] = 10587;
        HEAP32[$vararg_buffer + 12 >> 2] = 0;
        $ret$1$ph$i = _concatn($ret$06$i, $vararg_buffer) | 0;
        label = 15;
        break L14;
        break;
       }
      default:
       break L16;
      }
      break;
     }
    default:
     {}
    } while (0);
    HEAP32[$vararg_buffer4 >> 2] = $12;
    HEAP32[$vararg_buffer4 + 4 >> 2] = 13340;
    HEAP32[$vararg_buffer4 + 8 >> 2] = $elt$05$i;
    HEAP32[$vararg_buffer4 + 12 >> 2] = 10587;
    HEAP32[$vararg_buffer4 + 16 >> 2] = 0;
    $ret$1$ph$i = _concatn($ret$06$i, $vararg_buffer4) | 0;
    label = 15;
   } else label = 10; while (0);
   if ((label | 0) == 10) {
    label = 0;
    $ret$1$ph$i = _concat3($ret$06$i, $elt$05$i, 10587) | 0;
    label = 15;
   }
   if ((label | 0) == 15) {
    label = 0;
    _free($ret$06$i);
    $ret$13$i = $ret$1$ph$i;
   }
   $29 = _kpathsea_path_element($kpse, 0) | 0;
   if (!$29) {
    $ret$0$lcssa$i = $ret$13$i;
    break;
   } else {
    $elt$05$i = $29;
    $ret$06$i = $ret$13$i;
   }
  }
 }
 HEAP8[$ret$0$lcssa$i + ((_strlen($ret$0$lcssa$i) | 0) + -1) >> 0] = 0;
 if (($ret$0$lcssa$i | 0) == ($ret$0$lcssa | 0)) {
  $$0$i1 = $ret$0$lcssa;
  STACKTOP = sp;
  return $$0$i1 | 0;
 }
 _free($ret$0$lcssa);
 $$0$i1 = $ret$0$lcssa$i;
 STACKTOP = sp;
 return $$0$i1 | 0;
}

function _kpathsea_var_expand($kpse, $src) {
 $kpse = $kpse | 0;
 $src = $src | 0;
 var $0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $17 = 0, $18 = 0, $2 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $33 = 0, $4 = 0, $8 = 0, $9 = 0, $expansion = 0, $s$0 = 0, $s$2 = 0, $var_end$0$lcssa = 0, $var_end$06 = 0, $var_end$06$phi = 0, $var_end1$0 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $expansion = sp + 28 | 0;
 $0 = sp + 16 | 0;
 _fn_init($0);
 HEAP32[$expansion >> 2] = HEAP32[$0 >> 2];
 HEAP32[$expansion + 4 >> 2] = HEAP32[$0 + 4 >> 2];
 HEAP32[$expansion + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 $1 = HEAP32[21] | 0;
 $s$0 = $src;
 L1 : while (1) {
  $2 = HEAP8[$s$0 >> 0] | 0;
  L3 : do switch ($2 << 24 >> 24) {
  case 0:
   {
    break L1;
    break;
   }
  case 36:
   {
    $3 = $s$0 + 1 | 0;
    $4 = HEAP8[$3 >> 0] | 0;
    if ($4 << 24 >> 24 > -1) {
     if (!(_isalnum($4 & 255) | 0)) {
      $8 = HEAP8[$3 >> 0] | 0;
      label = 6;
     }
    } else {
     $8 = $4;
     label = 6;
    }
    L9 : do if ((label | 0) == 6) {
     label = 0;
     switch ($8 << 24 >> 24) {
     case 95:
      {
       break L9;
       break;
      }
     case 123:
      break;
     default:
      {
       _fwrite(12399, 9, 1, $1) | 0;
       $33 = HEAP8[$3 >> 0] | 0;
       HEAP32[$vararg_buffer1 >> 2] = $src;
       HEAP32[$vararg_buffer1 + 4 >> 2] = $33;
       _fprintf($1, 12499, $vararg_buffer1) | 0;
       _fwrite(12726, 2, 1, $1) | 0;
       _fflush($1) | 0;
       _fn_grow($expansion, $s$0, 2);
       $s$2 = $3;
       break L3;
      }
     }
     $25 = $s$0 + 2 | 0;
     $var_end1$0 = $25;
     while (1) {
      $26 = HEAP8[$var_end1$0 >> 0] | 0;
      $27 = $26 << 24 >> 24 == 0;
      if ($26 << 24 >> 24 != 125 & ($27 ^ 1)) $var_end1$0 = $var_end1$0 + 1 | 0; else break;
     }
     if ($27) {
      _fwrite(12399, 9, 1, $1) | 0;
      HEAP32[$vararg_buffer >> 2] = $src;
      _fprintf($1, 12464, $vararg_buffer) | 0;
      _fwrite(12726, 2, 1, $1) | 0;
      _fflush($1) | 0;
      $s$2 = $var_end1$0 + -1 | 0;
      break L3;
     } else {
      _expand($kpse, $expansion, $25, $var_end1$0 + -1 | 0) | 0;
      $s$2 = $var_end1$0;
      break L3;
     }
    } while (0);
    $9 = $s$0 + 2 | 0;
    $10 = HEAP8[$9 >> 0] | 0;
    L21 : do if ($10 << 24 >> 24 > -1) {
     $12 = $10;
     $15 = $9;
     $var_end$06 = $3;
     while (1) {
      if (!(_isalnum($12 & 255) | 0)) if ((HEAP8[$15 >> 0] | 0) != 95) {
       $var_end$0$lcssa = $var_end$06;
       break L21;
      }
      $17 = $15 + 1 | 0;
      $18 = HEAP8[$17 >> 0] | 0;
      if ($18 << 24 >> 24 > -1) {
       $var_end$06$phi = $15;
       $12 = $18;
       $15 = $17;
       $var_end$06 = $var_end$06$phi;
      } else {
       $var_end$0$lcssa = $15;
       break;
      }
     }
    } else $var_end$0$lcssa = $3; while (0);
    if (!(_expand($kpse, $expansion, $3, $var_end$0$lcssa) | 0)) {
     _fn_grow($expansion, $s$0, 2 - $3 + $var_end$0$lcssa | 0);
     $s$2 = $var_end$0$lcssa;
    } else $s$2 = $var_end$0$lcssa;
    break;
   }
  default:
   {
    _fn_1grow($expansion, $2);
    $s$2 = $s$0;
   }
  } while (0);
  $s$0 = $s$2 + 1 | 0;
 }
 _fn_1grow($expansion, 0);
 STACKTOP = sp;
 return HEAP32[$expansion >> 2] | 0;
}

function _open_input($f_ptr, $filefmt, $fopen_mode) {
 $f_ptr = $f_ptr | 0;
 $filefmt = $filefmt | 0;
 $fopen_mode = $fopen_mode | 0;
 var $$lcssa = 0, $0 = 0, $11 = 0, $12 = 0, $15 = 0, $17 = 0, $24 = 0, $32 = 0, $40 = 0, $48 = 0, $50 = 0, $51 = 0, $52 = 0, $55 = 0, $57 = 0, $59 = 0, $61 = 0, $65 = 0, $66 = 0, $76 = 0, $77 = 0, $78 = 0, $i$02 = 0;
 HEAP32[$f_ptr >> 2] = 0;
 $0 = HEAP32[4701] | 0;
 if ($0 | 0) _free($0);
 HEAP32[4701] = 0;
 do if (HEAP32[4700] | 0) if (!(_kpse_absolute_p((HEAP32[4048] | 0) + 1 | 0, 0) | 0)) {
  $11 = _concat3(HEAP32[4700] | 0, 13340, (HEAP32[4048] | 0) + 1 | 0) | 0;
  $12 = _kpse_fopen_trace($11, $fopen_mode) | 0;
  HEAP32[$f_ptr >> 2] = $12;
  if (!$12) {
   _free($11);
   break;
  } else {
   _free(HEAP32[4048] | 0);
   $15 = _strlen($11) | 0;
   HEAP32[4049] = $15;
   $17 = _xmalloc($15 + 2 | 0) | 0;
   HEAP32[4048] = $17;
   _strcpy($17 + 1 | 0, $11) | 0;
   HEAP32[4701] = $11;
   break;
  }
 } while (0);
 if (!(HEAP32[$f_ptr >> 2] | 0)) {
  do if (($filefmt | 0) < 0) {
   $24 = _kpse_fopen_trace((HEAP32[4048] | 0) + 1 | 0, $fopen_mode) | 0;
   HEAP32[$f_ptr >> 2] = $24;
   $66 = $24;
  } else {
   $32 = _kpse_find_file((HEAP32[4048] | 0) + 1 | 0, $filefmt, ($filefmt | 0) != 33 & (($filefmt | 0) != 26 | (HEAP32[4702] | 0) != 0) & 1) | 0;
   if (!$32) {
    $66 = HEAP32[$f_ptr >> 2] | 0;
    break;
   }
   HEAP32[4701] = _xstrdup($32) | 0;
   do if ((HEAP8[$32 >> 0] | 0) == 46) if ((HEAP8[$32 + 1 >> 0] | 0) == 47) {
    $40 = HEAP32[4048] | 0;
    if ((HEAP8[$40 + 1 >> 0] | 0) == 46) if ((HEAP8[$40 + 2 >> 0] | 0) == 47) break;
    $48 = HEAP8[$32 + 2 >> 0] | 0;
    if (!($48 << 24 >> 24)) $$lcssa = $32; else {
     $50 = $48;
     $51 = $32;
     $i$02 = 0;
     while (1) {
      HEAP8[$51 >> 0] = $50;
      $52 = $i$02 + 1 | 0;
      $55 = HEAP8[$32 + ($i$02 + 3) >> 0] | 0;
      $57 = $32 + $52 | 0;
      if (!($55 << 24 >> 24)) {
       $$lcssa = $57;
       break;
      } else {
       $50 = $55;
       $51 = $57;
       $i$02 = $52;
      }
     }
    }
    HEAP8[$$lcssa >> 0] = 0;
   } while (0);
   _free(HEAP32[4048] | 0);
   $59 = _strlen($32) | 0;
   HEAP32[4049] = $59;
   $61 = _xmalloc($59 + 2 | 0) | 0;
   HEAP32[4048] = $61;
   _strcpy($61 + 1 | 0, $32) | 0;
   _free($32);
   $65 = _xfopen((HEAP32[4048] | 0) + 1 | 0, $fopen_mode) | 0;
   HEAP32[$f_ptr >> 2] = $65;
   $66 = $65;
  } while (0);
  if (!$66) {
   $76 = HEAP32[$f_ptr >> 2] | 0;
   $77 = ($76 | 0) != 0;
   $78 = $77 & 1;
   return $78 | 0;
  }
 }
 _recorder_record_name(6114, (HEAP32[4048] | 0) + 1 | 0);
 switch ($filefmt | 0) {
 case 3:
  {
   HEAP32[4703] = _getc(HEAP32[$f_ptr >> 2] | 0) | 0;
   $76 = HEAP32[$f_ptr >> 2] | 0;
   $77 = ($76 | 0) != 0;
   $78 = $77 & 1;
   return $78 | 0;
  }
 case 19:
  {
   HEAP32[4704] = _getc(HEAP32[$f_ptr >> 2] | 0) | 0;
   $76 = HEAP32[$f_ptr >> 2] | 0;
   $77 = ($76 | 0) != 0;
   $78 = $77 & 1;
   return $78 | 0;
  }
 case 20:
  {
   HEAP32[4703] = _getc(HEAP32[$f_ptr >> 2] | 0) | 0;
   $76 = HEAP32[$f_ptr >> 2] | 0;
   $77 = ($76 | 0) != 0;
   $78 = $77 & 1;
   return $78 | 0;
  }
 default:
  {
   $76 = HEAP32[$f_ptr >> 2] | 0;
   $77 = ($76 | 0) != 0;
   $78 = $77 & 1;
   return $78 | 0;
  }
 }
 return 0;
}

function ___stpncpy($d, $s, $n) {
 $d = $d | 0;
 $s = $s | 0;
 $n = $n | 0;
 var $$0$lcssa = 0, $$0$lcssa42 = 0, $$031 = 0, $$04$lcssa = 0, $$04$lcssa43 = 0, $$0430 = 0, $$06$lcssa = 0, $$06$lcssa44 = 0, $$0629 = 0, $$1$lcssa = 0, $$117 = 0, $$15$ph = 0, $$1511 = 0, $$17$ph = 0, $$1710 = 0, $$2$ph = 0, $$212 = 0, $$28 = 0, $$3 = 0, $$lcssa = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $16 = 0, $20 = 0, $26 = 0, $27 = 0, $28 = 0, $31 = 0, $33 = 0, $35 = 0, $7 = 0, $8 = 0, $wd$0$lcssa = 0, $wd$018 = 0, $ws$0$lcssa = 0, $ws$019 = 0, label = 0;
 $0 = $s;
 do if (!(($0 ^ $d) & 3)) {
  $7 = ($n | 0) != 0;
  L3 : do if ($7 & ($0 & 3 | 0) != 0) {
   $$031 = $n;
   $$0430 = $s;
   $$0629 = $d;
   while (1) {
    $8 = HEAP8[$$0430 >> 0] | 0;
    HEAP8[$$0629 >> 0] = $8;
    if (!($8 << 24 >> 24)) {
     $$0$lcssa42 = $$031;
     $$04$lcssa43 = $$0430;
     $$06$lcssa44 = $$0629;
     break L3;
    }
    $10 = $$031 + -1 | 0;
    $11 = $$0430 + 1 | 0;
    $12 = $$0629 + 1 | 0;
    $16 = ($10 | 0) != 0;
    if ($16 & ($11 & 3 | 0) != 0) {
     $$031 = $10;
     $$0430 = $11;
     $$0629 = $12;
    } else {
     $$0$lcssa = $10;
     $$04$lcssa = $11;
     $$06$lcssa = $12;
     $$lcssa = $16;
     label = 5;
     break;
    }
   }
  } else {
   $$0$lcssa = $n;
   $$04$lcssa = $s;
   $$06$lcssa = $d;
   $$lcssa = $7;
   label = 5;
  } while (0);
  if ((label | 0) == 5) if ($$lcssa) {
   $$0$lcssa42 = $$0$lcssa;
   $$04$lcssa43 = $$04$lcssa;
   $$06$lcssa44 = $$06$lcssa;
  } else {
   $$28 = $$06$lcssa;
   $$3 = 0;
   break;
  }
  if (!(HEAP8[$$04$lcssa43 >> 0] | 0)) {
   $$28 = $$06$lcssa44;
   $$3 = $$0$lcssa42;
  } else {
   L11 : do if ($$0$lcssa42 >>> 0 > 3) {
    $$117 = $$0$lcssa42;
    $wd$018 = $$06$lcssa44;
    $ws$019 = $$04$lcssa43;
    while (1) {
     $20 = HEAP32[$ws$019 >> 2] | 0;
     if (($20 & -2139062144 ^ -2139062144) & $20 + -16843009 | 0) {
      $$1$lcssa = $$117;
      $wd$0$lcssa = $wd$018;
      $ws$0$lcssa = $ws$019;
      break L11;
     }
     HEAP32[$wd$018 >> 2] = $20;
     $26 = $$117 + -4 | 0;
     $27 = $ws$019 + 4 | 0;
     $28 = $wd$018 + 4 | 0;
     if ($26 >>> 0 > 3) {
      $$117 = $26;
      $wd$018 = $28;
      $ws$019 = $27;
     } else {
      $$1$lcssa = $26;
      $wd$0$lcssa = $28;
      $ws$0$lcssa = $27;
      break;
     }
    }
   } else {
    $$1$lcssa = $$0$lcssa42;
    $wd$0$lcssa = $$06$lcssa44;
    $ws$0$lcssa = $$04$lcssa43;
   } while (0);
   $$15$ph = $ws$0$lcssa;
   $$17$ph = $wd$0$lcssa;
   $$2$ph = $$1$lcssa;
   label = 11;
  }
 } else {
  $$15$ph = $s;
  $$17$ph = $d;
  $$2$ph = $n;
  label = 11;
 } while (0);
 L16 : do if ((label | 0) == 11) if (!$$2$ph) {
  $$28 = $$17$ph;
  $$3 = 0;
 } else {
  $$1511 = $$15$ph;
  $$1710 = $$17$ph;
  $$212 = $$2$ph;
  while (1) {
   $31 = HEAP8[$$1511 >> 0] | 0;
   HEAP8[$$1710 >> 0] = $31;
   if (!($31 << 24 >> 24)) {
    $$28 = $$1710;
    $$3 = $$212;
    break L16;
   }
   $33 = $$212 + -1 | 0;
   $35 = $$1710 + 1 | 0;
   if (!$33) {
    $$28 = $35;
    $$3 = 0;
    break;
   } else {
    $$1511 = $$1511 + 1 | 0;
    $$1710 = $35;
    $$212 = $33;
   }
  }
 } while (0);
 _memset($$28 | 0, 0, $$3 | 0) | 0;
 return $$28 | 0;
}

function _traceandstatprinting() {
 var $0 = 0, $1 = 0, $11 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $84 = 0, $85 = 0, $92 = 0, $95 = 0, $97 = 0, $storemerge1 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer2 = 0, $vararg_buffer20 = 0, $vararg_buffer25 = 0, $vararg_buffer5 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $vararg_buffer25 = sp + 80 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer13 = sp + 40 | 0;
 $vararg_buffer8 = sp + 24 | 0;
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[3989] | 0;
 $1 = HEAP32[4157] | 0;
 HEAP32[$vararg_buffer >> 2] = 2672;
 HEAP32[$vararg_buffer + 4 >> 2] = $1;
 _fprintf($0, 1132, $vararg_buffer) | 0;
 $4 = HEAP32[3989] | 0;
 if ((HEAP32[4157] | 0) == 1) {
  HEAP32[$vararg_buffer2 >> 2] = 2685;
  _fprintf($4, 960, $vararg_buffer2) | 0;
 } else {
  HEAP32[$vararg_buffer5 >> 2] = 2693;
  _fprintf($4, 960, $vararg_buffer5) | 0;
 }
 $5 = HEAP32[3989] | 0;
 $6 = HEAP32[4158] | 0;
 HEAP32[$vararg_buffer8 >> 2] = 2712;
 HEAP32[$vararg_buffer8 + 4 >> 2] = $6;
 HEAP32[$vararg_buffer8 + 8 >> 2] = 2725;
 _fprintf($5, 2703, $vararg_buffer8) | 0;
 $7 = HEAP32[3989] | 0;
 $8 = HEAP32[4e3] | 0;
 $11 = HEAP32[(HEAP32[4041] | 0) + ($8 << 2) >> 2] | 0;
 HEAP32[$vararg_buffer13 >> 2] = 2712;
 HEAP32[$vararg_buffer13 + 4 >> 2] = $8;
 HEAP32[$vararg_buffer13 + 8 >> 2] = 2772;
 HEAP32[$vararg_buffer13 + 12 >> 2] = $11;
 HEAP32[$vararg_buffer13 + 16 >> 2] = 2787;
 _fprintf($7, 2758, $vararg_buffer13) | 0;
 $84 = (HEAP32[4197] | 0) + ((HEAP32[4196] | 0) + ((HEAP32[4195] | 0) + ((HEAP32[4194] | 0) + ((HEAP32[4193] | 0) + ((HEAP32[4192] | 0) + ((HEAP32[4191] | 0) + ((HEAP32[4190] | 0) + ((HEAP32[4189] | 0) + ((HEAP32[4188] | 0) + ((HEAP32[4187] | 0) + ((HEAP32[4186] | 0) + ((HEAP32[4185] | 0) + ((HEAP32[4184] | 0) + ((HEAP32[4183] | 0) + ((HEAP32[4182] | 0) + ((HEAP32[4181] | 0) + ((HEAP32[4180] | 0) + ((HEAP32[4179] | 0) + ((HEAP32[4178] | 0) + ((HEAP32[4177] | 0) + ((HEAP32[4176] | 0) + ((HEAP32[4175] | 0) + ((HEAP32[4174] | 0) + ((HEAP32[4173] | 0) + ((HEAP32[4172] | 0) + ((HEAP32[4171] | 0) + ((HEAP32[4170] | 0) + ((HEAP32[4169] | 0) + ((HEAP32[4168] | 0) + ((HEAP32[4167] | 0) + ((HEAP32[4166] | 0) + ((HEAP32[4165] | 0) + ((HEAP32[4164] | 0) + ((HEAP32[4163] | 0) + ((HEAP32[4162] | 0) + (HEAP32[4161] | 0)))))))))))))))))))))))))))))))))))) | 0;
 HEAP32[4160] = $84;
 HEAP32[4159] = 37;
 $85 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer20 >> 2] = 2800;
 HEAP32[$vararg_buffer20 + 4 >> 2] = $84;
 HEAP32[$vararg_buffer20 + 8 >> 2] = 2840;
 _fprintf($85, 2703, $vararg_buffer20) | 0;
 HEAP32[4159] = 0;
 $storemerge1 = 0;
 while (1) {
  _zoutpoolstr(HEAP32[3989] | 0, HEAP32[(HEAP32[4145] | 0) + (HEAP32[16796 + ($storemerge1 << 2) >> 2] << 2) >> 2] | 0);
  $92 = HEAP32[3989] | 0;
  $95 = HEAP32[16644 + (HEAP32[4159] << 2) >> 2] | 0;
  HEAP32[$vararg_buffer25 >> 2] = 2861;
  HEAP32[$vararg_buffer25 + 4 >> 2] = $95;
  _fprintf($92, 2854, $vararg_buffer25) | 0;
  $97 = (HEAP32[4159] | 0) + 1 | 0;
  HEAP32[4159] = $97;
  if (($97 | 0) < 37) $storemerge1 = $97; else break;
 }
 STACKTOP = sp;
 return;
}

function _xtextlength() {
 var $$pre = 0, $0 = 0, $11 = 0, $13 = 0, $14 = 0, $17 = 0, $18 = 0, $26 = 0, $28 = 0, $29 = 0, $30 = 0, $32 = 0, $35 = 0, $36 = 0, $38 = 0, $39 = 0, $40 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $8 = 0, $storemerge = 0, $storemerge1 = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   HEAP32[4346] = 0;
   $5 = HEAP32[4345] | 0;
   $6 = HEAP32[4041] | 0;
   $8 = HEAP32[$6 + ($5 << 2) >> 2] | 0;
   HEAP32[4343] = $8;
   $11 = HEAP32[$6 + ($5 + 1 << 2) >> 2] | 0;
   HEAP32[4344] = $11;
   HEAP32[4342] = 0;
   L4 : do if (($8 | 0) < ($11 | 0)) {
    $$pre = HEAP32[4042] | 0;
    $14 = $8;
    $18 = 0;
    $36 = 0;
    while (1) {
     $13 = $14 + 1 | 0;
     HEAP32[4343] = $13;
     switch (HEAP8[$$pre + $14 >> 0] | 0) {
     case 123:
      {
       $17 = $18 + 1 | 0;
       HEAP32[4342] = $17;
       if (($18 | 0) == 0 & ($13 | 0) < ($11 | 0)) if ((HEAP8[$$pre + $13 >> 0] | 0) == 92) {
        $storemerge1 = $14 + 2 | 0;
        HEAP32[4343] = $storemerge1;
        L13 : do if (($storemerge1 | 0) < ($11 | 0)) {
         $26 = $storemerge1;
         $29 = $17;
         while (1) {
          switch (HEAP8[$$pre + $26 >> 0] | 0) {
          case 125:
           {
            $28 = $29 + -1 | 0;
            HEAP32[4342] = $28;
            $32 = $28;
            break;
           }
          case 123:
           {
            $30 = $29 + 1 | 0;
            HEAP32[4342] = $30;
            $32 = $30;
            break;
           }
          default:
           $32 = $29;
          }
          $storemerge = $26 + 1 | 0;
          HEAP32[4343] = $storemerge;
          if (($storemerge | 0) < ($11 | 0) & ($32 | 0) > 0) {
           $26 = $storemerge;
           $29 = $32;
          } else {
           $45 = $storemerge;
           $46 = $32;
           break L13;
          }
         }
        } else {
         $45 = $storemerge1;
         $46 = $17;
        } while (0);
        $35 = $36 + 1 | 0;
        HEAP32[4346] = $35;
        $40 = $45;
        $43 = $35;
        $44 = $46;
       } else {
        $40 = $13;
        $43 = $36;
        $44 = $17;
       } else {
        $40 = $13;
        $43 = $36;
        $44 = $17;
       }
       break;
      }
     case 125:
      {
       if (($18 | 0) > 0) {
        $38 = $18 + -1 | 0;
        HEAP32[4342] = $38;
        $40 = $13;
        $43 = $36;
        $44 = $38;
       } else {
        $40 = $13;
        $43 = $36;
        $44 = $18;
       }
       break;
      }
     default:
      {
       $39 = $36 + 1 | 0;
       HEAP32[4346] = $39;
       $40 = $13;
       $43 = $39;
       $44 = $18;
      }
     }
     if (($40 | 0) < ($11 | 0)) {
      $14 = $40;
      $18 = $44;
      $36 = $43;
     } else {
      $42 = $43;
      break L4;
     }
    }
   } else $42 = 0; while (0);
   _zpushlitstk($42, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 return;
}

function _match($filename, $path_elt) {
 $filename = $filename | 0;
 $path_elt = $path_elt | 0;
 var $$$2 = 0, $$020 = 0, $$020$lcssa83 = 0, $$0219 = 0, $$0219$lcssa84 = 0, $$11861 = 0, $$13 = 0, $$13$lcssa = 0, $$2$ph = 0, $$24$ph = 0, $$4 = 0, $$lcssa = 0, $$lcssa78 = 0, $$lcssa82 = 0, $$lcssa86 = 0, $$pre33 = 0, $0 = 0, $11 = 0, $13 = 0, $17 = 0, $19 = 0, $2 = 0, $21 = 0, $23 = 0, $24 = 0, $25 = 0, $29 = 0, $36 = 0, $37 = 0, $4 = 0, $matched$3 = 0, label = 0;
 $0 = HEAP8[$filename >> 0] | 0;
 L1 : do if (!($0 << 24 >> 24)) {
  $$2$ph = $filename;
  $$24$ph = $path_elt;
  $29 = 0;
 } else {
  $$020 = $filename;
  $$0219 = $path_elt;
  $4 = $0;
  while (1) {
   $2 = HEAP8[$$0219 >> 0] | 0;
   if (!($2 << 24 >> 24)) {
    $$2$ph = $$020;
    $$24$ph = $$0219;
    $29 = $4;
    break L1;
   }
   if ($4 << 24 >> 24 != $2 << 24 >> 24) {
    $$020$lcssa83 = $$020;
    $$0219$lcssa84 = $$0219;
    $$lcssa82 = $4;
    $$lcssa86 = $2;
    break;
   }
   $23 = $$020 + 1 | 0;
   $24 = $$0219 + 1 | 0;
   $25 = HEAP8[$23 >> 0] | 0;
   if (!($25 << 24 >> 24)) {
    $$2$ph = $23;
    $$24$ph = $24;
    $29 = 0;
    break L1;
   } else {
    $$020 = $23;
    $$0219 = $24;
    $4 = $25;
   }
  }
  if ($$020$lcssa83 >>> 0 > $filename >>> 0 & $$lcssa86 << 24 >> 24 == 47) if ((HEAP8[$$0219$lcssa84 + -1 >> 0] | 0) == 47) {
   $$13 = $$0219$lcssa84;
   $11 = 47;
   L8 : while (1) {
    switch ($11 << 24 >> 24) {
    case 0:
     {
      $matched$3 = 1;
      label = 18;
      break L8;
      break;
     }
    case 47:
     break;
    default:
     {
      $$13$lcssa = $$13;
      $$lcssa78 = $11;
      break L8;
     }
    }
    $13 = $$13 + 1 | 0;
    $$13 = $13;
    $11 = HEAP8[$13 >> 0] | 0;
   }
   if ((label | 0) == 18) return $matched$3 | 0;
   if (!($$lcssa82 << 24 >> 24)) {
    $$2$ph = $$020$lcssa83;
    $$24$ph = $$13$lcssa;
    $29 = 0;
   } else {
    $$11861 = $$020$lcssa83;
    $17 = $$lcssa82;
    while (1) {
     if ((HEAP8[$$11861 + -1 >> 0] | 0) == 47 ? $17 << 24 >> 24 == $$lcssa78 << 24 >> 24 : 0) {
      $19 = _match($$11861, $$13$lcssa) | 0;
      if ($19 | 0) {
       $matched$3 = $19;
       break;
      }
     }
     $21 = $$11861 + 1 | 0;
     $$pre33 = HEAP8[$21 >> 0] | 0;
     if (!($$pre33 << 24 >> 24)) {
      $$2$ph = $21;
      $$24$ph = $$13$lcssa;
      $29 = 0;
      break L1;
     } else {
      $$11861 = $21;
      $17 = $$pre33;
     }
    }
    return $matched$3 | 0;
   }
  } else {
   $$2$ph = $$020$lcssa83;
   $$24$ph = $$0219$lcssa84;
   $29 = $$lcssa82;
  } else {
   $$2$ph = $$020$lcssa83;
   $$24$ph = $$0219$lcssa84;
   $29 = $$lcssa82;
  }
 } while (0);
 if (HEAP8[$$24$ph >> 0] | 0) {
  $matched$3 = 0;
  return $matched$3 | 0;
 }
 $$$2 = $29 << 24 >> 24 == 47 ? $$2$ph + 1 | 0 : $$2$ph;
 if (($$$2 | 0) == ($filename | 0)) $$4 = $$$2; else if ((HEAP8[$$$2 + -1 >> 0] | 0) == 47) $$4 = $$$2; else {
  $matched$3 = 0;
  return $matched$3 | 0;
 }
 while (1) {
  $36 = HEAP8[$$4 >> 0] | 0;
  $37 = $36 << 24 >> 24 == 0;
  if ($36 << 24 >> 24 != 47 & ($37 ^ 1)) $$4 = $$4 + 1 | 0; else {
   $$lcssa = $37;
   break;
  }
 }
 $matched$3 = $$lcssa & 1;
 return $matched$3 | 0;
}

function _printbadinputline() {
 var $$lcssa = 0, $29 = 0, $36 = 0, $46 = 0, $47 = 0, $52 = 0, $7 = 0, $74 = 0, $79 = 0, $81 = 0, $88 = 0, $91 = 0, $92 = 0, $bfptr$010 = 0, $bfptr$16 = 0, $bfptr$24 = 0, $bfptr$3$lcssa = 0, $bfptr$31 = 0, $storemerge$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(1170, 3, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1170, 3, 1, HEAP32[3990] | 0) | 0;
 if ((HEAP32[4045] | 0) > 0) {
  $bfptr$010 = 0;
  while (1) {
   $7 = HEAPU8[(HEAP32[3993] | 0) + $bfptr$010 >> 0] | 0;
   if ((HEAP8[25877 + $7 >> 0] | 0) == 1) {
    _putc(HEAPU8[26165] | 0, HEAP32[3989] | 0) | 0;
    _putc(HEAPU8[26165] | 0, HEAP32[3990] | 0) | 0;
   } else {
    _putc(HEAPU8[26133 + $7 >> 0] | 0, HEAP32[3989] | 0) | 0;
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $bfptr$010 >> 0] | 0) >> 0] | 0, HEAP32[3990] | 0) | 0;
   }
   $29 = $bfptr$010 + 1 | 0;
   if (($29 | 0) < (HEAP32[4045] | 0)) $bfptr$010 = $29; else break;
  }
 }
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _fwrite(1170, 3, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1170, 3, 1, HEAP32[3990] | 0) | 0;
 $36 = HEAP32[4045] | 0;
 if (($36 | 0) > 0) {
  $bfptr$16 = 0;
  while (1) {
   _putc(HEAPU8[26165] | 0, HEAP32[3989] | 0) | 0;
   _putc(HEAPU8[26165] | 0, HEAP32[3990] | 0) | 0;
   $46 = $bfptr$16 + 1 | 0;
   $47 = HEAP32[4045] | 0;
   if (($46 | 0) < ($47 | 0)) $bfptr$16 = $46; else {
    $$lcssa = $47;
    break;
   }
  }
 } else $$lcssa = $36;
 if (($$lcssa | 0) < (HEAP32[3999] | 0)) {
  $bfptr$24 = $$lcssa;
  while (1) {
   $52 = HEAPU8[(HEAP32[3993] | 0) + $bfptr$24 >> 0] | 0;
   if ((HEAP8[25877 + $52 >> 0] | 0) == 1) {
    _putc(HEAPU8[26165] | 0, HEAP32[3989] | 0) | 0;
    _putc(HEAPU8[26165] | 0, HEAP32[3990] | 0) | 0;
   } else {
    _putc(HEAPU8[26133 + $52 >> 0] | 0, HEAP32[3989] | 0) | 0;
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $bfptr$24 >> 0] | 0) >> 0] | 0, HEAP32[3990] | 0) | 0;
   }
   $74 = $bfptr$24 + 1 | 0;
   if (($74 | 0) < (HEAP32[3999] | 0)) $bfptr$24 = $74; else break;
  }
 }
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 $79 = HEAP32[4045] | 0;
 L21 : do if (($79 | 0) > 0) {
  $81 = HEAP32[3993] | 0;
  $bfptr$31 = 0;
  while (1) {
   if ((HEAP8[25877 + (HEAPU8[$81 + $bfptr$31 >> 0] | 0) >> 0] | 0) != 1) {
    $bfptr$3$lcssa = $bfptr$31;
    break L21;
   }
   $88 = $bfptr$31 + 1 | 0;
   if (($88 | 0) < ($79 | 0)) $bfptr$31 = $88; else {
    $bfptr$3$lcssa = $88;
    break;
   }
  }
 } else $bfptr$3$lcssa = 0; while (0);
 if (($bfptr$3$lcssa | 0) == ($79 | 0)) {
  $91 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer >> 2] = 1174;
  _fprintf($91, 960, $vararg_buffer) | 0;
  $92 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer1 >> 2] = 1174;
  _fprintf($92, 960, $vararg_buffer1) | 0;
 }
 if ((HEAPU8[25620] | 0) < 2) {
  HEAP8[25620] = 2;
  $storemerge$i = 1;
  HEAP32[3991] = $storemerge$i;
  STACKTOP = sp;
  return;
 } else {
  $storemerge$i = (HEAP32[3991] | 0) + 1 | 0;
  HEAP32[3991] = $storemerge$i;
  STACKTOP = sp;
  return;
 }
}

function _kpathsea_name_ok($kpse, $fname, $check_var, $default_choice, $action, $silent) {
 $kpse = $kpse | 0;
 $fname = $fname | 0;
 $check_var = $check_var | 0;
 $default_choice = $default_choice | 0;
 $action = $action | 0;
 $silent = $silent | 0;
 var $$0 = 0, $$pre$phiZ2D = 0, $0 = 0, $10 = 0, $17 = 0, $2 = 0, $21 = 0, $3 = 0, $36 = 0, $38 = 0, $44 = 0, $47 = 0, $5 = 0, $51 = 0, $default_choice$ = 0, $dotpair$011 = 0, $strlen = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer = sp;
 $0 = _kpathsea_var_value($kpse, $check_var) | 0;
 $default_choice$ = ($0 | 0) == 0 ? $default_choice : $0;
 $2 = HEAP8[$default_choice$ >> 0] | 0;
 switch ($2 << 24 >> 24) {
 case 49:
 case 121:
 case 97:
  {
   $$0 = 1;
   STACKTOP = sp;
   return $$0 | 0;
  }
 default:
  {}
 }
 $3 = _strchr($fname, 46) | 0;
 L4 : do if (!$3) label = 10; else {
  $5 = $3;
  while (1) {
   if (($5 | 0) == ($fname | 0)) label = 6; else if ((HEAP8[$5 + -1 >> 0] | 0) == 47) label = 6; else $$pre$phiZ2D = $5 + 1 | 0;
   L10 : do if ((label | 0) == 6) {
    label = 0;
    $10 = $5 + 1 | 0;
    switch (HEAP8[$10 >> 0] | 0) {
    case 47:
     {
      $$pre$phiZ2D = $10;
      break L10;
      break;
     }
    case 46:
     {
      if ((HEAP8[$5 + 2 >> 0] | 0) == 47) {
       $$pre$phiZ2D = $10;
       break L10;
      }
      break;
     }
    default:
     {}
    }
    if (!(_strcmp($5, 8184) | 0)) $$pre$phiZ2D = $10; else break L4;
   } while (0);
   $17 = _strchr($$pre$phiZ2D, 46) | 0;
   if (!$17) {
    label = 10;
    break;
   } else $5 = $17;
  }
 } while (0);
 L16 : do if ((label | 0) == 10) {
  switch ($2 << 24 >> 24) {
  case 48:
  case 110:
  case 114:
   {
    $$0 = 1;
    STACKTOP = sp;
    return $$0 | 0;
   }
  default:
   {}
  }
  if (_kpathsea_absolute_p($kpse, $fname, 0) | 0) {
   $21 = _kpathsea_var_value($kpse, 12171) | 0;
   if (!$21) break;
   if (!(HEAP8[$21 >> 0] | 0)) break;
   $strlen = _strlen($21) | 0;
   if (_strncmp($fname, $21, $strlen) | 0) break;
   if ((HEAP8[$fname + $strlen >> 0] | 0) != 47) break;
  }
  if ((HEAP8[$fname >> 0] | 0) == 46) if ((HEAP8[$fname + 1 >> 0] | 0) == 46) if ((HEAP8[$fname + 2 >> 0] | 0) == 47) break;
  $36 = _strstr($fname, 11235) | 0;
  if (!$36) {
   $$0 = 1;
   STACKTOP = sp;
   return $$0 | 0;
  } else $dotpair$011 = $36;
  while (1) {
   $38 = $dotpair$011 + 2 | 0;
   if ((HEAP8[$38 >> 0] | 0) == 47) if ((HEAP8[$dotpair$011 + -1 >> 0] | 0) == 47) break L16;
   $44 = _strstr($38, 11235) | 0;
   if (!$44) {
    $$0 = 1;
    break;
   } else $dotpair$011 = $44;
  }
  STACKTOP = sp;
  return $$0 | 0;
 } while (0);
 if ($silent | 0) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $47 = HEAP32[21] | 0;
 $51 = HEAP32[44 + ($action << 2) >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = HEAP32[$kpse + 104 >> 2];
 HEAP32[$vararg_buffer + 4 >> 2] = $51;
 HEAP32[$vararg_buffer + 8 >> 2] = $fname;
 HEAP32[$vararg_buffer + 12 >> 2] = $check_var;
 HEAP32[$vararg_buffer + 16 >> 2] = $default_choice$;
 _fprintf($47, 9970, $vararg_buffer) | 0;
 $$0 = 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _pop_arg($arg, $type, $ap) {
 $arg = $arg | 0;
 $type = $type | 0;
 $ap = $ap | 0;
 var $105 = 0, $106 = 0.0, $112 = 0, $113 = 0.0, $13 = 0, $14 = 0, $17 = 0, $26 = 0, $27 = 0, $28 = 0, $37 = 0, $38 = 0, $40 = 0, $43 = 0, $44 = 0, $53 = 0, $54 = 0, $56 = 0, $59 = 0, $6 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $79 = 0, $80 = 0, $82 = 0, $85 = 0, $94 = 0, $95 = 0, $96 = 0;
 L1 : do if ($type >>> 0 <= 20) do switch ($type | 0) {
 case 9:
  {
   $6 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $7 = HEAP32[$6 >> 2] | 0;
   HEAP32[$ap >> 2] = $6 + 4;
   HEAP32[$arg >> 2] = $7;
   break L1;
   break;
  }
 case 10:
  {
   $13 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $14 = HEAP32[$13 >> 2] | 0;
   HEAP32[$ap >> 2] = $13 + 4;
   $17 = $arg;
   HEAP32[$17 >> 2] = $14;
   HEAP32[$17 + 4 >> 2] = (($14 | 0) < 0) << 31 >> 31;
   break L1;
   break;
  }
 case 11:
  {
   $26 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $27 = HEAP32[$26 >> 2] | 0;
   HEAP32[$ap >> 2] = $26 + 4;
   $28 = $arg;
   HEAP32[$28 >> 2] = $27;
   HEAP32[$28 + 4 >> 2] = 0;
   break L1;
   break;
  }
 case 12:
  {
   $37 = (HEAP32[$ap >> 2] | 0) + (8 - 1) & ~(8 - 1);
   $38 = $37;
   $40 = HEAP32[$38 >> 2] | 0;
   $43 = HEAP32[$38 + 4 >> 2] | 0;
   HEAP32[$ap >> 2] = $37 + 8;
   $44 = $arg;
   HEAP32[$44 >> 2] = $40;
   HEAP32[$44 + 4 >> 2] = $43;
   break L1;
   break;
  }
 case 13:
  {
   $53 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $54 = HEAP32[$53 >> 2] | 0;
   HEAP32[$ap >> 2] = $53 + 4;
   $56 = ($54 & 65535) << 16 >> 16;
   $59 = $arg;
   HEAP32[$59 >> 2] = $56;
   HEAP32[$59 + 4 >> 2] = (($56 | 0) < 0) << 31 >> 31;
   break L1;
   break;
  }
 case 14:
  {
   $68 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $69 = HEAP32[$68 >> 2] | 0;
   HEAP32[$ap >> 2] = $68 + 4;
   $70 = $arg;
   HEAP32[$70 >> 2] = $69 & 65535;
   HEAP32[$70 + 4 >> 2] = 0;
   break L1;
   break;
  }
 case 15:
  {
   $79 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $80 = HEAP32[$79 >> 2] | 0;
   HEAP32[$ap >> 2] = $79 + 4;
   $82 = ($80 & 255) << 24 >> 24;
   $85 = $arg;
   HEAP32[$85 >> 2] = $82;
   HEAP32[$85 + 4 >> 2] = (($82 | 0) < 0) << 31 >> 31;
   break L1;
   break;
  }
 case 16:
  {
   $94 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $95 = HEAP32[$94 >> 2] | 0;
   HEAP32[$ap >> 2] = $94 + 4;
   $96 = $arg;
   HEAP32[$96 >> 2] = $95 & 255;
   HEAP32[$96 + 4 >> 2] = 0;
   break L1;
   break;
  }
 case 17:
  {
   $105 = (HEAP32[$ap >> 2] | 0) + (8 - 1) & ~(8 - 1);
   $106 = +HEAPF64[$105 >> 3];
   HEAP32[$ap >> 2] = $105 + 8;
   HEAPF64[$arg >> 3] = $106;
   break L1;
   break;
  }
 case 18:
  {
   $112 = (HEAP32[$ap >> 2] | 0) + (8 - 1) & ~(8 - 1);
   $113 = +HEAPF64[$112 >> 3];
   HEAP32[$ap >> 2] = $112 + 8;
   HEAPF64[$arg >> 3] = $113;
   break L1;
   break;
  }
 default:
  break L1;
 } while (0); while (0);
 return;
}

function _kpathsea_element_dirs($kpse, $elt) {
 $kpse = $kpse | 0;
 $elt = $elt | 0;
 var $$0 = 0, $$pre6 = 0, $11 = 0, $15 = 0, $16 = 0, $18 = 0, $2 = 0, $20 = 0, $24 = 0, $27 = 0, $29 = 0, $31 = 0, $35 = 0, $37 = 0, $38 = 0, $45 = 0, $5 = 0, $e$0 = 0, $e$03 = 0, $e$04 = 0, $i$0$i$lcssa = 0, $p$03$us$i = 0, $p$03$us$i$lcssa = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer5 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 if (!$elt) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 switch (HEAP8[$elt >> 0] | 0) {
 case 47:
  {
   $2 = 1;
   while (1) if ((HEAP8[$elt + $2 >> 0] | 0) == 47) $2 = $2 + 1 | 0; else {
    $i$0$i$lcssa = $2;
    break;
   }
   break;
  }
 case 0:
  {
   $$0 = 0;
   STACKTOP = sp;
   return $$0 | 0;
  }
 default:
  $i$0$i$lcssa = 0;
 }
 $5 = $elt + $i$0$i$lcssa | 0;
 if ($i$0$i$lcssa >>> 0 > 1) {
  if (HEAP32[$kpse + 44 >> 2] & 1 | 0) {
   $11 = HEAP32[21] | 0;
   _fwrite(13458, 7, 1, $11) | 0;
   HEAP32[$vararg_buffer >> 2] = $elt;
   HEAP32[$vararg_buffer + 4 >> 2] = 0;
   _fprintf($11, 13189, $vararg_buffer) | 0;
   _fflush($11) | 0;
  }
  _memmove($elt + 1 | 0, $5 | 0, (_strlen($5) | 0) + 1 | 0) | 0;
 }
 $15 = $kpse + 60 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $$pre6 = $kpse + 56 | 0;
 L15 : do if ($16 | 0) {
  $18 = HEAP32[$$pre6 >> 2] | 0;
  $p$03$us$i = 0;
  while (1) {
   $20 = HEAP32[$18 + ($p$03$us$i << 3) >> 2] | 0;
   if ($20 | 0) if (!(_strcmp($20, $elt) | 0)) {
    $p$03$us$i$lcssa = $p$03$us$i;
    break;
   }
   $24 = $p$03$us$i + 1 | 0;
   if ($24 >>> 0 < $16 >>> 0) $p$03$us$i = $24; else break L15;
  }
  $27 = HEAP32[$18 + ($p$03$us$i$lcssa << 3) + 4 >> 2] | 0;
  if ($27 | 0) {
   $$0 = $27;
   STACKTOP = sp;
   return $$0 | 0;
  }
 } while (0);
 $29 = _xmalloc(4) | 0;
 HEAP32[$29 >> 2] = 0;
 _expand_elt($kpse, $29, $elt, 0);
 $31 = (HEAP32[$15 >> 2] | 0) + 1 | 0;
 HEAP32[$15 >> 2] = $31;
 HEAP32[$$pre6 >> 2] = _xrealloc(HEAP32[$$pre6 >> 2] | 0, $31 << 3) | 0;
 $35 = _xstrdup($elt) | 0;
 $37 = (HEAP32[$15 >> 2] | 0) + -1 | 0;
 $38 = HEAP32[$$pre6 >> 2] | 0;
 HEAP32[$38 + ($37 << 3) >> 2] = $35;
 HEAP32[$38 + ($37 << 3) + 4 >> 2] = $29;
 if (!(HEAP32[$kpse + 44 >> 2] & 16)) {
  $$0 = $29;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $45 = HEAP32[21] | 0;
 _fwrite(13458, 7, 1, $45) | 0;
 HEAP32[$vararg_buffer2 >> 2] = $elt;
 _fprintf($45, 13342, $vararg_buffer2) | 0;
 _fflush($45) | 0;
 if ($29 | 0) {
  $e$03 = HEAP32[$29 >> 2] | 0;
  if ($e$03 | 0) {
   $e$04 = $e$03;
   while (1) {
    HEAP32[$vararg_buffer5 >> 2] = HEAP32[$e$04 >> 2];
    _fprintf($45, 13361, $vararg_buffer5) | 0;
    $e$0 = HEAP32[$e$04 + 8 >> 2] | 0;
    if (!$e$0) break; else $e$04 = $e$0;
   }
  }
 }
 _putc(10, $45) | 0;
 _fflush($45) | 0;
 $$0 = $29;
 STACKTOP = sp;
 return $$0 | 0;
}

function ___stdio_write($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $15 = 0, $20 = 0, $25 = 0, $3 = 0, $34 = 0, $36 = 0, $38 = 0, $49 = 0, $5 = 0, $9 = 0, $cnt$0 = 0, $cnt$1 = 0, $iov$0 = 0, $iov$0$lcssa11 = 0, $iov$1 = 0, $iovcnt$0 = 0, $iovcnt$0$lcssa12 = 0, $iovcnt$1 = 0, $iovs = 0, $rem$0 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $iovs = sp + 32 | 0;
 $0 = $f + 28 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 HEAP32[$iovs >> 2] = $1;
 $3 = $f + 20 | 0;
 $5 = (HEAP32[$3 >> 2] | 0) - $1 | 0;
 HEAP32[$iovs + 4 >> 2] = $5;
 HEAP32[$iovs + 8 >> 2] = $buf;
 HEAP32[$iovs + 12 >> 2] = $len;
 $9 = $f + 60 | 0;
 $10 = $f + 44 | 0;
 $iov$0 = $iovs;
 $iovcnt$0 = 2;
 $rem$0 = $5 + $len | 0;
 while (1) {
  if (!(HEAP32[5757] | 0)) {
   HEAP32[$vararg_buffer3 >> 2] = HEAP32[$9 >> 2];
   HEAP32[$vararg_buffer3 + 4 >> 2] = $iov$0;
   HEAP32[$vararg_buffer3 + 8 >> 2] = $iovcnt$0;
   $cnt$0 = ___syscall_ret(___syscall146(146, $vararg_buffer3 | 0) | 0) | 0;
  } else {
   _pthread_cleanup_push(3, $f | 0);
   HEAP32[$vararg_buffer >> 2] = HEAP32[$9 >> 2];
   HEAP32[$vararg_buffer + 4 >> 2] = $iov$0;
   HEAP32[$vararg_buffer + 8 >> 2] = $iovcnt$0;
   $15 = ___syscall_ret(___syscall146(146, $vararg_buffer | 0) | 0) | 0;
   _pthread_cleanup_pop(0);
   $cnt$0 = $15;
  }
  if (($rem$0 | 0) == ($cnt$0 | 0)) {
   label = 6;
   break;
  }
  if (($cnt$0 | 0) < 0) {
   $iov$0$lcssa11 = $iov$0;
   $iovcnt$0$lcssa12 = $iovcnt$0;
   label = 8;
   break;
  }
  $34 = $rem$0 - $cnt$0 | 0;
  $36 = HEAP32[$iov$0 + 4 >> 2] | 0;
  if ($cnt$0 >>> 0 > $36 >>> 0) {
   $38 = HEAP32[$10 >> 2] | 0;
   HEAP32[$0 >> 2] = $38;
   HEAP32[$3 >> 2] = $38;
   $49 = HEAP32[$iov$0 + 12 >> 2] | 0;
   $cnt$1 = $cnt$0 - $36 | 0;
   $iov$1 = $iov$0 + 8 | 0;
   $iovcnt$1 = $iovcnt$0 + -1 | 0;
  } else if (($iovcnt$0 | 0) == 2) {
   HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + $cnt$0;
   $49 = $36;
   $cnt$1 = $cnt$0;
   $iov$1 = $iov$0;
   $iovcnt$1 = 2;
  } else {
   $49 = $36;
   $cnt$1 = $cnt$0;
   $iov$1 = $iov$0;
   $iovcnt$1 = $iovcnt$0;
  }
  HEAP32[$iov$1 >> 2] = (HEAP32[$iov$1 >> 2] | 0) + $cnt$1;
  HEAP32[$iov$1 + 4 >> 2] = $49 - $cnt$1;
  $iov$0 = $iov$1;
  $iovcnt$0 = $iovcnt$1;
  $rem$0 = $34;
 }
 if ((label | 0) == 6) {
  $20 = HEAP32[$10 >> 2] | 0;
  HEAP32[$f + 16 >> 2] = $20 + (HEAP32[$f + 48 >> 2] | 0);
  $25 = $20;
  HEAP32[$0 >> 2] = $25;
  HEAP32[$3 >> 2] = $25;
  $$0 = $len;
 } else if ((label | 0) == 8) {
  HEAP32[$f + 16 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$3 >> 2] = 0;
  HEAP32[$f >> 2] = HEAP32[$f >> 2] | 32;
  if (($iovcnt$0$lcssa12 | 0) == 2) $$0 = 0; else $$0 = $len - (HEAP32[$iov$0$lcssa11 + 4 >> 2] | 0) | 0;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _element($kpse, $passed_path, $env_p) {
 $kpse = $kpse | 0;
 $passed_path = $passed_path | 0;
 $env_p = $env_p | 0;
 var $$0 = 0, $$in = 0, $$phi$trans$insert = 0, $$pre$phiZ2D = 0, $1 = 0, $13 = 0, $14 = 0, $17 = 0, $2 = 0, $21 = 0, $22 = 0, $25 = 0, $26 = 0, $27 = 0, $30 = 0, $32 = 0, $33 = 0, $34 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $9 = 0, $brace_level$02 = 0, $brace_level$02$us = 0, $brace_level$1 = 0, $brace_level$1$us = 0, $p$0$lcssa = 0, $p$01 = 0, $p$01$us = 0;
 $1 = $kpse + 88 | 0;
 if (!$passed_path) {
  $2 = HEAP32[$1 >> 2] | 0;
  if (!$2) {
   $$0 = 0;
   return $$0 | 0;
  } else $$in = $2;
 } else {
  HEAP32[$1 >> 2] = $passed_path;
  $$in = $passed_path;
 }
 $4 = $$in;
 $5 = HEAP8[$$in >> 0] | 0;
 L6 : do if (!($5 << 24 >> 24)) $p$0$lcssa = $$in; else if (!$env_p) {
  $17 = $5;
  $brace_level$02 = 0;
  $p$01 = $$in;
  while (1) {
   if (($brace_level$02 | 0) == 0 & $17 << 24 >> 24 == 47) {
    $p$0$lcssa = $p$01;
    break L6;
   }
   switch ($17 << 24 >> 24) {
   case 123:
    {
     $brace_level$1 = $brace_level$02 + 1 | 0;
     break;
    }
   case 125:
    {
     $brace_level$1 = $brace_level$02 + -1 | 0;
     break;
    }
   default:
    $brace_level$1 = $brace_level$02;
   }
   $21 = $p$01 + 1 | 0;
   $22 = HEAP8[$21 >> 0] | 0;
   if (!($22 << 24 >> 24)) {
    $p$0$lcssa = $21;
    break L6;
   } else {
    $17 = $22;
    $brace_level$02 = $brace_level$1;
    $p$01 = $21;
   }
  }
 } else {
  $9 = $5;
  $brace_level$02$us = 0;
  $p$01$us = $$in;
  while (1) {
   if (($brace_level$02$us | 0) == 0 & $9 << 24 >> 24 == 58) {
    $p$0$lcssa = $p$01$us;
    break L6;
   }
   switch ($9 << 24 >> 24) {
   case 123:
    {
     $brace_level$1$us = $brace_level$02$us + 1 | 0;
     break;
    }
   case 125:
    {
     $brace_level$1$us = $brace_level$02$us + -1 | 0;
     break;
    }
   default:
    $brace_level$1$us = $brace_level$02$us;
   }
   $13 = $p$01$us + 1 | 0;
   $14 = HEAP8[$13 >> 0] | 0;
   if (!($14 << 24 >> 24)) {
    $p$0$lcssa = $13;
    break L6;
   } else {
    $9 = $14;
    $brace_level$02$us = $brace_level$1$us;
    $p$01$us = $13;
   }
  }
 } while (0);
 $25 = $p$0$lcssa - $4 | 0;
 $26 = $25 + 1 | 0;
 $27 = $kpse + 84 | 0;
 if ($26 >>> 0 > (HEAP32[$27 >> 2] | 0) >>> 0) {
  HEAP32[$27 >> 2] = $26;
  $30 = $kpse + 80 | 0;
  $32 = _xrealloc(HEAP32[$30 >> 2] | 0, $26) | 0;
  HEAP32[$30 >> 2] = $32;
  $$pre$phiZ2D = $30;
  $33 = $32;
  $34 = HEAP32[$1 >> 2] | 0;
 } else {
  $$phi$trans$insert = $kpse + 80 | 0;
  $$pre$phiZ2D = $$phi$trans$insert;
  $33 = HEAP32[$$phi$trans$insert >> 2] | 0;
  $34 = $$in;
 }
 _strncpy($33, $34, $25) | 0;
 HEAP8[(HEAP32[$$pre$phiZ2D >> 2] | 0) + $25 >> 0] = 0;
 $37 = HEAP32[$$pre$phiZ2D >> 2] | 0;
 $38 = HEAP32[$1 >> 2] | 0;
 HEAP32[$1 >> 2] = (HEAP8[$38 + $25 >> 0] | 0) == 0 ? 0 : $38 + $26 | 0;
 $$0 = $37;
 return $$0 | 0;
}

function _xswap() {
 var $0 = 0, $11 = 0, $17 = 0, $2 = 0, $20 = 0, $26 = 0, $28 = 0, $3 = 0, $31 = 0, $35 = 0, $36 = 0, $38 = 0, $41 = 0, $45 = 0, $47 = 0, $49 = 0, $5 = 0, $52 = 0, $53 = 0, $54 = 0, $56 = 0, $59 = 0, $61 = 0, $63 = 0, $66 = 0, $68 = 0, $7 = 0, $70 = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 $2 = HEAP32[4345] | 0;
 if ($0 << 24 >> 24 == 1) {
  $3 = HEAP32[4364] | 0;
  if (($2 | 0) >= ($3 | 0)) {
   $17 = HEAP32[4365] | 0;
   if ((HEAP8[26649] | 0) != 1 | ($17 | 0) < ($3 | 0)) {
    $20 = (HEAP32[4e3] | 0) + 1 | 0;
    HEAP32[4e3] = $20;
    HEAP32[4237] = HEAP32[(HEAP32[4041] | 0) + ($20 << 2) >> 2];
    _zpushlitstk($2, 1);
    _zpushlitstk(HEAP32[4365] | 0, HEAP8[26649] | 0);
    return;
   }
   HEAP32[4333] = 0;
   $26 = HEAP32[4041] | 0;
   $28 = HEAP32[$26 + ($17 << 2) >> 2] | 0;
   HEAP32[4238] = $28;
   $31 = HEAP32[$26 + ($17 + 1 << 2) >> 2] | 0;
   HEAP32[4239] = $31;
   if (($31 - $28 | 0) > (HEAP32[3992] | 0)) {
    _bufferoverflow();
    $35 = HEAP32[4333] | 0;
    $36 = HEAP32[4238] | 0;
    $38 = HEAP32[4239] | 0;
   } else {
    $35 = 0;
    $36 = $28;
    $38 = $31;
   }
   HEAP32[4251] = $35;
   if (($36 | 0) < ($38 | 0)) {
    $41 = $36;
    $45 = $35;
    while (1) {
     HEAP8[(HEAP32[3995] | 0) + $45 >> 0] = HEAP8[(HEAP32[4042] | 0) + $41 >> 0] | 0;
     $47 = (HEAP32[4251] | 0) + 1 | 0;
     HEAP32[4251] = $47;
     $49 = (HEAP32[4238] | 0) + 1 | 0;
     HEAP32[4238] = $49;
     if (($49 | 0) < (HEAP32[4239] | 0)) {
      $41 = $49;
      $45 = $47;
     } else {
      $52 = $47;
      break;
     }
    }
   } else $52 = $35;
   HEAP32[4333] = $52;
   $53 = HEAP32[4345] | 0;
   $54 = HEAP32[4041] | 0;
   $56 = HEAP32[$54 + ($53 << 2) >> 2] | 0;
   HEAP32[4343] = $56;
   $59 = HEAP32[$54 + ($53 + 1 << 2) >> 2] | 0;
   HEAP32[4344] = $59;
   if (($56 | 0) < ($59 | 0)) {
    $63 = $56;
    $66 = HEAP32[4237] | 0;
    while (1) {
     $61 = HEAP32[4042] | 0;
     HEAP8[$61 + $66 >> 0] = HEAP8[$61 + $63 >> 0] | 0;
     $68 = (HEAP32[4237] | 0) + 1 | 0;
     HEAP32[4237] = $68;
     $70 = (HEAP32[4343] | 0) + 1 | 0;
     HEAP32[4343] = $70;
     if (($70 | 0) < (HEAP32[4344] | 0)) {
      $63 = $70;
      $66 = $68;
     } else break;
    }
   }
   _zpushlitstk(_makestring() | 0, 1);
   _addpoolbufandpush();
   return;
  }
 }
 _zpushlitstk($2, $0);
 $5 = HEAP8[26649] | 0;
 $7 = HEAP32[4365] | 0;
 if (!($5 << 24 >> 24 != 1 | ($7 | 0) < (HEAP32[4364] | 0))) {
  $11 = (HEAP32[4e3] | 0) + 1 | 0;
  HEAP32[4e3] = $11;
  HEAP32[4237] = HEAP32[(HEAP32[4041] | 0) + ($11 << 2) >> 2];
 }
 _zpushlitstk($7, $5);
 return;
}

function _bufferoverflow() {
 var $0 = 0, $1 = 0, $14 = 0, $15 = 0, $21 = 0, $22 = 0, $28 = 0, $29 = 0, $36 = 0, $37 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, $vararg_buffer10 = 0, $vararg_buffer16 = 0, $vararg_buffer22 = 0, $vararg_buffer28 = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $vararg_buffer28 = sp + 80 | 0;
 $vararg_buffer22 = sp + 64 | 0;
 $vararg_buffer16 = sp + 48 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[3989] | 0;
 $1 = HEAP32[3992] | 0;
 HEAP32[$vararg_buffer >> 2] = 1077;
 HEAP32[$vararg_buffer + 4 >> 2] = 1;
 HEAP32[$vararg_buffer + 8 >> 2] = $1 + 2e4;
 HEAP32[$vararg_buffer + 12 >> 2] = $1;
 _fprintf($0, 1023, $vararg_buffer) | 0;
 HEAP32[3993] = _xrealloc(HEAP32[3993] | 0, (HEAP32[3992] | 0) + 20001 | 0) | 0;
 $7 = HEAP32[3989] | 0;
 $8 = HEAP32[3992] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 1084;
 HEAP32[$vararg_buffer4 + 4 >> 2] = 1;
 HEAP32[$vararg_buffer4 + 8 >> 2] = $8 + 2e4;
 HEAP32[$vararg_buffer4 + 12 >> 2] = $8;
 _fprintf($7, 1023, $vararg_buffer4) | 0;
 HEAP32[3994] = _xrealloc(HEAP32[3994] | 0, (HEAP32[3992] | 0) + 20001 | 0) | 0;
 $14 = HEAP32[3989] | 0;
 $15 = HEAP32[3992] | 0;
 HEAP32[$vararg_buffer10 >> 2] = 1094;
 HEAP32[$vararg_buffer10 + 4 >> 2] = 1;
 HEAP32[$vararg_buffer10 + 8 >> 2] = $15 + 2e4;
 HEAP32[$vararg_buffer10 + 12 >> 2] = $15;
 _fprintf($14, 1023, $vararg_buffer10) | 0;
 HEAP32[3995] = _xrealloc(HEAP32[3995] | 0, (HEAP32[3992] | 0) + 20001 | 0) | 0;
 $21 = HEAP32[3989] | 0;
 $22 = HEAP32[3992] | 0;
 HEAP32[$vararg_buffer16 >> 2] = 1101;
 HEAP32[$vararg_buffer16 + 4 >> 2] = 1;
 HEAP32[$vararg_buffer16 + 8 >> 2] = $22 + 2e4;
 HEAP32[$vararg_buffer16 + 12 >> 2] = $22;
 _fprintf($21, 1023, $vararg_buffer16) | 0;
 HEAP32[3996] = _xrealloc(HEAP32[3996] | 0, (HEAP32[3992] | 0) + 20001 | 0) | 0;
 $28 = HEAP32[3989] | 0;
 $29 = HEAP32[3992] | 0;
 HEAP32[$vararg_buffer22 >> 2] = 1109;
 HEAP32[$vararg_buffer22 + 4 >> 2] = 4;
 HEAP32[$vararg_buffer22 + 8 >> 2] = $29 + 2e4;
 HEAP32[$vararg_buffer22 + 12 >> 2] = $29;
 _fprintf($28, 1023, $vararg_buffer22) | 0;
 HEAP32[3997] = _xrealloc(HEAP32[3997] | 0, (HEAP32[3992] << 2) + 80004 | 0) | 0;
 $36 = HEAP32[3989] | 0;
 $37 = HEAP32[3992] | 0;
 HEAP32[$vararg_buffer28 >> 2] = 1118;
 HEAP32[$vararg_buffer28 + 4 >> 2] = 1;
 HEAP32[$vararg_buffer28 + 8 >> 2] = $37 + 2e4;
 HEAP32[$vararg_buffer28 + 12 >> 2] = $37;
 _fprintf($36, 1023, $vararg_buffer28) | 0;
 HEAP32[3998] = _xrealloc(HEAP32[3998] | 0, (HEAP32[3992] | 0) + 20001 | 0) | 0;
 HEAP32[3992] = (HEAP32[3992] | 0) + 2e4;
 STACKTOP = sp;
 return;
}

function _hash_lookup($table, $key) {
 $table = $table | 0;
 $key = $key | 0;
 var $$02$i = 0, $0 = 0, $17 = 0, $26 = 0, $27 = 0, $3 = 0, $32 = 0, $33 = 0, $34 = 0, $38 = 0, $43 = 0, $46 = 0, $5 = 0, $7 = 0, $8 = 0, $n$0$lcssa$i = 0, $n$03$i = 0, $p$0 = 0, $p$0$us = 0, $p$04 = 0, $p$05 = 0, $p$05$us = 0, $r$03 = 0, $ret = 0, $table$1$val = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer1 = sp + 16 | 0;
 $vararg_buffer = sp + 8 | 0;
 $ret = sp;
 $table$1$val = HEAP32[$table + 4 >> 2] | 0;
 $0 = HEAP8[$key >> 0] | 0;
 if (!($0 << 24 >> 24)) $n$0$lcssa$i = 0; else {
  $$02$i = $key;
  $3 = $0;
  $n$03$i = 0;
  while (1) {
   $5 = $$02$i + 1 | 0;
   $7 = ((($n$03$i << 1) + ($3 << 24 >> 24) | 0) >>> 0) % ($table$1$val >>> 0) | 0;
   $8 = HEAP8[$5 >> 0] | 0;
   if (!($8 << 24 >> 24)) {
    $n$0$lcssa$i = $7;
    break;
   } else {
    $$02$i = $5;
    $3 = $8;
    $n$03$i = $7;
   }
  }
 }
 HEAP32[$ret >> 2] = 0;
 HEAP32[$ret + 4 >> 2] = 0;
 $p$04 = HEAP32[(HEAP32[$table >> 2] | 0) + ($n$0$lcssa$i << 2) >> 2] | 0;
 L5 : do if (!$p$04) label = 10; else {
  if (!$key) {
   $p$05$us = $p$04;
   while (1) {
    $p$0$us = HEAP32[$p$05$us + 8 >> 2] | 0;
    if (!$p$0$us) {
     label = 10;
     break L5;
    } else $p$05$us = $p$0$us;
   }
  } else $p$05 = $p$04;
  while (1) {
   $17 = HEAP32[$p$05 >> 2] | 0;
   if ($17 | 0) if (!(_strcmp($key, $17) | 0)) _cstr_list_add($ret, HEAP32[$p$05 + 4 >> 2] | 0);
   $p$0 = HEAP32[$p$05 + 8 >> 2] | 0;
   if (!$p$0) break; else $p$05 = $p$0;
  }
  $26 = $ret + 4 | 0;
  if (!(HEAP32[$ret + 4 >> 2] | 0)) $34 = $26; else {
   _cstr_list_add($ret, 0);
   $34 = $26;
  }
 } while (0);
 if ((label | 0) == 10) $34 = $ret + 4 | 0;
 $27 = HEAP32[16] | 0;
 if (!(HEAP32[$27 + 44 >> 2] & 2)) {
  $46 = HEAP32[$34 >> 2] | 0;
  STACKTOP = sp;
  return $46 | 0;
 }
 $32 = HEAP32[21] | 0;
 _fwrite(13458, 7, 1, $32) | 0;
 HEAP32[$vararg_buffer >> 2] = $key;
 _fprintf($32, 10802, $vararg_buffer) | 0;
 _fflush($32) | 0;
 $33 = HEAP32[$34 >> 2] | 0;
 if (!$33) _fwrite(10821, 7, 1, $32) | 0; else {
  if (HEAP32[$33 >> 2] | 0) {
   $38 = $27 + 76 | 0;
   $r$03 = $33;
   while (1) {
    _putc(32, $32) | 0;
    if (!(HEAP32[$38 >> 2] | 0)) _fputs(HEAP32[$r$03 >> 2] | 0, $32) | 0; else {
     HEAP32[$vararg_buffer1 >> 2] = HEAP32[$r$03 >> 2];
     _fprintf($32, 10829, $vararg_buffer1) | 0;
    }
    $43 = $r$03 + 4 | 0;
    if (!(HEAP32[$43 >> 2] | 0)) break; else $r$03 = $43;
   }
  }
  _putc(10, $32) | 0;
 }
 _fflush($32) | 0;
 $46 = HEAP32[$34 >> 2] | 0;
 STACKTOP = sp;
 return $46 | 0;
}

function _memchr($src, $c, $n) {
 $src = $src | 0;
 $c = $c | 0;
 $n = $n | 0;
 var $$0$lcssa = 0, $$0$lcssa30 = 0, $$019 = 0, $$1$lcssa = 0, $$110 = 0, $$110$lcssa = 0, $$24 = 0, $$3 = 0, $$lcssa = 0, $0 = 0, $13 = 0, $15 = 0, $17 = 0, $20 = 0, $26 = 0, $27 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $8 = 0, $9 = 0, $s$0$lcssa = 0, $s$0$lcssa29 = 0, $s$020 = 0, $s$15 = 0, $s$2 = 0, $w$0$lcssa = 0, $w$011 = 0, $w$011$lcssa = 0, label = 0;
 $0 = $c & 255;
 $4 = ($n | 0) != 0;
 L1 : do if ($4 & ($src & 3 | 0) != 0) {
  $5 = $c & 255;
  $$019 = $n;
  $s$020 = $src;
  while (1) {
   if ((HEAP8[$s$020 >> 0] | 0) == $5 << 24 >> 24) {
    $$0$lcssa30 = $$019;
    $s$0$lcssa29 = $s$020;
    label = 6;
    break L1;
   }
   $8 = $s$020 + 1 | 0;
   $9 = $$019 + -1 | 0;
   $13 = ($9 | 0) != 0;
   if ($13 & ($8 & 3 | 0) != 0) {
    $$019 = $9;
    $s$020 = $8;
   } else {
    $$0$lcssa = $9;
    $$lcssa = $13;
    $s$0$lcssa = $8;
    label = 5;
    break;
   }
  }
 } else {
  $$0$lcssa = $n;
  $$lcssa = $4;
  $s$0$lcssa = $src;
  label = 5;
 } while (0);
 if ((label | 0) == 5) if ($$lcssa) {
  $$0$lcssa30 = $$0$lcssa;
  $s$0$lcssa29 = $s$0$lcssa;
  label = 6;
 } else {
  $$3 = 0;
  $s$2 = $s$0$lcssa;
 }
 L8 : do if ((label | 0) == 6) {
  $15 = $c & 255;
  if ((HEAP8[$s$0$lcssa29 >> 0] | 0) == $15 << 24 >> 24) {
   $$3 = $$0$lcssa30;
   $s$2 = $s$0$lcssa29;
  } else {
   $17 = Math_imul($0, 16843009) | 0;
   L11 : do if ($$0$lcssa30 >>> 0 > 3) {
    $$110 = $$0$lcssa30;
    $w$011 = $s$0$lcssa29;
    while (1) {
     $20 = HEAP32[$w$011 >> 2] ^ $17;
     if (($20 & -2139062144 ^ -2139062144) & $20 + -16843009 | 0) {
      $$110$lcssa = $$110;
      $w$011$lcssa = $w$011;
      break;
     }
     $26 = $w$011 + 4 | 0;
     $27 = $$110 + -4 | 0;
     if ($27 >>> 0 > 3) {
      $$110 = $27;
      $w$011 = $26;
     } else {
      $$1$lcssa = $27;
      $w$0$lcssa = $26;
      label = 11;
      break L11;
     }
    }
    $$24 = $$110$lcssa;
    $s$15 = $w$011$lcssa;
   } else {
    $$1$lcssa = $$0$lcssa30;
    $w$0$lcssa = $s$0$lcssa29;
    label = 11;
   } while (0);
   if ((label | 0) == 11) if (!$$1$lcssa) {
    $$3 = 0;
    $s$2 = $w$0$lcssa;
    break;
   } else {
    $$24 = $$1$lcssa;
    $s$15 = $w$0$lcssa;
   }
   while (1) {
    if ((HEAP8[$s$15 >> 0] | 0) == $15 << 24 >> 24) {
     $$3 = $$24;
     $s$2 = $s$15;
     break L8;
    }
    $32 = $s$15 + 1 | 0;
    $33 = $$24 + -1 | 0;
    if (!$33) {
     $$3 = 0;
     $s$2 = $32;
     break;
    } else {
     $$24 = $33;
     $s$15 = $32;
    }
   }
  }
 } while (0);
 return ($$3 | 0 ? $s$2 : 0) | 0;
}

function _kpathsea_set_program_name($kpse, $argv0, $progname) {
 $kpse = $kpse | 0;
 $argv0 = $argv0 | 0;
 $progname = $progname | 0;
 var $0 = 0, $10 = 0, $11 = 0, $14 = 0, $15 = 0, $19 = 0, $2 = 0, $3 = 0, $31 = 0, $35 = 0, $39 = 0, $45 = 0, $49 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $buf = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $buf = sp + 20 | 0;
 $0 = _getenv(11324) | 0;
 if ($0 | 0) {
  $2 = _atoi($0) | 0;
  $3 = $kpse + 44 | 0;
  HEAP32[$3 >> 2] = HEAP32[$3 >> 2] | $2;
 }
 $6 = _xstrdup($argv0) | 0;
 $7 = $kpse + 104 | 0;
 HEAP32[$7 >> 2] = $6;
 $8 = _kpathsea_selfdir($kpse, $6) | 0;
 _kpathsea_xputenv($kpse, 11339, $8);
 $9 = _xdirname($8) | 0;
 _kpathsea_xputenv($kpse, 11351, $9);
 $10 = _xdirname($9) | 0;
 _kpathsea_xputenv($kpse, 11363, $10);
 $11 = _xdirname($10) | 0;
 _kpathsea_xputenv($kpse, 11378, $11);
 _free($8);
 _free($9);
 _free($10);
 _free($11);
 $14 = _xstrdup(_xbasename(HEAP32[$7 >> 2] | 0) | 0) | 0;
 $15 = $kpse + 108 | 0;
 HEAP32[$15 >> 2] = $14;
 do if (!$progname) {
  $19 = _find_suffix($14) | 0;
  if ($19 | 0) if (!(_strcmp($19, 11398) | 0)) {
   HEAP32[$kpse + 112 >> 2] = _remove_suffix(HEAP32[$15 >> 2] | 0) | 0;
   break;
  }
  HEAP32[$kpse + 112 >> 2] = _xstrdup(HEAP32[$15 >> 2] | 0) | 0;
 } else HEAP32[$kpse + 112 >> 2] = _xstrdup($progname) | 0; while (0);
 HEAP32[$buf >> 2] = 6581359;
 if ((_snprintf($buf, 2, 11402, $vararg_buffer) | 0) != 1) ___assert_fail(11404, 11278, 715, 11450);
 $31 = $buf + 1 | 0;
 if (HEAP8[$31 >> 0] | 0) ___assert_fail(11404, 11278, 715, 11450);
 $35 = (_snprintf($buf, 2, 12168, $vararg_buffer1) | 0) >>> 0 > 1;
 if (!($35 & (HEAP8[$31 >> 0] | 0) == 0)) ___assert_fail(11476, 11278, 716, 11450);
 $39 = (_snprintf($buf, 2, 11533, $vararg_buffer3) | 0) >>> 0 > 1;
 if (!($39 & (HEAP8[$31 >> 0] | 0) == 0)) ___assert_fail(11537, 11278, 717, 11450);
 if ((HEAP32[16] | 0) == ($kpse | 0)) {
  $52 = $kpse + 112 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  _kpathsea_xputenv($kpse, 11595, $53);
  STACKTOP = sp;
  return;
 }
 $45 = _xstrdup(HEAP32[$7 >> 2] | 0) | 0;
 HEAP32[(HEAP32[16] | 0) + 104 >> 2] = $45;
 $49 = _xstrdup(HEAP32[$15 >> 2] | 0) | 0;
 HEAP32[(HEAP32[16] | 0) + 108 >> 2] = $49;
 $52 = $kpse + 112 | 0;
 $53 = HEAP32[$52 >> 2] | 0;
 _kpathsea_xputenv($kpse, 11595, $53);
 STACKTOP = sp;
 return;
}

function _zlessthan($arg1, $arg2) {
 $arg1 = $arg1 | 0;
 $arg2 = $arg2 | 0;
 var $$lcssa = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $14 = 0, $16 = 0, $18 = 0, $2 = 0, $20 = 0, $23 = 0, $25 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $36 = 0, $38 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0, $Result$0 = 0, $charptr$02 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4255] | 0;
 $1 = Math_imul($0, $arg1) | 0;
 $2 = HEAP32[4256] | 0;
 $5 = (Math_imul($0, $arg2) | 0) + $2 | 0;
 $7 = (HEAP32[4257] | 0) + 1 | 0;
 $8 = Math_imul($7, $1 + $2 | 0) | 0;
 $9 = HEAP32[4258] | 0;
 $11 = HEAP8[$9 + $8 >> 0] | 0;
 $12 = Math_imul($7, $5) | 0;
 $14 = HEAP8[$9 + $12 >> 0] | 0;
 $16 = $14 << 24 >> 24 == 127;
 L1 : do if ($11 << 24 >> 24 == 127) $$lcssa = $16; else {
  $34 = $11;
  $36 = $14;
  $38 = $16;
  $charptr$02 = 0;
  while (1) {
   if ($38) {
    $Result$0 = 0;
    label = 9;
    break;
   }
   if (($34 & 255) < ($36 & 255)) {
    $Result$0 = 1;
    label = 9;
    break;
   }
   $18 = $charptr$02 + 1 | 0;
   if (($34 & 255) > ($36 & 255)) {
    $Result$0 = 0;
    label = 9;
    break;
   }
   $20 = HEAP8[$9 + ($8 + $18) >> 0] | 0;
   $23 = HEAP8[$9 + ($12 + $18) >> 0] | 0;
   $25 = $23 << 24 >> 24 == 127;
   if ($20 << 24 >> 24 == 127) {
    $$lcssa = $25;
    break L1;
   } else {
    $34 = $20;
    $36 = $23;
    $38 = $25;
    $charptr$02 = $18;
   }
  }
  if ((label | 0) == 9) {
   STACKTOP = sp;
   return $Result$0 | 0;
  }
 } while (0);
 if (($arg1 | 0) < ($arg2 | 0) | $$lcssa ^ 1) {
  $Result$0 = 1;
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 if (($arg1 | 0) > ($arg2 | 0)) {
  $Result$0 = 0;
  STACKTOP = sp;
  return $Result$0 | 0;
 } else {
  _fwrite(2896, 18, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2896, 18, 1, HEAP32[3990] | 0) | 0;
  $30 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer >> 2] = 964;
  _fprintf($30, 960, $vararg_buffer) | 0;
  $31 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer1 >> 2] = 964;
  _fprintf($31, 960, $vararg_buffer1) | 0;
  $32 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer4 >> 2] = 985;
  _fprintf($32, 960, $vararg_buffer4) | 0;
  $33 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer7 >> 2] = 985;
  _fprintf($33, 960, $vararg_buffer7) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
 return 0;
}

function _xduplicate() {
 var $$lcssa = 0, $0 = 0, $12 = 0, $17 = 0, $19 = 0, $21 = 0, $25 = 0, $28 = 0, $30 = 0, $32 = 0, $38 = 0, $39 = 0, $40 = 0, $42 = 0, $46 = 0, $5 = 0, $51 = 0, $53 = 0, $54 = 0, $56 = 0, $58 = 0, $61 = 0, $63 = 0, $65 = 0, $69 = 0, $9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 if ($0 << 24 >> 24 != 1) {
  _zpushlitstk(HEAP32[4345] | 0, $0);
  _zpushlitstk(HEAP32[4345] | 0, HEAP8[26648] | 0);
  STACKTOP = sp;
  return;
 }
 $5 = HEAP32[4360] | 0;
 $9 = HEAP32[4364] | 0;
 if ((HEAP32[(HEAP32[4361] | 0) + ($5 << 2) >> 2] | 0) >= ($9 | 0)) {
  $12 = (HEAP32[4e3] | 0) + 1 | 0;
  HEAP32[4e3] = $12;
  HEAP32[4237] = HEAP32[(HEAP32[4041] | 0) + ($12 << 2) >> 2];
 }
 HEAP32[4360] = $5 + 1;
 $17 = HEAP32[4345] | 0;
 if (($17 | 0) < ($9 | 0)) {
  _zpushlitstk($17, 1);
  STACKTOP = sp;
  return;
 }
 $19 = HEAP32[4237] | 0;
 $21 = HEAP32[4041] | 0;
 $25 = HEAP32[$21 + ($17 << 2) >> 2] | 0;
 $28 = HEAP32[4043] | 0;
 if (((HEAP32[$21 + ($17 + 1 << 2) >> 2] | 0) + $19 - $25 | 0) > ($28 | 0)) {
  $32 = $28;
  while (1) {
   $30 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = 1161;
   HEAP32[$vararg_buffer + 4 >> 2] = 1;
   HEAP32[$vararg_buffer + 8 >> 2] = $32 + 65e3;
   HEAP32[$vararg_buffer + 12 >> 2] = $32;
   _fprintf($30, 1023, $vararg_buffer) | 0;
   HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
   $38 = (HEAP32[4043] | 0) + 65e3 | 0;
   HEAP32[4043] = $38;
   $39 = HEAP32[4237] | 0;
   $40 = HEAP32[4345] | 0;
   $42 = HEAP32[4041] | 0;
   $46 = HEAP32[$42 + ($40 << 2) >> 2] | 0;
   if (((HEAP32[$42 + ($40 + 1 << 2) >> 2] | 0) + $39 - $46 | 0) > ($38 | 0)) $32 = $38; else {
    $$lcssa = $46;
    $51 = $40;
    $53 = $42;
    $69 = $39;
    break;
   }
  }
 } else {
  $$lcssa = $25;
  $51 = $17;
  $53 = $21;
  $69 = $19;
 }
 HEAP32[4343] = $$lcssa;
 $54 = HEAP32[$53 + ($51 + 1 << 2) >> 2] | 0;
 HEAP32[4344] = $54;
 if (($$lcssa | 0) < ($54 | 0)) {
  $58 = $$lcssa;
  $61 = $69;
  while (1) {
   $56 = HEAP32[4042] | 0;
   HEAP8[$56 + $61 >> 0] = HEAP8[$56 + $58 >> 0] | 0;
   $63 = (HEAP32[4237] | 0) + 1 | 0;
   HEAP32[4237] = $63;
   $65 = (HEAP32[4343] | 0) + 1 | 0;
   HEAP32[4343] = $65;
   if (($65 | 0) < (HEAP32[4344] | 0)) {
    $58 = $65;
    $61 = $63;
   } else break;
  }
 }
 _zpushlitstk(_makestring() | 0, 1);
 STACKTOP = sp;
 return;
}

function ___fdopen($fd, $mode) {
 $fd = $fd | 0;
 $mode = $mode | 0;
 var $$0 = 0, $0 = 0, $12 = 0, $14 = 0, $19 = 0, $24 = 0, $26 = 0, $37 = 0, $4 = 0, $tio = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer3 = 0, $vararg_buffer7 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 $vararg_buffer12 = sp + 40 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $tio = sp + 52 | 0;
 $0 = HEAP8[$mode >> 0] | 0;
 if (!(_memchr(15914, $0 << 24 >> 24, 4) | 0)) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $$0 = 0;
 } else {
  $4 = _malloc(8212) | 0;
  if (!$4) $$0 = 0; else {
   dest = $4;
   stop = dest + 112 | 0;
   do {
    HEAP32[dest >> 2] = 0;
    dest = dest + 4 | 0;
   } while ((dest | 0) < (stop | 0));
   if (!(_strchr($mode, 43) | 0)) HEAP32[$4 >> 2] = $0 << 24 >> 24 == 114 ? 8 : 4;
   if (!(_strchr($mode, 101) | 0)) $12 = $0; else {
    HEAP32[$vararg_buffer >> 2] = $fd;
    HEAP32[$vararg_buffer + 4 >> 2] = 2;
    HEAP32[$vararg_buffer + 8 >> 2] = 1;
    ___syscall221(221, $vararg_buffer | 0) | 0;
    $12 = HEAP8[$mode >> 0] | 0;
   }
   if ($12 << 24 >> 24 == 97) {
    HEAP32[$vararg_buffer3 >> 2] = $fd;
    HEAP32[$vararg_buffer3 + 4 >> 2] = 3;
    $14 = ___syscall221(221, $vararg_buffer3 | 0) | 0;
    if (!($14 & 1024)) {
     HEAP32[$vararg_buffer7 >> 2] = $fd;
     HEAP32[$vararg_buffer7 + 4 >> 2] = 4;
     HEAP32[$vararg_buffer7 + 8 >> 2] = $14 | 1024;
     ___syscall221(221, $vararg_buffer7 | 0) | 0;
    }
    $19 = HEAP32[$4 >> 2] | 128;
    HEAP32[$4 >> 2] = $19;
    $26 = $19;
   } else $26 = HEAP32[$4 >> 2] | 0;
   HEAP32[$4 + 60 >> 2] = $fd;
   HEAP32[$4 + 44 >> 2] = $4 + 120;
   HEAP32[$4 + 48 >> 2] = 8092;
   $24 = $4 + 75 | 0;
   HEAP8[$24 >> 0] = -1;
   if (!($26 & 8)) {
    HEAP32[$vararg_buffer12 >> 2] = $fd;
    HEAP32[$vararg_buffer12 + 4 >> 2] = 21505;
    HEAP32[$vararg_buffer12 + 8 >> 2] = $tio;
    if (!(___syscall54(54, $vararg_buffer12 | 0) | 0)) HEAP8[$24 >> 0] = 10;
   }
   HEAP32[$4 + 32 >> 2] = 3;
   HEAP32[$4 + 36 >> 2] = 1;
   HEAP32[$4 + 40 >> 2] = 2;
   HEAP32[$4 + 12 >> 2] = 1;
   if (!(HEAP32[5758] | 0)) HEAP32[$4 + 76 >> 2] = -1;
   ___lock(23056);
   $37 = HEAP32[5763] | 0;
   HEAP32[$4 + 56 >> 2] = $37;
   if ($37 | 0) HEAP32[$37 + 52 >> 2] = $4;
   HEAP32[5763] = $4;
   ___unlock(23056);
   $$0 = $4;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _checkcommandexecution() {
 var $0 = 0, $10 = 0, $2 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer14 = 0, $vararg_buffer17 = 0, $vararg_buffer20 = 0, $vararg_buffer23 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $vararg_buffer23 = sp + 72 | 0;
 $vararg_buffer20 = sp + 64 | 0;
 $vararg_buffer17 = sp + 56 | 0;
 $vararg_buffer14 = sp + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4360] | 0;
 if ($0 | 0) {
  $2 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer >> 2] = 3581;
  HEAP32[$vararg_buffer + 4 >> 2] = $0;
  HEAP32[$vararg_buffer + 8 >> 2] = 3586;
  _fprintf($2, 2703, $vararg_buffer) | 0;
  $3 = HEAP32[3990] | 0;
  $4 = HEAP32[4360] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 3581;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $4;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 3586;
  _fprintf($3, 2703, $vararg_buffer3) | 0;
  if ((HEAP32[4360] | 0) > 0) do {
   _zzpoplitstk($vararg_buffer3, $vararg_buffer);
   $7 = HEAP8[$vararg_buffer >> 0] | 0;
   if ($7 << 24 >> 24 == 4) {
    $9 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer8 >> 2] = 3567;
    _fprintf($9, 960, $vararg_buffer8) | 0;
    $10 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer11 >> 2] = 3567;
    _fprintf($10, 960, $vararg_buffer11) | 0;
   } else _zprintlit(HEAP32[$vararg_buffer3 >> 2] | 0, $7);
  } while ((HEAP32[4360] | 0) > 0);
  _fwrite(3595, 32, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3595, 32, 1, HEAP32[3990] | 0) | 0;
  _bstexwarnprint();
 }
 if ((HEAP32[4364] | 0) == (HEAP32[4e3] | 0)) {
  STACKTOP = sp;
  return;
 } else {
  _fwrite(3628, 27, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3628, 27, 1, HEAP32[3990] | 0) | 0;
  $21 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer14 >> 2] = 964;
  _fprintf($21, 960, $vararg_buffer14) | 0;
  $22 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer17 >> 2] = 964;
  _fprintf($22, 960, $vararg_buffer17) | 0;
  $23 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer20 >> 2] = 985;
  _fprintf($23, 960, $vararg_buffer20) | 0;
  $24 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer23 >> 2] = 985;
  _fprintf($24, 960, $vararg_buffer23) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
}

function _str_list_uniqify($l) {
 $l = $l | 0;
 var $$lcssa63 = 0, $$lcssa65 = 0, $$pre = 0, $0 = 0, $10 = 0, $14 = 0, $16 = 0, $19 = 0, $2 = 0, $22 = 0, $23 = 0, $25 = 0, $27 = 0, $29 = 0, $4 = 0, $5 = 0, $7 = 0, $e$0$ph19 = 0, $e$08 = 0, $f$0$lcssa = 0, $f$05 = 0, $f$05$us = 0, $ret$sroa$0$0$ph$lcssa = 0, $ret$sroa$0$0$ph18 = 0, $ret$sroa$7$0$ph$lcssa = 0, $ret$sroa$7$0$ph17 = 0;
 $0 = HEAP32[$l >> 2] | 0;
 $$pre = $l + 4 | 0;
 L1 : do if (!$0) {
  $ret$sroa$0$0$ph$lcssa = 0;
  $ret$sroa$7$0$ph$lcssa = 0;
 } else {
  $29 = $0;
  $e$0$ph19 = 0;
  $ret$sroa$0$0$ph18 = 0;
  $ret$sroa$7$0$ph17 = 0;
  while (1) {
   $7 = $29;
   $e$08 = $e$0$ph19;
   while (1) {
    $2 = HEAP32[$$pre >> 2] | 0;
    $4 = HEAP32[$2 + ($e$08 << 2) >> 2] | 0;
    $5 = $e$08 + 1 | 0;
    L6 : do if ($5 >>> 0 < $7 >>> 0) {
     if (!$4) {
      $f$05 = $5;
      while (1) {
       $16 = $f$05 + 1 | 0;
       if ($16 >>> 0 < $7 >>> 0) $f$05 = $16; else {
        $f$0$lcssa = $16;
        break L6;
       }
      }
     } else $f$05$us = $5;
     while (1) {
      $10 = HEAP32[$2 + ($f$05$us << 2) >> 2] | 0;
      if ($10 | 0) if (!(_strcmp($4, $10) | 0)) {
       $f$0$lcssa = $f$05$us;
       break L6;
      }
      $14 = $f$05$us + 1 | 0;
      if ($14 >>> 0 < $7 >>> 0) $f$05$us = $14; else {
       $f$0$lcssa = $14;
       break;
      }
     }
    } else $f$0$lcssa = $5; while (0);
    if (($f$0$lcssa | 0) == ($7 | 0)) {
     $$lcssa63 = $4;
     $$lcssa65 = $5;
     break;
    }
    _free($4);
    $27 = HEAP32[$l >> 2] | 0;
    if ($5 >>> 0 < $27 >>> 0) {
     $7 = $27;
     $e$08 = $5;
    } else {
     $ret$sroa$0$0$ph$lcssa = $ret$sroa$0$0$ph18;
     $ret$sroa$7$0$ph$lcssa = $ret$sroa$7$0$ph17;
     break L1;
    }
   }
   $19 = $ret$sroa$0$0$ph18 + 1 | 0;
   $22 = _xrealloc($ret$sroa$7$0$ph17, $19 << 2) | 0;
   $23 = $22;
   HEAP32[$22 + ($ret$sroa$0$0$ph18 << 2) >> 2] = $$lcssa63;
   $25 = HEAP32[$l >> 2] | 0;
   if ($$lcssa65 >>> 0 < $25 >>> 0) {
    $29 = $25;
    $e$0$ph19 = $$lcssa65;
    $ret$sroa$0$0$ph18 = $19;
    $ret$sroa$7$0$ph17 = $23;
   } else {
    $ret$sroa$0$0$ph$lcssa = $19;
    $ret$sroa$7$0$ph$lcssa = $23;
    break;
   }
  }
 } while (0);
 HEAP32[$l >> 2] = $ret$sroa$0$0$ph$lcssa;
 HEAP32[$$pre >> 2] = $ret$sroa$7$0$ph$lcssa;
 return;
}

function _kpathsea_magstep_fix($kpse, $dpi, $bdpi, $m_ret) {
 $kpse = $kpse | 0;
 $dpi = $dpi | 0;
 $bdpi = $bdpi | 0;
 $m_ret = $m_ret | 0;
 var $$1$lcssa$i = 0, $$17$i = 0, $$25$i = 0, $$3$i = 0.0, $$lcssa = 0.0, $$lcssa21 = 0, $$lcssa22 = 0, $$lcssa23 = 0, $$n$i = 0, $1 = 0, $10 = 0, $15 = 0, $16 = 0.0, $19 = 0.0, $2 = 0.0, $25 = 0, $26 = 0, $3 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $42 = 0, $8 = 0, $m$04 = 0, $real_dpi$03 = 0, $real_dpi$1 = 0, $real_dpi$1$lcssa = 0, $t$0$lcssa$i = 0.0, $t$06$i = 0.0, $t$1$lcssa$i = 0.0, $t$14$i = 0.0;
 $1 = $dpi >>> 0 < $bdpi >>> 0 ? -1 : 1;
 $2 = +($bdpi | 0);
 $m$04 = 0;
 $real_dpi$03 = 0;
 while (1) {
  $3 = Math_imul($m$04, $1) | 0;
  $4 = ($3 | 0) < 0;
  $$n$i = $4 ? 0 - $3 | 0 : $3;
  $8 = $$n$i & -2;
  $$3$i = ($$n$i & 1 | 0) == 0 ? 1.0 : 1.095445115;
  if (($8 | 0) > 8) {
   $10 = $8 + -9 | 0;
   $$17$i = $8;
   $t$06$i = $$3$i;
   while (1) {
    $15 = $$17$i + -8 | 0;
    $16 = $t$06$i * 2.0736;
    if (($15 | 0) > 8) {
     $$17$i = $15;
     $t$06$i = $16;
    } else {
     $$lcssa = $16;
     break;
    }
   }
   $$1$lcssa$i = $8 + -8 - ($10 & -8) | 0;
   $t$0$lcssa$i = $$lcssa;
  } else {
   $$1$lcssa$i = $8;
   $t$0$lcssa$i = $$3$i;
  }
  if (($$1$lcssa$i | 0) > 0) {
   $$25$i = $$1$lcssa$i;
   $t$14$i = $t$0$lcssa$i;
   while (1) {
    $19 = $t$14$i * 1.2;
    if (($$25$i | 0) > 2) {
     $$25$i = $$25$i + -2 | 0;
     $t$14$i = $19;
    } else {
     $t$1$lcssa$i = $19;
     break;
    }
   }
  } else $t$1$lcssa$i = $t$0$lcssa$i;
  $25 = ~~(($4 ? $2 / $t$1$lcssa$i : $2 * $t$1$lcssa$i) + .5);
  $26 = $25 - $dpi | 0;
  if (((($26 | 0) < 0 ? 0 - $26 | 0 : $26) | 0) < 2) $real_dpi$1 = $25; else {
   $32 = (Math_imul($26, $1) | 0) > 0;
   $real_dpi$1 = $32 ? $dpi : $real_dpi$03;
  }
  $33 = $m$04 + 1 | 0;
  $34 = ($real_dpi$1 | 0) != 0;
  if (($33 | 0) < 40 & ($34 ^ 1)) {
   $m$04 = $33;
   $real_dpi$03 = $real_dpi$1;
  } else {
   $$lcssa21 = $3;
   $$lcssa22 = $25;
   $$lcssa23 = $34;
   $real_dpi$1$lcssa = $real_dpi$1;
   break;
  }
 }
 if (!$m_ret) {
  $42 = $$lcssa23 ? $real_dpi$1$lcssa : $dpi;
  return $42 | 0;
 }
 HEAP32[$m_ret >> 2] = ($real_dpi$1$lcssa | 0) == ((($$lcssa22 | 0) == 0 ? 0 : $$lcssa21) | 0) & 1;
 $42 = $$lcssa23 ? $real_dpi$1$lcssa : $dpi;
 return $42 | 0;
}

function _zcheckciteoverflow($lastcite) {
 $lastcite = $lastcite | 0;
 var $$01 = 0, $10 = 0, $17 = 0, $18 = 0, $2 = 0, $25 = 0, $26 = 0, $32 = 0, $34 = 0, $36 = 0, $39 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer10 = 0, $vararg_buffer16 = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer16 = sp + 48 | 0;
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 if ((HEAP32[4098] | 0) != ($lastcite | 0)) {
  STACKTOP = sp;
  return;
 }
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 1423;
 HEAP32[$vararg_buffer + 4 >> 2] = 4;
 HEAP32[$vararg_buffer + 8 >> 2] = $lastcite + 750;
 HEAP32[$vararg_buffer + 12 >> 2] = $lastcite;
 _fprintf($2, 1023, $vararg_buffer) | 0;
 HEAP32[4099] = _xrealloc(HEAP32[4099] | 0, (HEAP32[4098] << 2) + 3004 | 0) | 0;
 $9 = HEAP32[3989] | 0;
 $10 = HEAP32[4098] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 1433;
 HEAP32[$vararg_buffer4 + 4 >> 2] = 4;
 HEAP32[$vararg_buffer4 + 8 >> 2] = $10 + 750;
 HEAP32[$vararg_buffer4 + 12 >> 2] = $10;
 _fprintf($9, 1023, $vararg_buffer4) | 0;
 HEAP32[4100] = _xrealloc(HEAP32[4100] | 0, (HEAP32[4098] << 2) + 3004 | 0) | 0;
 $17 = HEAP32[3989] | 0;
 $18 = HEAP32[4098] | 0;
 HEAP32[$vararg_buffer10 >> 2] = 1443;
 HEAP32[$vararg_buffer10 + 4 >> 2] = 4;
 HEAP32[$vararg_buffer10 + 8 >> 2] = $18 + 750;
 HEAP32[$vararg_buffer10 + 12 >> 2] = $18;
 _fprintf($17, 1023, $vararg_buffer10) | 0;
 HEAP32[4101] = _xrealloc(HEAP32[4101] | 0, (HEAP32[4098] << 2) + 3004 | 0) | 0;
 $25 = HEAP32[3989] | 0;
 $26 = HEAP32[4098] | 0;
 HEAP32[$vararg_buffer16 >> 2] = 1456;
 HEAP32[$vararg_buffer16 + 4 >> 2] = 4;
 HEAP32[$vararg_buffer16 + 8 >> 2] = $26 + 750;
 HEAP32[$vararg_buffer16 + 12 >> 2] = $26;
 _fprintf($25, 1023, $vararg_buffer16) | 0;
 $32 = _xrealloc(HEAP32[4102] | 0, (HEAP32[4098] << 2) + 3004 | 0) | 0;
 HEAP32[4102] = $32;
 $34 = (HEAP32[4098] | 0) + 750 | 0;
 HEAP32[4098] = $34;
 if (($34 | 0) <= ($lastcite | 0)) {
  STACKTOP = sp;
  return;
 }
 $36 = HEAP32[4100] | 0;
 $$01 = $lastcite;
 while (1) {
  HEAP32[$36 + ($$01 << 2) >> 2] = 0;
  HEAP32[$32 + ($$01 << 2) >> 2] = 0;
  $39 = $$01 + 1 | 0;
  if (($39 | 0) < (HEAP32[4098] | 0)) $$01 = $39; else break;
 }
 STACKTOP = sp;
 return;
}

function _str_list_concat_elements($target, $more) {
 $target = $target | 0;
 $more = $more | 0;
 var $$lcssa22 = 0, $$pre = 0, $0 = 0, $11 = 0, $14 = 0, $18 = 0, $19 = 0, $2 = 0, $21 = 0, $22 = 0, $24 = 0, $32 = 0, $33 = 0, $36 = 0, $41 = 0, $45 = 0, $46 = 0, $47 = 0, $6 = 0, $8 = 0, $i$02 = 0, $i1$06 = 0, $i1$13 = 0, $j$011 = 0, $new_len$010 = 0, $new_len$1$lcssa = 0, $new_len$1$lcssa$lcssa = 0, $new_len$15 = 0;
 $0 = HEAP32[$more >> 2] | 0;
 if (!$0) return;
 $2 = HEAP32[$target >> 2] | 0;
 if (!$2) {
  HEAP32[$target >> 2] = $0;
  $6 = $target + 4 | 0;
  HEAP32[$6 >> 2] = _xmalloc($0 << 2) | 0;
  $8 = HEAP32[$more + 4 >> 2] | 0;
  $i$02 = 0;
  while (1) {
   $11 = _xstrdup(HEAP32[$8 + ($i$02 << 2) >> 2] | 0) | 0;
   HEAP32[(HEAP32[$6 >> 2] | 0) + ($i$02 << 2) >> 2] = $11;
   $14 = $i$02 + 1 | 0;
   if (($14 | 0) == ($0 | 0)) break; else $i$02 = $14;
  }
  return;
 }
 $18 = _xmalloc(Math_imul($0 << 2, $2) | 0) | 0;
 $19 = $target + 4 | 0;
 $21 = HEAP32[$more + 4 >> 2] | 0;
 $$pre = HEAP32[$target >> 2] | 0;
 $22 = $$pre;
 $45 = $$pre;
 $j$011 = 0;
 $new_len$010 = 0;
 while (1) {
  if (!$22) {
   $46 = $45;
   $47 = 0;
   $new_len$1$lcssa = $new_len$010;
  } else {
   $24 = $21 + ($j$011 << 2) | 0;
   $i1$06 = 0;
   $new_len$15 = $new_len$010;
   while (1) {
    HEAP32[$18 + ($new_len$15 << 2) >> 2] = _concat(HEAP32[(HEAP32[$19 >> 2] | 0) + ($i1$06 << 2) >> 2] | 0, HEAP32[$24 >> 2] | 0) | 0;
    $32 = $new_len$15 + 1 | 0;
    $33 = $i1$06 + 1 | 0;
    if (($33 | 0) == (HEAP32[$target >> 2] | 0)) {
     $46 = $33;
     $47 = $33;
     $new_len$1$lcssa = $32;
     break;
    } else {
     $i1$06 = $33;
     $new_len$15 = $32;
    }
   }
  }
  $36 = $j$011 + 1 | 0;
  if (($36 | 0) == ($0 | 0)) {
   $$lcssa22 = $46;
   $new_len$1$lcssa$lcssa = $new_len$1$lcssa;
   break;
  } else {
   $22 = $47;
   $45 = $46;
   $j$011 = $36;
   $new_len$010 = $new_len$1$lcssa;
  }
 }
 if ($$lcssa22 | 0) {
  $i1$13 = 0;
  while (1) {
   _free(HEAP32[(HEAP32[$19 >> 2] | 0) + ($i1$13 << 2) >> 2] | 0);
   $41 = $i1$13 + 1 | 0;
   if (($41 | 0) == (HEAP32[$target >> 2] | 0)) break; else $i1$13 = $41;
  }
 }
 _free(HEAP32[$19 >> 2] | 0);
 HEAP32[$target >> 2] = $new_len$1$lcssa$lcssa;
 HEAP32[$19 >> 2] = $18;
 return;
}

function _do_subdir($kpse, $str_list_ptr, $elt, $elt_length, $post) {
 $kpse = $kpse | 0;
 $str_list_ptr = $str_list_ptr | 0;
 $elt = $elt | 0;
 $elt_length = $elt_length | 0;
 $post = $post | 0;
 var $0 = 0, $17 = 0, $19 = 0, $21 = 0, $22 = 0, $23 = 0, $27 = 0, $29 = 0, $37 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $name = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $name = sp + 12 | 0;
 $0 = sp;
 _fn_copy0($0, $elt, $elt_length);
 HEAP32[$name >> 2] = HEAP32[$0 >> 2];
 HEAP32[$name + 4 >> 2] = HEAP32[$0 + 4 >> 2];
 HEAP32[$name + 8 >> 2] = HEAP32[$0 + 8 >> 2];
 if ((HEAP8[$elt + ($elt_length + -1) >> 0] | 0) != 47) ___assert_fail(13221, 13296, 131, 13330);
 $5 = HEAP32[$name >> 2] | 0;
 $6 = _opendir($5) | 0;
 if (!$6) {
  _fn_free($name);
  STACKTOP = sp;
  return;
 }
 if (!(HEAP8[$post >> 0] | 0)) {
  if ((HEAP8[$5 + ((_strlen($5) | 0) + -1) >> 0] | 0) == 47) $17 = _xstrdup($5) | 0; else $17 = _concat($5, 13340) | 0;
  _str_llist_add($str_list_ptr, $17);
 } else {
  _fn_str_grow($name, $post);
  _expand_elt($kpse, $str_list_ptr, HEAP32[$name >> 2] | 0, $elt_length);
  _fn_shrink_to($name, $elt_length);
 }
 $19 = _readdir($6) | 0;
 if ($19 | 0) {
  $21 = $name + 8 | 0;
  $23 = $19;
  while (1) {
   $22 = $23 + 19 | 0;
   if ((HEAP8[$22 >> 0] | 0) != 46) {
    _fn_str_grow($name, $22);
    $27 = _kpathsea_dir_links($kpse, HEAP32[$name >> 2] | 0, 0) | 0;
    do if (($27 | 0) > -1) {
     $29 = HEAP32[$21 >> 2] | 0;
     _fn_str_grow($name, 13340);
     if (HEAP8[$post >> 0] | 0) {
      _fn_str_grow($name, $post);
      _expand_elt($kpse, $str_list_ptr, HEAP32[$name >> 2] | 0, $29);
      _fn_shrink_to($name, $29);
     }
     if (($27 | 0) != 2) {
      _do_subdir($kpse, $str_list_ptr, HEAP32[$name >> 2] | 0, $29, $post);
      break;
     }
     if (!(HEAP8[$post >> 0] | 0)) {
      $37 = HEAP32[$name >> 2] | 0;
      if ((HEAP8[$37 + ((_strlen($37) | 0) + -1) >> 0] | 0) == 47) $45 = _xstrdup($37) | 0; else $45 = _concat($37, 13340) | 0;
      _str_llist_add($str_list_ptr, $45);
     }
    } while (0);
    _fn_shrink_to($name, $elt_length);
   }
   $46 = _readdir($6) | 0;
   if (!$46) break; else $23 = $46;
  }
 }
 _fn_free($name);
 _xclosedir($6);
 STACKTOP = sp;
 return;
}

function _xinttochr() {
 var $$lcssa = 0, $$lcssa10 = 0, $$lcssa11 = 0, $0 = 0, $1 = 0, $10 = 0, $13 = 0, $15 = 0, $19 = 0, $21 = 0, $22 = 0, $25 = 0, $27 = 0, $6 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer6 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer6 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 $1 = HEAP32[4345] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   if ($1 >>> 0 > 127) {
    $9 = HEAP32[3989] | 0;
    HEAP32[$vararg_buffer >> 2] = $1;
    HEAP32[$vararg_buffer + 4 >> 2] = 4072;
    _fprintf($9, 2418, $vararg_buffer) | 0;
    $10 = HEAP32[3990] | 0;
    HEAP32[$vararg_buffer2 >> 2] = HEAP32[4345];
    HEAP32[$vararg_buffer2 + 4 >> 2] = 4072;
    _fprintf($10, 2418, $vararg_buffer2) | 0;
    _bstexwarnprint();
    _zpushlitstk(HEAP32[4301] | 0, 1);
    STACKTOP = sp;
    return;
   }
   $6 = HEAP32[4237] | 0;
   $7 = HEAP32[4043] | 0;
   if (($6 | 0) < ($7 | 0)) {
    $$lcssa = $6;
    $25 = $1;
    $27 = HEAP32[4042] | 0;
   } else {
    $15 = $7;
    while (1) {
     $13 = HEAP32[3989] | 0;
     HEAP32[$vararg_buffer6 >> 2] = 1161;
     HEAP32[$vararg_buffer6 + 4 >> 2] = 1;
     HEAP32[$vararg_buffer6 + 8 >> 2] = $15 + 65e3;
     HEAP32[$vararg_buffer6 + 12 >> 2] = $15;
     _fprintf($13, 1023, $vararg_buffer6) | 0;
     $19 = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
     HEAP32[4042] = $19;
     $21 = (HEAP32[4043] | 0) + 65e3 | 0;
     HEAP32[4043] = $21;
     $22 = HEAP32[4237] | 0;
     if (($22 | 0) < ($21 | 0)) {
      $$lcssa10 = $19;
      $$lcssa11 = $22;
      break;
     } else $15 = $21;
    }
    $$lcssa = $$lcssa11;
    $25 = HEAP32[4345] | 0;
    $27 = $$lcssa10;
   }
   HEAP8[$27 + $$lcssa >> 0] = $25;
   HEAP32[4237] = (HEAP32[4237] | 0) + 1;
   _zpushlitstk(_makestring() | 0, 1);
   STACKTOP = sp;
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit($1, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 STACKTOP = sp;
 return;
}

function _xequals() {
 var $$pre$i = 0, $0 = 0, $1 = 0, $18 = 0, $19 = 0, $22 = 0, $23 = 0, $26 = 0, $31 = 0, $35 = 0, $39 = 0, $42 = 0, $45 = 0, $46 = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 $1 = HEAP8[26649] | 0;
 if ($0 << 24 >> 24 != $1 << 24 >> 24) {
  if (!($0 << 24 >> 24 == 4 | $1 << 24 >> 24 == 4)) {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3656, 2, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3656, 2, 1, HEAP32[3990] | 0) | 0;
   _zprintstklit(HEAP32[4365] | 0, HEAP8[26649] | 0);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   _fwrite(3659, 37, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3659, 37, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
  _zpushlitstk(0, 0);
  return;
 }
 switch ($0 << 24 >> 24) {
 case 1:
 case 0:
  {
   $18 = HEAP32[4365] | 0;
   $19 = HEAP32[4345] | 0;
   if (!($0 << 24 >> 24)) if (($18 | 0) == ($19 | 0)) {
    _zpushlitstk(1, 0);
    return;
   } else {
    _zpushlitstk(0, 0);
    return;
   }
   $22 = HEAP32[4041] | 0;
   $23 = $22 + ($18 + 1 << 2) | 0;
   $26 = HEAP32[$22 + ($18 << 2) >> 2] | 0;
   $31 = $22 + ($19 << 2) | 0;
   L19 : do if (((HEAP32[$23 >> 2] | 0) - $26 | 0) == ((HEAP32[$22 + ($19 + 1 << 2) >> 2] | 0) - (HEAP32[$31 >> 2] | 0) | 0)) {
    HEAP32[4238] = $26;
    $35 = HEAP32[$31 >> 2] | 0;
    HEAP32[4239] = $35;
    if (($26 | 0) < (HEAP32[$23 >> 2] | 0)) {
     $$pre$i = HEAP32[4042] | 0;
     $39 = $26;
     $42 = $35;
     while (1) {
      if ((HEAP8[$$pre$i + $39 >> 0] | 0) != (HEAP8[$$pre$i + $42 >> 0] | 0)) break L19;
      $45 = $39 + 1 | 0;
      HEAP32[4238] = $45;
      $46 = $42 + 1 | 0;
      HEAP32[4239] = $46;
      if (($45 | 0) < (HEAP32[$23 >> 2] | 0)) {
       $39 = $45;
       $42 = $46;
      } else break;
     }
    }
    _zpushlitstk(1, 0);
    return;
   } while (0);
   _zpushlitstk(0, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3697, 29, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3697, 29, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _kpathsea_tilde_expand($kpse, $name) {
 $kpse = $kpse | 0;
 $name = $name | 0;
 var $$0 = 0, $$03 = 0, $1 = 0, $12 = 0, $17 = 0, $18 = 0, $20 = 0, $24 = 0, $28 = 0, $6 = 0, $7 = 0, $c$0 = 0, $c$0$lcssa = 0, $c$1 = 0, $c$2 = 0, $expansion$0 = 0, $home$0 = 0, $home$1 = 0, $prefix$0 = 0, $prefix$02 = 0, label = 0;
 if (!$name) ___assert_fail(12234, 12239, 53, 12270);
 $1 = HEAP8[$name >> 0] | 0;
 if ($1 << 24 >> 24 == 33) if ((HEAP8[$name + 1 >> 0] | 0) == 33) {
  $6 = $name + 2 | 0;
  $$0 = $6;
  $7 = HEAP8[$6 >> 0] | 0;
  $prefix$0 = 12292;
  label = 6;
 } else {
  $$03 = $name;
  $prefix$02 = 30748;
 } else {
  $$0 = $name;
  $7 = $1;
  $prefix$0 = 30748;
  label = 6;
 }
 if ((label | 0) == 6) if ($7 << 24 >> 24 == 126) {
  $12 = $$0 + 1 | 0;
  switch (HEAP8[$12 >> 0] | 0) {
  case 47:
  case 0:
   {
    $24 = _getenv(12295) | 0;
    $c$1 = 1;
    $home$0 = $24 | 0 ? $24 : 15912;
    break;
   }
  default:
   {
    $c$0 = 2;
    L11 : while (1) {
     switch (HEAP8[$$0 + $c$0 >> 0] | 0) {
     case 0:
     case 47:
      {
       $c$0$lcssa = $c$0;
       break L11;
       break;
      }
     default:
      {}
     }
     $c$0 = $c$0 + 1 | 0;
    }
    $17 = _xmalloc($c$0$lcssa) | 0;
    $18 = $c$0$lcssa + -1 | 0;
    _strncpy($17, $12, $18) | 0;
    HEAP8[$17 + $18 >> 0] = 0;
    $20 = _getpwnam($17 | 0) | 0;
    _free($17);
    if (!$20) {
     $c$1 = $c$0$lcssa;
     $home$0 = 15912;
    } else {
     $c$1 = $c$0$lcssa;
     $home$0 = HEAP32[$20 + 20 >> 2] | 0;
    }
   }
  }
  if ((HEAP8[$home$0 >> 0] | 0) == 47) {
   $28 = $home$0 + 1 | 0;
   $home$1 = (HEAP8[$28 >> 0] | 0) == 47 ? $28 : $home$0;
  } else $home$1 = $home$0;
  if (!(HEAP8[$$0 + $c$1 >> 0] | 0)) $c$2 = $c$1; else $c$2 = ((HEAP8[$home$1 + ((_strlen($home$1) | 0) + -1) >> 0] | 0) == 47 & 1) + $c$1 | 0;
  $expansion$0 = _concat3($prefix$0, $home$1, $$0 + $c$2 | 0) | 0;
  return $expansion$0 | 0;
 } else {
  $$03 = $$0;
  $prefix$02 = $prefix$0;
 }
 $expansion$0 = (HEAP8[$prefix$02 >> 0] | 0) == 0 ? $$03 : $$03 + -2 | 0;
 return $expansion$0 | 0;
}

function _parsearguments() {
 var $12 = 0, $18 = 0, $31 = 0, $longoptions = 0, $optionindex = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 $vararg_buffer = sp;
 $longoptions = sp + 16 | 0;
 $optionindex = sp + 8 | 0;
 HEAP32[4669] = 1;
 HEAP32[4689] = 2;
 HEAP32[$longoptions >> 2] = 5716;
 HEAP32[$longoptions + 4 >> 2] = 0;
 HEAP32[$longoptions + 8 >> 2] = 18676;
 HEAP32[$longoptions + 12 >> 2] = 0;
 HEAP32[$longoptions + 16 >> 2] = 5722;
 HEAP32[$longoptions + 20 >> 2] = 1;
 HEAP32[$longoptions + 24 >> 2] = 0;
 HEAP32[$longoptions + 28 >> 2] = 0;
 HEAP32[$longoptions + 32 >> 2] = 5736;
 HEAP32[$longoptions + 36 >> 2] = 0;
 HEAP32[$longoptions + 40 >> 2] = 0;
 HEAP32[$longoptions + 44 >> 2] = 0;
 HEAP32[$longoptions + 48 >> 2] = 5741;
 $12 = $longoptions + 52 | 0;
 HEAP32[$12 >> 2] = 0;
 HEAP32[$12 + 4 >> 2] = 0;
 HEAP32[$12 + 8 >> 2] = 0;
 HEAP32[$12 + 12 >> 2] = 0;
 HEAP32[$12 + 16 >> 2] = 0;
 HEAP32[$12 + 20 >> 2] = 0;
 HEAP32[$12 + 24 >> 2] = 0;
 L1 : while (1) {
  switch (_getopt_long_only(HEAP32[4698] | 0, HEAP32[4699] | 0, 30748, $longoptions, $optionindex) | 0) {
  case -1:
   {
    label = 10;
    break L1;
    break;
   }
  case 63:
   {
    label = 3;
    break L1;
    break;
   }
  default:
   {}
  }
  $18 = HEAP32[$longoptions + (HEAP32[$optionindex >> 2] << 4) >> 2] | 0;
  if (!(_strcmp($18, 5722) | 0)) {
   HEAP32[4689] = _atoi(HEAP32[5750] | 0) | 0;
   continue;
  }
  if (!(_strcmp($18, 5736) | 0)) {
   label = 7;
   break;
  }
  if (!(_strcmp($18, 5741) | 0)) {
   label = 9;
   break;
  }
 }
 if ((label | 0) == 3) _usage(5649); else if ((label | 0) == 7) _usagehelp(8, 0); else if ((label | 0) == 9) _printversionandexit(5749, 5779, 0, 0); else if ((label | 0) == 10) if (((HEAP32[18] | 0) + 1 | 0) == (HEAP32[4698] | 0)) {
  STACKTOP = sp;
  return;
 } else {
  $31 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = 5649;
  HEAP32[$vararg_buffer + 4 >> 2] = 5800;
  _fprintf($31, 5794, $vararg_buffer) | 0;
  _usage(5649);
 }
}

function _printrecursionillegal() {
 var $$lcssa = 0, $0 = 0, $1 = 0, $15 = 0, $16 = 0, $18 = 0, $19 = 0, $21 = 0, $29 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $i$01$i$i = 0, $i$01$i1$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 2915;
 _fprintf($0, 960, $vararg_buffer) | 0;
 $1 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 2915;
 _fprintf($1, 960, $vararg_buffer1) | 0;
 _fwrite(2957, 9, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2957, 9, 1, HEAP32[3990] | 0) | 0;
 $4 = HEAP32[3990] | 0;
 $5 = HEAP32[4044] | 0;
 $6 = HEAP32[4045] | 0;
 if (($5 | 0) < ($6 | 0)) {
  $i$01$i$i = $5;
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i$i >> 0] | 0) >> 0] | 0, $4) | 0;
   $15 = $i$01$i$i + 1 | 0;
   $16 = HEAP32[4045] | 0;
   if (($15 | 0) < ($16 | 0)) $i$01$i$i = $15; else {
    $$lcssa = $16;
    break;
   }
  }
  $19 = HEAP32[4044] | 0;
  $21 = $$lcssa;
 } else {
  $19 = $5;
  $21 = $6;
 }
 $18 = HEAP32[3989] | 0;
 if (($19 | 0) < ($21 | 0)) $i$01$i1$i = $19; else {
  $32 = $18;
  HEAP32[$vararg_buffer4 >> 2] = 2967;
  _fprintf($32, 960, $vararg_buffer4) | 0;
  $33 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer7 >> 2] = 2967;
  _fprintf($33, 960, $vararg_buffer7) | 0;
  _skiptokenprint();
  STACKTOP = sp;
  return;
 }
 while (1) {
  _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $18) | 0;
  $29 = $i$01$i1$i + 1 | 0;
  if (($29 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $29; else break;
 }
 $32 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 2967;
 _fprintf($32, 960, $vararg_buffer4) | 0;
 $33 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 2967;
 _fprintf($33, 960, $vararg_buffer7) | 0;
 _skiptokenprint();
 STACKTOP = sp;
 return;
}

function ___stpcpy($d, $s) {
 $d = $d | 0;
 $s = $s | 0;
 var $$0$lcssa = 0, $$01$lcssa = 0, $$0115 = 0, $$016 = 0, $$03 = 0, $$1$ph = 0, $$12$ph = 0, $$128 = 0, $$19 = 0, $0 = 0, $10 = 0, $14 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $29 = 0, $31 = 0, $32 = 0, $33 = 0, $7 = 0, $9 = 0, $wd$0$lcssa = 0, $wd$010 = 0, $ws$0$lcssa = 0, $ws$011 = 0, label = 0;
 $0 = $s;
 L1 : do if (!(($0 ^ $d) & 3)) {
  if (!($0 & 3)) {
   $$0$lcssa = $s;
   $$01$lcssa = $d;
  } else {
   $$0115 = $d;
   $$016 = $s;
   while (1) {
    $7 = HEAP8[$$016 >> 0] | 0;
    HEAP8[$$0115 >> 0] = $7;
    if (!($7 << 24 >> 24)) {
     $$03 = $$0115;
     break L1;
    }
    $9 = $$016 + 1 | 0;
    $10 = $$0115 + 1 | 0;
    if (!($9 & 3)) {
     $$0$lcssa = $9;
     $$01$lcssa = $10;
     break;
    } else {
     $$0115 = $10;
     $$016 = $9;
    }
   }
  }
  $14 = HEAP32[$$0$lcssa >> 2] | 0;
  if (!(($14 & -2139062144 ^ -2139062144) & $14 + -16843009)) {
   $22 = $14;
   $wd$010 = $$01$lcssa;
   $ws$011 = $$0$lcssa;
   while (1) {
    $20 = $ws$011 + 4 | 0;
    $21 = $wd$010 + 4 | 0;
    HEAP32[$wd$010 >> 2] = $22;
    $23 = HEAP32[$20 >> 2] | 0;
    if (!(($23 & -2139062144 ^ -2139062144) & $23 + -16843009)) {
     $22 = $23;
     $wd$010 = $21;
     $ws$011 = $20;
    } else {
     $wd$0$lcssa = $21;
     $ws$0$lcssa = $20;
     break;
    }
   }
  } else {
   $wd$0$lcssa = $$01$lcssa;
   $ws$0$lcssa = $$0$lcssa;
  }
  $$1$ph = $ws$0$lcssa;
  $$12$ph = $wd$0$lcssa;
  label = 8;
 } else {
  $$1$ph = $s;
  $$12$ph = $d;
  label = 8;
 } while (0);
 if ((label | 0) == 8) {
  $29 = HEAP8[$$1$ph >> 0] | 0;
  HEAP8[$$12$ph >> 0] = $29;
  if (!($29 << 24 >> 24)) $$03 = $$12$ph; else {
   $$128 = $$12$ph;
   $$19 = $$1$ph;
   while (1) {
    $31 = $$19 + 1 | 0;
    $32 = $$128 + 1 | 0;
    $33 = HEAP8[$31 >> 0] | 0;
    HEAP8[$32 >> 0] = $33;
    if (!($33 << 24 >> 24)) {
     $$03 = $32;
     break;
    } else {
     $$128 = $32;
     $$19 = $31;
    }
   }
  }
 }
 return $$03 | 0;
}

function _init_maketex($kpse, $fmt, $dflt_prog, $varargs) {
 $kpse = $kpse | 0;
 $fmt = $fmt | 0;
 $dflt_prog = $dflt_prog | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $1 = 0, $16 = 0, $17 = 0, $20 = 0, $24 = 0, $25 = 0, $28 = 0, $3 = 0, $34 = 0, $35 = 0, $4 = 0, $41 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $ap = 0, $dflt_prog$ = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 $0 = $kpse + 132 + ($fmt * 68 | 0) + 44 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $dflt_prog$ = ($1 | 0) == 0 ? $dflt_prog : $1;
 $3 = _uppercasify($dflt_prog$) | 0;
 $4 = _kpathsea_var_value($kpse, $3) | 0;
 HEAP32[$0 >> 2] = $dflt_prog$;
 $5 = $kpse + 132 + ($fmt * 68 | 0) + 48 | 0;
 HEAP32[$5 >> 2] = 0;
 $6 = _xmalloc(8) | 0;
 $7 = $kpse + 132 + ($fmt * 68 | 0) + 52 | 0;
 HEAP32[$7 >> 2] = $6;
 $8 = HEAP32[$5 >> 2] | 0;
 HEAP32[$5 >> 2] = $8 + 1;
 HEAP32[$6 + ($8 << 2) >> 2] = $dflt_prog;
 HEAP32[$ap >> 2] = $varargs;
 $16 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
 $17 = HEAP32[$16 >> 2] | 0;
 HEAP32[$ap >> 2] = $16 + 4;
 if ($17 | 0) {
  $20 = HEAP32[$5 >> 2] | 0;
  $28 = $17;
  while (1) {
   HEAP32[$5 >> 2] = $20 + 1;
   $24 = _xrealloc(HEAP32[$7 >> 2] | 0, ($20 << 2) + 8 | 0) | 0;
   HEAP32[$7 >> 2] = $24;
   $25 = HEAP32[$5 >> 2] | 0;
   HEAP32[$24 + ($25 + -1 << 2) >> 2] = $28;
   $34 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $35 = HEAP32[$34 >> 2] | 0;
   HEAP32[$ap >> 2] = $34 + 4;
   if (!$35) break; else {
    $20 = $25;
    $28 = $35;
   }
  }
 }
 HEAP32[(HEAP32[$7 >> 2] | 0) + (HEAP32[$5 >> 2] << 2) >> 2] = 0;
 if (!$4) {
  _free($3);
  STACKTOP = sp;
  return;
 }
 $41 = HEAP8[$4 >> 0] | 0;
 if (!($41 << 24 >> 24)) {
  _free($3);
  STACKTOP = sp;
  return;
 }
 $43 = $kpse + 132 + ($fmt * 68 | 0) + 60 | 0;
 if ((HEAP32[$43 >> 2] | 0) >>> 0 > 3) {
  _free($3);
  STACKTOP = sp;
  return;
 }
 HEAP32[$kpse + 132 + ($fmt * 68 | 0) + 56 >> 2] = $41 << 24 >> 24 == 49 & 1;
 HEAP32[$43 >> 2] = 3;
 _free($3);
 STACKTOP = sp;
 return;
}

function _kpathsea_xputenv($kpse, $var, $value) {
 $kpse = $kpse | 0;
 $var = $var | 0;
 $value = $value | 0;
 var $0 = 0, $12 = 0, $14 = 0, $2 = 0, $21 = 0, $29 = 0, $3 = 0, $30 = 0, $33 = 0, $34 = 0, $39 = 0, $4 = 0, $7 = 0, $cur_loc$02 = 0, $cur_loc$04 = 0, $cur_loc$04$lcssa = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = _concat3($var, 12701, $value) | 0;
 $2 = (_strlen($var) | 0) + 1 | 0;
 $3 = $kpse + 4164 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 L1 : do if (!$4) $cur_loc$02 = 0; else {
  $7 = HEAP32[$kpse + 4160 >> 2] | 0;
  $cur_loc$04 = 0;
  while (1) {
   if (!(_strncmp(HEAP32[$7 + ($cur_loc$04 << 2) >> 2] | 0, $0, $2) | 0)) {
    $cur_loc$04$lcssa = $cur_loc$04;
    break;
   }
   $12 = $cur_loc$04 + 1 | 0;
   if (($12 | 0) == ($4 | 0)) {
    $cur_loc$02 = $4;
    break L1;
   } else $cur_loc$04 = $12;
  }
  $14 = _getenv($var | 0) | 0;
  if (!$14) $cur_loc$02 = $cur_loc$04$lcssa; else if (!(_strcmp($14, $0 + $2 | 0) | 0)) {
   _free($0);
   STACKTOP = sp;
   return;
  } else $cur_loc$02 = $cur_loc$04$lcssa;
 } while (0);
 if ((_putenv($0 | 0) | 0) < 0) {
  $21 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[$kpse + 104 >> 2];
  _fprintf($21, 12703, $vararg_buffer) | 0;
  HEAP32[$vararg_buffer1 >> 2] = $0;
  _fprintf($21, 12715, $vararg_buffer1) | 0;
  _fwrite(12726, 2, 1, $21) | 0;
  _exit(1);
 }
 if ((_getenv($var | 0) | 0) != ($0 + $2 | 0)) {
  _free($0);
  STACKTOP = sp;
  return;
 }
 if (($cur_loc$02 | 0) == (HEAP32[$3 >> 2] | 0)) {
  $29 = $cur_loc$02 + 1 | 0;
  HEAP32[$3 >> 2] = $29;
  $30 = $kpse + 4160 | 0;
  $33 = _xrealloc(HEAP32[$30 >> 2] | 0, $29 << 2) | 0;
  HEAP32[$30 >> 2] = $33;
  $39 = $33;
 } else {
  $34 = $kpse + 4160 | 0;
  _free(HEAP32[(HEAP32[$34 >> 2] | 0) + ($cur_loc$02 << 2) >> 2] | 0);
  $39 = HEAP32[$34 >> 2] | 0;
 }
 HEAP32[$39 + ($cur_loc$02 << 2) >> 2] = $0;
 STACKTOP = sp;
 return;
}

function _kpathsea_fontmap_lookup($kpse, $key) {
 $kpse = $kpse | 0;
 $key = $key | 0;
 var $$byval_copy1 = 0, $0 = 0, $1 = 0, $13 = 0, $14 = 0, $18 = 0, $20 = 0, $21 = 0, $22 = 0, $24 = 0, $26 = 0, $27 = 0, $28 = 0, $30 = 0, $32 = 0, $34 = 0, $35 = 0, $5 = 0, $7 = 0, $8 = 0, $elt$04 = 0, $filenames$01$i = 0, $ret$0 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $$byval_copy1 = sp;
 $0 = _find_suffix($key) | 0;
 $1 = $kpse + 64 | 0;
 if (!(HEAP32[$kpse + 68 >> 2] | 0)) {
  $5 = _kpathsea_init_format($kpse, 11) | 0;
  HEAP32[$kpse + 72 >> 2] = $5;
  $7 = _kpathsea_all_path_search($kpse, $5, 10598) | 0;
  _hash_create($$byval_copy1, 4001);
  $8 = $$byval_copy1;
  $13 = HEAP32[$8 + 4 >> 2] | 0;
  $14 = $1;
  HEAP32[$14 >> 2] = HEAP32[$8 >> 2];
  HEAP32[$14 + 4 >> 2] = $13;
  $18 = HEAP32[$7 >> 2] | 0;
  if ($18 | 0) {
   $20 = $18;
   $filenames$01$i = $7;
   while (1) {
    _map_file_parse($kpse, $20);
    $21 = $filenames$01$i + 4 | 0;
    $22 = HEAP32[$21 >> 2] | 0;
    if (!$22) break; else {
     $20 = $22;
     $filenames$01$i = $21;
    }
   }
  }
 };
 HEAP32[$$byval_copy1 >> 2] = HEAP32[$1 >> 2];
 HEAP32[$$byval_copy1 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
 $24 = _hash_lookup($$byval_copy1, $key) | 0;
 $26 = ($0 | 0) != 0;
 if ($26 & ($24 | 0) == 0) {
  $27 = _remove_suffix($key) | 0;
  HEAP32[$$byval_copy1 >> 2] = HEAP32[$1 >> 2];
  HEAP32[$$byval_copy1 + 4 >> 2] = HEAP32[$1 + 4 >> 2];
  $28 = _hash_lookup($$byval_copy1, $27) | 0;
  _free($27);
  $ret$0 = $28;
 } else $ret$0 = $24;
 if (!($26 & ($ret$0 | 0) != 0)) {
  STACKTOP = sp;
  return $ret$0 | 0;
 }
 $30 = HEAP32[$ret$0 >> 2] | 0;
 if (!$30) {
  STACKTOP = sp;
  return $ret$0 | 0;
 } else {
  $32 = $30;
  $elt$04 = $ret$0;
 }
 while (1) {
  HEAP32[$elt$04 >> 2] = _extend_filename($32, $0) | 0;
  $34 = $elt$04 + 4 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  if (!$35) break; else {
   $32 = $35;
   $elt$04 = $34;
  }
 }
 STACKTOP = sp;
 return $ret$0 | 0;
}

function _skiptokenprint() {
 var $$pre = 0, $18 = 0, $19 = 0, $2 = 0, $21 = 0, $23 = 0, $27 = 0, $29 = 0, $3 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $9 = 0, $storemerge$i = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 _putc(45, HEAP32[3989] | 0) | 0;
 _putc(45, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 $3 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer >> 2] = 1501;
 HEAP32[$vararg_buffer + 4 >> 2] = $3;
 HEAP32[$vararg_buffer + 8 >> 2] = 1297;
 _fprintf($2, 1280, $vararg_buffer) | 0;
 $4 = HEAP32[3990] | 0;
 $5 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 1501;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $5;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 1297;
 _fprintf($4, 1280, $vararg_buffer3) | 0;
 $6 = HEAP32[4096] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $6);
 _zoutpoolstr(HEAP32[3989] | 0, $6);
 $9 = HEAP32[4097] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $9);
 _zoutpoolstr(HEAP32[3989] | 0, $9);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 if ((HEAPU8[25620] | 0) < 2) {
  HEAP8[25620] = 2;
  $storemerge$i = 1;
 } else $storemerge$i = (HEAP32[3991] | 0) + 1 | 0;
 HEAP32[3991] = $storemerge$i;
 $18 = HEAP32[4045] | 0;
 HEAP32[4044] = $18;
 $19 = HEAP32[3993] | 0;
 $21 = HEAP8[$19 + $18 >> 0] | 0;
 switch ($21 << 24 >> 24) {
 case 37:
 case 125:
  {
   STACKTOP = sp;
   return;
  }
 default:
  {}
 }
 $$pre = HEAP32[3999] | 0;
 $23 = $21;
 $27 = $18;
 L8 : while (1) {
  if (!(($27 | 0) < ($$pre | 0) ? (HEAP8[25877 + ($23 & 255) >> 0] | 0) != 1 : 0)) {
   label = 8;
   break;
  }
  $29 = $27 + 1 | 0;
  HEAP32[4045] = $29;
  $31 = HEAP8[$19 + $29 >> 0] | 0;
  switch ($31 << 24 >> 24) {
  case 37:
  case 125:
   {
    label = 8;
    break L8;
    break;
   }
  default:
   {
    $23 = $31;
    $27 = $29;
   }
  }
 }
 if ((label | 0) == 8) {
  STACKTOP = sp;
  return;
 }
}

function _kpathsea_readable_file($kpse, $name) {
 $kpse = $kpse | 0;
 $name = $name | 0;
 var $$1 = 0, $11 = 0, $17 = 0, $18 = 0, $8 = 0, $c_len$02 = 0, $c_len$1 = 0, $c_len$1$lcssa = 0, $s$0$t$0 = 0, $s$0$t$0$lcssa = 0, $s$03 = 0, $s$2 = 0, $st = 0, $t$04 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $st = sp;
 _kpathsea_normalize_path($kpse, $name) | 0;
 if (!(_stat($name, $st) | 0)) if ((HEAP32[$st + 24 >> 2] & 61440 | 0) != 16384) {
  $$1 = $name;
  STACKTOP = sp;
  return $$1 | 0;
 }
 switch (HEAP32[(___errno_location() | 0) >> 2] | 0) {
 case 36:
  {
   $8 = HEAP8[$name >> 0] | 0;
   if ($8 << 24 >> 24) {
    $11 = $8;
    $c_len$02 = 0;
    $s$03 = $name;
    $t$04 = $name;
    while (1) {
     $s$0$t$0 = $c_len$02 >>> 0 < 256 ? $s$03 : $t$04;
     if ($11 << 24 >> 24 == 47) if ($c_len$02 >>> 0 > 255) {
      _memmove($s$0$t$0 | 0, $s$03 | 0, (_strlen($s$03) | 0) + 1 | 0) | 0;
      $c_len$1 = 0;
      $s$2 = $s$0$t$0;
     } else {
      $c_len$1 = 0;
      $s$2 = $s$03;
     } else {
      $c_len$1 = $c_len$02 + 1 | 0;
      $s$2 = $s$03;
     }
     $17 = $s$2 + 1 | 0;
     $18 = HEAP8[$17 >> 0] | 0;
     if (!($18 << 24 >> 24)) {
      $c_len$1$lcssa = $c_len$1;
      $s$0$t$0$lcssa = $s$0$t$0;
      break;
     } else {
      $11 = $18;
      $c_len$02 = $c_len$1;
      $s$03 = $17;
      $t$04 = $s$0$t$0;
     }
    }
    if ($c_len$1$lcssa >>> 0 > 255) HEAP8[$s$0$t$0$lcssa >> 0] = 0;
   }
   if (!(_stat($name, $st) | 0)) if ((HEAP32[$st + 24 >> 2] & 61440 | 0) != 16384) {
    $$1 = $name;
    STACKTOP = sp;
    return $$1 | 0;
   }
   $$1 = 0;
   STACKTOP = sp;
   return $$1 | 0;
  }
 case 13:
  {
   if (_kpathsea_tex_hush($kpse, 11604) | 0) {
    $$1 = 0;
    STACKTOP = sp;
    return $$1 | 0;
   }
   _perror($name);
   $$1 = 0;
   STACKTOP = sp;
   return $$1 | 0;
  }
 default:
  {
   $$1 = 0;
   STACKTOP = sp;
   return $$1 | 0;
  }
 }
 return 0;
}

function _compressbibwhite() {
 var $$lcssa$i = 0, $0 = 0, $10 = 0, $12 = 0, $18 = 0, $19 = 0, $21 = 0, $22 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $Result$0 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4251] | 0;
 if (($0 | 0) == (HEAP32[3992] | 0)) {
  $3 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer >> 2] = 2020;
  HEAP32[$vararg_buffer + 4 >> 2] = $0;
  HEAP32[$vararg_buffer + 8 >> 2] = 2045;
  _fprintf($3, 1280, $vararg_buffer) | 0;
  $4 = HEAP32[3990] | 0;
  $5 = HEAP32[3992] | 0;
  HEAP32[$vararg_buffer3 >> 2] = 2020;
  HEAP32[$vararg_buffer3 + 4 >> 2] = $5;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 2045;
  _fprintf($4, 1280, $vararg_buffer3) | 0;
  _biberrprint();
  $Result$0 = 0;
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 HEAP8[(HEAP32[3995] | 0) + $0 >> 0] = 32;
 HEAP32[4251] = (HEAP32[4251] | 0) + 1;
 $12 = HEAP32[4045] | 0;
 while (1) {
  $10 = HEAP32[3993] | 0;
  $18 = HEAP32[3999] | 0;
  $19 = ($12 | 0) < ($18 | 0);
  if ((HEAP8[25877 + (HEAPU8[$10 + $12 >> 0] | 0) >> 0] | 0) == 1 & $19) {
   $22 = $12;
   while (1) {
    $21 = $22 + 1 | 0;
    HEAP32[4045] = $21;
    $29 = ($21 | 0) < ($18 | 0);
    if ($29 & (HEAP8[25877 + (HEAPU8[$10 + $21 >> 0] | 0) >> 0] | 0) == 1) $22 = $21; else {
     $$lcssa$i = $29;
     break;
    }
   }
  } else $$lcssa$i = $19;
  if ($$lcssa$i) {
   $Result$0 = 1;
   label = 10;
   break;
  }
  if (!(_zinputln(HEAP32[(HEAP32[4316] | 0) + (HEAP32[4093] << 2) >> 2] | 0) | 0)) break;
  HEAP32[4146] = (HEAP32[4146] | 0) + 1;
  HEAP32[4045] = 0;
  $12 = 0;
 }
 if ((label | 0) == 10) {
  STACKTOP = sp;
  return $Result$0 | 0;
 }
 _fwrite(1912, 28, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1912, 28, 1, HEAP32[3990] | 0) | 0;
 _biberrprint();
 $Result$0 = 0;
 STACKTOP = sp;
 return $Result$0 | 0;
}

function _open_output($f_ptr, $fopen_mode) {
 $f_ptr = $f_ptr | 0;
 $fopen_mode = $fopen_mode | 0;
 var $11 = 0, $15 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $24 = 0, $27 = 0, $29 = 0, $3 = 0, $34 = 0, $35 = 0, $36 = 0, $5 = 0, $7 = 0, $9 = 0, $fname$0 = 0, $fname$2 = 0, $fname$24 = 0, $fname$25 = 0, label = 0;
 $2 = _kpse_absolute_p((HEAP32[4048] | 0) + 1 | 0, 0) | 0;
 $3 = HEAP32[4700] | 0;
 $5 = ($2 | 0) != 0;
 $7 = (HEAP32[4048] | 0) + 1 | 0;
 if ($5 | ($3 | 0) == 0) $fname$0 = $7; else $fname$0 = _concat3($3, 13340, $7) | 0;
 $9 = _kpse_fopen_trace($fname$0, $fopen_mode) | 0;
 HEAP32[$f_ptr >> 2] = $9;
 if (!$9) {
  $11 = _kpse_var_value(12171) | 0;
  if (!$11) label = 9; else if ($5 | (HEAP8[$11 >> 0] | 0) == 0) label = 9; else {
   $15 = HEAP32[4048] | 0;
   if (($fname$0 | 0) == ($15 + 1 | 0)) $19 = $15; else {
    _free($fname$0);
    $19 = HEAP32[4048] | 0;
   }
   $20 = _concat3($11, 13340, $19 + 1 | 0) | 0;
   $21 = _kpse_fopen_trace($20, $fopen_mode) | 0;
   HEAP32[$f_ptr >> 2] = $21;
   $22 = $21;
   $fname$2 = $20;
  }
  if ((label | 0) == 9) {
   $22 = HEAP32[$f_ptr >> 2] | 0;
   $fname$2 = $fname$0;
  }
  if (!$22) $fname$25 = $fname$2; else {
   $fname$24 = $fname$2;
   label = 11;
  }
 } else {
  $fname$24 = $fname$0;
  label = 11;
 }
 if ((label | 0) == 11) {
  $24 = HEAP32[4048] | 0;
  if (($fname$24 | 0) != ($24 + 1 | 0)) {
   _free($24);
   $27 = _strlen($fname$24) | 0;
   HEAP32[4049] = $27;
   $29 = _xmalloc($27 + 2 | 0) | 0;
   HEAP32[4048] = $29;
   _strcpy($29 + 1 | 0, $fname$24) | 0;
  }
  _recorder_record_name(6143, $fname$24);
  $fname$25 = $fname$24;
 }
 if (($fname$25 | 0) == ((HEAP32[4048] | 0) + 1 | 0)) {
  $34 = HEAP32[$f_ptr >> 2] | 0;
  $35 = ($34 | 0) != 0;
  $36 = $35 & 1;
  return $36 | 0;
 }
 _free($fname$25);
 $34 = HEAP32[$f_ptr >> 2] | 0;
 $35 = ($34 | 0) != 0;
 $36 = $35 & 1;
 return $36 | 0;
}

function _kpathsea_brace_expand_element($kpse, $elt) {
 $kpse = $kpse | 0;
 $elt = $elt | 0;
 var $$lcssa = 0, $$pre = 0, $$pre7 = 0, $0 = 0, $1 = 0, $12 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $22 = 0, $3 = 0, $6 = 0, $8 = 0, $9 = 0, $expansions = 0, $i$03 = 0, $i$11 = 0, $ret$0$lcssa8 = 0, $ret$02 = 0, $x$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $0 = sp;
 $expansions = sp + 8 | 0;
 HEAP32[$0 >> 2] = $elt;
 _brace_expand($expansions, $0);
 $1 = _xmalloc(1) | 0;
 HEAP8[$1 >> 0] = 0;
 $2 = HEAP32[$expansions >> 2] | 0;
 $3 = ($2 | 0) == 0;
 if ($3) $ret$0$lcssa8 = $1; else {
  $$pre = HEAP32[$expansions + 4 >> 2] | 0;
  $i$03 = 0;
  $ret$02 = $1;
  while (1) {
   $6 = $$pre + ($i$03 << 2) | 0;
   $8 = _kpathsea_var_expand($kpse, HEAP32[$6 >> 2] | 0) | 0;
   $9 = _kpathsea_tilde_expand($kpse, $8) | 0;
   if (($9 | 0) != ($8 | 0)) _free($8);
   if (!$9) label = 10; else {
    $12 = HEAP32[$6 >> 2] | 0;
    if (!$12) label = 10; else if (!(_strcmp($9, $12) | 0)) $x$0 = $9; else label = 10;
   }
   if ((label | 0) == 10) {
    label = 0;
    $16 = _kpathsea_brace_expand_element($kpse, $9) | 0;
    _free($9);
    $x$0 = $16;
   }
   $17 = _concat3($ret$02, $x$0, 10587) | 0;
   _free($ret$02);
   _free($x$0);
   $18 = $i$03 + 1 | 0;
   if (($18 | 0) == ($2 | 0)) {
    $$lcssa = $17;
    break;
   } else {
    $i$03 = $18;
    $ret$02 = $17;
   }
  }
  if ($3) $ret$0$lcssa8 = $$lcssa; else {
   $$pre7 = HEAP32[$expansions + 4 >> 2] | 0;
   $i$11 = 0;
   while (1) {
    _free(HEAP32[$$pre7 + ($i$11 << 2) >> 2] | 0);
    $22 = $i$11 + 1 | 0;
    if (($22 | 0) == ($2 | 0)) {
     $ret$0$lcssa8 = $$lcssa;
     break;
    } else $i$11 = $22;
   }
  }
 }
 _str_list_free($expansions);
 HEAP8[$ret$0$lcssa8 + ((_strlen($ret$0$lcssa8) | 0) + -1) >> 0] = 0;
 STACKTOP = sp;
 return $ret$0$lcssa8 | 0;
}

function _vfprintf($f, $fmt, $ap) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$ = 0, $$0 = 0, $12 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $21 = 0, $22 = 0, $28 = 0, $32 = 0, $6 = 0, $7 = 0, $ap2 = 0, $internal_buf = 0, $nl_arg = 0, $nl_type = 0, $ret$1 = 0, dest = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 $ap2 = sp + 120 | 0;
 $nl_type = sp + 80 | 0;
 $nl_arg = sp;
 $internal_buf = sp + 136 | 0;
 dest = $nl_type;
 stop = dest + 40 | 0;
 do {
  HEAP32[dest >> 2] = 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 HEAP32[$ap2 >> 2] = HEAP32[$ap >> 2];
 if ((_printf_core(0, $fmt, $ap2, $nl_arg, $nl_type) | 0) < 0) $$0 = -1; else {
  if ((HEAP32[$f + 76 >> 2] | 0) > -1) $32 = ___lockfile($f) | 0; else $32 = 0;
  $6 = HEAP32[$f >> 2] | 0;
  $7 = $6 & 32;
  if ((HEAP8[$f + 74 >> 0] | 0) < 1) HEAP32[$f >> 2] = $6 & -33;
  $12 = $f + 48 | 0;
  if (!(HEAP32[$12 >> 2] | 0)) {
   $16 = $f + 44 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   HEAP32[$16 >> 2] = $internal_buf;
   $18 = $f + 28 | 0;
   HEAP32[$18 >> 2] = $internal_buf;
   $19 = $f + 20 | 0;
   HEAP32[$19 >> 2] = $internal_buf;
   HEAP32[$12 >> 2] = 80;
   $21 = $f + 16 | 0;
   HEAP32[$21 >> 2] = $internal_buf + 80;
   $22 = _printf_core($f, $fmt, $ap2, $nl_arg, $nl_type) | 0;
   if (!$17) $ret$1 = $22; else {
    FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 7]($f, 0, 0) | 0;
    $$ = (HEAP32[$19 >> 2] | 0) == 0 ? -1 : $22;
    HEAP32[$16 >> 2] = $17;
    HEAP32[$12 >> 2] = 0;
    HEAP32[$21 >> 2] = 0;
    HEAP32[$18 >> 2] = 0;
    HEAP32[$19 >> 2] = 0;
    $ret$1 = $$;
   }
  } else $ret$1 = _printf_core($f, $fmt, $ap2, $nl_arg, $nl_type) | 0;
  $28 = HEAP32[$f >> 2] | 0;
  HEAP32[$f >> 2] = $28 | $7;
  if ($32 | 0) ___unlockfile($f);
  $$0 = ($28 & 32 | 0) == 0 ? $ret$1 : -1;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _kpathsea_expand_default($kpse, $path, $fallback) {
 $kpse = $kpse | 0;
 $path = $path | 0;
 $fallback = $fallback | 0;
 var $$lcssa = 0, $$phi$trans$insert = 0, $$pr = 0, $10 = 0, $16 = 0, $17 = 0, $22 = 0, $26 = 0, $3 = 0, $expansion$1 = 0, $loc$0 = 0, $loc$0$lcssa7 = 0, label = 0;
 if (!$fallback) ___assert_fail(10917, 10926, 40, 10960);
 if (!$path) {
  $expansion$1 = _xstrdup($fallback) | 0;
  return $expansion$1 | 0;
 }
 $3 = HEAP8[$path >> 0] | 0;
 if ($3 << 24 >> 24 == 58) if (!(HEAP8[$path + 1 >> 0] | 0)) {
  $expansion$1 = _xstrdup($fallback) | 0;
  return $expansion$1 | 0;
 } else {
  $expansion$1 = _concat($fallback, $path) | 0;
  return $expansion$1 | 0;
 }
 $10 = _strlen($path) | 0;
 if ((HEAP8[$path + ($10 + -1) >> 0] | 0) == 58) {
  $expansion$1 = _concat($path, $fallback) | 0;
  return $expansion$1 | 0;
 } else {
  $$pr = $3;
  $loc$0 = $path;
 }
 L19 : while (1) switch ($$pr << 24 >> 24) {
 case 0:
  {
   label = 15;
   break L19;
   break;
  }
 case 58:
  {
   $16 = $loc$0 + 1 | 0;
   $17 = HEAP8[$16 >> 0] | 0;
   if ($17 << 24 >> 24 == 58) {
    $$lcssa = $16;
    $loc$0$lcssa7 = $loc$0;
    label = 14;
    break L19;
   } else {
    $$pr = $17;
    $loc$0 = $16;
    continue L19;
   }
   break;
  }
 default:
  {
   $$phi$trans$insert = $loc$0 + 1 | 0;
   $$pr = HEAP8[$$phi$trans$insert >> 0] | 0;
   $loc$0 = $$phi$trans$insert;
   continue L19;
  }
 }
 if ((label | 0) == 14) {
  $22 = _xmalloc($10 + 1 + (_strlen($fallback) | 0) | 0) | 0;
  $26 = $loc$0$lcssa7 - $path + 1 | 0;
  _strncpy($22, $path, $26) | 0;
  HEAP8[$22 + $26 >> 0] = 0;
  _strcat($22, $fallback) | 0;
  _strcat($22, $$lcssa) | 0;
  $expansion$1 = $22;
  return $expansion$1 | 0;
 } else if ((label | 0) == 15) {
  $expansion$1 = _xstrdup($path) | 0;
  return $expansion$1 | 0;
 }
 return 0;
}

function _remove_dots($kpse, $dir) {
 $kpse = $kpse | 0;
 $dir = $dir | 0;
 var $$lcssa = 0, $0 = 0, $10 = 0, $13 = 0, $25 = 0, $27 = 0, $28 = 0, $31 = 0, $34 = 0, $8 = 0, $9 = 0, $c$03 = 0, $last$0 = 0, $last$0$lcssa8 = 0, $ret$02 = 0, $ret$1 = 0, $ret$1$lcssa = 0;
 $0 = _kpathsea_filename_component($kpse, $dir) | 0;
 if (!$0) ___assert_fail(11274, 11278, 323, 11312); else {
  $c$03 = $0;
  $ret$02 = 0;
 }
 while (1) {
  L5 : do if (!(_strcmp($c$03, 15912) | 0)) if (!$ret$02) $ret$1 = _xgetcwd() | 0; else $ret$1 = $ret$02; else {
   $8 = ($ret$02 | 0) == 0;
   if (_strcmp($c$03, 11235) | 0) if ($8) {
    $ret$1 = _concat(13340, $c$03) | 0;
    break;
   } else {
    $25 = (HEAP8[$ret$02 + ((_strlen($ret$02) | 0) + -1) >> 0] | 0) == 47;
    $27 = _concat3($ret$02, $25 ? 30748 : 13340, $c$03) | 0;
    _free($ret$02);
    $ret$1 = $27;
    break;
   }
   if ($8) {
    $9 = _xgetcwd() | 0;
    $10 = _xdirname($9) | 0;
    _free($9);
    $ret$1 = $10;
    break;
   }
   $last$0 = _strlen($ret$02) | 0;
   while (1) {
    if (!$last$0) {
     $ret$1 = $ret$02;
     break L5;
    }
    $13 = $last$0 + -1 | 0;
    if ((HEAP8[$ret$02 + $13 >> 0] | 0) == 47) {
     $$lcssa = $13;
     $last$0$lcssa8 = $last$0;
     break;
    } else $last$0 = $13;
   }
   HEAP8[$ret$02 + ($last$0$lcssa8 >>> 0 > 1 ? $$lcssa : 1) >> 0] = 0;
   $ret$1 = $ret$02;
  } while (0);
  $28 = _kpathsea_filename_component($kpse, 0) | 0;
  if (!$28) {
   $ret$1$lcssa = $ret$1;
   break;
  } else {
   $c$03 = $28;
   $ret$02 = $ret$1;
  }
 }
 if (!$ret$1$lcssa) ___assert_fail(11274, 11278, 323, 11312);
 $31 = _strlen($ret$1$lcssa) | 0;
 if (!$31) return $ret$1$lcssa | 0;
 $34 = $ret$1$lcssa + ($31 + -1) | 0;
 if ((HEAP8[$34 >> 0] | 0) != 47) return $ret$1$lcssa | 0;
 HEAP8[$34 >> 0] = 0;
 return $ret$1$lcssa | 0;
}

function _zoutpoolstr($f, $s) {
 $f = $f | 0;
 $s = $s | 0;
 var $10 = 0, $11 = 0, $12 = 0, $14 = 0, $17 = 0, $18 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $i$0 = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer15 = 0, $vararg_buffer2 = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer15 = sp + 40 | 0;
 $vararg_buffer12 = sp + 32 | 0;
 $vararg_buffer9 = sp + 24 | 0;
 $vararg_buffer6 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 if (($s | 0) >= 0) if (((HEAP32[4e3] | 0) + 3 | 0) > ($s | 0) & (HEAP32[4001] | 0) > ($s | 0)) {
  $12 = HEAP32[4041] | 0;
  $14 = HEAP32[$12 + ($s << 2) >> 2] | 0;
  $17 = HEAP32[$12 + ($s + 1 << 2) >> 2] | 0;
  $18 = $17 + -1 | 0;
  if (($14 | 0) < ($17 | 0)) $i$0 = $14; else {
   STACKTOP = sp;
   return;
  }
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[4042] | 0) + $i$0 >> 0] | 0) >> 0] | 0, $f) | 0;
   if (($i$0 | 0) < ($18 | 0)) $i$0 = $i$0 + 1 | 0; else break;
  }
  STACKTOP = sp;
  return;
 }
 $6 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 1138;
 HEAP32[$vararg_buffer + 4 >> 2] = $s;
 _fprintf($6, 1132, $vararg_buffer) | 0;
 $7 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer2 >> 2] = 1138;
 HEAP32[$vararg_buffer2 + 4 >> 2] = $s;
 _fprintf($7, 1132, $vararg_buffer2) | 0;
 $8 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer6 >> 2] = 964;
 _fprintf($8, 960, $vararg_buffer6) | 0;
 $9 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer9 >> 2] = 964;
 _fprintf($9, 960, $vararg_buffer9) | 0;
 $10 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer12 >> 2] = 985;
 _fprintf($10, 960, $vararg_buffer12) | 0;
 $11 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer15 >> 2] = 985;
 _fprintf($11, 960, $vararg_buffer15) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _xinttostr() {
 var $$0$i = 0, $$1$i = 0, $$lcssa = 0, $0 = 0, $1 = 0, $16 = 0, $20 = 0, $21 = 0, $22 = 0, $24 = 0, $25 = 0, $5 = 0, $intptr$0$i = 0, $intptr$1$i = 0, $intptr$1$i$lcssa = 0, $intptr$21$i = 0, $intxptr$02$i = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 $1 = HEAP32[4345] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $5 = HEAP32[3995] | 0;
   if (($1 | 0) < 0) {
    if (!(HEAP32[3992] | 0)) _bufferoverflow();
    HEAP8[$5 >> 0] = 45;
    $$0$i = 0 - $1 | 0;
    $intptr$0$i = 1;
   } else {
    $$0$i = $1;
    $intptr$0$i = 0;
   }
   $$1$i = $$0$i;
   $intptr$1$i = $intptr$0$i;
   while (1) {
    if (($intptr$1$i | 0) == (HEAP32[3992] | 0)) _bufferoverflow();
    HEAP8[$5 + $intptr$1$i >> 0] = (($$1$i | 0) % 10 | 0) + 48;
    $16 = $intptr$1$i + 1 | 0;
    if (($$1$i + 9 | 0) >>> 0 > 18) {
     $$1$i = ($$1$i | 0) / 10 | 0;
     $intptr$1$i = $16;
    } else {
     $$lcssa = $16;
     $intptr$1$i$lcssa = $intptr$1$i;
     break;
    }
   }
   HEAP32[4333] = $$lcssa;
   if (($intptr$0$i | 0) < ($intptr$1$i$lcssa | 0)) {
    $intptr$21$i = $intptr$1$i$lcssa;
    $intxptr$02$i = $intptr$0$i;
    while (1) {
     $20 = $5 + $intxptr$02$i | 0;
     $21 = HEAP8[$20 >> 0] | 0;
     $22 = $5 + $intptr$21$i | 0;
     HEAP8[$20 >> 0] = HEAP8[$22 >> 0] | 0;
     HEAP8[$22 >> 0] = $21;
     $24 = $intptr$21$i + -1 | 0;
     $25 = $intxptr$02$i + 1 | 0;
     if (($25 | 0) < ($24 | 0)) {
      $intptr$21$i = $24;
      $intxptr$02$i = $25;
     } else break;
    }
   }
   _addpoolbufandpush();
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit($1, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(HEAP32[4301] | 0, 1);
 return;
}

function _xnumnames() {
 var $0 = 0, $10 = 0, $14 = 0, $15 = 0, $17 = 0, $20 = 0, $24 = 0, $26 = 0, $28 = 0, $31 = 0, $35 = 0, $4 = 0, $5 = 0, $7 = 0, $storemerge$lcssa = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   HEAP32[4333] = 0;
   $4 = HEAP32[4345] | 0;
   $5 = HEAP32[4041] | 0;
   $7 = HEAP32[$5 + ($4 << 2) >> 2] | 0;
   HEAP32[4238] = $7;
   $10 = HEAP32[$5 + ($4 + 1 << 2) >> 2] | 0;
   HEAP32[4239] = $10;
   if (($10 - $7 | 0) > (HEAP32[3992] | 0)) {
    _bufferoverflow();
    $14 = HEAP32[4333] | 0;
    $15 = HEAP32[4238] | 0;
    $17 = HEAP32[4239] | 0;
   } else {
    $14 = 0;
    $15 = $7;
    $17 = $10;
   }
   HEAP32[4251] = $14;
   if (($15 | 0) < ($17 | 0)) {
    $20 = $15;
    $24 = $14;
    while (1) {
     HEAP8[(HEAP32[3995] | 0) + $24 >> 0] = HEAP8[(HEAP32[4042] | 0) + $20 >> 0] | 0;
     $26 = (HEAP32[4251] | 0) + 1 | 0;
     HEAP32[4251] = $26;
     $28 = (HEAP32[4238] | 0) + 1 | 0;
     HEAP32[4238] = $28;
     if (($28 | 0) < (HEAP32[4239] | 0)) {
      $20 = $28;
      $24 = $26;
     } else {
      $31 = $26;
      break;
     }
    }
   } else $31 = $14;
   HEAP32[4333] = $31;
   HEAP32[4251] = 0;
   HEAP32[4379] = 0;
   if (($31 | 0) > 0) {
    do {
     _znamescanforand(HEAP32[4345] | 0);
     $35 = (HEAP32[4379] | 0) + 1 | 0;
     HEAP32[4379] = $35;
    } while ((HEAP32[4251] | 0) < (HEAP32[4333] | 0));
    $storemerge$lcssa = $35;
   } else $storemerge$lcssa = 0;
   _zpushlitstk($storemerge$lcssa, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function ___stdio_read($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $$0 = 0, $$cast = 0, $0 = 0, $1 = 0, $15 = 0, $2 = 0, $27 = 0, $30 = 0, $31 = 0, $7 = 0, $cnt$0 = 0, $iov = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $iov = sp + 32 | 0;
 HEAP32[$iov >> 2] = $buf;
 $0 = $iov + 4 | 0;
 $1 = $f + 48 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 HEAP32[$0 >> 2] = $len - (($2 | 0) != 0 & 1);
 $7 = $f + 44 | 0;
 HEAP32[$iov + 8 >> 2] = HEAP32[$7 >> 2];
 HEAP32[$iov + 12 >> 2] = $2;
 if (!(HEAP32[5757] | 0)) {
  HEAP32[$vararg_buffer3 >> 2] = HEAP32[$f + 60 >> 2];
  HEAP32[$vararg_buffer3 + 4 >> 2] = $iov;
  HEAP32[$vararg_buffer3 + 8 >> 2] = 2;
  $cnt$0 = ___syscall_ret(___syscall145(145, $vararg_buffer3 | 0) | 0) | 0;
 } else {
  _pthread_cleanup_push(4, $f | 0);
  HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
  HEAP32[$vararg_buffer + 4 >> 2] = $iov;
  HEAP32[$vararg_buffer + 8 >> 2] = 2;
  $15 = ___syscall_ret(___syscall145(145, $vararg_buffer | 0) | 0) | 0;
  _pthread_cleanup_pop(0);
  $cnt$0 = $15;
 }
 if (($cnt$0 | 0) < 1) {
  HEAP32[$f >> 2] = HEAP32[$f >> 2] | $cnt$0 & 48 ^ 16;
  HEAP32[$f + 8 >> 2] = 0;
  HEAP32[$f + 4 >> 2] = 0;
  $$0 = $cnt$0;
 } else {
  $27 = HEAP32[$0 >> 2] | 0;
  if ($cnt$0 >>> 0 > $27 >>> 0) {
   $30 = HEAP32[$7 >> 2] | 0;
   $31 = $f + 4 | 0;
   HEAP32[$31 >> 2] = $30;
   $$cast = $30;
   HEAP32[$f + 8 >> 2] = $$cast + ($cnt$0 - $27);
   if (!(HEAP32[$1 >> 2] | 0)) $$0 = $len; else {
    HEAP32[$31 >> 2] = $$cast + 1;
    HEAP8[$buf + ($len + -1) >> 0] = HEAP8[$$cast >> 0] | 0;
    $$0 = $len;
   }
  } else $$0 = $cnt$0;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _printversionandexit($banner, $copyright_holder, $author, $extra_info) {
 $banner = $banner | 0;
 $copyright_holder = $copyright_holder | 0;
 $author = $author | 0;
 $extra_info = $extra_info | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $13 = 0, $17 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, $vararg_buffer12 = 0, $vararg_buffer3 = 0, $vararg_buffer6 = 0, $vararg_buffer9 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer12 = sp + 40 | 0;
 $vararg_buffer9 = sp + 32 | 0;
 $vararg_buffer6 = sp + 24 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = _strchr($banner, 44) | 0;
 $1 = _strrchr($banner, 32) | 0;
 if (!(($0 | 0) != 0 & ($1 | 0) != 0)) ___assert_fail(6157, 6187, 33, 6229);
 $7 = $0 - $banner | 0;
 $8 = $7 + -8 | 0;
 $10 = _xmalloc($7 + -7 | 0) | 0;
 _strncpy($10, $banner + 8 | 0, $8) | 0;
 HEAP8[$10 + $8 >> 0] = 0;
 $13 = HEAP32[10] | 0;
 HEAP32[$vararg_buffer >> 2] = $10;
 HEAP32[$vararg_buffer + 4 >> 2] = $1 + 1;
 HEAP32[$vararg_buffer + 8 >> 2] = $13;
 _printf(6249, $vararg_buffer) | 0;
 _puts(HEAP32[17] | 0) | 0;
 if (!$copyright_holder) $$0 = $author; else {
  HEAP32[$vararg_buffer3 >> 2] = $copyright_holder;
  _printf(6258, $vararg_buffer3) | 0;
  $$0 = ($author | 0) == 0 ? $copyright_holder : $author;
 }
 _puts(6278) | 0;
 $17 = HEAP32[79] | 0;
 _fwrite(6336, 24, 1, $17) | 0;
 HEAP32[$vararg_buffer6 >> 2] = $10;
 _printf(6361, $vararg_buffer6) | 0;
 _puts(6388) | 0;
 _puts(6427) | 0;
 HEAP32[$vararg_buffer9 >> 2] = $10;
 _printf(6482, $vararg_buffer9) | 0;
 HEAP32[$vararg_buffer12 >> 2] = $10;
 HEAP32[$vararg_buffer12 + 4 >> 2] = $$0;
 _printf(6516, $vararg_buffer12) | 0;
 if (!$extra_info) _uexit(0);
 _fputs($extra_info, $17) | 0;
 _uexit(0);
}

function _zzpoplitstk($poplit, $poptype) {
 $poplit = $poplit | 0;
 $poptype = $poptype | 0;
 var $0 = 0, $11 = 0, $13 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4360] | 0;
 if (!$0) {
  _fwrite(3451, 36, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3451, 36, 1, HEAP32[3990] | 0) | 0;
  _bstexwarnprint();
  HEAP8[$poptype >> 0] = 4;
  STACKTOP = sp;
  return;
 }
 $4 = $0 + -1 | 0;
 HEAP32[4360] = $4;
 HEAP32[$poplit >> 2] = HEAP32[(HEAP32[4361] | 0) + ($4 << 2) >> 2];
 $11 = HEAP8[(HEAP32[4362] | 0) + (HEAP32[4360] | 0) >> 0] | 0;
 HEAP8[$poptype >> 0] = $11;
 if ($11 << 24 >> 24 != 1) {
  STACKTOP = sp;
  return;
 }
 $13 = HEAP32[$poplit >> 2] | 0;
 if (($13 | 0) < (HEAP32[4364] | 0)) {
  STACKTOP = sp;
  return;
 }
 if (($13 | 0) != ((HEAP32[4e3] | 0) + -1 | 0)) {
  _fwrite(3488, 26, 1, HEAP32[3989] | 0) | 0;
  _fwrite(3488, 26, 1, HEAP32[3990] | 0) | 0;
  $21 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer >> 2] = 964;
  _fprintf($21, 960, $vararg_buffer) | 0;
  $22 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer1 >> 2] = 964;
  _fprintf($22, 960, $vararg_buffer1) | 0;
  $23 = HEAP32[3989] | 0;
  HEAP32[$vararg_buffer4 >> 2] = 985;
  _fprintf($23, 960, $vararg_buffer4) | 0;
  $24 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer7 >> 2] = 985;
  _fprintf($24, 960, $vararg_buffer7) | 0;
  HEAP8[25620] = 3;
  _longjmp(16008, 1);
 }
 HEAP32[4e3] = $13;
 HEAP32[4237] = HEAP32[(HEAP32[4041] | 0) + ($13 << 2) >> 2];
 STACKTOP = sp;
 return;
}

function ___execvpe($file, $argv, $envp) {
 $file = $file | 0;
 $argv = $argv | 0;
 $envp = $envp | 0;
 var $$ = 0, $$01 = 0, $$2 = 0, $$lcssa = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $22 = 0, $26 = 0, $8 = 0, $p$0 = 0, $z$0 = 0, sp = 0;
 sp = STACKTOP;
 $0 = _getenv(15918) | 0;
 $1 = ___errno_location() | 0;
 HEAP32[$1 >> 2] = 2;
 L1 : do if (!(HEAP8[$file >> 0] | 0)) $$2 = -1; else {
  if (_strchr($file, 47) | 0) {
   $$2 = _execve($file, $argv, $envp) | 0;
   break;
  }
  $$ = ($0 | 0) == 0 ? 15923 : $0;
  $8 = _strnlen($file, 256) | 0;
  if ($8 >>> 0 > 255) {
   HEAP32[$1 >> 2] = 36;
   $$2 = -1;
   break;
  }
  $11 = (_strnlen($$, 4095) | 0) + 1 | 0;
  $12 = $8 + 1 | 0;
  $13 = $12 + $11 | 0;
  $p$0 = $$;
  while (1) {
   $14 = _llvm_stacksave() | 0;
   $15 = STACKTOP;
   STACKTOP = STACKTOP + ((1 * $13 | 0) + 15 & -16) | 0;
   $16 = _strchr($p$0, 58) | 0;
   if (!$16) $z$0 = $p$0 + (_strlen($p$0) | 0) | 0; else $z$0 = $16;
   $22 = $z$0 - $p$0 | 0;
   if ($22 >>> 0 < $11 >>> 0) {
    _memcpy($15 | 0, $p$0 | 0, $22 | 0) | 0;
    $26 = $15 + $22 | 0;
    HEAP8[$26 >> 0] = 47;
    _memcpy($26 + ($z$0 >>> 0 > $p$0 >>> 0 & 1) | 0, $file | 0, $12 | 0) | 0;
    _execve($15, $argv, $envp) | 0;
    if ((HEAP32[$1 >> 2] | 0) != 2) {
     $$lcssa = $14;
     break;
    }
    $$01 = (HEAP8[$z$0 >> 0] | 0) == 0 ? 2 : 0;
   } else $$01 = (HEAP8[$z$0 >> 0] | 0) == 0 ? 2 : 4;
   _llvm_stackrestore($14 | 0);
   switch ($$01 | 0) {
   case 4:
   case 0:
    {
     $p$0 = $z$0 + 1 | 0;
     break;
    }
   default:
    {
     $$2 = -1;
     break L1;
    }
   }
  }
  _llvm_stackrestore($$lcssa | 0);
  $$2 = -1;
 } while (0);
 STACKTOP = sp;
 return $$2 | 0;
}

function _zprintstklit($stklt, $stktp) {
 $stklt = $stklt | 0;
 $stktp = $stktp | 0;
 var $1 = 0, $13 = 0, $2 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 switch ($stktp & 255 | 0) {
 case 0:
  {
   $1 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = $stklt;
   HEAP32[$vararg_buffer + 4 >> 2] = 2424;
   _fprintf($1, 2418, $vararg_buffer) | 0;
   $2 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer2 >> 2] = $stklt;
   HEAP32[$vararg_buffer2 + 4 >> 2] = 2424;
   _fprintf($2, 2418, $vararg_buffer2) | 0;
   STACKTOP = sp;
   return;
  }
 case 1:
  {
   _putc(34, HEAP32[3989] | 0) | 0;
   _putc(34, HEAP32[3990] | 0) | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $stklt);
   _zoutpoolstr(HEAP32[3989] | 0, $stklt);
   _fwrite(2447, 21, 1, HEAP32[3989] | 0) | 0;
   _fwrite(2447, 21, 1, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   _putc(96, HEAP32[3989] | 0) | 0;
   _putc(96, HEAP32[3990] | 0) | 0;
   $13 = HEAP32[(HEAP32[4145] | 0) + ($stklt << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $13);
   _zoutpoolstr(HEAP32[3989] | 0, $13);
   _fwrite(2469, 23, 1, HEAP32[3989] | 0) | 0;
   _fwrite(2469, 23, 1, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 3:
  {
   _putc(96, HEAP32[3989] | 0) | 0;
   _putc(96, HEAP32[3990] | 0) | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $stklt);
   _zoutpoolstr(HEAP32[3989] | 0, $stklt);
   _fwrite(2493, 20, 1, HEAP32[3989] | 0) | 0;
   _fwrite(2493, 20, 1, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 4:
  {
   _illeglliteralconfusion();
   break;
  }
 default:
  _unknwnliteralconfusion();
 }
}

function _bstidprint() {
 var $1 = 0, $10 = 0, $18 = 0, $19 = 0, $27 = 0, $28 = 0, $36 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer13 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 $vararg_buffer13 = sp + 48 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 switch (HEAP8[26389] | 0) {
 case 0:
  {
   $1 = HEAP32[3989] | 0;
   $9 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
   HEAP32[$vararg_buffer >> 2] = 34;
   HEAP32[$vararg_buffer + 4 >> 2] = $9;
   HEAP32[$vararg_buffer + 8 >> 2] = 1757;
   _fprintf($1, 1750, $vararg_buffer) | 0;
   $10 = HEAP32[3990] | 0;
   $18 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
   HEAP32[$vararg_buffer3 >> 2] = 34;
   HEAP32[$vararg_buffer3 + 4 >> 2] = $18;
   HEAP32[$vararg_buffer3 + 8 >> 2] = 1757;
   _fprintf($10, 1750, $vararg_buffer3) | 0;
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   $19 = HEAP32[3989] | 0;
   $27 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
   HEAP32[$vararg_buffer8 >> 2] = 34;
   HEAP32[$vararg_buffer8 + 4 >> 2] = $27;
   HEAP32[$vararg_buffer8 + 8 >> 2] = 1788;
   _fprintf($19, 1750, $vararg_buffer8) | 0;
   $28 = HEAP32[3990] | 0;
   $36 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
   HEAP32[$vararg_buffer13 >> 2] = 34;
   HEAP32[$vararg_buffer13 + 4 >> 2] = $36;
   HEAP32[$vararg_buffer13 + 8 >> 2] = 1788;
   _fprintf($28, 1750, $vararg_buffer13) | 0;
   STACKTOP = sp;
   return;
  }
 default:
  _idscanningconfusion();
 }
}

function _bstexwarnprint() {
 var $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $21 = 0, $7 = 0, $storemerge$i = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (HEAP32[4152] | 0) {
  _fwrite(2298, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2298, 11, 1, HEAP32[3990] | 0) | 0;
  $7 = HEAP32[(HEAP32[4099] | 0) + (HEAP32[4150] << 2) >> 2] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $7);
  _zoutpoolstr(HEAP32[3989] | 0, $7);
 }
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _fwrite(2310, 16, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2310, 16, 1, HEAP32[3990] | 0) | 0;
 $14 = HEAP32[3989] | 0;
 $15 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer >> 2] = 1501;
 HEAP32[$vararg_buffer + 4 >> 2] = $15;
 HEAP32[$vararg_buffer + 8 >> 2] = 1297;
 _fprintf($14, 1280, $vararg_buffer) | 0;
 $16 = HEAP32[3990] | 0;
 $17 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 1501;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $17;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 1297;
 _fprintf($16, 1280, $vararg_buffer3) | 0;
 $18 = HEAP32[4096] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $18);
 _zoutpoolstr(HEAP32[3989] | 0, $18);
 $21 = HEAP32[4097] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $21);
 _zoutpoolstr(HEAP32[3989] | 0, $21);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 if ((HEAPU8[25620] | 0) < 2) {
  HEAP8[25620] = 2;
  $storemerge$i = 1;
  HEAP32[3991] = $storemerge$i;
  STACKTOP = sp;
  return;
 } else {
  $storemerge$i = (HEAP32[3991] | 0) + 1 | 0;
  HEAP32[3991] = $storemerge$i;
  STACKTOP = sp;
  return;
 }
}

function _log_search($kpse, $filenames$0, $filenames$1) {
 $kpse = $kpse | 0;
 $filenames$0 = $filenames$0 | 0;
 $filenames$1 = $filenames$1 | 0;
 var $$pre$phiZ2D = 0, $0 = 0, $12 = 0, $16 = 0, $18 = 0, $24 = 0, $29 = 0, $3 = 0, $5 = 0, $8 = 0, $e$01 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = $kpse + 100 | 0;
 if (!(HEAP32[$0 >> 2] | 0)) {
  $3 = _kpathsea_var_value($kpse, 11066) | 0;
  HEAP32[$0 >> 2] = 1;
  if ($3 | 0) {
   $5 = _kpse_fopen_trace($3, 12168) | 0;
   HEAP32[$kpse + 96 >> 2] = $5;
   if (!$5) _perror($3);
   _free($3);
  }
 }
 $8 = $kpse + 44 | 0;
 do if (!(HEAP32[$8 >> 2] & 32)) {
  $12 = $kpse + 96 | 0;
  if ((HEAP32[$12 >> 2] | 0) != 0 & ($filenames$0 | 0) != 0) $$pre$phiZ2D = $12; else {
   STACKTOP = sp;
   return;
  }
 } else if (!$filenames$0) {
  STACKTOP = sp;
  return;
 } else {
  $$pre$phiZ2D = $kpse + 96 | 0;
  break;
 } while (0);
 $16 = HEAP32[21] | 0;
 $e$01 = 0;
 while (1) {
  $18 = HEAP32[$filenames$1 + ($e$01 << 2) >> 2] | 0;
  if (!$18) {
   label = 18;
   break;
  }
  if (HEAP32[$$pre$phiZ2D >> 2] | 0) if (_kpathsea_absolute_p($kpse, $18, 0) | 0) {
   $24 = HEAP32[$$pre$phiZ2D >> 2] | 0;
   HEAP32[$vararg_buffer >> 2] = _time(0) | 0;
   HEAP32[$vararg_buffer + 4 >> 2] = $18;
   _fprintf($24, 11075, $vararg_buffer) | 0;
  }
  if (HEAP32[$8 >> 2] & 32 | 0) {
   _putc(32, $16) | 0;
   _fputs($18, $16) | 0;
  }
  $29 = $e$01 + 1 | 0;
  if ($29 >>> 0 < $filenames$0 >>> 0) $e$01 = $29; else {
   label = 18;
   break;
  }
 }
 if ((label | 0) == 18) {
  STACKTOP = sp;
  return;
 }
}

function _lastcheckforauxerrors() {
 var $0 = 0;
 $0 = HEAP32[4150] | 0;
 HEAP32[4157] = $0;
 HEAP32[4673] = HEAP32[4093];
 if (!(HEAP32[4670] | 0)) {
  _fwrite(1466, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1466, 11, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4593, 18, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4593, 18, 1, HEAP32[3990] | 0) | 0;
  _auxend2errprint();
 } else if (!(HEAP32[4328] | $0)) {
  _fwrite(1466, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1466, 11, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4612, 9, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4612, 9, 1, HEAP32[3990] | 0) | 0;
  _auxend2errprint();
 }
 if (!(HEAP32[4666] | 0)) {
  _fwrite(1466, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1466, 11, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4622, 16, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4622, 16, 1, HEAP32[3990] | 0) | 0;
  _auxend2errprint();
 } else if (!(HEAP32[4673] | 0)) {
  _fwrite(1466, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1466, 11, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4639, 14, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4639, 14, 1, HEAP32[3990] | 0) | 0;
  _auxend2errprint();
 }
 if (!(HEAP32[4668] | 0)) {
  _fwrite(1466, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(1466, 11, 1, HEAP32[3990] | 0) | 0;
  _fwrite(4654, 17, 1, HEAP32[3989] | 0) | 0;
  _fwrite(4654, 17, 1, HEAP32[3990] | 0) | 0;
  _auxend2errprint();
  return;
 }
 if (HEAP32[4096] | 0) return;
 _fwrite(1466, 11, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1466, 11, 1, HEAP32[3990] | 0) | 0;
 _fwrite(4672, 10, 1, HEAP32[3989] | 0) | 0;
 _fwrite(4672, 10, 1, HEAP32[3990] | 0) | 0;
 _auxend2errprint();
 return;
}

function _target_suffixed_names($kpse, $target, $count, $format, $name, $use_fontmaps, $has_potential_suffix) {
 $kpse = $kpse | 0;
 $target = $target | 0;
 $count = $count | 0;
 $format = $format | 0;
 $name = $name | 0;
 $use_fontmaps = $use_fontmaps | 0;
 $has_potential_suffix = $has_potential_suffix | 0;
 var $17 = 0, $18 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $30 = 0, $31 = 0, $4 = 0, $7 = 0, $8 = 0, $9 = 0, $ext$01 = 0, $ext$01$us = 0;
 if ($has_potential_suffix | 0) return;
 $2 = HEAP32[$kpse + 132 + ($format * 68 | 0) + 32 >> 2] | 0;
 if (!$2) return;
 $4 = HEAP32[$2 >> 2] | 0;
 if (!$4) return;
 if (!$use_fontmaps) {
  $7 = $4;
  $ext$01$us = $2;
  while (1) {
   $8 = _concat($name, $7) | 0;
   $9 = HEAP32[$count >> 2] | 0;
   HEAP32[(HEAP32[$target >> 2] | 0) + ($9 << 2) >> 2] = $8;
   HEAP32[$count >> 2] = $9 + 1;
   HEAP32[$target >> 2] = _xrealloc(HEAP32[$target >> 2] | 0, ($9 << 2) + 8 | 0) | 0;
   $17 = $ext$01$us + 4 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   if (!$18) break; else {
    $7 = $18;
    $ext$01$us = $17;
   }
  }
  return;
 } else {
  $20 = $4;
  $ext$01 = $2;
  while (1) {
   $21 = _concat($name, $20) | 0;
   $22 = HEAP32[$count >> 2] | 0;
   HEAP32[(HEAP32[$target >> 2] | 0) + ($22 << 2) >> 2] = $21;
   HEAP32[$count >> 2] = $22 + 1;
   HEAP32[$target >> 2] = _xrealloc(HEAP32[$target >> 2] | 0, ($22 << 2) + 8 | 0) | 0;
   _target_fontmaps($kpse, $target, $count, $21);
   $30 = $ext$01 + 4 | 0;
   $31 = HEAP32[$30 >> 2] | 0;
   if (!$31) break; else {
    $20 = $31;
    $ext$01 = $30;
   }
  }
  return;
 }
}

function _kpathsea_selfdir($kpse, $argv0) {
 $kpse = $kpse | 0;
 $argv0 = $argv0 | 0;
 var $12 = 0, $17 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $6 = 0, $9 = 0, $elt$03 = 0, $s = 0, $self$0$lcssa = 0, $self$1 = 0, $self$2 = 0, $self$3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $s = sp;
 if (!(_kpathsea_absolute_p($kpse, $argv0, 1) | 0)) {
  $4 = _kpathsea_path_element($kpse, _getenv(15918) | 0) | 0;
  if (!$4) $self$0$lcssa = 0; else {
   $6 = $s + 24 | 0;
   $elt$03 = $4;
   while (1) {
    $9 = _concat3((HEAP8[$elt$03 >> 0] | 0) == 0 ? 15912 : $elt$03, 13340, $argv0) | 0;
    if (!(_stat($9, $s) | 0)) {
     $12 = HEAP32[$6 >> 2] | 0;
     if (($12 & 73 | 0) == 0 | ($12 & 61440 | 0) == 16384) label = 7; else $self$1 = $9;
    } else label = 7;
    if ((label | 0) == 7) {
     label = 0;
     _free($9);
     $self$1 = 0;
    }
    $17 = _kpathsea_path_element($kpse, 0) | 0;
    if (($self$1 | 0) == 0 & ($17 | 0) != 0) $elt$03 = $17; else {
     $self$0$lcssa = $self$1;
     break;
    }
   }
  }
  $self$2 = $self$0$lcssa;
 } else $self$2 = _xstrdup($argv0) | 0;
 if ($self$2 | 0) {
  $self$3 = $self$2;
  $22 = _expand_symlinks($kpse, $self$3) | 0;
  $23 = _remove_dots($kpse, $22) | 0;
  _free($self$3);
  $24 = _xdirname($23) | 0;
  _free($23);
  STACKTOP = sp;
  return $24 | 0;
 }
 $self$3 = _concat3(15912, 13340, $argv0) | 0;
 $22 = _expand_symlinks($kpse, $self$3) | 0;
 $23 = _remove_dots($kpse, $22) | 0;
 _free($self$3);
 $24 = _xdirname($23) | 0;
 _free($23);
 STACKTOP = sp;
 return $24 | 0;
}

function _addpoolbufandpush() {
 var $0 = 0, $1 = 0, $15 = 0, $16 = 0, $17 = 0, $25 = 0, $27 = 0, $29 = 0, $3 = 0, $32 = 0, $33 = 0, $5 = 0, $7 = 0, $9 = 0, $storemerge1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4237] | 0;
 $1 = HEAP32[4333] | 0;
 $3 = HEAP32[4043] | 0;
 if (($1 + $0 | 0) > ($3 | 0)) {
  $9 = $3;
  while (1) {
   $7 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = 1161;
   HEAP32[$vararg_buffer + 4 >> 2] = 1;
   HEAP32[$vararg_buffer + 8 >> 2] = $9 + 65e3;
   HEAP32[$vararg_buffer + 12 >> 2] = $9;
   _fprintf($7, 1023, $vararg_buffer) | 0;
   HEAP32[4042] = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
   $15 = (HEAP32[4043] | 0) + 65e3 | 0;
   HEAP32[4043] = $15;
   $16 = HEAP32[4237] | 0;
   $17 = HEAP32[4333] | 0;
   if (($17 + $16 | 0) > ($15 | 0)) $9 = $15; else {
    $33 = $16;
    $5 = $17;
    break;
   }
  }
 } else {
  $33 = $0;
  $5 = $1;
 }
 HEAP32[4251] = 0;
 if (($5 | 0) > 0) {
  $25 = $33;
  $storemerge1 = 0;
 } else {
  $32 = _makestring() | 0;
  _zpushlitstk($32, 1);
  STACKTOP = sp;
  return;
 }
 while (1) {
  HEAP8[(HEAP32[4042] | 0) + $25 >> 0] = HEAP8[(HEAP32[3995] | 0) + $storemerge1 >> 0] | 0;
  $27 = (HEAP32[4237] | 0) + 1 | 0;
  HEAP32[4237] = $27;
  $29 = (HEAP32[4251] | 0) + 1 | 0;
  HEAP32[4251] = $29;
  if (($29 | 0) < (HEAP32[4333] | 0)) {
   $25 = $27;
   $storemerge1 = $29;
  } else break;
 }
 $32 = _makestring() | 0;
 _zpushlitstk($32, 1);
 STACKTOP = sp;
 return;
}
function ___strchrnul($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $$0 = 0, $$02$lcssa = 0, $$0211 = 0, $$1 = 0, $0 = 0, $11 = 0, $15 = 0, $16 = 0, $22 = 0, $23 = 0, $29 = 0, $30 = 0, $36 = 0, $37 = 0, $5 = 0, $8 = 0, $w$0$lcssa = 0, $w$08 = 0;
 $0 = $c & 255;
 L1 : do if (!$0) $$0 = $s + (_strlen($s) | 0) | 0; else {
  if (!($s & 3)) $$02$lcssa = $s; else {
   $5 = $c & 255;
   $$0211 = $s;
   while (1) {
    $8 = HEAP8[$$0211 >> 0] | 0;
    if ($8 << 24 >> 24 == 0 ? 1 : $8 << 24 >> 24 == $5 << 24 >> 24) {
     $$0 = $$0211;
     break L1;
    }
    $11 = $$0211 + 1 | 0;
    if (!($11 & 3)) {
     $$02$lcssa = $11;
     break;
    } else $$0211 = $11;
   }
  }
  $15 = Math_imul($0, 16843009) | 0;
  $16 = HEAP32[$$02$lcssa >> 2] | 0;
  L10 : do if (!(($16 & -2139062144 ^ -2139062144) & $16 + -16843009)) {
   $23 = $16;
   $w$08 = $$02$lcssa;
   while (1) {
    $22 = $23 ^ $15;
    if (($22 & -2139062144 ^ -2139062144) & $22 + -16843009 | 0) {
     $w$0$lcssa = $w$08;
     break L10;
    }
    $29 = $w$08 + 4 | 0;
    $30 = HEAP32[$29 >> 2] | 0;
    if (!(($30 & -2139062144 ^ -2139062144) & $30 + -16843009)) {
     $23 = $30;
     $w$08 = $29;
    } else {
     $w$0$lcssa = $29;
     break;
    }
   }
  } else $w$0$lcssa = $$02$lcssa; while (0);
  $36 = $c & 255;
  $$1 = $w$0$lcssa;
  while (1) {
   $37 = HEAP8[$$1 >> 0] | 0;
   if ($37 << 24 >> 24 == 0 ? 1 : $37 << 24 >> 24 == $36 << 24 >> 24) {
    $$0 = $$1;
    break;
   } else $$1 = $$1 + 1 | 0;
  }
 } while (0);
 return $$0 | 0;
}

function _kpathsea_dir_links($kpse, $fn, $nlinks) {
 $kpse = $kpse | 0;
 $fn = $fn | 0;
 $nlinks = $nlinks | 0;
 var $$0 = 0, $$1 = 0, $$byval_copy = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $15 = 0, $20 = 0, $40 = 0, $5 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 $$byval_copy = sp + 16 | 0;
 $vararg_buffer = sp + 8 | 0;
 $0 = sp;
 $1 = $kpse + 48 | 0;
 if (!(HEAP32[$kpse + 52 >> 2] | 0)) {
  _hash_create($0, 457);
  $5 = $0;
  $10 = HEAP32[$5 + 4 >> 2] | 0;
  $11 = $1;
  HEAP32[$11 >> 2] = HEAP32[$5 >> 2];
  HEAP32[$11 + 4 >> 2] = $10;
 }
 $15 = $kpse + 44 | 0;
 if (HEAP32[$15 >> 2] & 2 | 0) HEAP32[$kpse + 76 >> 2] = 1;
 HEAP32[$$byval_copy >> 2] = HEAP32[$1 >> 2];
 HEAP32[$$byval_copy + 4 >> 2] = HEAP32[$1 + 4 >> 2];
 $20 = _hash_lookup($$byval_copy, $fn) | 0;
 if (HEAP32[$15 >> 2] & 2 | 0) HEAP32[$kpse + 76 >> 2] = 0;
 if ($20 | 0) {
  $$1 = HEAP32[$20 >> 2] | 0;
  STACKTOP = sp;
  return $$1 | 0;
 }
 if (!(_stat($fn, $$byval_copy) | 0)) if ((HEAP32[$$byval_copy + 24 >> 2] & 61440 | 0) == 16384) $$0 = HEAP32[$$byval_copy + 16 >> 2] | 0; else $$0 = -1; else $$0 = -1;
 _hash_insert($1, _xstrdup($fn) | 0, $$0);
 if (HEAP32[$15 >> 2] & 1 | 0) {
  $40 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $40) | 0;
  HEAP32[$vararg_buffer >> 2] = $fn;
  HEAP32[$vararg_buffer + 4 >> 2] = $$0;
  _fprintf($40, 13466, $vararg_buffer) | 0;
  _fflush($40) | 0;
 }
 $$1 = $$0;
 STACKTOP = sp;
 return $$1 | 0;
}

function ___fwritex($s, $l, $f) {
 $s = $s | 0;
 $l = $l | 0;
 $f = $f | 0;
 var $$0 = 0, $$01 = 0, $$02 = 0, $0 = 0, $1 = 0, $11 = 0, $19 = 0, $29 = 0, $6 = 0, $7 = 0, $9 = 0, $i$0 = 0, $i$0$lcssa12 = 0, $i$1 = 0, label = 0;
 $0 = $f + 16 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) if (!(___towrite($f) | 0)) {
  $9 = HEAP32[$0 >> 2] | 0;
  label = 5;
 } else $$0 = 0; else {
  $9 = $1;
  label = 5;
 }
 L5 : do if ((label | 0) == 5) {
  $6 = $f + 20 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  $11 = $7;
  if (($9 - $7 | 0) >>> 0 < $l >>> 0) {
   $$0 = FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 7]($f, $s, $l) | 0;
   break;
  }
  L10 : do if ((HEAP8[$f + 75 >> 0] | 0) > -1) {
   $i$0 = $l;
   while (1) {
    if (!$i$0) {
     $$01 = $l;
     $$02 = $s;
     $29 = $11;
     $i$1 = 0;
     break L10;
    }
    $19 = $i$0 + -1 | 0;
    if ((HEAP8[$s + $19 >> 0] | 0) == 10) {
     $i$0$lcssa12 = $i$0;
     break;
    } else $i$0 = $19;
   }
   if ((FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 7]($f, $s, $i$0$lcssa12) | 0) >>> 0 < $i$0$lcssa12 >>> 0) {
    $$0 = $i$0$lcssa12;
    break L5;
   }
   $$01 = $l - $i$0$lcssa12 | 0;
   $$02 = $s + $i$0$lcssa12 | 0;
   $29 = HEAP32[$6 >> 2] | 0;
   $i$1 = $i$0$lcssa12;
  } else {
   $$01 = $l;
   $$02 = $s;
   $29 = $11;
   $i$1 = 0;
  } while (0);
  _memcpy($29 | 0, $$02 | 0, $$01 | 0) | 0;
  HEAP32[$6 >> 2] = (HEAP32[$6 >> 2] | 0) + $$01;
  $$0 = $i$1 + $$01 | 0;
 } while (0);
 return $$0 | 0;
}

function _kpathsea_var_value($kpse, $var) {
 $kpse = $kpse | 0;
 $var = $var | 0;
 var $0 = 0, $1 = 0, $10 = 0, $13 = 0, $16 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $9 = 0, $value$25 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = $kpse + 112 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) ___assert_fail(12300, 12319, 36, 12353);
 $3 = _concat3($var, 15912, $1) | 0;
 $4 = _getenv($3 | 0) | 0;
 _free($3);
 if (!$4) label = 5; else if (!(HEAP8[$4 >> 0] | 0)) label = 5; else {
  $value$25 = $4;
  label = 10;
 }
 do if ((label | 0) == 5) {
  $9 = _concat3($var, 12372, HEAP32[$0 >> 2] | 0) | 0;
  $10 = _getenv($9 | 0) | 0;
  _free($9);
  if ($10 | 0) if (HEAP8[$10 >> 0] | 0) {
   $value$25 = $10;
   label = 10;
   break;
  }
  $13 = _getenv($var | 0) | 0;
  if ($13 | 0) if (HEAP8[$13 >> 0] | 0) {
   $value$25 = $13;
   label = 10;
   break;
  }
  $16 = _kpathsea_cnf_get($kpse, $var) | 0;
  if (!$16) $24 = 0; else {
   $value$25 = $16;
   label = 10;
  }
 } while (0);
 if ((label | 0) == 10) $24 = _kpathsea_expand($kpse, $value$25) | 0;
 if (!(HEAP32[$kpse + 44 >> 2] & 64)) {
  STACKTOP = sp;
  return $24 | 0;
 }
 $23 = HEAP32[21] | 0;
 _fwrite(13458, 7, 1, $23) | 0;
 HEAP32[$vararg_buffer >> 2] = $var;
 HEAP32[$vararg_buffer + 4 >> 2] = $24 | 0 ? $24 : 12374;
 _fprintf($23, 12380, $vararg_buffer) | 0;
 _fflush($23) | 0;
 STACKTOP = sp;
 return $24 | 0;
}

function _xpreamble() {
 var $10 = 0, $13 = 0, $16 = 0, $17 = 0, $19 = 0, $22 = 0, $26 = 0, $28 = 0, $30 = 0, $33 = 0, $35 = 0, $4 = 0, $5 = 0, $7 = 0, $storemerge1 = 0;
 HEAP32[4333] = 0;
 HEAP32[4304] = 0;
 if ((HEAP32[4385] | 0) > 0) {
  $13 = 0;
  $storemerge1 = 0;
 } else {
  _addpoolbufandpush();
  return;
 }
 while (1) {
  $4 = HEAP32[(HEAP32[4325] | 0) + ($storemerge1 << 2) >> 2] | 0;
  $5 = HEAP32[4041] | 0;
  $7 = HEAP32[$5 + ($4 << 2) >> 2] | 0;
  HEAP32[4238] = $7;
  $10 = HEAP32[$5 + ($4 + 1 << 2) >> 2] | 0;
  HEAP32[4239] = $10;
  if (($10 - $7 + $13 | 0) > (HEAP32[3992] | 0)) {
   _bufferoverflow();
   $16 = HEAP32[4333] | 0;
   $17 = HEAP32[4238] | 0;
   $19 = HEAP32[4239] | 0;
  } else {
   $16 = $13;
   $17 = $7;
   $19 = $10;
  }
  HEAP32[4251] = $16;
  if (($17 | 0) < ($19 | 0)) {
   $22 = $17;
   $26 = $16;
   while (1) {
    HEAP8[(HEAP32[3995] | 0) + $26 >> 0] = HEAP8[(HEAP32[4042] | 0) + $22 >> 0] | 0;
    $28 = (HEAP32[4251] | 0) + 1 | 0;
    HEAP32[4251] = $28;
    $30 = (HEAP32[4238] | 0) + 1 | 0;
    HEAP32[4238] = $30;
    if (($30 | 0) < (HEAP32[4239] | 0)) {
     $22 = $30;
     $26 = $28;
    } else {
     $33 = $28;
     break;
    }
   }
  } else $33 = $16;
  HEAP32[4333] = $33;
  $35 = (HEAP32[4304] | 0) + 1 | 0;
  HEAP32[4304] = $35;
  if (($35 | 0) < (HEAP32[4385] | 0)) {
   $13 = $33;
   $storemerge1 = $35;
  } else break;
 }
 _addpoolbufandpush();
 return;
}

function _bsterrprintandlookforblankline() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 _putc(45, HEAP32[3989] | 0) | 0;
 _putc(45, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 $3 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer >> 2] = 1501;
 HEAP32[$vararg_buffer + 4 >> 2] = $3;
 HEAP32[$vararg_buffer + 8 >> 2] = 1297;
 _fprintf($2, 1280, $vararg_buffer) | 0;
 $4 = HEAP32[3990] | 0;
 $5 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 1501;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $5;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 1297;
 _fprintf($4, 1280, $vararg_buffer3) | 0;
 $6 = HEAP32[4096] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $6);
 _zoutpoolstr(HEAP32[3989] | 0, $6);
 $9 = HEAP32[4097] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $9);
 _zoutpoolstr(HEAP32[3989] | 0, $9);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _printbadinputline();
 if (!(HEAP32[3999] | 0)) {
  HEAP32[4045] = 0;
  STACKTOP = sp;
  return;
 }
 while (1) {
  if (!(_zinputln(HEAP32[4104] | 0) | 0)) {
   label = 3;
   break;
  }
  HEAP32[4103] = (HEAP32[4103] | 0) + 1;
  if (!(HEAP32[3999] | 0)) {
   label = 5;
   break;
  }
 }
 if ((label | 0) == 3) _longjmp(16420, 1); else if ((label | 0) == 5) {
  HEAP32[4045] = 0;
  STACKTOP = sp;
  return;
 }
}

function _kpathsea_set_suffixes($kpse, $format, $alternate, $varargs) {
 $kpse = $kpse | 0;
 $format = $format | 0;
 $alternate = $alternate | 0;
 $varargs = $varargs | 0;
 var $11 = 0, $15 = 0, $17 = 0, $23 = 0, $24 = 0, $26 = 0, $27 = 0, $8 = 0, $9 = 0, $ap = 0, $count$0$lcssa$i = 0, $count$01$i = 0, $list$0$ph$i = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $list$0$ph$i = ($alternate | 0) == 0 ? $kpse + 132 + ($format * 68 | 0) + 32 | 0 : $kpse + 132 + ($format * 68 | 0) + 36 | 0;
 $8 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
 $9 = HEAP32[$8 >> 2] | 0;
 HEAP32[$ap >> 2] = $8 + 4;
 if (!$9) {
  $count$0$lcssa$i = 0;
  $26 = HEAP32[$list$0$ph$i >> 2] | 0;
  $27 = $26 + ($count$0$lcssa$i << 2) | 0;
  HEAP32[$27 >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 $17 = $9;
 $count$01$i = 0;
 while (1) {
  $11 = $count$01$i + 1 | 0;
  $15 = _xrealloc(HEAP32[$list$0$ph$i >> 2] | 0, ($count$01$i << 2) + 8 | 0) | 0;
  HEAP32[$list$0$ph$i >> 2] = $15;
  HEAP32[$15 + ($count$01$i << 2) >> 2] = $17;
  $23 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
  $24 = HEAP32[$23 >> 2] | 0;
  HEAP32[$ap >> 2] = $23 + 4;
  if (!$24) {
   $count$0$lcssa$i = $11;
   break;
  } else {
   $17 = $24;
   $count$01$i = $11;
  }
 }
 $26 = HEAP32[$list$0$ph$i >> 2] | 0;
 $27 = $26 + ($count$0$lcssa$i << 2) | 0;
 HEAP32[$27 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _auxerrprint() {
 var $0 = 0, $10 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $7 = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer3 = 0, $vararg_buffer8 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer11 = sp + 40 | 0;
 $vararg_buffer8 = sp + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[3989] | 0;
 $3 = HEAP32[16288 + (HEAP32[4050] << 2) >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = 1288;
 HEAP32[$vararg_buffer + 4 >> 2] = $3;
 HEAP32[$vararg_buffer + 8 >> 2] = 1297;
 _fprintf($0, 1280, $vararg_buffer) | 0;
 $4 = HEAP32[3990] | 0;
 $7 = HEAP32[16288 + (HEAP32[4050] << 2) >> 2] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 1288;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $7;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 1297;
 _fprintf($4, 1280, $vararg_buffer3) | 0;
 $10 = HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $10);
 _zoutpoolstr(HEAP32[3989] | 0, $10);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _printbadinputline();
 _fwrite(1213, 38, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1213, 38, 1, HEAP32[3990] | 0) | 0;
 $17 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer8 >> 2] = 1307;
 _fprintf($17, 960, $vararg_buffer8) | 0;
 $18 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer11 >> 2] = 1307;
 _fprintf($18, 960, $vararg_buffer11) | 0;
 STACKTOP = sp;
 return;
}

function _zpushlitstk($pushlt, $pushtype) {
 $pushlt = $pushlt | 0;
 $pushtype = $pushtype | 0;
 var $16 = 0, $17 = 0, $25 = 0, $26 = 0, $6 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[(HEAP32[4361] | 0) + (HEAP32[4360] << 2) >> 2] = $pushlt;
 HEAP8[(HEAP32[4362] | 0) + (HEAP32[4360] | 0) >> 0] = $pushtype;
 $6 = HEAP32[4360] | 0;
 if (($6 | 0) != (HEAP32[4363] | 0)) {
  $26 = $6;
  $25 = $26 + 1 | 0;
  HEAP32[4360] = $25;
  STACKTOP = sp;
  return;
 }
 $9 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 3428;
 HEAP32[$vararg_buffer + 4 >> 2] = 4;
 HEAP32[$vararg_buffer + 8 >> 2] = $6 + 50;
 HEAP32[$vararg_buffer + 12 >> 2] = $6;
 _fprintf($9, 1023, $vararg_buffer) | 0;
 HEAP32[4361] = _xrealloc(HEAP32[4361] | 0, (HEAP32[4363] << 2) + 204 | 0) | 0;
 $16 = HEAP32[3989] | 0;
 $17 = HEAP32[4363] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 3438;
 HEAP32[$vararg_buffer4 + 4 >> 2] = 1;
 HEAP32[$vararg_buffer4 + 8 >> 2] = $17 + 50;
 HEAP32[$vararg_buffer4 + 12 >> 2] = $17;
 _fprintf($16, 1023, $vararg_buffer4) | 0;
 HEAP32[4362] = _xrealloc(HEAP32[4362] | 0, (HEAP32[4363] | 0) + 51 | 0) | 0;
 HEAP32[4363] = (HEAP32[4363] | 0) + 50;
 $26 = HEAP32[4360] | 0;
 $25 = $26 + 1 | 0;
 HEAP32[4360] = $25;
 STACKTOP = sp;
 return;
}

function _read_line($f) {
 $f = $f | 0;
 var $$lcssa = 0, $0 = 0, $1 = 0, $12 = 0, $4 = 0, $6 = 0, $limit$0$ph = 0, $line$0$ph = 0, $line$0$ph$lcssa = 0, $line$1 = 0, $loc$0 = 0, $loc$0$lcssa = 0, $loc$0$ph = 0, $loc$0$ph$phi = 0;
 $0 = _xmalloc(75) | 0;
 _flockfile($f);
 $limit$0$ph = 75;
 $line$0$ph = $0;
 $loc$0$ph = 0;
 L1 : while (1) {
  $loc$0 = $loc$0$ph;
  while (1) {
   $1 = _getc_unlocked($f) | 0;
   switch ($1 | 0) {
   case 10:
   case 13:
   case -1:
    {
     $$lcssa = $1;
     $line$0$ph$lcssa = $line$0$ph;
     $loc$0$lcssa = $loc$0;
     break L1;
     break;
    }
   default:
    {}
   }
   HEAP8[$line$0$ph + $loc$0 >> 0] = $1;
   $4 = $loc$0 + 1 | 0;
   if (($4 | 0) == ($limit$0$ph | 0)) break; else $loc$0 = $4;
  }
  $6 = $limit$0$ph + 75 | 0;
  $loc$0$ph$phi = $limit$0$ph;
  $limit$0$ph = $6;
  $line$0$ph = _xrealloc($line$0$ph, $6) | 0;
  $loc$0$ph = $loc$0$ph$phi;
 }
 if (($loc$0$lcssa | 0) == 0 & ($$lcssa | 0) == -1) {
  _free($line$0$ph$lcssa);
  $line$1 = 0;
 } else {
  HEAP8[$line$0$ph$lcssa + $loc$0$lcssa >> 0] = 0;
  if (($$lcssa | 0) == 13) {
   $12 = _getc_unlocked($f) | 0;
   if (($12 | 0) == 10) $line$1 = $line$0$ph$lcssa; else {
    _ungetc($12, $f) | 0;
    $line$1 = $line$0$ph$lcssa;
   }
  } else $line$1 = $line$0$ph$lcssa;
 }
 _funlockfile($f);
 return $line$1 | 0;
}

function _zprintlit($stklt, $stktp) {
 $stklt = $stklt | 0;
 $stktp = $stktp | 0;
 var $1 = 0, $2 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 switch ($stktp & 255 | 0) {
 case 0:
  {
   $1 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = $stklt;
   _fprintf($1, 2514, $vararg_buffer) | 0;
   $2 = HEAP32[3990] | 0;
   HEAP32[$vararg_buffer1 >> 2] = $stklt;
   _fprintf($2, 2514, $vararg_buffer1) | 0;
   STACKTOP = sp;
   return;
  }
 case 1:
  {
   _zoutpoolstr(HEAP32[3990] | 0, $stklt);
   _zoutpoolstr(HEAP32[3989] | 0, $stklt);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   $9 = HEAP32[(HEAP32[4145] | 0) + ($stklt << 2) >> 2] | 0;
   _zoutpoolstr(HEAP32[3990] | 0, $9);
   _zoutpoolstr(HEAP32[3989] | 0, $9);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 3:
  {
   _zoutpoolstr(HEAP32[3990] | 0, $stklt);
   _zoutpoolstr(HEAP32[3989] | 0, $stklt);
   _putc(10, HEAP32[3989] | 0) | 0;
   _putc(10, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 4:
  {
   _illeglliteralconfusion();
   break;
  }
 default:
  _unknwnliteralconfusion();
 }
}

function _atoi($s) {
 $s = $s | 0;
 var $$0 = 0, $$0$lcssa = 0, $$1$ph = 0, $$13 = 0, $$lcssa9 = 0, $10 = 0, $11 = 0, $4 = 0, $5 = 0, $8 = 0, $isdigittmp = 0, $isdigittmp1 = 0, $isdigittmp5 = 0, $n$0$lcssa = 0, $n$04 = 0, $neg$0 = 0, $neg$1$ph = 0, label = 0;
 $$0 = $s;
 while (1) {
  $4 = $$0 + 1 | 0;
  if (!(_isspace(HEAP8[$$0 >> 0] | 0) | 0)) {
   $$0$lcssa = $$0;
   $$lcssa9 = $4;
   break;
  } else $$0 = $4;
 }
 $5 = HEAP8[$$0$lcssa >> 0] | 0;
 switch ($5 << 24 >> 24 | 0) {
 case 45:
  {
   $neg$0 = 1;
   label = 5;
   break;
  }
 case 43:
  {
   $neg$0 = 0;
   label = 5;
   break;
  }
 default:
  {
   $$1$ph = $$0$lcssa;
   $8 = $5;
   $neg$1$ph = 0;
  }
 }
 if ((label | 0) == 5) {
  $$1$ph = $$lcssa9;
  $8 = HEAP8[$$lcssa9 >> 0] | 0;
  $neg$1$ph = $neg$0;
 }
 $isdigittmp1 = ($8 << 24 >> 24) + -48 | 0;
 if ($isdigittmp1 >>> 0 < 10) {
  $$13 = $$1$ph;
  $isdigittmp5 = $isdigittmp1;
  $n$04 = 0;
  while (1) {
   $10 = $$13 + 1 | 0;
   $11 = ($n$04 * 10 | 0) - $isdigittmp5 | 0;
   $isdigittmp = (HEAP8[$10 >> 0] | 0) + -48 | 0;
   if ($isdigittmp >>> 0 < 10) {
    $$13 = $10;
    $isdigittmp5 = $isdigittmp;
    $n$04 = $11;
   } else {
    $n$0$lcssa = $11;
    break;
   }
  }
 } else $n$0$lcssa = 0;
 return ($neg$1$ph | 0 ? $n$0$lcssa : 0 - $n$0$lcssa | 0) | 0;
}

function _zprintfnclass($fnloc) {
 $fnloc = $fnloc | 0;
 do switch (HEAPU8[(HEAP32[4144] | 0) + $fnloc >> 0] | 0 | 0) {
 case 0:
  {
   _fwrite(1571, 8, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1571, 8, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 1:
  {
   _fwrite(1580, 14, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1580, 14, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 2:
  {
   _fwrite(1595, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1595, 15, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 3:
  {
   _fwrite(1611, 14, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1611, 14, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 4:
  {
   _fwrite(1626, 5, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1626, 5, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 5:
  {
   _fwrite(1632, 22, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1632, 22, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 6:
  {
   _fwrite(1655, 21, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1655, 21, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 7:
  {
   _fwrite(1677, 23, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1677, 23, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 case 8:
  {
   _fwrite(1701, 22, 1, HEAP32[3989] | 0) | 0;
   _fwrite(1701, 22, 1, HEAP32[3990] | 0) | 0;
   return;
  }
 default:
  _unknwnfunctionclassconfusion();
 } while (0);
}

function _vsnprintf($s, $n, $fmt, $ap) {
 $s = $s | 0;
 $n = $n | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 var $$$02 = 0, $$0 = 0, $$01 = 0, $$02 = 0, $10 = 0, $11 = 0, $13 = 0, $15 = 0, $5 = 0, $8 = 0, $b = 0, $f = 0, dest = 0, label = 0, sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 $b = sp + 112 | 0;
 $f = sp;
 dest = $f;
 src = 436;
 stop = dest + 112 | 0;
 do {
  HEAP32[dest >> 2] = HEAP32[src >> 2];
  dest = dest + 4 | 0;
  src = src + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 if (($n + -1 | 0) >>> 0 > 2147483646) if (!$n) {
  $$01 = $b;
  $$02 = 1;
  label = 4;
 } else {
  HEAP32[(___errno_location() | 0) >> 2] = 75;
  $$0 = -1;
 } else {
  $$01 = $s;
  $$02 = $n;
  label = 4;
 }
 if ((label | 0) == 4) {
  $5 = -2 - $$01 | 0;
  $$$02 = $$02 >>> 0 > $5 >>> 0 ? $5 : $$02;
  HEAP32[$f + 48 >> 2] = $$$02;
  $8 = $f + 20 | 0;
  HEAP32[$8 >> 2] = $$01;
  HEAP32[$f + 44 >> 2] = $$01;
  $10 = $$01 + $$$02 | 0;
  $11 = $f + 16 | 0;
  HEAP32[$11 >> 2] = $10;
  HEAP32[$f + 28 >> 2] = $10;
  $13 = _vfprintf($f, $fmt, $ap) | 0;
  if (!$$$02) $$0 = $13; else {
   $15 = HEAP32[$8 >> 2] | 0;
   HEAP8[$15 + ((($15 | 0) == (HEAP32[$11 >> 2] | 0)) << 31 >> 31) >> 0] = 0;
   $$0 = $13;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _recorder_record_name($prefix, $name) {
 $prefix = $prefix | 0;
 $name = $name | 0;
 var $11 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $6 = 0, $7 = 0, $9 = 0, $pid_str$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $pid_str$i = sp + 24 | 0;
 if (!(HEAP32[4705] | 0)) {
  STACKTOP = sp;
  return;
 }
 $2 = HEAP32[4706] | 0;
 if (!$2) {
  HEAP32[$vararg_buffer >> 2] = _getpid() | 0;
  _sprintf($pid_str$i, 10829, $vararg_buffer) | 0;
  $6 = _concat3(HEAP32[4736] | 0, $pid_str$i, 6120) | 0;
  HEAP32[4707] = $6;
  $7 = HEAP32[4700] | 0;
  if (!$7) $11 = $6; else {
   $9 = _concat3($7, 13340, $6) | 0;
   _free(HEAP32[4707] | 0);
   HEAP32[4707] = $9;
   $11 = $9;
  }
  HEAP32[4706] = _xfopen($11, 6125) | 0;
  $13 = _xgetcwd() | 0;
  $14 = HEAP32[4706] | 0;
  HEAP32[$vararg_buffer1 >> 2] = $13;
  _fprintf($14, 6128, $vararg_buffer1) | 0;
  _free($13);
  $15 = HEAP32[4706] | 0;
 } else $15 = $2;
 HEAP32[$vararg_buffer4 >> 2] = $prefix;
 HEAP32[$vararg_buffer4 + 4 >> 2] = $name;
 _fprintf($15, 6136, $vararg_buffer4) | 0;
 _fflush(HEAP32[4706] | 0) | 0;
 STACKTOP = sp;
 return;
}

function _macrowarnprint() {
 var $$lcssa = 0, $13 = 0, $14 = 0, $16 = 0, $17 = 0, $19 = 0, $2 = 0, $27 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $i$01$i$i = 0, $i$01$i1$i = 0;
 _fwrite(2057, 22, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2057, 22, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3990] | 0;
 $3 = HEAP32[4044] | 0;
 $4 = HEAP32[4045] | 0;
 if (($3 | 0) < ($4 | 0)) {
  $i$01$i$i = $3;
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i$i >> 0] | 0) >> 0] | 0, $2) | 0;
   $13 = $i$01$i$i + 1 | 0;
   $14 = HEAP32[4045] | 0;
   if (($13 | 0) < ($14 | 0)) $i$01$i$i = $13; else {
    $$lcssa = $14;
    break;
   }
  }
  $17 = HEAP32[4044] | 0;
  $19 = $$lcssa;
 } else {
  $17 = $3;
  $19 = $4;
 }
 $16 = HEAP32[3989] | 0;
 if (($17 | 0) < ($19 | 0)) $i$01$i1$i = $17; else {
  $30 = $16;
  _fwrite(2080, 5, 1, $30) | 0;
  $31 = HEAP32[3990] | 0;
  _fwrite(2080, 5, 1, $31) | 0;
  return;
 }
 while (1) {
  _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $16) | 0;
  $27 = $i$01$i1$i + 1 | 0;
  if (($27 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $27; else break;
 }
 $30 = HEAP32[3989] | 0;
 _fwrite(2080, 5, 1, $30) | 0;
 $31 = HEAP32[3990] | 0;
 _fwrite(2080, 5, 1, $31) | 0;
 return;
}

function _str_llist_float($l, $mover) {
 $l = $l | 0;
 $mover = $mover | 0;
 var $$lcssa = 0, $0 = 0, $10 = 0, $11 = 0, $8 = 0, $9 = 0, $before_mover$0 = 0, $last_moved$0 = 0, $last_moved$0$lcssa = 0, $unmoved$0 = 0, $unmoved$0$in = 0, $unmoved$0$lcssa = 0;
 $0 = $mover + 4 | 0;
 if (!(HEAP32[$0 >> 2] | 0)) {
  $last_moved$0 = 0;
  $unmoved$0$in = $l;
 } else return;
 while (1) {
  $unmoved$0 = HEAP32[$unmoved$0$in >> 2] | 0;
  if (!(HEAP32[$unmoved$0 + 4 >> 2] | 0)) {
   $last_moved$0$lcssa = $last_moved$0;
   $unmoved$0$lcssa = $unmoved$0;
   break;
  } else {
   $last_moved$0 = $unmoved$0;
   $unmoved$0$in = $unmoved$0 + 8 | 0;
  }
 }
 do if (($unmoved$0$lcssa | 0) != ($mover | 0)) {
  $8 = $mover + 8 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  $before_mover$0 = $unmoved$0$lcssa;
  while (1) {
   $10 = $before_mover$0 + 8 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   if (($11 | 0) == ($mover | 0)) {
    $$lcssa = $10;
    break;
   } else $before_mover$0 = $11;
  }
  HEAP32[$$lcssa >> 2] = $9;
  HEAP32[$8 >> 2] = $unmoved$0$lcssa;
  if (!$last_moved$0$lcssa) {
   HEAP32[$l >> 2] = $mover;
   break;
  } else {
   HEAP32[$last_moved$0$lcssa + 8 >> 2] = $mover;
   break;
  }
 } while (0);
 HEAP32[$0 >> 2] = 1;
 return;
}

function _skptokenunknownfunctionprint() {
 var $$lcssa = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $14 = 0, $15 = 0, $17 = 0, $2 = 0, $25 = 0, $28 = 0, $29 = 0, $i$01$i$i = 0, $i$01$i1$i = 0;
 $0 = HEAP32[3990] | 0;
 $1 = HEAP32[4044] | 0;
 $2 = HEAP32[4045] | 0;
 if (($1 | 0) < ($2 | 0)) {
  $i$01$i$i = $1;
  while (1) {
   _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i$i >> 0] | 0) >> 0] | 0, $0) | 0;
   $11 = $i$01$i$i + 1 | 0;
   $12 = HEAP32[4045] | 0;
   if (($11 | 0) < ($12 | 0)) $i$01$i$i = $11; else {
    $$lcssa = $12;
    break;
   }
  }
  $15 = HEAP32[4044] | 0;
  $17 = $$lcssa;
 } else {
  $15 = $1;
  $17 = $2;
 }
 $14 = HEAP32[3989] | 0;
 if (($15 | 0) < ($17 | 0)) $i$01$i1$i = $15; else {
  $28 = $14;
  _fwrite(3001, 23, 1, $28) | 0;
  $29 = HEAP32[3990] | 0;
  _fwrite(3001, 23, 1, $29) | 0;
  _skiptokenprint();
  return;
 }
 while (1) {
  _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + $i$01$i1$i >> 0] | 0) >> 0] | 0, $14) | 0;
  $25 = $i$01$i1$i + 1 | 0;
  if (($25 | 0) < (HEAP32[4045] | 0)) $i$01$i1$i = $25; else break;
 }
 $28 = HEAP32[3989] | 0;
 _fwrite(3001, 23, 1, $28) | 0;
 $29 = HEAP32[3990] | 0;
 _fwrite(3001, 23, 1, $29) | 0;
 _skiptokenprint();
 return;
}

function _zzadddatabasecite($newcite) {
 $newcite = $newcite | 0;
 var $12 = 0, $27 = 0, $4 = 0, $5 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 _zcheckciteoverflow(HEAP32[$newcite >> 2] | 0);
 $4 = Math_imul((HEAP32[$newcite >> 2] | 0) + 1 | 0, HEAP32[4247] | 0) | 0;
 $5 = HEAP32[4148] | 0;
 if (($5 | 0) < ($4 | 0)) {
  $7 = HEAP32[3989] | 0;
  $8 = $4 + 5e3 | 0;
  HEAP32[$vararg_buffer >> 2] = 1901;
  HEAP32[$vararg_buffer + 4 >> 2] = 4;
  HEAP32[$vararg_buffer + 8 >> 2] = $8;
  HEAP32[$vararg_buffer + 12 >> 2] = $5;
  _fprintf($7, 1023, $vararg_buffer) | 0;
  $12 = _xrealloc(HEAP32[4149] | 0, ($4 << 2) + 20004 | 0) | 0;
  HEAP32[4149] = $12;
  HEAP32[4148] = $8;
  if (($5 | 0) <= ($4 + 4999 | 0)) _memset($12 + ($5 << 2) | 0, 0, 5e3 - $5 + $4 << 2 | 0) | 0;
 }
 HEAP32[(HEAP32[4099] | 0) + (HEAP32[$newcite >> 2] << 2) >> 2] = HEAP32[(HEAP32[4145] | 0) + (HEAP32[4248] << 2) >> 2];
 $27 = HEAP32[4249] | 0;
 HEAP32[$27 + (HEAP32[4248] << 2) >> 2] = HEAP32[$newcite >> 2];
 HEAP32[$27 + (HEAP32[4250] << 2) >> 2] = HEAP32[4248];
 HEAP32[$newcite >> 2] = (HEAP32[$newcite >> 2] | 0) + 1;
 STACKTOP = sp;
 return;
}

function _hash_insert_normalized($table, $key, $value) {
 $table = $table | 0;
 $key = $key | 0;
 $value = $value | 0;
 var $$02$i = 0, $$lcssa = 0, $0 = 0, $10 = 0, $14 = 0, $15 = 0, $17 = 0, $18 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $loc$0 = 0, $n$0$lcssa$i = 0, $n$03$i = 0, $table$1$val = 0;
 $table$1$val = HEAP32[$table + 4 >> 2] | 0;
 $0 = HEAP8[$key >> 0] | 0;
 if (!($0 << 24 >> 24)) $n$0$lcssa$i = 0; else {
  $$02$i = $key;
  $3 = $0;
  $n$03$i = 0;
  while (1) {
   $5 = $$02$i + 1 | 0;
   $7 = ((($n$03$i << 1) + ($3 << 24 >> 24) | 0) >>> 0) % ($table$1$val >>> 0) | 0;
   $8 = HEAP8[$5 >> 0] | 0;
   if (!($8 << 24 >> 24)) {
    $n$0$lcssa$i = $7;
    break;
   } else {
    $$02$i = $5;
    $3 = $8;
    $n$03$i = $7;
   }
  }
 }
 $10 = _xmalloc(12) | 0;
 HEAP32[$10 >> 2] = $key;
 HEAP32[$10 + 4 >> 2] = $value;
 HEAP32[$10 + 8 >> 2] = 0;
 $14 = (HEAP32[$table >> 2] | 0) + ($n$0$lcssa$i << 2) | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 if (!$15) {
  HEAP32[$14 >> 2] = $10;
  return;
 } else $loc$0 = $15;
 while (1) {
  $17 = $loc$0 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  if (!$18) {
   $$lcssa = $17;
   break;
  } else $loc$0 = $18;
 }
 HEAP32[$$lcssa >> 2] = $10;
 return;
}

function _hash_insert($table, $key, $value) {
 $table = $table | 0;
 $key = $key | 0;
 $value = $value | 0;
 var $$02$i = 0, $$lcssa = 0, $0 = 0, $10 = 0, $14 = 0, $15 = 0, $17 = 0, $18 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $loc$0 = 0, $n$0$lcssa$i = 0, $n$03$i = 0, $table$1$val = 0;
 $table$1$val = HEAP32[$table + 4 >> 2] | 0;
 $0 = HEAP8[$key >> 0] | 0;
 if (!($0 << 24 >> 24)) $n$0$lcssa$i = 0; else {
  $$02$i = $key;
  $3 = $0;
  $n$03$i = 0;
  while (1) {
   $5 = $$02$i + 1 | 0;
   $7 = ((($n$03$i << 1) + ($3 << 24 >> 24) | 0) >>> 0) % ($table$1$val >>> 0) | 0;
   $8 = HEAP8[$5 >> 0] | 0;
   if (!($8 << 24 >> 24)) {
    $n$0$lcssa$i = $7;
    break;
   } else {
    $$02$i = $5;
    $3 = $8;
    $n$03$i = $7;
   }
  }
 }
 $10 = _xmalloc(12) | 0;
 HEAP32[$10 >> 2] = $key;
 HEAP32[$10 + 4 >> 2] = $value;
 HEAP32[$10 + 8 >> 2] = 0;
 $14 = (HEAP32[$table >> 2] | 0) + ($n$0$lcssa$i << 2) | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 if (!$15) {
  HEAP32[$14 >> 2] = $10;
  return;
 } else $loc$0 = $15;
 while (1) {
  $17 = $loc$0 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  if (!$18) {
   $$lcssa = $17;
   break;
  } else $loc$0 = $18;
 }
 HEAP32[$$lcssa >> 2] = $10;
 return;
}

function _bstwarnprint() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $7 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[3989] | 0;
 $1 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer >> 2] = 1501;
 HEAP32[$vararg_buffer + 4 >> 2] = $1;
 HEAP32[$vararg_buffer + 8 >> 2] = 1297;
 _fprintf($0, 1280, $vararg_buffer) | 0;
 $2 = HEAP32[3990] | 0;
 $3 = HEAP32[4103] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 1501;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $3;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 1297;
 _fprintf($2, 1280, $vararg_buffer3) | 0;
 $4 = HEAP32[4096] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $4);
 _zoutpoolstr(HEAP32[3989] | 0, $4);
 $7 = HEAP32[4097] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $7);
 _zoutpoolstr(HEAP32[3989] | 0, $7);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 switch (HEAP8[25620] | 0) {
 case 1:
  {
   HEAP32[3991] = (HEAP32[3991] | 0) + 1;
   STACKTOP = sp;
   return;
  }
 case 0:
  {
   HEAP8[25620] = 1;
   HEAP32[3991] = 1;
   STACKTOP = sp;
   return;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 }
}

function _strcasecmp($_l, $_r) {
 $_l = $_l | 0;
 $_r = $_r | 0;
 var $0 = 0, $13 = 0, $14 = 0, $15 = 0, $19 = 0, $20 = 0, $3 = 0, $5 = 0, $7 = 0, $8 = 0, $l$03 = 0, $l$03$lcssa20 = 0, $r$0$lcssa = 0, $r$04 = 0, $r$04$lcssa19 = 0;
 $0 = HEAP8[$_l >> 0] | 0;
 L1 : do if (!($0 << 24 >> 24)) {
  $19 = 0;
  $r$0$lcssa = $_r;
 } else {
  $5 = $0;
  $7 = $0 & 255;
  $l$03 = $_l;
  $r$04 = $_r;
  while (1) {
   $3 = HEAP8[$r$04 >> 0] | 0;
   if (!($3 << 24 >> 24)) {
    $19 = $5;
    $r$0$lcssa = $r$04;
    break L1;
   }
   if ($5 << 24 >> 24 != $3 << 24 >> 24) {
    $8 = _tolower($7) | 0;
    if (($8 | 0) != (_tolower(HEAPU8[$r$04 >> 0] | 0) | 0)) {
     $l$03$lcssa20 = $l$03;
     $r$04$lcssa19 = $r$04;
     break;
    }
   }
   $13 = $l$03 + 1 | 0;
   $14 = $r$04 + 1 | 0;
   $15 = HEAP8[$13 >> 0] | 0;
   if (!($15 << 24 >> 24)) {
    $19 = 0;
    $r$0$lcssa = $14;
    break L1;
   } else {
    $5 = $15;
    $7 = $15 & 255;
    $l$03 = $13;
    $r$04 = $14;
   }
  }
  $19 = HEAP8[$l$03$lcssa20 >> 0] | 0;
  $r$0$lcssa = $r$04$lcssa19;
 } while (0);
 $20 = _tolower($19 & 255) | 0;
 return $20 - (_tolower(HEAPU8[$r$0$lcssa >> 0] | 0) | 0) | 0;
}

function _fflush($f) {
 $f = $f | 0;
 var $$0 = 0, $$01 = 0, $$012 = 0, $$014 = 0, $23 = 0, $27 = 0, $6 = 0, $phitmp = 0, $r$0$lcssa = 0, $r$03 = 0, $r$1 = 0;
 do if (!$f) {
  if (!(HEAP32[108] | 0)) $27 = 0; else $27 = _fflush(HEAP32[108] | 0) | 0;
  ___lock(23056);
  $$012 = HEAP32[5763] | 0;
  if (!$$012) $r$0$lcssa = $27; else {
   $$014 = $$012;
   $r$03 = $27;
   while (1) {
    if ((HEAP32[$$014 + 76 >> 2] | 0) > -1) $23 = ___lockfile($$014) | 0; else $23 = 0;
    if ((HEAP32[$$014 + 20 >> 2] | 0) >>> 0 > (HEAP32[$$014 + 28 >> 2] | 0) >>> 0) $r$1 = ___fflush_unlocked($$014) | 0 | $r$03; else $r$1 = $r$03;
    if ($23 | 0) ___unlockfile($$014);
    $$01 = HEAP32[$$014 + 56 >> 2] | 0;
    if (!$$01) {
     $r$0$lcssa = $r$1;
     break;
    } else {
     $$014 = $$01;
     $r$03 = $r$1;
    }
   }
  }
  ___unlock(23056);
  $$0 = $r$0$lcssa;
 } else {
  if ((HEAP32[$f + 76 >> 2] | 0) <= -1) {
   $$0 = ___fflush_unlocked($f) | 0;
   break;
  }
  $phitmp = (___lockfile($f) | 0) == 0;
  $6 = ___fflush_unlocked($f) | 0;
  if ($phitmp) $$0 = $6; else {
   ___unlockfile($f);
   $$0 = $6;
  }
 } while (0);
 return $$0 | 0;
}

function _fmt_u($0, $1, $s) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $s = $s | 0;
 var $$0$lcssa = 0, $$01$lcssa$off0 = 0, $$05 = 0, $$1$lcssa = 0, $$12 = 0, $$lcssa19 = 0, $13 = 0, $14 = 0, $25 = 0, $28 = 0, $7 = 0, $8 = 0, $9 = 0, $y$03 = 0;
 if ($1 >>> 0 > 0 | ($1 | 0) == 0 & $0 >>> 0 > 4294967295) {
  $$05 = $s;
  $7 = $0;
  $8 = $1;
  while (1) {
   $9 = ___uremdi3($7 | 0, $8 | 0, 10, 0) | 0;
   $13 = $$05 + -1 | 0;
   HEAP8[$13 >> 0] = $9 | 48;
   $14 = ___udivdi3($7 | 0, $8 | 0, 10, 0) | 0;
   if ($8 >>> 0 > 9 | ($8 | 0) == 9 & $7 >>> 0 > 4294967295) {
    $$05 = $13;
    $7 = $14;
    $8 = tempRet0;
   } else {
    $$lcssa19 = $13;
    $28 = $14;
    break;
   }
  }
  $$0$lcssa = $$lcssa19;
  $$01$lcssa$off0 = $28;
 } else {
  $$0$lcssa = $s;
  $$01$lcssa$off0 = $0;
 }
 if (!$$01$lcssa$off0) $$1$lcssa = $$0$lcssa; else {
  $$12 = $$0$lcssa;
  $y$03 = $$01$lcssa$off0;
  while (1) {
   $25 = $$12 + -1 | 0;
   HEAP8[$25 >> 0] = ($y$03 >>> 0) % 10 | 0 | 48;
   if ($y$03 >>> 0 < 10) {
    $$1$lcssa = $25;
    break;
   } else {
    $$12 = $25;
    $y$03 = ($y$03 >>> 0) / 10 | 0;
   }
  }
 }
 return $$1$lcssa | 0;
}

function _expand_elt($kpse, $str_list_ptr, $elt, $start) {
 $kpse = $kpse | 0;
 $str_list_ptr = $str_list_ptr | 0;
 $elt = $elt | 0;
 $start = $start | 0;
 var $$lcssa = 0, $2 = 0, $22 = 0, $6 = 0, $dir$0 = 0, $dir$0$lcssa8 = 0, label = 0;
 $dir$0 = $elt + $start | 0;
 L1 : while (1) switch (HEAP8[$dir$0 >> 0] | 0) {
 case 0:
  {
   break L1;
   break;
  }
 case 47:
  {
   $2 = $dir$0 + 1 | 0;
   if ((HEAP8[$2 >> 0] | 0) == 47) {
    $dir$0$lcssa8 = $dir$0;
    label = 5;
    break L1;
   } else {
    $dir$0 = $2;
    continue L1;
   }
   break;
  }
 default:
  {
   $dir$0 = $dir$0 + 1 | 0;
   continue L1;
  }
 }
 if ((label | 0) == 5) {
  $6 = $dir$0$lcssa8 + 2 | 0;
  while (1) if ((HEAP8[$6 >> 0] | 0) == 47) $6 = $6 + 1 | 0; else {
   $$lcssa = $6;
   break;
  }
  _do_subdir($kpse, $str_list_ptr, $elt, 1 - $elt + $dir$0$lcssa8 | 0, $$lcssa);
  return;
 }
 if (!(_kpathsea_dir_p($kpse, $elt) | 0)) return;
 if ((HEAP8[$elt + ((_strlen($elt) | 0) + -1) >> 0] | 0) == 47) $22 = _xstrdup($elt) | 0; else $22 = _concat($elt, 13340) | 0;
 _str_llist_add($str_list_ptr, $22);
 return;
}

function _strlen($s) {
 $s = $s | 0;
 var $$01$lcssa = 0, $$014 = 0, $$1$lcssa = 0, $$lcssa20 = 0, $$pn = 0, $$pn15 = 0, $0 = 0, $18 = 0, $21 = 0, $5 = 0, $6 = 0, $9 = 0, $w$0 = 0, $w$0$lcssa = 0, label = 0;
 $0 = $s;
 L1 : do if (!($0 & 3)) {
  $$01$lcssa = $s;
  label = 4;
 } else {
  $$014 = $s;
  $21 = $0;
  while (1) {
   if (!(HEAP8[$$014 >> 0] | 0)) {
    $$pn = $21;
    break L1;
   }
   $5 = $$014 + 1 | 0;
   $6 = $5;
   if (!($6 & 3)) {
    $$01$lcssa = $5;
    label = 4;
    break;
   } else {
    $$014 = $5;
    $21 = $6;
   }
  }
 } while (0);
 if ((label | 0) == 4) {
  $w$0 = $$01$lcssa;
  while (1) {
   $9 = HEAP32[$w$0 >> 2] | 0;
   if (!(($9 & -2139062144 ^ -2139062144) & $9 + -16843009)) $w$0 = $w$0 + 4 | 0; else {
    $$lcssa20 = $9;
    $w$0$lcssa = $w$0;
    break;
   }
  }
  if (!(($$lcssa20 & 255) << 24 >> 24)) $$1$lcssa = $w$0$lcssa; else {
   $$pn15 = $w$0$lcssa;
   while (1) {
    $18 = $$pn15 + 1 | 0;
    if (!(HEAP8[$18 >> 0] | 0)) {
     $$1$lcssa = $18;
     break;
    } else $$pn15 = $18;
   }
  }
  $$pn = $$1$lcssa;
 }
 return $$pn - $0 | 0;
}

function _xempty() {
 var $$pre = 0, $0 = 0, $11 = 0, $17 = 0, $2 = 0, $3 = 0, $5 = 0, $8 = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 switch ($0 & 255 | 0) {
 case 1:
  {
   $2 = HEAP32[4345] | 0;
   $3 = HEAP32[4041] | 0;
   $5 = HEAP32[$3 + ($2 << 2) >> 2] | 0;
   HEAP32[4343] = $5;
   $8 = HEAP32[$3 + ($2 + 1 << 2) >> 2] | 0;
   HEAP32[4344] = $8;
   L5 : do if (($5 | 0) < ($8 | 0)) {
    $$pre = HEAP32[4042] | 0;
    $11 = $5;
    while (1) {
     if ((HEAP8[25877 + (HEAPU8[$$pre + $11 >> 0] | 0) >> 0] | 0) != 1) break;
     $17 = $11 + 1 | 0;
     HEAP32[4343] = $17;
     if (($17 | 0) < ($8 | 0)) $11 = $17; else break L5;
    }
    _zpushlitstk(0, 0);
    return;
   } while (0);
   _zpushlitstk(1, 0);
   return;
  }
 case 3:
  {
   _zpushlitstk(1, 0);
   return;
  }
 case 4:
  {
   _zpushlitstk(0, 0);
   return;
  }
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3874, 32, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3874, 32, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
   _zpushlitstk(0, 0);
   return;
  }
 }
}

function _bibidprint() {
 var $11 = 0, $12 = 0, $20 = 0, $3 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 switch (HEAP8[26389] | 0) {
 case 0:
  {
   _fwrite(2086, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(2086, 15, 1, HEAP32[3990] | 0) | 0;
   STACKTOP = sp;
   return;
  }
 case 2:
  {
   $3 = HEAP32[3989] | 0;
   $11 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
   HEAP32[$vararg_buffer >> 2] = 34;
   HEAP32[$vararg_buffer + 4 >> 2] = $11;
   HEAP32[$vararg_buffer + 8 >> 2] = 2102;
   _fprintf($3, 1750, $vararg_buffer) | 0;
   $12 = HEAP32[3990] | 0;
   $20 = HEAPU8[26133 + (HEAPU8[(HEAP32[3993] | 0) + (HEAP32[4045] | 0) >> 0] | 0) >> 0] | 0;
   HEAP32[$vararg_buffer3 >> 2] = 34;
   HEAP32[$vararg_buffer3 + 4 >> 2] = $20;
   HEAP32[$vararg_buffer3 + 8 >> 2] = 2102;
   _fprintf($12, 1750, $vararg_buffer3) | 0;
   STACKTOP = sp;
   return;
  }
 default:
  _idscanningconfusion();
 }
}

function _pad($f, $c, $w, $l, $fl) {
 $f = $f | 0;
 $c = $c | 0;
 $w = $w | 0;
 $l = $l | 0;
 $fl = $fl | 0;
 var $$0$lcssa6 = 0, $$02 = 0, $10 = 0, $11 = 0, $14 = 0, $15 = 0, $17 = 0, $18 = 0, $3 = 0, $7 = 0, $9 = 0, $pad = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 $pad = sp;
 do if (($w | 0) > ($l | 0) & ($fl & 73728 | 0) == 0) {
  $3 = $w - $l | 0;
  _memset($pad | 0, $c | 0, ($3 >>> 0 > 256 ? 256 : $3) | 0) | 0;
  $7 = HEAP32[$f >> 2] | 0;
  $9 = ($7 & 32 | 0) == 0;
  if ($3 >>> 0 > 255) {
   $10 = $w - $l | 0;
   $$02 = $3;
   $17 = $7;
   $18 = $9;
   while (1) {
    if ($18) {
     ___fwritex($pad, 256, $f) | 0;
     $14 = HEAP32[$f >> 2] | 0;
    } else $14 = $17;
    $11 = $$02 + -256 | 0;
    $15 = ($14 & 32 | 0) == 0;
    if ($11 >>> 0 > 255) {
     $$02 = $11;
     $17 = $14;
     $18 = $15;
    } else break;
   }
   if ($15) $$0$lcssa6 = $10 & 255; else break;
  } else if ($9) $$0$lcssa6 = $3; else break;
  ___fwritex($pad, $$0$lcssa6, $f) | 0;
 } while (0);
 STACKTOP = sp;
 return;
}

function _xquote() {
 var $$lcssa = 0, $0 = 0, $1 = 0, $11 = 0, $12 = 0, $15 = 0, $3 = 0, $5 = 0, $9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4237] | 0;
 $1 = HEAP32[4043] | 0;
 if (($0 | 0) < ($1 | 0)) {
  $$lcssa = $0;
  $15 = HEAP32[4042] | 0;
 } else {
  $5 = $1;
  while (1) {
   $3 = HEAP32[3989] | 0;
   HEAP32[$vararg_buffer >> 2] = 1161;
   HEAP32[$vararg_buffer + 4 >> 2] = 1;
   HEAP32[$vararg_buffer + 8 >> 2] = $5 + 65e3;
   HEAP32[$vararg_buffer + 12 >> 2] = $5;
   _fprintf($3, 1023, $vararg_buffer) | 0;
   $9 = _xrealloc(HEAP32[4042] | 0, (HEAP32[4043] | 0) + 65001 | 0) | 0;
   HEAP32[4042] = $9;
   $11 = (HEAP32[4043] | 0) + 65e3 | 0;
   HEAP32[4043] = $11;
   $12 = HEAP32[4237] | 0;
   if (($12 | 0) < ($11 | 0)) {
    $$lcssa = $12;
    $15 = $9;
    break;
   } else $5 = $11;
  }
 }
 HEAP8[$15 + $$lcssa >> 0] = 34;
 HEAP32[4237] = (HEAP32[4237] | 0) + 1;
 _zpushlitstk(_makestring() | 0, 1);
 STACKTOP = sp;
 return;
}

function _readdir($dir) {
 $dir = $dir | 0;
 var $$1 = 0, $0 = 0, $1 = 0, $13 = 0, $14 = 0, $2 = 0, $7 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = $dir + 8 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = $dir + 12 | 0;
 do if (($1 | 0) < (HEAP32[$2 >> 2] | 0)) {
  $14 = $1;
  label = 6;
 } else {
  HEAP32[$vararg_buffer >> 2] = HEAP32[$dir >> 2];
  HEAP32[$vararg_buffer + 4 >> 2] = $dir + 24;
  HEAP32[$vararg_buffer + 8 >> 2] = 2048;
  $7 = ___syscall220(220, $vararg_buffer | 0) | 0;
  if (($7 | 0) >= 1) {
   HEAP32[$2 >> 2] = $7;
   HEAP32[$0 >> 2] = 0;
   $14 = 0;
   label = 6;
   break;
  }
  if (($7 | 0) < 0 & ($7 | 0) != -2) {
   HEAP32[(___errno_location() | 0) >> 2] = 0 - $7;
   $$1 = 0;
  } else $$1 = 0;
 } while (0);
 if ((label | 0) == 6) {
  $13 = $dir + 24 + $14 | 0;
  HEAP32[$0 >> 2] = (HEAPU16[$13 + 16 >> 1] | 0) + $14;
  HEAP32[$dir + 4 >> 2] = HEAP32[$13 + 8 >> 2];
  $$1 = $13;
 }
 STACKTOP = sp;
 return $$1 | 0;
}

function _biberrprint() {
 var $6 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _putc(45, HEAP32[3989] | 0) | 0;
 _putc(45, HEAP32[3990] | 0) | 0;
 _biblnnumprint();
 _printbadinputline();
 _fwrite(1213, 38, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1213, 38, 1, HEAP32[3990] | 0) | 0;
 $6 = HEAP32[3989] | 0;
 if (!(HEAP32[4147] | 0)) {
  HEAP32[$vararg_buffer4 >> 2] = 1895;
  _fprintf($6, 960, $vararg_buffer4) | 0;
  $8 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer7 >> 2] = 1895;
  _fprintf($8, 960, $vararg_buffer7) | 0;
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$vararg_buffer >> 2] = 1307;
  _fprintf($6, 960, $vararg_buffer) | 0;
  $7 = HEAP32[3990] | 0;
  HEAP32[$vararg_buffer1 >> 2] = 1307;
  _fprintf($7, 960, $vararg_buffer1) | 0;
  STACKTOP = sp;
  return;
 }
}

function _biblnnumprint() {
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $7 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[3989] | 0;
 $1 = HEAP32[4146] | 0;
 HEAP32[$vararg_buffer >> 2] = 1501;
 HEAP32[$vararg_buffer + 4 >> 2] = $1;
 HEAP32[$vararg_buffer + 8 >> 2] = 1297;
 _fprintf($0, 1280, $vararg_buffer) | 0;
 $2 = HEAP32[3990] | 0;
 $3 = HEAP32[4146] | 0;
 HEAP32[$vararg_buffer3 >> 2] = 1501;
 HEAP32[$vararg_buffer3 + 4 >> 2] = $3;
 HEAP32[$vararg_buffer3 + 8 >> 2] = 1297;
 _fprintf($2, 1280, $vararg_buffer3) | 0;
 $7 = HEAP32[(HEAP32[4094] | 0) + (HEAP32[4093] << 2) >> 2] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $7);
 _zoutpoolstr(HEAP32[3989] | 0, $7);
 $10 = HEAP32[4095] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $10);
 _zoutpoolstr(HEAP32[3989] | 0, $10);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 STACKTOP = sp;
 return;
}

function _strncmp($_l, $_r, $n) {
 $_l = $_l | 0;
 $_r = $_r | 0;
 $n = $n | 0;
 var $$03 = 0, $$08 = 0, $$08$in = 0, $1 = 0, $10 = 0, $13 = 0, $3 = 0, $6 = 0, $8 = 0, $9 = 0, $l$06 = 0, $r$0$lcssa = 0, $r$07 = 0;
 if (!$n) $$03 = 0; else {
  $1 = HEAP8[$_l >> 0] | 0;
  L3 : do if (!($1 << 24 >> 24)) {
   $13 = 0;
   $r$0$lcssa = $_r;
  } else {
   $$08$in = $n;
   $6 = $1;
   $l$06 = $_l;
   $r$07 = $_r;
   while (1) {
    $$08 = $$08$in + -1 | 0;
    $3 = HEAP8[$r$07 >> 0] | 0;
    if (!($6 << 24 >> 24 == $3 << 24 >> 24 & (($$08 | 0) != 0 & $3 << 24 >> 24 != 0))) {
     $13 = $6;
     $r$0$lcssa = $r$07;
     break L3;
    }
    $8 = $l$06 + 1 | 0;
    $9 = $r$07 + 1 | 0;
    $10 = HEAP8[$8 >> 0] | 0;
    if (!($10 << 24 >> 24)) {
     $13 = 0;
     $r$0$lcssa = $9;
     break;
    } else {
     $$08$in = $$08;
     $6 = $10;
     $l$06 = $8;
     $r$07 = $9;
    }
   }
  } while (0);
  $$03 = ($13 & 255) - (HEAPU8[$r$0$lcssa >> 0] | 0) | 0;
 }
 return $$03 | 0;
}

function _xchrtoint() {
 var $0 = 0, $1 = 0, $14 = 0, $5 = 0, $9 = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 $1 = HEAP32[4345] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   $5 = HEAP32[4041] | 0;
   $9 = HEAP32[$5 + ($1 << 2) >> 2] | 0;
   if (((HEAP32[$5 + ($1 + 1 << 2) >> 2] | 0) - $9 | 0) == 1) {
    _zpushlitstk(HEAPU8[(HEAP32[4042] | 0) + $9 >> 0] | 0, 0);
    return;
   } else {
    _putc(34, HEAP32[3989] | 0) | 0;
    _putc(34, HEAP32[3990] | 0) | 0;
    $14 = HEAP32[4345] | 0;
    _zoutpoolstr(HEAP32[3990] | 0, $14);
    _zoutpoolstr(HEAP32[3989] | 0, $14);
    _fwrite(3847, 26, 1, HEAP32[3989] | 0) | 0;
    _fwrite(3847, 26, 1, HEAP32[3990] | 0) | 0;
    _bstexwarnprint();
    _zpushlitstk(0, 0);
    return;
   }
   break;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit($1, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _zinputln($f) {
 $f = $f | 0;
 var $$pr = 0, $$pre = 0, $18 = 0, $19 = 0, $9 = 0, $Result$0 = 0, label = 0;
 HEAP32[3999] = 0;
 if (_eof($f) | 0) {
  $Result$0 = 0;
  return $Result$0 | 0;
 }
 if (!(_eoln($f) | 0)) do {
  if ((HEAP32[3999] | 0) >= (HEAP32[3992] | 0)) _bufferoverflow();
  $9 = HEAP8[25621 + (_getc($f) | 0) >> 0] | 0;
  HEAP8[(HEAP32[3993] | 0) + (HEAP32[3999] | 0) >> 0] = $9;
  HEAP32[3999] = (HEAP32[3999] | 0) + 1;
 } while (!(_eoln($f) | 0));
 _getc($f) | 0;
 $$pr = HEAP32[3999] | 0;
 if (($$pr | 0) <= 0) {
  $Result$0 = 1;
  return $Result$0 | 0;
 }
 $$pre = HEAP32[3993] | 0;
 $19 = $$pr;
 while (1) {
  $18 = $19 + -1 | 0;
  if ((HEAP8[25877 + (HEAPU8[$$pre + $18 >> 0] | 0) >> 0] | 0) != 1) {
   $Result$0 = 1;
   label = 10;
   break;
  }
  HEAP32[3999] = $18;
  if (($19 | 0) > 1) $19 = $18; else {
   $Result$0 = 1;
   label = 10;
   break;
  }
 }
 if ((label | 0) == 10) return $Result$0 | 0;
 return 0;
}

function _makestring() {
 var $0 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[4e3] | 0;
 if (($0 | 0) == (HEAP32[4001] | 0)) {
  _fwrite(926, 33, 1, HEAP32[3989] | 0) | 0;
  _fwrite(926, 33, 1, HEAP32[3990] | 0) | 0;
  HEAP8[25620] = 3;
  $5 = HEAP32[3989] | 0;
  $6 = HEAP32[4001] | 0;
  HEAP32[$vararg_buffer >> 2] = 2866;
  HEAP32[$vararg_buffer + 4 >> 2] = $6;
  _fprintf($5, 2854, $vararg_buffer) | 0;
  $7 = HEAP32[3990] | 0;
  $8 = HEAP32[4001] | 0;
  HEAP32[$vararg_buffer2 >> 2] = 2866;
  HEAP32[$vararg_buffer2 + 4 >> 2] = $8;
  _fprintf($7, 2854, $vararg_buffer2) | 0;
  _longjmp(16008, 1);
 } else {
  $9 = $0 + 1 | 0;
  HEAP32[4e3] = $9;
  HEAP32[(HEAP32[4041] | 0) + ($9 << 2) >> 2] = HEAP32[4237];
  STACKTOP = sp;
  return (HEAP32[4e3] | 0) + -1 | 0;
 }
 return 0;
}

function _outputbblline() {
 var $$pre = 0, $0 = 0, $12 = 0, $24 = 0, $3 = 0, $4 = 0, $storemerge2 = 0;
 $0 = HEAP32[4153] | 0;
 do if ($0 | 0) {
  if (($0 | 0) <= 0) {
   HEAP32[4154] = 0;
   break;
  }
  $$pre = HEAP32[3996] | 0;
  $4 = $0;
  while (1) {
   $3 = $4 + -1 | 0;
   if ((HEAP8[25877 + (HEAPU8[$$pre + $3 >> 0] | 0) >> 0] | 0) != 1) {
    $12 = $4;
    break;
   }
   HEAP32[4153] = $3;
   if (($4 | 0) > 1) $4 = $3; else {
    $12 = $3;
    break;
   }
  }
  if (!$12) return;
  HEAP32[4154] = 0;
  if (($12 | 0) > 0) {
   $storemerge2 = 0;
   while (1) {
    _putc(HEAPU8[26133 + (HEAPU8[(HEAP32[3996] | 0) + $storemerge2 >> 0] | 0) >> 0] | 0, HEAP32[4155] | 0) | 0;
    $24 = (HEAP32[4154] | 0) + 1 | 0;
    HEAP32[4154] = $24;
    if (($24 | 0) < (HEAP32[4153] | 0)) $storemerge2 = $24; else break;
   }
  }
 } while (0);
 _putc(10, HEAP32[4155] | 0) | 0;
 HEAP32[4156] = (HEAP32[4156] | 0) + 1;
 HEAP32[4153] = 0;
 return;
}

function _fputc($c, $f) {
 $c = $c | 0;
 $f = $f | 0;
 var $$0 = 0, $10 = 0, $22 = 0, $23 = 0, $31 = 0, $9 = 0, label = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) < 0) label = 3; else if (!(___lockfile($f) | 0)) label = 3; else {
  if ((HEAP8[$f + 75 >> 0] | 0) == ($c | 0)) label = 10; else {
   $22 = $f + 20 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   if ($23 >>> 0 < (HEAP32[$f + 16 >> 2] | 0) >>> 0) {
    HEAP32[$22 >> 2] = $23 + 1;
    HEAP8[$23 >> 0] = $c;
    $31 = $c & 255;
   } else label = 10;
  }
  if ((label | 0) == 10) $31 = ___overflow($f, $c) | 0;
  ___unlockfile($f);
  $$0 = $31;
 }
 do if ((label | 0) == 3) {
  if ((HEAP8[$f + 75 >> 0] | 0) != ($c | 0)) {
   $9 = $f + 20 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   if ($10 >>> 0 < (HEAP32[$f + 16 >> 2] | 0) >>> 0) {
    HEAP32[$9 >> 2] = $10 + 1;
    HEAP8[$10 >> 0] = $c;
    $$0 = $c & 255;
    break;
   }
  }
  $$0 = ___overflow($f, $c) | 0;
 } while (0);
 return $$0 | 0;
}

function _putc($c, $f) {
 $c = $c | 0;
 $f = $f | 0;
 var $$0 = 0, $10 = 0, $22 = 0, $23 = 0, $31 = 0, $9 = 0, label = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) < 0) label = 3; else if (!(___lockfile($f) | 0)) label = 3; else {
  if ((HEAP8[$f + 75 >> 0] | 0) == ($c | 0)) label = 10; else {
   $22 = $f + 20 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   if ($23 >>> 0 < (HEAP32[$f + 16 >> 2] | 0) >>> 0) {
    HEAP32[$22 >> 2] = $23 + 1;
    HEAP8[$23 >> 0] = $c;
    $31 = $c & 255;
   } else label = 10;
  }
  if ((label | 0) == 10) $31 = ___overflow($f, $c) | 0;
  ___unlockfile($f);
  $$0 = $31;
 }
 do if ((label | 0) == 3) {
  if ((HEAP8[$f + 75 >> 0] | 0) != ($c | 0)) {
   $9 = $f + 20 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   if ($10 >>> 0 < (HEAP32[$f + 16 >> 2] | 0) >>> 0) {
    HEAP32[$9 >> 2] = $10 + 1;
    HEAP8[$10 >> 0] = $c;
    $$0 = $c & 255;
    break;
   }
  }
  $$0 = ___overflow($f, $c) | 0;
 } while (0);
 return $$0 | 0;
}

function _concatn_with_spaces($str1, $varargs) {
 $str1 = $str1 | 0;
 $varargs = $varargs | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $17 = 0, $18 = 0, $7 = 0, $8 = 0, $ap = 0, $ret$0$lcssa = 0, $ret$01 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 if (!$str1) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $1 = _xstrdup($str1) | 0;
 HEAP32[$ap >> 2] = $varargs;
 $7 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
 $8 = HEAP32[$7 >> 2] | 0;
 HEAP32[$ap >> 2] = $7 + 4;
 if (!$8) $ret$0$lcssa = $1; else {
  $10 = $8;
  $ret$01 = $1;
  while (1) {
   $11 = _concat3($ret$01, 6878, $10) | 0;
   _free($ret$01);
   $17 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $18 = HEAP32[$17 >> 2] | 0;
   HEAP32[$ap >> 2] = $17 + 4;
   if (!$18) {
    $ret$0$lcssa = $11;
    break;
   } else {
    $10 = $18;
    $ret$01 = $11;
   }
  }
 }
 $$0 = $ret$0$lcssa;
 STACKTOP = sp;
 return $$0 | 0;
}

function _strerror($e) {
 $e = $e | 0;
 var $$lcssa = 0, $10 = 0, $5 = 0, $9 = 0, $i$03 = 0, $i$03$lcssa = 0, $i$12 = 0, $s$0$lcssa = 0, $s$01 = 0, $s$1 = 0, label = 0;
 $i$03 = 0;
 while (1) {
  if ((HEAPU8[13488 + $i$03 >> 0] | 0) == ($e | 0)) {
   $i$03$lcssa = $i$03;
   label = 2;
   break;
  }
  $5 = $i$03 + 1 | 0;
  if (($5 | 0) == 87) {
   $i$12 = 87;
   $s$01 = 13576;
   label = 5;
   break;
  } else $i$03 = $5;
 }
 if ((label | 0) == 2) if (!$i$03$lcssa) $s$0$lcssa = 13576; else {
  $i$12 = $i$03$lcssa;
  $s$01 = 13576;
  label = 5;
 }
 if ((label | 0) == 5) while (1) {
  label = 0;
  $s$1 = $s$01;
  while (1) {
   $9 = $s$1 + 1 | 0;
   if (!(HEAP8[$s$1 >> 0] | 0)) {
    $$lcssa = $9;
    break;
   } else $s$1 = $9;
  }
  $10 = $i$12 + -1 | 0;
  if (!$10) {
   $s$0$lcssa = $$lcssa;
   break;
  } else {
   $i$12 = $10;
   $s$01 = $$lcssa;
   label = 5;
  }
 }
 return $s$0$lcssa | 0;
}

function _xgreaterthan() {
 var $0 = 0, $4 = 0, $5 = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $4 = HEAP8[26649] | 0;
   $5 = HEAP32[4365] | 0;
   switch ($4 << 24 >> 24) {
   case 0:
    {
     if (($5 | 0) > (HEAP32[4345] | 0)) {
      _zpushlitstk(1, 0);
      return;
     } else {
      _zpushlitstk(0, 0);
      return;
     }
     break;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit($5, $4);
     _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(0, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _concatn($str1, $varargs) {
 $str1 = $str1 | 0;
 $varargs = $varargs | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $17 = 0, $18 = 0, $7 = 0, $8 = 0, $ap = 0, $ret$0$lcssa = 0, $ret$01 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 if (!$str1) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $1 = _xstrdup($str1) | 0;
 HEAP32[$ap >> 2] = $varargs;
 $7 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
 $8 = HEAP32[$7 >> 2] | 0;
 HEAP32[$ap >> 2] = $7 + 4;
 if (!$8) $ret$0$lcssa = $1; else {
  $10 = $8;
  $ret$01 = $1;
  while (1) {
   $11 = _concat($ret$01, $10) | 0;
   _free($ret$01);
   $17 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
   $18 = HEAP32[$17 >> 2] | 0;
   HEAP32[$ap >> 2] = $17 + 4;
   if (!$18) {
    $ret$0$lcssa = $11;
    break;
   } else {
    $10 = $18;
    $ret$01 = $11;
   }
  }
 }
 $$0 = $ret$0$lcssa;
 STACKTOP = sp;
 return $$0 | 0;
}

function _xlessthan() {
 var $0 = 0, $4 = 0, $5 = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $4 = HEAP8[26649] | 0;
   $5 = HEAP32[4365] | 0;
   switch ($4 << 24 >> 24) {
   case 0:
    {
     if (($5 | 0) < (HEAP32[4345] | 0)) {
      _zpushlitstk(1, 0);
      return;
     } else {
      _zpushlitstk(0, 0);
      return;
     }
     break;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit($5, $4);
     _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(0, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _wcrtomb($s, $wc, $st) {
 $s = $s | 0;
 $wc = $wc | 0;
 $st = $st | 0;
 var $$0 = 0;
 do if (!$s) $$0 = 1; else {
  if ($wc >>> 0 < 128) {
   HEAP8[$s >> 0] = $wc;
   $$0 = 1;
   break;
  }
  if ($wc >>> 0 < 2048) {
   HEAP8[$s >> 0] = $wc >>> 6 | 192;
   HEAP8[$s + 1 >> 0] = $wc & 63 | 128;
   $$0 = 2;
   break;
  }
  if ($wc >>> 0 < 55296 | ($wc & -8192 | 0) == 57344) {
   HEAP8[$s >> 0] = $wc >>> 12 | 224;
   HEAP8[$s + 1 >> 0] = $wc >>> 6 & 63 | 128;
   HEAP8[$s + 2 >> 0] = $wc & 63 | 128;
   $$0 = 3;
   break;
  }
  if (($wc + -65536 | 0) >>> 0 < 1048576) {
   HEAP8[$s >> 0] = $wc >>> 18 | 240;
   HEAP8[$s + 1 >> 0] = $wc >>> 12 & 63 | 128;
   HEAP8[$s + 2 >> 0] = $wc >>> 6 & 63 | 128;
   HEAP8[$s + 3 >> 0] = $wc & 63 | 128;
   $$0 = 4;
   break;
  } else {
   HEAP32[(___errno_location() | 0) >> 2] = 84;
   $$0 = -1;
   break;
  }
 } while (0);
 return $$0 | 0;
}

function _unknwnfunctionclassconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(1548, 22, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1548, 22, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _citekeydisappearedconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(2155, 22, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2155, 22, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _fopen($filename, $mode) {
 $filename = $filename | 0;
 $mode = $mode | 0;
 var $$0 = 0, $5 = 0, $7 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 if (!(_memchr(15914, HEAP8[$mode >> 0] | 0, 4) | 0)) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $$0 = 0;
 } else {
  $5 = ___fmodeflags($mode) | 0 | 32768;
  HEAP32[$vararg_buffer >> 2] = $filename;
  HEAP32[$vararg_buffer + 4 >> 2] = $5;
  HEAP32[$vararg_buffer + 8 >> 2] = 438;
  $7 = ___syscall_ret(___syscall5(5, $vararg_buffer | 0) | 0) | 0;
  if (($7 | 0) < 0) $$0 = 0; else {
   $9 = ___fdopen($7, $mode) | 0;
   if (!$9) {
    HEAP32[$vararg_buffer3 >> 2] = $7;
    ___syscall6(6, $vararg_buffer3 | 0) | 0;
    $$0 = 0;
   } else $$0 = $9;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _caseconversionconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(2640, 31, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2640, 31, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _unknwnliteralconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(2397, 20, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2397, 20, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _illeglliteralconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(2376, 20, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2376, 20, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _nonexistentcrossreferenceerror() {
 var $6 = 0, $7 = 0, $storemerge$i = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(2206, 22, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2206, 22, 1, HEAP32[3990] | 0) | 0;
 _zbadcrossreferenceprint(HEAP32[(HEAP32[4149] | 0) + (HEAP32[4151] << 2) >> 2] | 0);
 $6 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 2229;
 _fprintf($6, 960, $vararg_buffer) | 0;
 $7 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 2229;
 _fprintf($7, 960, $vararg_buffer1) | 0;
 if ((HEAPU8[25620] | 0) < 2) {
  HEAP8[25620] = 2;
  $storemerge$i = 1;
  HEAP32[3991] = $storemerge$i;
  STACKTOP = sp;
  return;
 } else {
  $storemerge$i = (HEAP32[3991] | 0) + 1 | 0;
  HEAP32[3991] = $storemerge$i;
  STACKTOP = sp;
  return;
 }
}

function _idscanningconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(1724, 25, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1724, 25, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function ___overflow($f, $_c) {
 $f = $f | 0;
 $_c = $_c | 0;
 var $$0 = 0, $0 = 0, $1 = 0, $10 = 0, $2 = 0, $6 = 0, $7 = 0, $9 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 $0 = $_c & 255;
 HEAP8[$c >> 0] = $0;
 $1 = $f + 16 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 if (!$2) if (!(___towrite($f) | 0)) {
  $9 = HEAP32[$1 >> 2] | 0;
  label = 4;
 } else $$0 = -1; else {
  $9 = $2;
  label = 4;
 }
 do if ((label | 0) == 4) {
  $6 = $f + 20 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  if ($7 >>> 0 < $9 >>> 0) {
   $10 = $_c & 255;
   if (($10 | 0) != (HEAP8[$f + 75 >> 0] | 0)) {
    HEAP32[$6 >> 2] = $7 + 1;
    HEAP8[$7 >> 0] = $0;
    $$0 = $10;
    break;
   }
  }
  if ((FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 7]($f, $c, 1) | 0) == 1) $$0 = HEAPU8[$c >> 0] | 0; else $$0 = -1;
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _hashciteconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(1407, 15, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1407, 15, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _bibcmdconfusion() {
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 _fwrite(2125, 29, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2125, 29, 1, HEAP32[3990] | 0) | 0;
 $2 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer >> 2] = 964;
 _fprintf($2, 960, $vararg_buffer) | 0;
 $3 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer1 >> 2] = 964;
 _fprintf($3, 960, $vararg_buffer1) | 0;
 $4 = HEAP32[3989] | 0;
 HEAP32[$vararg_buffer4 >> 2] = 985;
 _fprintf($4, 960, $vararg_buffer4) | 0;
 $5 = HEAP32[3990] | 0;
 HEAP32[$vararg_buffer7 >> 2] = 985;
 _fprintf($5, 960, $vararg_buffer7) | 0;
 HEAP8[25620] = 3;
 _longjmp(16008, 1);
}

function _fn_grow($f, $source, $len) {
 $f = $f | 0;
 $source = $source | 0;
 $len = $len | 0;
 var $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $0 = $f + 8 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $3 = $f + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $$pre$i = HEAP32[$f >> 2] | 0;
 if (($1 + $len | 0) >>> 0 > $4 >>> 0) {
  $7 = $4;
  $8 = $$pre$i;
  while (1) {
   $6 = $7 + 75 | 0;
   HEAP32[$3 >> 2] = $6;
   $9 = _xrealloc($8, $6) | 0;
   HEAP32[$f >> 2] = $9;
   $10 = HEAP32[$0 >> 2] | 0;
   $12 = HEAP32[$3 >> 2] | 0;
   if (($10 + $len | 0) >>> 0 > $12 >>> 0) {
    $7 = $12;
    $8 = $9;
   } else {
    $15 = $9;
    $16 = $10;
    break;
   }
  }
 } else {
  $15 = $$pre$i;
  $16 = $1;
 }
 _strncpy($15 + $16 | 0, $source, $len) | 0;
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + $len;
 return;
}

function _frexp($x, $e) {
 $x = +$x;
 $e = $e | 0;
 var $$0 = 0.0, $$01 = 0.0, $0 = 0, $1 = 0, $2 = 0, $4 = 0, $7 = 0.0, $storemerge = 0;
 HEAPF64[tempDoublePtr >> 3] = $x;
 $0 = HEAP32[tempDoublePtr >> 2] | 0;
 $1 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $2 = _bitshift64Lshr($0 | 0, $1 | 0, 52) | 0;
 $4 = $2 & 2047;
 switch ($4 | 0) {
 case 0:
  {
   if ($x != 0.0) {
    $7 = +_frexp($x * 18446744073709551616.0, $e);
    $$01 = $7;
    $storemerge = (HEAP32[$e >> 2] | 0) + -64 | 0;
   } else {
    $$01 = $x;
    $storemerge = 0;
   }
   HEAP32[$e >> 2] = $storemerge;
   $$0 = $$01;
   break;
  }
 case 2047:
  {
   $$0 = $x;
   break;
  }
 default:
  {
   HEAP32[$e >> 2] = $4 + -1022;
   HEAP32[tempDoublePtr >> 2] = $0;
   HEAP32[tempDoublePtr + 4 >> 2] = $1 & -2146435073 | 1071644672;
   $$0 = +HEAPF64[tempDoublePtr >> 3];
  }
 }
 return +$$0;
}

function _xdirname($name) {
 $name = $name | 0;
 var $$0 = 0, $13 = 0, $2 = 0, $8 = 0, $loc$0 = 0, $loc$1 = 0, $loc$1$lcssa = 0, label = 0;
 if (!$name) {
  $$0 = 0;
  return $$0 | 0;
 }
 $loc$0 = _strlen($name) | 0;
 while (1) {
  if (!$loc$0) {
   label = 5;
   break;
  }
  $2 = $loc$0 + -1 | 0;
  if ((HEAP8[$name + $2 >> 0] | 0) == 47) {
   $loc$1 = $loc$0;
   break;
  } else $loc$0 = $2;
 }
 if ((label | 0) == 5) {
  $$0 = _xstrdup(15912) | 0;
  return $$0 | 0;
 }
 while (1) {
  if ($loc$1 >>> 0 <= 1) {
   $loc$1$lcssa = $loc$1;
   break;
  }
  $8 = $loc$1 + -1 | 0;
  if ((HEAP8[$name + $8 >> 0] | 0) == 47) $loc$1 = $8; else {
   $loc$1$lcssa = $loc$1;
   break;
  }
 }
 $13 = _xmalloc($loc$1$lcssa + 1 | 0) | 0;
 _strncpy($13, $name, $loc$1$lcssa) | 0;
 HEAP8[$13 + $loc$1$lcssa >> 0] = 0;
 $$0 = $13;
 return $$0 | 0;
}

function _kpathsea_normalize_path($kpse, $elt) {
 $kpse = $kpse | 0;
 $elt = $elt | 0;
 var $$lcssa = 0, $0 = 0, $9 = 0, $i$0 = 0, $i$0$lcssa = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $i$0 = 0;
 while (1) {
  $0 = $elt + $i$0 | 0;
  if ((HEAP8[$0 >> 0] | 0) == 47) $i$0 = $i$0 + 1 | 0; else {
   $$lcssa = $0;
   $i$0$lcssa = $i$0;
   break;
  }
 }
 if ($i$0$lcssa >>> 0 <= 1) {
  STACKTOP = sp;
  return 0;
 }
 if (HEAP32[$kpse + 44 >> 2] & 1 | 0) {
  $9 = HEAP32[21] | 0;
  _fwrite(13458, 7, 1, $9) | 0;
  HEAP32[$vararg_buffer >> 2] = $elt;
  HEAP32[$vararg_buffer + 4 >> 2] = 0;
  _fprintf($9, 13189, $vararg_buffer) | 0;
  _fflush($9) | 0;
 }
 _memmove($elt + 1 | 0, $$lcssa | 0, (_strlen($$lcssa) | 0) + 1 | 0) | 0;
 STACKTOP = sp;
 return 0;
}

function _setupboundvariable($var, $var_name, $dflt) {
 $var = $var | 0;
 $var_name = $var_name | 0;
 $dflt = $dflt | 0;
 var $0 = 0, $2 = 0, $6 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _kpse_var_value($var_name) | 0;
 HEAP32[$var >> 2] = $dflt;
 if (!$0) {
  STACKTOP = sp;
  return;
 }
 $2 = _atoi($0) | 0;
 if (($2 | 0) < 0) label = 4; else if (($dflt | 0) > 0 & ($2 | 0) == 0) label = 4; else HEAP32[$var >> 2] = $2;
 if ((label | 0) == 4) {
  $6 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[4734];
  HEAP32[$vararg_buffer + 4 >> 2] = $2;
  HEAP32[$vararg_buffer + 8 >> 2] = $var_name;
  HEAP32[$vararg_buffer + 12 >> 2] = $dflt;
  _fprintf($6, 6543, $vararg_buffer) | 0;
 }
 _free($0);
 STACKTOP = sp;
 return;
}

function _ungetc($c, $f) {
 $c = $c | 0;
 $f = $f | 0;
 var $$1 = 0, $10 = 0, $11 = 0, $16 = 0, $19 = 0, label = 0;
 do if (($c | 0) == -1) $$1 = -1; else {
  if ((HEAP32[$f + 76 >> 2] | 0) > -1) $16 = ___lockfile($f) | 0; else $16 = 0;
  if (!(HEAP32[$f + 8 >> 2] | 0)) {
   if (!(___toread($f) | 0)) label = 6;
  } else label = 6;
  if ((label | 0) == 6) {
   $10 = $f + 4 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   if ($11 >>> 0 > ((HEAP32[$f + 44 >> 2] | 0) + -8 | 0) >>> 0) {
    $19 = $11 + -1 | 0;
    HEAP32[$10 >> 2] = $19;
    HEAP8[$19 >> 0] = $c;
    HEAP32[$f >> 2] = HEAP32[$f >> 2] & -17;
    if (!$16) {
     $$1 = $c;
     break;
    }
    ___unlockfile($f);
    $$1 = $c;
    break;
   }
  }
  if (!$16) $$1 = -1; else {
   ___unlockfile($f);
   $$1 = -1;
  }
 } while (0);
 return $$1 | 0;
}

function _xminus() {
 var $0 = 0, $4 = 0, $5 = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $4 = HEAP8[26649] | 0;
   $5 = HEAP32[4365] | 0;
   switch ($4 << 24 >> 24) {
   case 0:
    {
     _zpushlitstk($5 - (HEAP32[4345] | 0) | 0, 0);
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit($5, $4);
     _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(0, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _xplus() {
 var $0 = 0, $4 = 0, $5 = 0;
 _zzpoplitstk(17380, 26648);
 _zzpoplitstk(17460, 26649);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 0:
  {
   $4 = HEAP8[26649] | 0;
   $5 = HEAP32[4365] | 0;
   switch ($4 << 24 >> 24) {
   case 0:
    {
     _zpushlitstk((HEAP32[4345] | 0) + $5 | 0, 0);
     return;
    }
   case 4:
    break;
   default:
    {
     _zprintstklit($5, $4);
     _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
     _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
     _bstexwarnprint();
    }
   }
   _zpushlitstk(0, 0);
   return;
  }
 case 4:
  break;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3515, 17, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3515, 17, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _fn_1grow($f, $c) {
 $f = $f | 0;
 $c = $c | 0;
 var $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 $0 = $f + 8 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 $3 = $f + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $$pre$i = HEAP32[$f >> 2] | 0;
 if (($1 + 1 | 0) >>> 0 > $4 >>> 0) {
  $7 = $4;
  $8 = $$pre$i;
  while (1) {
   $6 = $7 + 75 | 0;
   HEAP32[$3 >> 2] = $6;
   $9 = _xrealloc($8, $6) | 0;
   HEAP32[$f >> 2] = $9;
   $10 = HEAP32[$0 >> 2] | 0;
   $12 = HEAP32[$3 >> 2] | 0;
   if (($10 + 1 | 0) >>> 0 > $12 >>> 0) {
    $7 = $12;
    $8 = $9;
   } else {
    $15 = $9;
    $16 = $10;
    break;
   }
  }
 } else {
  $15 = $$pre$i;
  $16 = $1;
 }
 HEAP8[$15 + $16 >> 0] = $c;
 HEAP32[$0 >> 2] = (HEAP32[$0 >> 2] | 0) + 1;
 return;
}

function _uppercasify($s) {
 $s = $s | 0;
 var $$pre = 0, $0 = 0, $1 = 0, $10 = 0, $12 = 0, $13 = 0, $14 = 0, $3 = 0, $6 = 0, $target$02 = 0, label = 0;
 $0 = _xstrdup($s) | 0;
 $1 = HEAP8[$0 >> 0] | 0;
 if (!($1 << 24 >> 24)) return $0 | 0; else {
  $3 = $1;
  $target$02 = $0;
 }
 while (1) {
  if ($3 << 24 >> 24 > -1) {
   $6 = (_islower($3 & 255) | 0) == 0;
   $$pre = HEAP8[$target$02 >> 0] | 0;
   if ($6) {
    $10 = $$pre;
    label = 5;
   } else $12 = _toupper($$pre & 255) | 0;
  } else {
   $10 = $3;
   label = 5;
  }
  if ((label | 0) == 5) {
   label = 0;
   $12 = $10 << 24 >> 24;
  }
  HEAP8[$target$02 >> 0] = $12;
  $13 = $target$02 + 1 | 0;
  $14 = HEAP8[$13 >> 0] | 0;
  if (!($14 << 24 >> 24)) break; else {
   $3 = $14;
   $target$02 = $13;
  }
 }
 return $0 | 0;
}

function _realloc($oldmem, $bytes) {
 $oldmem = $oldmem | 0;
 $bytes = $bytes | 0;
 var $12 = 0, $15 = 0, $20 = 0, $9 = 0, $mem$1 = 0;
 if (!$oldmem) {
  $mem$1 = _malloc($bytes) | 0;
  return $mem$1 | 0;
 }
 if ($bytes >>> 0 > 4294967231) {
  HEAP32[(___errno_location() | 0) >> 2] = 12;
  $mem$1 = 0;
  return $mem$1 | 0;
 }
 $9 = _try_realloc_chunk($oldmem + -8 | 0, $bytes >>> 0 < 11 ? 16 : $bytes + 11 & -8) | 0;
 if ($9 | 0) {
  $mem$1 = $9 + 8 | 0;
  return $mem$1 | 0;
 }
 $12 = _malloc($bytes) | 0;
 if (!$12) {
  $mem$1 = 0;
  return $mem$1 | 0;
 }
 $15 = HEAP32[$oldmem + -4 >> 2] | 0;
 $20 = ($15 & -8) - (($15 & 3 | 0) == 0 ? 8 : 4) | 0;
 _memcpy($12 | 0, $oldmem | 0, ($20 >>> 0 < $bytes >>> 0 ? $20 : $bytes) | 0) | 0;
 _free($oldmem);
 $mem$1 = $12;
 return $mem$1 | 0;
}

function _target_fontmaps($kpse, $target, $count, $name) {
 $kpse = $kpse | 0;
 $target = $target | 0;
 $count = $count | 0;
 $name = $name | 0;
 var $0 = 0, $15 = 0, $2 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $mapped_names$01 = 0;
 $0 = _kpathsea_fontmap_lookup($kpse, $name) | 0;
 if (!$0) return;
 $2 = HEAP32[$0 >> 2] | 0;
 if (!$2) return;
 $5 = $2;
 $mapped_names$01 = $0;
 while (1) {
  $4 = $mapped_names$01 + 4 | 0;
  $6 = _xstrdup($5) | 0;
  $7 = HEAP32[$count >> 2] | 0;
  HEAP32[(HEAP32[$target >> 2] | 0) + ($7 << 2) >> 2] = $6;
  HEAP32[$count >> 2] = $7 + 1;
  HEAP32[$target >> 2] = _xrealloc(HEAP32[$target >> 2] | 0, ($7 << 2) + 8 | 0) | 0;
  $15 = HEAP32[$4 >> 2] | 0;
  if (!$15) break; else {
   $5 = $15;
   $mapped_names$01 = $4;
  }
 }
 return;
}

function _fn_str_grow($f, $s) {
 $f = $f | 0;
 $s = $s | 0;
 var $$pre$i = 0, $0 = 0, $1 = 0, $10 = 0, $13 = 0, $15 = 0, $4 = 0, $5 = 0, $7 = 0, $8 = 0, $9 = 0;
 $0 = _strlen($s) | 0;
 $1 = $f + 8 | 0;
 $4 = $f + 4 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $$pre$i = HEAP32[$f >> 2] | 0;
 if (((HEAP32[$1 >> 2] | 0) + $0 | 0) >>> 0 > $5 >>> 0) {
  $8 = $5;
  $9 = $$pre$i;
  while (1) {
   $7 = $8 + 75 | 0;
   HEAP32[$4 >> 2] = $7;
   $10 = _xrealloc($9, $7) | 0;
   HEAP32[$f >> 2] = $10;
   $13 = HEAP32[$4 >> 2] | 0;
   if (((HEAP32[$1 >> 2] | 0) + $0 | 0) >>> 0 > $13 >>> 0) {
    $8 = $13;
    $9 = $10;
   } else {
    $15 = $10;
    break;
   }
  }
 } else $15 = $$pre$i;
 _strcat($15, $s) | 0;
 HEAP32[$1 >> 2] = (HEAP32[$1 >> 2] | 0) + $0;
 return;
}

function _getcwd($buf, $size) {
 $buf = $buf | 0;
 $size = $size | 0;
 var $$0 = 0, $$01 = 0, $$02 = 0, $tmp = 0, $vararg_buffer = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 4112 | 0;
 $vararg_buffer = sp;
 $tmp = sp + 8 | 0;
 if (!$buf) {
  $$0 = 4096;
  $$01 = $tmp;
  label = 4;
 } else if (!$size) {
  HEAP32[(___errno_location() | 0) >> 2] = 22;
  $$02 = 0;
 } else {
  $$0 = $size;
  $$01 = $buf;
  label = 4;
 }
 if ((label | 0) == 4) {
  HEAP32[$vararg_buffer >> 2] = $$01;
  HEAP32[$vararg_buffer + 4 >> 2] = $$0;
  if ((___syscall_ret(___syscall183(183, $vararg_buffer | 0) | 0) | 0) < 0) $$02 = 0; else if (($$01 | 0) == ($tmp | 0)) $$02 = ___strdup($tmp) | 0; else $$02 = $$01;
 }
 STACKTOP = sp;
 return $$02 | 0;
}

function ___fflush_unlocked($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $9 = 0, label = 0;
 $0 = $f + 20 | 0;
 $2 = $f + 28 | 0;
 if ((HEAP32[$0 >> 2] | 0) >>> 0 > (HEAP32[$2 >> 2] | 0) >>> 0) {
  FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 7]($f, 0, 0) | 0;
  if (!(HEAP32[$0 >> 2] | 0)) $$0 = -1; else label = 3;
 } else label = 3;
 if ((label | 0) == 3) {
  $9 = $f + 4 | 0;
  $10 = HEAP32[$9 >> 2] | 0;
  $11 = $f + 8 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  if ($10 >>> 0 < $12 >>> 0) FUNCTION_TABLE_iiii[HEAP32[$f + 40 >> 2] & 7]($f, $10 - $12 | 0, 1) | 0;
  HEAP32[$f + 16 >> 2] = 0;
  HEAP32[$2 >> 2] = 0;
  HEAP32[$0 >> 2] = 0;
  HEAP32[$11 >> 2] = 0;
  HEAP32[$9 >> 2] = 0;
  $$0 = 0;
 }
 return $$0 | 0;
}

function _kpathsea_tex_hush($kpse, $what) {
 $kpse = $kpse | 0;
 $what = $what | 0;
 var $$0 = 0, $0 = 0, $13 = 0, $6 = 0, $h$02 = 0;
 $0 = _kpathsea_var_value($kpse, 11613) | 0;
 L1 : do if (!$0) $$0 = 0; else if (!(_strcmp($0, 11622) | 0)) $$0 = 1; else if (!(_strcmp($0, 11626) | 0)) $$0 = 0; else {
  $6 = _kpathsea_path_element($kpse, $0) | 0;
  if (!$6) $$0 = 0; else {
   if (!$what) while (1) if (!(_kpathsea_path_element($kpse, 0) | 0)) {
    $$0 = 0;
    break L1;
   } else $h$02 = $6;
   while (1) {
    if (!(_strcmp($h$02, $what) | 0)) {
     $$0 = 1;
     break L1;
    }
    $13 = _kpathsea_path_element($kpse, 0) | 0;
    if (!$13) {
     $$0 = 0;
     break;
    } else $h$02 = $13;
   }
  }
 } while (0);
 return $$0 | 0;
}

function _xwarning() {
 var $0 = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   _fwrite(4091, 9, 1, HEAP32[3989] | 0) | 0;
   _fwrite(4091, 9, 1, HEAP32[3990] | 0) | 0;
   _zprintlit(HEAP32[4345] | 0, HEAP8[26648] | 0);
   switch (HEAP8[25620] | 0) {
   case 1:
    {
     HEAP32[3991] = (HEAP32[3991] | 0) + 1;
     return;
    }
   case 0:
    {
     HEAP8[25620] = 1;
     HEAP32[3991] = 1;
     return;
    }
   default:
    return;
   }
   break;
  }
 case 4:
  return;
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
   return;
  }
 }
}

function _memcpy(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0;
 if ((num | 0) >= 4096) return _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;
 ret = dest | 0;
 if ((dest & 3) == (src & 3)) {
  while (dest & 3) {
   if (!num) return ret | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
   dest = dest + 1 | 0;
   src = src + 1 | 0;
   num = num - 1 | 0;
  }
  while ((num | 0) >= 4) {
   HEAP32[dest >> 2] = HEAP32[src >> 2];
   dest = dest + 4 | 0;
   src = src + 4 | 0;
   num = num - 4 | 0;
  }
 }
 while ((num | 0) > 0) {
  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  dest = dest + 1 | 0;
  src = src + 1 | 0;
  num = num - 1 | 0;
 }
 return ret | 0;
}

function _getc($f) {
 $f = $f | 0;
 var $$0 = 0, $14 = 0, $15 = 0, $23 = 0, $5 = 0, $6 = 0, label = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) < 0) label = 3; else if (!(___lockfile($f) | 0)) label = 3; else {
  $14 = $f + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  if ($15 >>> 0 < (HEAP32[$f + 8 >> 2] | 0) >>> 0) {
   HEAP32[$14 >> 2] = $15 + 1;
   $23 = HEAPU8[$15 >> 0] | 0;
  } else $23 = ___uflow($f) | 0;
  $$0 = $23;
 }
 do if ((label | 0) == 3) {
  $5 = $f + 4 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  if ($6 >>> 0 < (HEAP32[$f + 8 >> 2] | 0) >>> 0) {
   HEAP32[$5 >> 2] = $6 + 1;
   $$0 = HEAPU8[$6 >> 0] | 0;
   break;
  } else {
   $$0 = ___uflow($f) | 0;
   break;
  }
 } while (0);
 return $$0 | 0;
}

function _str_list_concat($target, $more) {
 $target = $target | 0;
 $more = $more | 0;
 var $0 = 0, $1 = 0, $14 = 0, $18 = 0, $2 = 0, $3 = 0, $6 = 0, $9 = 0;
 $0 = HEAP32[$target >> 2] | 0;
 $1 = HEAP32[$more >> 2] | 0;
 $2 = $1 + $0 | 0;
 HEAP32[$target >> 2] = $2;
 $3 = $target + 4 | 0;
 $6 = _xrealloc(HEAP32[$3 >> 2] | 0, $2 << 2) | 0;
 HEAP32[$3 >> 2] = $6;
 if (!$1) return;
 $9 = HEAP32[$more + 4 >> 2] | 0;
 HEAP32[$6 + ($0 << 2) >> 2] = HEAP32[$9 >> 2];
 if ($1 >>> 0 > 1) $14 = 1; else return;
 while (1) {
  HEAP32[(HEAP32[$3 >> 2] | 0) + ($14 + $0 << 2) >> 2] = HEAP32[$9 + ($14 << 2) >> 2];
  $18 = $14 + 1 | 0;
  if ($18 >>> 0 < $1 >>> 0) $14 = $18; else break;
 }
 return;
}

function _strcmp($l, $r) {
 $l = $l | 0;
 $r = $r | 0;
 var $$014 = 0, $$05 = 0, $$lcssa = 0, $$lcssa2 = 0, $0 = 0, $1 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 $0 = HEAP8[$l >> 0] | 0;
 $1 = HEAP8[$r >> 0] | 0;
 if ($0 << 24 >> 24 == 0 ? 1 : $0 << 24 >> 24 != $1 << 24 >> 24) {
  $$lcssa = $0;
  $$lcssa2 = $1;
 } else {
  $$014 = $l;
  $$05 = $r;
  while (1) {
   $4 = $$014 + 1 | 0;
   $5 = $$05 + 1 | 0;
   $6 = HEAP8[$4 >> 0] | 0;
   $7 = HEAP8[$5 >> 0] | 0;
   if ($6 << 24 >> 24 == 0 ? 1 : $6 << 24 >> 24 != $7 << 24 >> 24) {
    $$lcssa = $6;
    $$lcssa2 = $7;
    break;
   } else {
    $$014 = $4;
    $$05 = $5;
   }
  }
 }
 return ($$lcssa & 255) - ($$lcssa2 & 255) | 0;
}

function _memset(ptr, value, num) {
 ptr = ptr | 0;
 value = value | 0;
 num = num | 0;
 var stop = 0, value4 = 0, stop4 = 0, unaligned = 0;
 stop = ptr + num | 0;
 if ((num | 0) >= 20) {
  value = value & 255;
  unaligned = ptr & 3;
  value4 = value | value << 8 | value << 16 | value << 24;
  stop4 = stop & ~3;
  if (unaligned) {
   unaligned = ptr + 4 - unaligned | 0;
   while ((ptr | 0) < (unaligned | 0)) {
    HEAP8[ptr >> 0] = value;
    ptr = ptr + 1 | 0;
   }
  }
  while ((ptr | 0) < (stop4 | 0)) {
   HEAP32[ptr >> 2] = value4;
   ptr = ptr + 4 | 0;
  }
 }
 while ((ptr | 0) < (stop | 0)) {
  HEAP8[ptr >> 0] = value;
  ptr = ptr + 1 | 0;
 }
 return ptr - num | 0;
}

function _fork() {
 var $1 = 0, $10 = 0, $4 = 0, $5 = 0, $7 = 0, $set = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $set = sp + 16 | 0;
 _dummy(-1);
 ___block_all_sigs($set);
 $1 = ___syscall_ret(___syscall2(2, sp | 0) | 0) | 0;
 $4 = ($1 | 0) != 0;
 if (!($4 | (HEAP32[5757] | 0) == 0)) {
  $5 = _pthread_self() | 0;
  $7 = ___syscall_ret(___syscall20(20, sp + 8 | 0) | 0) | 0;
  HEAP32[$5 + 52 >> 2] = $7;
  HEAP32[$5 + 48 >> 2] = $7;
  $10 = $5 + 160 | 0;
  HEAP32[$10 >> 2] = 0;
  HEAP32[$10 + 4 >> 2] = 0;
  HEAP32[$10 + 8 >> 2] = 0;
  HEAP32[5761] = 0;
  HEAP32[5757] = $5;
 }
 ___restore_sigs($set);
 _dummy($4 & 1 ^ 1);
 STACKTOP = sp;
 return $1 | 0;
}

function _fclose($f) {
 $f = $f | 0;
 var $$pre = 0, $12 = 0, $18 = 0, $22 = 0, $24 = 0, $5 = 0, $7 = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) {}
 $5 = (HEAP32[$f >> 2] & 1 | 0) != 0;
 if (!$5) {
  ___lock(23056);
  $7 = HEAP32[$f + 52 >> 2] | 0;
  $$pre = $f + 56 | 0;
  if ($7 | 0) HEAP32[$7 + 56 >> 2] = HEAP32[$$pre >> 2];
  $12 = HEAP32[$$pre >> 2] | 0;
  if ($12 | 0) HEAP32[$12 + 52 >> 2] = $7;
  if ((HEAP32[5763] | 0) == ($f | 0)) HEAP32[5763] = $12;
  ___unlock(23056);
 }
 $18 = _fflush($f) | 0;
 $22 = FUNCTION_TABLE_ii[HEAP32[$f + 12 >> 2] & 3]($f) | 0 | $18;
 $24 = HEAP32[$f + 92 >> 2] | 0;
 if ($24 | 0) _free($24);
 if (!$5) _free($f);
 return $22 | 0;
}

function ___toread($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $15 = 0, $2 = 0, $21 = 0, $6 = 0, $8 = 0;
 $0 = $f + 74 | 0;
 $2 = HEAP8[$0 >> 0] | 0;
 HEAP8[$0 >> 0] = $2 + 255 | $2;
 $6 = $f + 20 | 0;
 $8 = $f + 44 | 0;
 if ((HEAP32[$6 >> 2] | 0) >>> 0 > (HEAP32[$8 >> 2] | 0) >>> 0) FUNCTION_TABLE_iiii[HEAP32[$f + 36 >> 2] & 7]($f, 0, 0) | 0;
 HEAP32[$f + 16 >> 2] = 0;
 HEAP32[$f + 28 >> 2] = 0;
 HEAP32[$6 >> 2] = 0;
 $15 = HEAP32[$f >> 2] | 0;
 if (!($15 & 20)) {
  $21 = HEAP32[$8 >> 2] | 0;
  HEAP32[$f + 8 >> 2] = $21;
  HEAP32[$f + 4 >> 2] = $21;
  $$0 = 0;
 } else if (!($15 & 4)) $$0 = -1; else {
  HEAP32[$f >> 2] = $15 | 32;
  $$0 = -1;
 }
 return $$0 | 0;
}

function _memcmp($vl, $vr, $n) {
 $vl = $vl | 0;
 $vr = $vr | 0;
 $n = $n | 0;
 var $$03 = 0, $$lcssa = 0, $$lcssa19 = 0, $1 = 0, $11 = 0, $2 = 0, $4 = 0, $l$04 = 0, $r$05 = 0;
 L1 : do if (!$n) $11 = 0; else {
  $$03 = $n;
  $l$04 = $vl;
  $r$05 = $vr;
  while (1) {
   $1 = HEAP8[$l$04 >> 0] | 0;
   $2 = HEAP8[$r$05 >> 0] | 0;
   if ($1 << 24 >> 24 != $2 << 24 >> 24) {
    $$lcssa = $1;
    $$lcssa19 = $2;
    break;
   }
   $4 = $$03 + -1 | 0;
   if (!$4) {
    $11 = 0;
    break L1;
   } else {
    $$03 = $4;
    $l$04 = $l$04 + 1 | 0;
    $r$05 = $r$05 + 1 | 0;
   }
  }
  $11 = ($$lcssa & 255) - ($$lcssa19 & 255) | 0;
 } while (0);
 return $11 | 0;
}

function _saveSetjmp(env, label, table, size) {
 env = env | 0;
 label = label | 0;
 table = table | 0;
 size = size | 0;
 var i = 0;
 setjmpId = setjmpId + 1 | 0;
 HEAP32[env >> 2] = setjmpId;
 while ((i | 0) < (size | 0)) {
  if (!(HEAP32[table + (i << 3) >> 2] | 0)) {
   HEAP32[table + (i << 3) >> 2] = setjmpId;
   HEAP32[table + ((i << 3) + 4) >> 2] = label;
   HEAP32[table + ((i << 3) + 8) >> 2] = 0;
   tempRet0 = size;
   return table | 0;
  }
  i = i + 1 | 0;
 }
 size = size * 2 | 0;
 table = _realloc(table | 0, 8 * (size + 1 | 0) | 0) | 0;
 table = _saveSetjmp(env | 0, label | 0, table | 0, size | 0) | 0;
 tempRet0 = size;
 return table | 0;
}

function _open($filename, $flags, $varargs) {
 $filename = $filename | 0;
 $flags = $flags | 0;
 $varargs = $varargs | 0;
 var $5 = 0, $6 = 0, $9 = 0, $ap = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer = sp;
 $ap = sp + 16 | 0;
 HEAP32[$ap >> 2] = $varargs;
 $5 = (HEAP32[$ap >> 2] | 0) + (4 - 1) & ~(4 - 1);
 $6 = HEAP32[$5 >> 2] | 0;
 HEAP32[$ap >> 2] = $5 + 4;
 HEAP32[$vararg_buffer >> 2] = $filename;
 HEAP32[$vararg_buffer + 4 >> 2] = $flags | 32768;
 HEAP32[$vararg_buffer + 8 >> 2] = $6;
 $9 = ___syscall_ret(___syscall5(5, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function ___stdio_seek($f, $off, $whence) {
 $f = $f | 0;
 $off = $off | 0;
 $whence = $whence | 0;
 var $5 = 0, $ret = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 $vararg_buffer = sp;
 $ret = sp + 20 | 0;
 HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
 HEAP32[$vararg_buffer + 4 >> 2] = 0;
 HEAP32[$vararg_buffer + 8 >> 2] = $off;
 HEAP32[$vararg_buffer + 12 >> 2] = $ret;
 HEAP32[$vararg_buffer + 16 >> 2] = $whence;
 if ((___syscall_ret(___syscall140(140, $vararg_buffer | 0) | 0) | 0) < 0) {
  HEAP32[$ret >> 2] = -1;
  $5 = -1;
 } else $5 = HEAP32[$ret >> 2] | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function ___fmodeflags($mode) {
 $mode = $mode | 0;
 var $1 = 0, $2 = 0, $4 = 0, $7 = 0, $flags$0 = 0, $flags$0$ = 0, $flags$2 = 0, $flags$2$ = 0, $flags$4 = 0;
 $1 = (_strchr($mode, 43) | 0) == 0;
 $2 = HEAP8[$mode >> 0] | 0;
 $flags$0 = $1 ? $2 << 24 >> 24 != 114 & 1 : 2;
 $4 = (_strchr($mode, 120) | 0) == 0;
 $flags$0$ = $4 ? $flags$0 : $flags$0 | 128;
 $7 = (_strchr($mode, 101) | 0) == 0;
 $flags$2 = $7 ? $flags$0$ : $flags$0$ | 524288;
 $flags$2$ = $2 << 24 >> 24 == 114 ? $flags$2 : $flags$2 | 64;
 $flags$4 = $2 << 24 >> 24 == 119 ? $flags$2$ | 512 : $flags$2$;
 return ($2 << 24 >> 24 == 97 ? $flags$4 | 1024 : $flags$4) | 0;
}

function _usagehelp($message, $bug_email) {
 $message = $message | 0;
 $bug_email = $bug_email | 0;
 var $$01 = 0, $1 = 0, $3 = 0, $4 = 0, $5 = 0, $bug_email$ = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $bug_email$ = $bug_email | 0 ? $bug_email : 6652;
 $1 = HEAP32[$message >> 2] | 0;
 if ($1 | 0) {
  $$01 = $message;
  $3 = $1;
  while (1) {
   _puts($3) | 0;
   $4 = $$01 + 4 | 0;
   $5 = HEAP32[$4 >> 2] | 0;
   if (!$5) break; else {
    $$01 = $4;
    $3 = $5;
   }
  }
 }
 HEAP32[$vararg_buffer >> 2] = $bug_email$;
 _printf(6666, $vararg_buffer) | 0;
 _uexit(0);
}

function _kpse_fopen_trace($filename, $mode) {
 $filename = $filename | 0;
 $mode = $mode | 0;
 var $0 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _fopen($filename, $mode) | 0;
 if (!(HEAP32[(HEAP32[16] | 0) + 44 >> 2] & 4)) {
  STACKTOP = sp;
  return $0 | 0;
 }
 $6 = HEAP32[21] | 0;
 _fwrite(13458, 7, 1, $6) | 0;
 HEAP32[$vararg_buffer >> 2] = $filename;
 HEAP32[$vararg_buffer + 4 >> 2] = $mode;
 HEAP32[$vararg_buffer + 8 >> 2] = $0;
 _fprintf($6, 10516, $vararg_buffer) | 0;
 _fflush($6) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _zbadcrossreferenceprint($s) {
 $s = $s | 0;
 var $5 = 0;
 _fwrite(2178, 9, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2178, 9, 1, HEAP32[3990] | 0) | 0;
 $5 = HEAP32[(HEAP32[4099] | 0) + (HEAP32[4150] << 2) >> 2] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $5);
 _zoutpoolstr(HEAP32[3989] | 0, $5);
 _putc(34, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(34, HEAP32[3990] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _fwrite(2188, 17, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2188, 17, 1, HEAP32[3990] | 0) | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $s);
 _zoutpoolstr(HEAP32[3989] | 0, $s);
 return;
}

function _xmissing() {
 var $4 = 0;
 _zzpoplitstk(17380, 26648);
 if (!(HEAP32[4152] | 0)) {
  _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
  _bstexwarnprint();
  return;
 }
 $4 = HEAP8[26648] | 0;
 switch ($4 << 24 >> 24) {
 case 4:
  break;
 case 3:
  {
   _zpushlitstk(1, 0);
   return;
  }
 case 1:
  {
   _zpushlitstk(0, 0);
   return;
  }
 default:
  {
   _zprintstklit(HEAP32[4345] | 0, $4);
   _fwrite(3874, 32, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3874, 32, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
  }
 }
 _zpushlitstk(0, 0);
 return;
}

function _puts($s) {
 $s = $s | 0;
 var $0 = 0, $10 = 0, $11 = 0, $18 = 0, $19 = 0;
 $0 = HEAP32[79] | 0;
 if ((HEAP32[$0 + 76 >> 2] | 0) > -1) $19 = ___lockfile($0) | 0; else $19 = 0;
 do if ((_fputs($s, $0) | 0) < 0) $18 = 1; else {
  if ((HEAP8[$0 + 75 >> 0] | 0) != 10) {
   $10 = $0 + 20 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   if ($11 >>> 0 < (HEAP32[$0 + 16 >> 2] | 0) >>> 0) {
    HEAP32[$10 >> 2] = $11 + 1;
    HEAP8[$11 >> 0] = 10;
    $18 = 0;
    break;
   }
  }
  $18 = (___overflow($0, 10) | 0) < 0;
 } while (0);
 if ($19 | 0) ___unlockfile($0);
 return $18 << 31 >> 31 | 0;
}

function _setupparams() {
 var $$ = 0, $10 = 0, $6 = 0, $8 = 0;
 _kpse_set_program_name(HEAP32[HEAP32[4699] >> 2] | 0, 5649);
 _setupboundvariable(17028, 5656, 100);
 if ((HEAP32[4257] | 0) < 100) HEAP32[4257] = 100;
 _setupboundvariable(17228, 5669, 1e3);
 if ((HEAP32[4307] | 0) < 1e3) HEAP32[4307] = 1e3;
 _setupboundvariable(16004, 5683, 4e3);
 $6 = HEAP32[4001] | 0;
 if (($6 | 0) < 4e3) {
  HEAP32[4001] = 4e3;
  $8 = 4e3;
 } else $8 = $6;
 $$ = ($8 | 0) < 5e3 ? 5e3 : $8;
 HEAP32[4245] = $$;
 $10 = $$ + 1 | 0;
 HEAP32[4695] = $$;
 HEAP32[4313] = $10;
 HEAP32[4386] = $10;
 return;
}

function _ftrylockfile($f) {
 $f = $f | 0;
 var $$0 = 0, $2 = 0, $3 = 0, $4 = 0, $6 = 0, $7 = 0;
 $2 = HEAP32[(_pthread_self() | 0) + 48 >> 2] | 0;
 $3 = $f + 76 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 do if (($4 | 0) == ($2 | 0)) {
  $6 = $f + 68 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  if (($7 | 0) == 2147483647) $$0 = -1; else {
   HEAP32[$6 >> 2] = $7 + 1;
   $$0 = 0;
  }
 } else {
  if (($4 | 0) < 0) HEAP32[$3 >> 2] = 0; else if ($4 | 0) {
   $$0 = -1;
   break;
  }
  if (!(HEAP32[$3 >> 2] | 0)) HEAP32[$3 >> 2] = $2;
  HEAP32[$f + 68 >> 2] = 1;
  $$0 = 0;
 } while (0);
 return $$0 | 0;
}

function _xrealloc($old_ptr, $size) {
 $old_ptr = $old_ptr | 0;
 $size = $size | 0;
 var $4 = 0, $6 = 0, $new_mem$0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if (!$old_ptr) {
  $new_mem$0 = _xmalloc($size) | 0;
  STACKTOP = sp;
  return $new_mem$0 | 0;
 }
 $4 = _realloc($old_ptr, $size | 0 ? $size : 1) | 0;
 if (!$4) {
  $6 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = $size;
  _fprintf($6, 12729, $vararg_buffer) | 0;
  _exit(1);
 } else {
  $new_mem$0 = $4;
  STACKTOP = sp;
  return $new_mem$0 | 0;
 }
 return 0;
}

function _xfopen($filename, $mode) {
 $filename = $filename | 0;
 $mode = $mode | 0;
 var $2 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if (!(($filename | 0) != 0 & ($mode | 0) != 0)) ___assert_fail(12574, 12591, 30, 12623);
 $2 = _kpse_fopen_trace($filename, $mode) | 0;
 if (!$2) {
  $4 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[(HEAP32[16] | 0) + 104 >> 2];
  _fprintf($4, 12640, $vararg_buffer) | 0;
  _perror($filename);
  _exit(1);
 } else {
  STACKTOP = sp;
  return $2 | 0;
 }
 return 0;
}

function _str_llist_add($l, $str) {
 $l = $l | 0;
 $str = $str | 0;
 var $$lcssa = 0, $0 = 0, $5 = 0, $6 = 0, $e$0 = 0, label = 0;
 $0 = _xmalloc(12) | 0;
 HEAP32[$0 >> 2] = $str;
 HEAP32[$0 + 4 >> 2] = 0;
 HEAP32[$0 + 8 >> 2] = 0;
 $e$0 = HEAP32[$l >> 2] | 0;
 while (1) {
  if (!$e$0) {
   label = 4;
   break;
  }
  $5 = $e$0 + 8 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  if (!$6) {
   $$lcssa = $5;
   label = 5;
   break;
  } else $e$0 = $6;
 }
 if ((label | 0) == 4) {
  HEAP32[$l >> 2] = $0;
  return;
 } else if ((label | 0) == 5) {
  HEAP32[$$lcssa >> 2] = $0;
  return;
 }
}

function _same_file_p($filename1, $filename2) {
 $filename1 = $filename1 | 0;
 $filename2 = $filename2 | 0;
 var $0 = 0, $13 = 0, $14 = 0, $sb1 = 0, $sb2 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 288 | 0;
 $sb1 = sp + 144 | 0;
 $sb2 = sp;
 $0 = _stat($filename1, $sb1) | 0;
 if (_stat($filename2, $sb2) | 0 | $0 | 0) {
  $14 = 0;
  STACKTOP = sp;
  return $14 | 0;
 }
 if ((HEAP32[$sb1 + 8 >> 2] | 0) == (HEAP32[$sb2 + 8 >> 2] | 0)) $13 = (HEAP32[$sb1 >> 2] | 0) == (HEAP32[$sb2 >> 2] | 0); else $13 = 0;
 $14 = $13 & 1;
 STACKTOP = sp;
 return $14 | 0;
}

function _auxend2errprint() {
 var $4 = 0, $storemerge$i = 0;
 _fwrite(1478, 22, 1, HEAP32[3989] | 0) | 0;
 _fwrite(1478, 22, 1, HEAP32[3990] | 0) | 0;
 $4 = HEAP32[16204 + (HEAP32[4050] << 2) >> 2] | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $4);
 _zoutpoolstr(HEAP32[3989] | 0, $4);
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 if ((HEAPU8[25620] | 0) < 2) {
  HEAP8[25620] = 2;
  $storemerge$i = 1;
  HEAP32[3991] = $storemerge$i;
  return;
 } else {
  $storemerge$i = (HEAP32[3991] | 0) + 1 | 0;
  HEAP32[3991] = $storemerge$i;
  return;
 }
}

function ___stdout_write($f, $buf, $len) {
 $f = $f | 0;
 $buf = $buf | 0;
 $len = $len | 0;
 var $9 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 $vararg_buffer = sp;
 HEAP32[$f + 36 >> 2] = 1;
 if (!(HEAP32[$f >> 2] & 64)) {
  HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
  HEAP32[$vararg_buffer + 4 >> 2] = 21505;
  HEAP32[$vararg_buffer + 8 >> 2] = sp + 12;
  if (___syscall54(54, $vararg_buffer | 0) | 0) HEAP8[$f + 75 >> 0] = -1;
 }
 $9 = ___stdio_write($f, $buf, $len) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _zprintmissingentry($s) {
 $s = $s | 0;
 _fwrite(2252, 45, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2252, 45, 1, HEAP32[3990] | 0) | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $s);
 _zoutpoolstr(HEAP32[3989] | 0, $s);
 _putc(34, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(34, HEAP32[3990] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 switch (HEAP8[25620] | 0) {
 case 1:
  {
   HEAP32[3991] = (HEAP32[3991] | 0) + 1;
   return;
  }
 case 0:
  {
   HEAP8[25620] = 1;
   HEAP32[3991] = 1;
   return;
  }
 default:
  return;
 }
}

function _fwrite($src, $size, $nmemb, $f) {
 $src = $src | 0;
 $size = $size | 0;
 $nmemb = $nmemb | 0;
 $f = $f | 0;
 var $0 = 0, $10 = 0, $6 = 0, $7 = 0, $phitmp = 0;
 $0 = Math_imul($nmemb, $size) | 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) {
  $phitmp = (___lockfile($f) | 0) == 0;
  $6 = ___fwritex($src, $0, $f) | 0;
  if ($phitmp) $7 = $6; else {
   ___unlockfile($f);
   $7 = $6;
  }
 } else $7 = ___fwritex($src, $0, $f) | 0;
 if (($7 | 0) == ($0 | 0)) $10 = $nmemb; else $10 = ($7 >>> 0) / ($size >>> 0) | 0;
 return $10 | 0;
}

function _calloc($n_elements, $elem_size) {
 $n_elements = $n_elements | 0;
 $elem_size = $elem_size | 0;
 var $1 = 0, $6 = 0, $req$0 = 0;
 if (!$n_elements) $req$0 = 0; else {
  $1 = Math_imul($elem_size, $n_elements) | 0;
  if (($elem_size | $n_elements) >>> 0 > 65535) $req$0 = (($1 >>> 0) / ($n_elements >>> 0) | 0 | 0) == ($elem_size | 0) ? $1 : -1; else $req$0 = $1;
 }
 $6 = _malloc($req$0) | 0;
 if (!$6) return $6 | 0;
 if (!(HEAP32[$6 + -4 >> 2] & 3)) return $6 | 0;
 _memset($6 | 0, 0, $req$0 | 0) | 0;
 return $6 | 0;
}

function _xbasename($name) {
 $name = $name | 0;
 var $base$0$ph = 0, $base$0$ph$lcssa = 0, $p$0 = 0, $p$0$lcssa4 = 0;
 $base$0$ph = $name;
 L1 : while (1) {
  $p$0 = $base$0$ph;
  L3 : while (1) {
   switch (HEAP8[$p$0 >> 0] | 0) {
   case 0:
    {
     $base$0$ph$lcssa = $base$0$ph;
     break L1;
     break;
    }
   case 47:
    {
     $p$0$lcssa4 = $p$0;
     break L3;
     break;
    }
   default:
    {}
   }
   $p$0 = $p$0 + 1 | 0;
  }
  $base$0$ph = $p$0$lcssa4 + 1 | 0;
 }
 return $base$0$ph$lcssa | 0;
}

function _opendir($name) {
 $name = $name | 0;
 var $$0 = 0, $0 = 0, $2 = 0, $vararg_buffer1 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $0 = _open($name, 589824, sp) | 0;
 do if (($0 | 0) < 0) $$0 = 0; else {
  $2 = _calloc(1, 2072) | 0;
  if (!$2) {
   HEAP32[$vararg_buffer1 >> 2] = $0;
   ___syscall6(6, $vararg_buffer1 | 0) | 0;
   $$0 = 0;
   break;
  } else {
   HEAP32[$2 >> 2] = $0;
   $$0 = $2;
   break;
  }
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _kpathsea_absolute_p($kpse, $filename, $relative_ok) {
 $kpse = $kpse | 0;
 $filename = $filename | 0;
 $relative_ok = $relative_ok | 0;
 var $0 = 0, $1 = 0, $12 = 0, $5 = 0;
 $0 = HEAP8[$filename >> 0] | 0;
 $1 = $0 << 24 >> 24 == 47;
 if (($relative_ok | 0) != 0 & $0 << 24 >> 24 == 46) {
  $5 = HEAP8[$filename + 1 >> 0] | 0;
  if ($5 << 24 >> 24 == 47) $12 = 1; else if ($5 << 24 >> 24 == 46) $12 = (HEAP8[$filename + 2 >> 0] | 0) == 47; else $12 = 0;
 } else $12 = 0;
 return ($1 | $12) & 1 | 0;
}

function ___towrite($f) {
 $f = $f | 0;
 var $$0 = 0, $0 = 0, $13 = 0, $2 = 0, $6 = 0;
 $0 = $f + 74 | 0;
 $2 = HEAP8[$0 >> 0] | 0;
 HEAP8[$0 >> 0] = $2 + 255 | $2;
 $6 = HEAP32[$f >> 2] | 0;
 if (!($6 & 8)) {
  HEAP32[$f + 8 >> 2] = 0;
  HEAP32[$f + 4 >> 2] = 0;
  $13 = HEAP32[$f + 44 >> 2] | 0;
  HEAP32[$f + 28 >> 2] = $13;
  HEAP32[$f + 20 >> 2] = $13;
  HEAP32[$f + 16 >> 2] = $13 + (HEAP32[$f + 48 >> 2] | 0);
  $$0 = 0;
 } else {
  HEAP32[$f >> 2] = $6 | 32;
  $$0 = -1;
 }
 return $$0 | 0;
}

function _kpse_fclose_trace($f) {
 $f = $f | 0;
 var $0 = 0, $6 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = _fclose($f) | 0;
 if (!(HEAP32[(HEAP32[16] | 0) + 44 >> 2] & 4)) {
  STACKTOP = sp;
  return $0 | 0;
 }
 $6 = HEAP32[21] | 0;
 _fwrite(13458, 7, 1, $6) | 0;
 HEAP32[$vararg_buffer >> 2] = $f;
 HEAP32[$vararg_buffer + 4 >> 2] = $0;
 _fprintf($6, 10540, $vararg_buffer) | 0;
 _fflush($6) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _bstmildexwarnprint() {
 var $7 = 0;
 if (HEAP32[4152] | 0) {
  _fwrite(2298, 11, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2298, 11, 1, HEAP32[3990] | 0) | 0;
  $7 = HEAP32[(HEAP32[4099] | 0) + (HEAP32[4150] << 2) >> 2] | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $7);
  _zoutpoolstr(HEAP32[3989] | 0, $7);
 }
 _putc(10, HEAP32[3989] | 0) | 0;
 _putc(10, HEAP32[3990] | 0) | 0;
 _fwrite(2327, 15, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2327, 15, 1, HEAP32[3990] | 0) | 0;
 _bstwarnprint();
 return;
}

function _xfclose($f, $filename) {
 $f = $f | 0;
 $filename = $filename | 0;
 var $3 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if (!$f) ___assert_fail(12630, 12591, 43, 12632);
 if ((_kpse_fclose_trace($f) | 0) == -1) {
  $3 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[(HEAP32[16] | 0) + 104 >> 2];
  _fprintf($3, 12640, $vararg_buffer) | 0;
  _perror($filename);
  _exit(1);
 } else {
  STACKTOP = sp;
  return;
 }
}

function _waitpid($pid, $status, $options) {
 $pid = $pid | 0;
 $status = $status | 0;
 $options = $options | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $pid;
 HEAP32[$vararg_buffer + 4 >> 2] = $status;
 HEAP32[$vararg_buffer + 8 >> 2] = $options;
 HEAP32[$vararg_buffer + 12 >> 2] = 0;
 $1 = ___syscall_ret(___syscall114(114, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _perror($msg) {
 $msg = $msg | 0;
 var $0 = 0, $13 = 0, $3 = 0;
 $0 = HEAP32[21] | 0;
 $3 = _strerror(HEAP32[(___errno_location() | 0) >> 2] | 0) | 0;
 if ((HEAP32[$0 + 76 >> 2] | 0) > -1) $13 = ___lockfile($0) | 0; else $13 = 0;
 if ($msg | 0) if (HEAP8[$msg >> 0] | 0) {
  _fwrite($msg, _strlen($msg) | 0, 1, $0) | 0;
  _fputc(58, $0) | 0;
  _fputc(32, $0) | 0;
 }
 _fwrite($3, _strlen($3) | 0, 1, $0) | 0;
 _fputc(10, $0) | 0;
 if ($13 | 0) ___unlockfile($0);
 return;
}

function _zdecrbracelevel($poplitvar) {
 $poplitvar = $poplitvar | 0;
 var $0 = 0;
 $0 = HEAP32[4330] | 0;
 if (!$0) {
  _fwrite(2597, 10, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2597, 10, 1, HEAP32[3990] | 0) | 0;
  _zoutpoolstr(HEAP32[3990] | 0, $poplitvar);
  _zoutpoolstr(HEAP32[3989] | 0, $poplitvar);
  _fwrite(2608, 31, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2608, 31, 1, HEAP32[3990] | 0) | 0;
  _bstmildexwarnprint();
  return;
 } else {
  HEAP32[4330] = $0 + -1;
  return;
 }
}

function _kpse_absolute_p($filename, $relative_ok) {
 $filename = $filename | 0;
 $relative_ok = $relative_ok | 0;
 var $0 = 0, $1 = 0, $12 = 0, $5 = 0;
 $0 = HEAP8[$filename >> 0] | 0;
 $1 = $0 << 24 >> 24 == 47;
 if (($relative_ok | 0) != 0 & $0 << 24 >> 24 == 46) {
  $5 = HEAP8[$filename + 1 >> 0] | 0;
  if ($5 << 24 >> 24 == 47) $12 = 1; else if ($5 << 24 >> 24 == 46) $12 = (HEAP8[$filename + 2 >> 0] | 0) == 47; else $12 = 0;
 } else $12 = 0;
 return ($1 | $12) & 1 | 0;
}

function _xgetcwd() {
 var $2 = 0, $6 = 0, $path = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 4112 | 0;
 $vararg_buffer = sp;
 $path = sp + 4 | 0;
 if (!(_getcwd($path, 4097) | 0)) {
  $2 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[(HEAP32[16] | 0) + 104 >> 2];
  _fprintf($2, 12640, $vararg_buffer) | 0;
  _perror(12645);
  _exit(1);
 } else {
  $6 = _xstrdup($path) | 0;
  STACKTOP = sp;
  return $6 | 0;
 }
 return 0;
}

function _find_suffix($name) {
 $name = $name | 0;
 var $$0 = 0, $0 = 0, $2 = 0, $p$0 = 0;
 $0 = _strrchr($name, 46) | 0;
 L1 : do if (!$0) $$0 = 0; else {
  $2 = $0 + 1 | 0;
  $p$0 = $2;
  L3 : while (1) {
   switch (HEAP8[$p$0 >> 0] | 0) {
   case 0:
    {
     $$0 = $2;
     break L1;
     break;
    }
   case 47:
    {
     break L3;
     break;
    }
   default:
    {}
   }
   $p$0 = $p$0 + 1 | 0;
  }
  $$0 = 0;
 } while (0);
 return $$0 | 0;
}

function _xtype() {
 var $7 = 0;
 if (!(HEAP32[4152] | 0)) {
  _fwrite(2343, 32, 1, HEAP32[3989] | 0) | 0;
  _fwrite(2343, 32, 1, HEAP32[3990] | 0) | 0;
  _bstexwarnprint();
  return;
 }
 $7 = HEAP32[(HEAP32[4100] | 0) + (HEAP32[4150] << 2) >> 2] | 0;
 if (($7 | 0) == 0 | ($7 | 0) == (HEAP32[4386] | 0)) {
  _zpushlitstk(HEAP32[4301] | 0, 1);
  return;
 } else {
  _zpushlitstk(HEAP32[(HEAP32[4145] | 0) + ($7 << 2) >> 2] | 0, 1);
  return;
 }
}

function _concat3($s1, $s2, $s3) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 $s3 = $s3 | 0;
 var $0 = 0, $2 = 0, $6 = 0, $7 = 0, $9 = 0;
 $0 = ($s2 | 0) != 0;
 if ($0) $7 = (_strlen($s2) | 0) + 1 | 0; else $7 = 1;
 $2 = ($s3 | 0) != 0;
 if ($2) $6 = _strlen($s3) | 0; else $6 = 0;
 $9 = _xmalloc($7 + $6 + (_strlen($s1) | 0) | 0) | 0;
 _strcpy($9, $s1) | 0;
 if ($0) _strcat($9, $s2) | 0;
 if (!$2) return $9 | 0;
 _strcat($9, $s3) | 0;
 return $9 | 0;
}

function _readlink($path, $buf, $bufsize) {
 $path = $path | 0;
 $buf = $buf | 0;
 $bufsize = $bufsize | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $path;
 HEAP32[$vararg_buffer + 4 >> 2] = $buf;
 HEAP32[$vararg_buffer + 8 >> 2] = $bufsize;
 $1 = ___syscall_ret(___syscall85(85, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _memmove(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0;
 if ((src | 0) < (dest | 0) & (dest | 0) < (src + num | 0)) {
  ret = dest;
  src = src + num | 0;
  dest = dest + num | 0;
  while ((num | 0) > 0) {
   dest = dest - 1 | 0;
   src = src - 1 | 0;
   num = num - 1 | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  }
  dest = ret;
 } else _memcpy(dest, src, num) | 0;
 return dest | 0;
}

function _execve($path, $argv, $envp) {
 $path = $path | 0;
 $argv = $argv | 0;
 $envp = $envp | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $path;
 HEAP32[$vararg_buffer + 4 >> 2] = $argv;
 HEAP32[$vararg_buffer + 8 >> 2] = $envp;
 $1 = ___syscall_ret(___syscall11(11, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _cmdline($n) {
 $n = $n | 0;
 var $2 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 if ((HEAP32[4698] | 0) > ($n | 0)) {
  STACKTOP = sp;
  return HEAP32[(HEAP32[4699] | 0) + ($n << 2) >> 2] | 0;
 } else {
  $2 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = HEAP32[HEAP32[4699] >> 2];
  _fprintf($2, 6081, $vararg_buffer) | 0;
  _uexit(1);
 }
 return 0;
}

function _read($fd, $buf, $count) {
 $fd = $fd | 0;
 $buf = $buf | 0;
 $count = $count | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $fd;
 HEAP32[$vararg_buffer + 4 >> 2] = $buf;
 HEAP32[$vararg_buffer + 8 >> 2] = $count;
 $1 = ___syscall_ret(___syscall3(3, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _zcheckbracelevel($poplitvar) {
 $poplitvar = $poplitvar | 0;
 if ((HEAP32[4330] | 0) <= 0) return;
 _fwrite(2597, 10, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2597, 10, 1, HEAP32[3990] | 0) | 0;
 _zoutpoolstr(HEAP32[3990] | 0, $poplitvar);
 _zoutpoolstr(HEAP32[3989] | 0, $poplitvar);
 _fwrite(2608, 31, 1, HEAP32[3989] | 0) | 0;
 _fwrite(2608, 31, 1, HEAP32[3990] | 0) | 0;
 _bstmildexwarnprint();
 return;
}

function ___uflow($f) {
 $f = $f | 0;
 var $$0 = 0, $c = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $c = sp;
 if (!(HEAP32[$f + 8 >> 2] | 0)) if (!(___toread($f) | 0)) label = 3; else $$0 = -1; else label = 3;
 if ((label | 0) == 3) if ((FUNCTION_TABLE_iiii[HEAP32[$f + 32 >> 2] & 7]($f, $c, 1) | 0) == 1) $$0 = HEAPU8[$c >> 0] | 0; else $$0 = -1;
 STACKTOP = sp;
 return $$0 | 0;
}

function _xmalloc($size) {
 $size = $size | 0;
 var $2 = 0, $4 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $2 = _malloc($size | 0 ? $size : 1) | 0;
 if (!$2) {
  $4 = HEAP32[21] | 0;
  HEAP32[$vararg_buffer >> 2] = $size;
  _fprintf($4, 12652, $vararg_buffer) | 0;
  _exit(1);
 } else {
  STACKTOP = sp;
  return $2 | 0;
 }
 return 0;
}

function ___uremdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $rem = 0, __stackBase__ = 0;
 __stackBase__ = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $rem = __stackBase__ | 0;
 ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) | 0;
 STACKTOP = __stackBase__;
 return (tempRet0 = HEAP32[$rem + 4 >> 2] | 0, HEAP32[$rem >> 2] | 0) | 0;
}

function _xwrite() {
 var $0 = 0, $1 = 0;
 _zzpoplitstk(17380, 26648);
 $0 = HEAP8[26648] | 0;
 $1 = HEAP32[4345] | 0;
 switch ($0 << 24 >> 24) {
 case 1:
  {
   _zaddoutpool($1);
   return;
  }
 case 4:
  return;
 default:
  {
   _zprintstklit($1, $0);
   _fwrite(3533, 15, 1, HEAP32[3989] | 0) | 0;
   _fwrite(3533, 15, 1, HEAP32[3990] | 0) | 0;
   _bstexwarnprint();
   return;
  }
 }
}

function _fn_copy0($agg$result, $s, $len) {
 $agg$result = $agg$result | 0;
 $s = $s | 0;
 $len = $len | 0;
 var $1 = 0, $2 = 0, $3 = 0;
 $1 = $len + 1 | 0;
 $2 = $len >>> 0 < 75 ? 75 : $1;
 $3 = _xmalloc($2) | 0;
 _strncpy($3, $s, $len) | 0;
 HEAP8[$3 + $len >> 0] = 0;
 HEAP32[$agg$result >> 2] = $3;
 HEAP32[$agg$result + 4 >> 2] = $2;
 HEAP32[$agg$result + 8 >> 2] = $1;
 return;
}

function ___block_all_sigs($set) {
 $set = $set | 0;
 var $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = 0;
 HEAP32[$vararg_buffer + 4 >> 2] = 548;
 HEAP32[$vararg_buffer + 8 >> 2] = $set;
 HEAP32[$vararg_buffer + 12 >> 2] = 8;
 ___syscall175(175, $vararg_buffer | 0) | 0;
 STACKTOP = sp;
 return;
}

function _eoln($file) {
 $file = $file | 0;
 var $$0 = 0, $2 = 0;
 L1 : do if (!(_feof($file) | 0)) {
  $2 = _getc($file) | 0;
  if (($2 | 0) == -1) $$0 = 1; else {
   _ungetc($2, $file) | 0;
   switch ($2 | 0) {
   case 10:
   case 13:
    {
     $$0 = 1;
     break L1;
     break;
    }
   default:
    {}
   }
   $$0 = 0;
  }
 } else $$0 = 1; while (0);
 return $$0 | 0;
}

function ___restore_sigs($set) {
 $set = $set | 0;
 var $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = 2;
 HEAP32[$vararg_buffer + 4 >> 2] = $set;
 HEAP32[$vararg_buffer + 8 >> 2] = 0;
 HEAP32[$vararg_buffer + 12 >> 2] = 8;
 ___syscall175(175, $vararg_buffer | 0) | 0;
 STACKTOP = sp;
 return;
}

function _llvm_cttz_i32(x) {
 x = x | 0;
 var ret = 0;
 ret = HEAP8[cttz_i8 + (x & 255) >> 0] | 0;
 if ((ret | 0) < 8) return ret | 0;
 ret = HEAP8[cttz_i8 + (x >> 8 & 255) >> 0] | 0;
 if ((ret | 0) < 8) return ret + 8 | 0;
 ret = HEAP8[cttz_i8 + (x >> 16 & 255) >> 0] | 0;
 if ((ret | 0) < 8) return ret + 16 | 0;
 return (HEAP8[cttz_i8 + (x >>> 24) >> 0] | 0) + 24 | 0;
}

function _lstat($path, $buf) {
 $path = $path | 0;
 $buf = $buf | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $path;
 HEAP32[$vararg_buffer + 4 >> 2] = $buf;
 $1 = ___syscall_ret(___syscall196(196, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _stat($path, $buf) {
 $path = $path | 0;
 $buf = $buf | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $path;
 HEAP32[$vararg_buffer + 4 >> 2] = $buf;
 $1 = ___syscall_ret(___syscall195(195, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function ___memrchr($m, $c, $n) {
 $m = $m | 0;
 $c = $c | 0;
 $n = $n | 0;
 var $$0 = 0, $$01 = 0, $0 = 0, $1 = 0, $3 = 0;
 $0 = $c & 255;
 $$01 = $n;
 while (1) {
  $1 = $$01 + -1 | 0;
  if (!$$01) {
   $$0 = 0;
   break;
  }
  $3 = $m + $1 | 0;
  if ((HEAP8[$3 >> 0] | 0) == $0 << 24 >> 24) {
   $$0 = $3;
   break;
  } else $$01 = $1;
 }
 return $$0 | 0;
}

function _remove_suffix($s) {
 $s = $s | 0;
 var $0 = 0, $5 = 0, $7 = 0, $ret$0 = 0;
 $0 = _find_suffix($s) | 0;
 if (!$0) {
  $ret$0 = _xstrdup($s) | 0;
  return $ret$0 | 0;
 } else {
  $5 = $0 + -1 - $s | 0;
  $7 = _xmalloc($5 + 1 | 0) | 0;
  _strncpy($7, $s, $5) | 0;
  HEAP8[$7 + $5 >> 0] = 0;
  $ret$0 = $7;
  return $ret$0 | 0;
 }
 return 0;
}

function _kpathsea_db_insert($kpse, $passed_fname) {
 $kpse = $kpse | 0;
 $passed_fname = $passed_fname | 0;
 var $0 = 0, $3 = 0, $4 = 0, $5 = 0;
 $0 = $kpse + 20 | 0;
 if (!(HEAP32[$0 >> 2] | 0)) return;
 $3 = _xstrdup($passed_fname) | 0;
 $4 = _xbasename($3) | 0;
 $5 = _xstrdup($4) | 0;
 HEAP8[$4 >> 0] = 0;
 _hash_insert($0, $5, $3);
 return;
}

function _kpathsea_init_format($kpse, $format) {
 $kpse = $kpse | 0;
 $format = $format | 0;
 var $0 = 0, $1 = 0, $3 = 0;
 $0 = $kpse + 132 + ($format * 68 | 0) + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if ($1 | 0) {
  $3 = $1;
  return $3 | 0;
 }
 _kpathsea_init_format_return_varlist($kpse, $format) | 0;
 $3 = HEAP32[$0 >> 2] | 0;
 return $3 | 0;
}

function _sn_write($f, $s, $l) {
 $f = $f | 0;
 $s = $s | 0;
 $l = $l | 0;
 var $2 = 0, $3 = 0, $4 = 0, $l$ = 0;
 $2 = $f + 20 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = (HEAP32[$f + 16 >> 2] | 0) - $3 | 0;
 $l$ = $4 >>> 0 > $l >>> 0 ? $l : $4;
 _memcpy($3 | 0, $s | 0, $l$ | 0) | 0;
 HEAP32[$2 >> 2] = (HEAP32[$2 >> 2] | 0) + $l$;
 return $l | 0;
}

function _feof($f) {
 $f = $f | 0;
 var $$lobit = 0, $$lobit2 = 0, $phitmp = 0;
 if ((HEAP32[$f + 76 >> 2] | 0) > -1) {
  $phitmp = (___lockfile($f) | 0) == 0;
  $$lobit = (HEAP32[$f >> 2] | 0) >>> 4 & 1;
  if ($phitmp) $$lobit2 = $$lobit; else $$lobit2 = $$lobit;
 } else $$lobit2 = (HEAP32[$f >> 2] | 0) >>> 4 & 1;
 return $$lobit2 | 0;
}

function _close($fd) {
 $fd = $fd | 0;
 var $0 = 0, $2 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $fd;
 $0 = ___syscall6(6, $vararg_buffer | 0) | 0;
 $2 = ___syscall_ret(($0 | 0) == -4 ? -115 : $0) | 0;
 STACKTOP = sp;
 return $2 | 0;
}

function _testSetjmp(id, table, size) {
 id = id | 0;
 table = table | 0;
 size = size | 0;
 var i = 0, curr = 0;
 while ((i | 0) < (size | 0)) {
  curr = HEAP32[table + (i << 3) >> 2] | 0;
  if (!curr) break;
  if ((curr | 0) == (id | 0)) return HEAP32[table + ((i << 3) + 4) >> 2] | 0;
  i = i + 1 | 0;
 }
 return 0;
}

function _cstr_list_add($l, $s) {
 $l = $l | 0;
 $s = $s | 0;
 var $1 = 0, $2 = 0, $5 = 0;
 $1 = (HEAP32[$l >> 2] | 0) + 1 | 0;
 HEAP32[$l >> 2] = $1;
 $2 = $l + 4 | 0;
 $5 = _xrealloc(HEAP32[$2 >> 2] | 0, $1 << 2) | 0;
 HEAP32[$2 >> 2] = $5;
 HEAP32[$5 + ((HEAP32[$l >> 2] | 0) + -1 << 2) >> 2] = $s;
 return;
}

function _str_list_add($l, $s) {
 $l = $l | 0;
 $s = $s | 0;
 var $1 = 0, $2 = 0, $5 = 0;
 $1 = (HEAP32[$l >> 2] | 0) + 1 | 0;
 HEAP32[$l >> 2] = $1;
 $2 = $l + 4 | 0;
 $5 = _xrealloc(HEAP32[$2 >> 2] | 0, $1 << 2) | 0;
 HEAP32[$2 >> 2] = $5;
 HEAP32[$5 + ((HEAP32[$l >> 2] | 0) + -1 << 2) >> 2] = $s;
 return;
}

function _snprintf($s, $n, $fmt, $varargs) {
 $s = $s | 0;
 $n = $n | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $0 = _vsnprintf($s, $n, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _kpathsea_dir_p($kpse, $fn) {
 $kpse = $kpse | 0;
 $fn = $fn | 0;
 var $7 = 0, $stats = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 $stats = sp;
 if (!(_stat($fn, $stats) | 0)) $7 = (HEAP32[$stats + 24 >> 2] & 61440 | 0) == 16384; else $7 = 0;
 STACKTOP = sp;
 return $7 & 1 | 0;
}

function ___stdio_close($f) {
 $f = $f | 0;
 var $3 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = HEAP32[$f + 60 >> 2];
 $3 = ___syscall_ret(___syscall6(6, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _getopt_long_only($argc, $argv, $options, $long_options, $opt_index) {
 $argc = $argc | 0;
 $argv = $argv | 0;
 $options = $options | 0;
 $long_options = $long_options | 0;
 $opt_index = $opt_index | 0;
 return __getopt_internal($argc, $argv, $options, $long_options, $opt_index, 1) | 0;
}

function _kpse_find_file($name, $format, $must_exist) {
 $name = $name | 0;
 $format = $format | 0;
 $must_exist = $must_exist | 0;
 var $1 = 0, $2 = 0;
 $1 = _kpathsea_find_file_generic(HEAP32[16] | 0, $name, $format, $must_exist, 0) | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 _free($1);
 return $2 | 0;
}

function _kpathsea_path_search($kpse, $path, $name, $must_exist) {
 $kpse = $kpse | 0;
 $path = $path | 0;
 $name = $name | 0;
 $must_exist = $must_exist | 0;
 var $0 = 0, $1 = 0;
 $0 = _search($kpse, $path, $name, $must_exist, 0) | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 _free($0);
 return $1 | 0;
}

function _hash_create($agg$result, $size) {
 $agg$result = $agg$result | 0;
 $size = $size | 0;
 var $0 = 0, $1 = 0;
 $0 = $size << 2;
 $1 = _xmalloc($0) | 0;
 if ($size | 0) _memset($1 | 0, 0, $0 | 0) | 0;
 HEAP32[$agg$result >> 2] = $1;
 HEAP32[$agg$result + 4 >> 2] = $size;
 return;
}

function _fn_shrink_to($f, $loc) {
 $f = $f | 0;
 $loc = $loc | 0;
 var $0 = 0;
 $0 = $f + 8 | 0;
 if ((HEAP32[$0 >> 2] | 0) >>> 0 > $loc >>> 0) {
  HEAP8[(HEAP32[$f >> 2] | 0) + $loc >> 0] = 0;
  HEAP32[$0 >> 2] = $loc + 1;
  return;
 } else ___assert_fail(13424, 13388, 116, 13445);
}

function _sprintf($s, $fmt, $varargs) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $0 = _vsprintf($s, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _pipe($fd) {
 $fd = $fd | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $fd;
 $1 = ___syscall_ret(___syscall42(42, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _fprintf($f, $fmt, $varargs) {
 $f = $f | 0;
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $0 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $0 = _vfprintf($f, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function _dup($fd) {
 $fd = $fd | 0;
 var $1 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 HEAP32[$vararg_buffer >> 2] = $fd;
 $1 = ___syscall_ret(___syscall41(41, $vararg_buffer | 0) | 0) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _flockfile($f) {
 $f = $f | 0;
 var $2 = 0, $3 = 0, $4 = 0;
 if (_ftrylockfile($f) | 0) {
  $2 = $f + 76 | 0;
  $3 = $f + 80 | 0;
  do {
   $4 = HEAP32[$2 >> 2] | 0;
   if ($4 | 0) ___wait($2 | 0, $3 | 0, $4 | 0, 1);
  } while ((_ftrylockfile($f) | 0) != 0);
 }
 return;
}

function _uexit($unix_code) {
 $unix_code = $unix_code | 0;
 var $final_code$0 = 0;
 switch ($unix_code | 0) {
 case 0:
  {
   $final_code$0 = 0;
   break;
  }
 case 1:
  {
   $final_code$0 = 1;
   break;
  }
 default:
  $final_code$0 = $unix_code;
 }
 _exit($final_code$0 | 0);
}

function _printf($fmt, $varargs) {
 $fmt = $fmt | 0;
 $varargs = $varargs | 0;
 var $1 = 0, $ap = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $ap = sp;
 HEAP32[$ap >> 2] = $varargs;
 $1 = _vfprintf(HEAP32[79] | 0, $fmt, $ap) | 0;
 STACKTOP = sp;
 return $1 | 0;
}

function _getc_unlocked($f) {
 $f = $f | 0;
 var $0 = 0, $1 = 0, $9 = 0;
 $0 = $f + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if ($1 >>> 0 < (HEAP32[$f + 8 >> 2] | 0) >>> 0) {
  HEAP32[$0 >> 2] = $1 + 1;
  $9 = HEAPU8[$1 >> 0] | 0;
 } else $9 = ___uflow($f) | 0;
 return $9 | 0;
}

function _bitshift64Shl(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high << bits | (low & (1 << bits) - 1 << 32 - bits) >>> 32 - bits;
  return low << bits;
 }
 tempRet0 = low << bits - 32;
 return 0;
}

function _usage($str) {
 $str = $str | 0;
 var $0 = 0, $vararg_buffer = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[21] | 0;
 HEAP32[$vararg_buffer >> 2] = $str;
 _fprintf($0, 6613, $vararg_buffer) | 0;
 _uexit(1);
}

function _bitshift64Lshr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 if ((bits | 0) < 32) {
  tempRet0 = high >>> bits;
  return low >>> bits | (high & (1 << bits) - 1) << 32 - bits;
 }
 tempRet0 = 0;
 return high >>> bits - 32 | 0;
}

function _eof($file) {
 $file = $file | 0;
 var $$0 = 0, $3 = 0;
 if (!$file) $$0 = 1; else if (!(_feof($file) | 0)) {
  $3 = _getc($file) | 0;
  if (($3 | 0) == -1) $$0 = 1; else {
   _ungetc($3, $file) | 0;
   $$0 = 0;
  }
 } else $$0 = 1;
 return $$0 | 0;
}

function _extend_filename($name, $default_suffix) {
 $name = $name | 0;
 $default_suffix = $default_suffix | 0;
 var $3 = 0;
 if (_find_suffix($name) | 0) {
  $3 = $name;
  return $3 | 0;
 }
 $3 = _concat3($name, 15912, $default_suffix) | 0;
 return $3 | 0;
}

function _kpathsea_expand($kpse, $s) {
 $kpse = $kpse | 0;
 $s = $s | 0;
 var $0 = 0, $1 = 0;
 $0 = _kpathsea_var_expand($kpse, $s) | 0;
 $1 = _kpathsea_tilde_expand($kpse, $0) | 0;
 if (($1 | 0) == ($0 | 0)) return $1 | 0;
 _free($0);
 return $1 | 0;
}

function _fn_free($f) {
 $f = $f | 0;
 var $0 = 0;
 $0 = HEAP32[$f >> 2] | 0;
 if (!$0) ___assert_fail(13365, 13388, 62, 13416); else {
  _free($0);
  HEAP32[$f >> 2] = 0;
  HEAP32[$f + 4 >> 2] = 0;
  HEAP32[$f + 8 >> 2] = 0;
  return;
 }
}

function _concat($s1, $s2) {
 $s1 = $s1 | 0;
 $s2 = $s2 | 0;
 var $0 = 0, $4 = 0;
 $0 = _strlen($s1) | 0;
 $4 = _xmalloc($0 + 1 + (_strlen($s2) | 0) | 0) | 0;
 _strcpy($4, $s1) | 0;
 _strcat($4 + $0 | 0, $s2) | 0;
 return $4 | 0;
}

function runPostSets() {}
function _i64Subtract(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var h = 0;
 h = b - d >>> 0;
 h = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0;
 return (tempRet0 = h, a - c >>> 0 | 0) | 0;
}

function ___strdup($s) {
 $s = $s | 0;
 var $$0 = 0, $1 = 0, $2 = 0;
 $1 = (_strlen($s) | 0) + 1 | 0;
 $2 = _malloc($1) | 0;
 if (!$2) $$0 = 0; else {
  _memcpy($2 | 0, $s | 0, $1 | 0) | 0;
  $$0 = $2;
 }
 return $$0 | 0;
}

function dynCall_iiiii(index, a1, a2, a3, a4) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return FUNCTION_TABLE_iiiii[index & 1](a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0;
}

function ___syscall_ret($r) {
 $r = $r | 0;
 var $$0 = 0;
 if ($r >>> 0 > 4294963200) {
  HEAP32[(___errno_location() | 0) >> 2] = 0 - $r;
  $$0 = -1;
 } else $$0 = $r;
 return $$0 | 0;
}

function _funlockfile($f) {
 $f = $f | 0;
 var $0 = 0, $2 = 0;
 $0 = $f + 68 | 0;
 $2 = (HEAP32[$0 >> 2] | 0) + -1 | 0;
 HEAP32[$0 >> 2] = $2;
 if (!$2) ___unlockfile($f);
 return;
}

function _i64Add(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var l = 0;
 l = a + c >>> 0;
 return (tempRet0 = b + d + (l >>> 0 < a >>> 0 | 0) >>> 0, l | 0) | 0;
}

function _kpse_set_program_name($argv0, $progname) {
 $argv0 = $argv0 | 0;
 $progname = $progname | 0;
 _kpathsea_set_program_name(HEAP32[16] | 0, $argv0, $progname);
 return;
}

function _fn_init($agg$result) {
 $agg$result = $agg$result | 0;
 HEAP32[$agg$result >> 2] = 0;
 HEAP32[$agg$result + 4 >> 2] = 0;
 HEAP32[$agg$result + 8 >> 2] = 0;
 return;
}

function dynCall_iiii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return FUNCTION_TABLE_iiii[index & 7](a1 | 0, a2 | 0, a3 | 0) | 0;
}

function ___udivdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 return ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0;
}

function _strchr($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 var $0 = 0;
 $0 = ___strchrnul($s, $c) | 0;
 return ((HEAP8[$0 >> 0] | 0) == ($c & 255) << 24 >> 24 ? $0 : 0) | 0;
}

function _str_list_free($l) {
 $l = $l | 0;
 var $0 = 0, $1 = 0;
 $0 = $l + 4 | 0;
 $1 = HEAP32[$0 >> 2] | 0;
 if (!$1) return;
 _free($1);
 HEAP32[$0 >> 2] = 0;
 return;
}

function _kpathsea_all_path_search($kpse, $path, $name) {
 $kpse = $kpse | 0;
 $path = $path | 0;
 $name = $name | 0;
 return _search($kpse, $path, $name, 1, 1) | 0;
}
function stackAlloc(size) {
 size = size | 0;
 var ret = 0;
 ret = STACKTOP;
 STACKTOP = STACKTOP + size | 0;
 STACKTOP = STACKTOP + 15 & -16;
 return ret | 0;
}

function _getpid() {
 var $0 = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 $0 = ___syscall20(20, sp | 0) | 0;
 STACKTOP = sp;
 return $0 | 0;
}

function ___errno_location() {
 var $$0 = 0;
 if (!(HEAP32[5757] | 0)) $$0 = 23072; else $$0 = HEAP32[(_pthread_self() | 0) + 64 >> 2] | 0;
 return $$0 | 0;
}

function establishStackSpace(stackBase, stackMax) {
 stackBase = stackBase | 0;
 stackMax = stackMax | 0;
 STACKTOP = stackBase;
 STACK_MAX = stackMax;
}

function _strnlen($s, $n) {
 $s = $s | 0;
 $n = $n | 0;
 var $0 = 0;
 $0 = _memchr($s, 0, $n) | 0;
 return (($0 | 0) == 0 ? $n : $0 - $s | 0) | 0;
}

function dynCall_iii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 return FUNCTION_TABLE_iii[index & 1](a1 | 0, a2 | 0) | 0;
}

function _wctomb($s, $wc) {
 $s = $s | 0;
 $wc = $wc | 0;
 var $$0 = 0;
 if (!$s) $$0 = 0; else $$0 = _wcrtomb($s, $wc, 0) | 0;
 return $$0 | 0;
}

function _strcat($dest, $src) {
 $dest = $dest | 0;
 $src = $src | 0;
 _strcpy($dest + (_strlen($dest) | 0) | 0, $src) | 0;
 return $dest | 0;
}

function _execvp($file, $argv) {
 $file = $file | 0;
 $argv = $argv | 0;
 return ___execvpe($file, $argv, HEAP32[___environ >> 2] | 0) | 0;
}

function setThrew(threw, value) {
 threw = threw | 0;
 value = value | 0;
 if (!__THREW__) {
  __THREW__ = threw;
  threwValue = value;
 }
}

function _vsprintf($s, $fmt, $ap) {
 $s = $s | 0;
 $fmt = $fmt | 0;
 $ap = $ap | 0;
 return _vsnprintf($s, 2147483647, $fmt, $ap) | 0;
}

function dynCall_vii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 FUNCTION_TABLE_vii[index & 1](a1 | 0, a2 | 0);
}

function _kpse_out_name_ok($fname) {
 $fname = $fname | 0;
 return _kpathsea_name_ok(HEAP32[16] | 0, $fname, 9997, 10009, 1, 0) | 0;
}

function _close_file($f) {
 $f = $f | 0;
 if (!$f) return;
 if ((_kpse_fclose_trace($f) | 0) != -1) return;
 _perror(6150);
 return;
}

function _kpse_in_name_ok($fname) {
 $fname = $fname | 0;
 return _kpathsea_name_ok(HEAP32[16] | 0, $fname, 9935, 11402, 0, 0) | 0;
}

function _closedir($dir) {
 $dir = $dir | 0;
 var $1 = 0;
 $1 = _close(HEAP32[$dir >> 2] | 0) | 0;
 _free($dir);
 return $1 | 0;
}

function _main($ac, $av) {
 $ac = $ac | 0;
 $av = $av | 0;
 HEAP32[4698] = $ac;
 HEAP32[4699] = $av;
 _mainbody();
 return 0;
}

function _kpathsea_filename_component($kpse, $p) {
 $kpse = $kpse | 0;
 $p = $p | 0;
 return _element($kpse, $p, 0) | 0;
}

function _strncpy($d, $s, $n) {
 $d = $d | 0;
 $s = $s | 0;
 $n = $n | 0;
 ___stpncpy($d, $s, $n) | 0;
 return $d | 0;
}

function _strcpy($dest, $src) {
 $dest = $dest | 0;
 $src = $src | 0;
 ___stpcpy($dest, $src) | 0;
 return $dest | 0;
}

function dynCall_ii(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 return FUNCTION_TABLE_ii[index & 3](a1 | 0) | 0;
}

function _toupper($c) {
 $c = $c | 0;
 var $1 = 0;
 $1 = (_islower($c) | 0) == 0;
 return ($1 ? $c : $c & 95) | 0;
}

function _tolower($c) {
 $c = $c | 0;
 var $1 = 0;
 $1 = (_isupper($c) | 0) == 0;
 return ($1 ? $c : $c | 32) | 0;
}

function _strrchr($s, $c) {
 $s = $s | 0;
 $c = $c | 0;
 return ___memrchr($s, $c, (_strlen($s) | 0) + 1 | 0) | 0;
}

function _kpathsea_path_element($kpse, $p) {
 $kpse = $kpse | 0;
 $p = $p | 0;
 return _element($kpse, $p, 1) | 0;
}

function _fputs($s, $f) {
 $s = $s | 0;
 $f = $f | 0;
 return (_fwrite($s, _strlen($s) | 0, 1, $f) | 0) + -1 | 0;
}

function _isalnum($c) {
 $c = $c | 0;
 return (($c + -48 | 0) >>> 0 < 10 | (_isalpha($c) | 0) != 0) & 1 | 0;
}

function b5(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 abort(5);
 return 0;
}

function dynCall_vi(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 FUNCTION_TABLE_vi[index & 7](a1 | 0);
}

function _kpse_var_value($var) {
 $var = $var | 0;
 return _kpathsea_var_value(HEAP32[16] | 0, $var) | 0;
}

function _xstrdup($s) {
 $s = $s | 0;
 return _strcpy(_xmalloc((_strlen($s) | 0) + 1 | 0) | 0, $s) | 0;
}

function _cleanup_252($p) {
 $p = $p | 0;
 if (!(HEAP32[$p + 68 >> 2] | 0)) ___unlockfile($p);
 return;
}

function _cleanup($p) {
 $p = $p | 0;
 if (!(HEAP32[$p + 68 >> 2] | 0)) ___unlockfile($p);
 return;
}

function _isspace($c) {
 $c = $c | 0;
 return (($c | 0) == 32 | ($c + -9 | 0) >>> 0 < 5) & 1 | 0;
}

function b0(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 abort(0);
 return 0;
}

function _wait($status) {
 $status = $status | 0;
 return _waitpid(-1, $status, 0) | 0;
}

function _isalpha($c) {
 $c = $c | 0;
 return (($c | 32) + -97 | 0) >>> 0 < 26 | 0;
}

function dynCall_v(index) {
 index = index | 0;
 FUNCTION_TABLE_v[index & 7]();
}

function _frexpl($x, $e) {
 $x = +$x;
 $e = $e | 0;
 return +(+_frexp($x, $e));
}

function _isupper($c) {
 $c = $c | 0;
 return ($c + -65 | 0) >>> 0 < 26 | 0;
}

function _islower($c) {
 $c = $c | 0;
 return ($c + -97 | 0) >>> 0 < 26 | 0;
}

function __exit($status) {
 $status = $status | 0;
 __Exit($status | 0);
}

function b6(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(6);
 return 0;
}

function setTempRet0(value) {
 value = value | 0;
 tempRet0 = value;
}

function _xclosedir($d) {
 $d = $d | 0;
 _closedir($d) | 0;
 return;
}

function stackRestore(top) {
 top = top | 0;
 STACKTOP = top;
}

function b2(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 abort(2);
}

function b3(p0) {
 p0 = p0 | 0;
 abort(3);
 return 0;
}

function ___unlockfile($f) {
 $f = $f | 0;
 return;
}

function ___lockfile($f) {
 $f = $f | 0;
 return 0;
}

function getTempRet0() {
 return tempRet0 | 0;
}

function stackSave() {
 return STACKTOP | 0;
}

function _dummy($x) {
 $x = $x | 0;
 return;
}

function b1(p0) {
 p0 = p0 | 0;
 abort(1);
}

function _pthread_self() {
 return 0;
}

function b4() {
 abort(4);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_iiii = [b0,___stdio_write,___stdio_seek,___stdio_read,___stdout_write,_sn_write,_fprintf,b0];
var FUNCTION_TABLE_vi = [b1,_close_file,_uexit,_cleanup_252,_cleanup,b1,b1,b1];
var FUNCTION_TABLE_vii = [b2,_zoutpoolstr];
var FUNCTION_TABLE_ii = [b3,___stdio_close,_xmalloc,_zinputln];
var FUNCTION_TABLE_v = [b4,_setupparams,_initialize,_getauxcommandandprocess,_lastcheckforauxerrors,_getbstcommandandprocess,_traceandstatprinting,b4];
var FUNCTION_TABLE_iiiii = [b5,_fwrite];
var FUNCTION_TABLE_iii = [b6,_putc];

  return { _testSetjmp: _testSetjmp, _saveSetjmp: _saveSetjmp, _free: _free, _main: _main, _realloc: _realloc, _i64Add: _i64Add, _memmove: _memmove, _pthread_self: _pthread_self, _i64Subtract: _i64Subtract, _memset: _memset, _malloc: _malloc, _memcpy: _memcpy, _llvm_cttz_i32: _llvm_cttz_i32, _bitshift64Shl: _bitshift64Shl, _bitshift64Lshr: _bitshift64Lshr, _fflush: _fflush, ___udivdi3: ___udivdi3, ___uremdi3: ___uremdi3, ___errno_location: ___errno_location, ___udivmoddi4: ___udivmoddi4, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, establishStackSpace: establishStackSpace, setThrew: setThrew, setTempRet0: setTempRet0, getTempRet0: getTempRet0, dynCall_iiii: dynCall_iiii, dynCall_vi: dynCall_vi, dynCall_vii: dynCall_vii, dynCall_ii: dynCall_ii, dynCall_v: dynCall_v, dynCall_iiiii: dynCall_iiiii, dynCall_iii: dynCall_iii };
});
// EMSCRIPTEN_END_ASM
if (!ENVIRONMENT_IS_BROWSIX) {
  if (typeof asmModule !== 'undefined')
    asm = asmModule(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
  else
    asm = asm(Module.asmGlobalArg, Module.asmLibraryArg, buffer);
} else {
  if (typeof SharedArrayBuffer !== 'undefined') Module.asmGlobalArg['Atomics'] = Atomics;
}

var _testSetjmp;
var _saveSetjmp;
var _free;
var _main;
var _realloc;
var _i64Add;
var _memmove;
var ___udivmoddi4;
var _pthread_self;
var _i64Subtract;
var _memset;
var _malloc;
var runPostSets;
var _memcpy;
var _llvm_cttz_i32;
var _bitshift64Lshr;
var _fflush;
var ___udivdi3;
var ___uremdi3;
var ___errno_location;
var _bitshift64Shl;
var dynCall_iiii;
var dynCall_vi;
var dynCall_vii;
var dynCall_ii;
var dynCall_v;
var dynCall_iiiii;
var dynCall_iii;


function initReceiving() {
  _testSetjmp = Module["_testSetjmp"] = asm["_testSetjmp"];
  _saveSetjmp = Module["_saveSetjmp"] = asm["_saveSetjmp"];
  _free = Module["_free"] = asm["_free"];
  _main = Module["_main"] = asm["_main"];
  _realloc = Module["_realloc"] = asm["_realloc"];
  _i64Add = Module["_i64Add"] = asm["_i64Add"];
  _memmove = Module["_memmove"] = asm["_memmove"];
  ___udivmoddi4 = Module["___udivmoddi4"] = asm["___udivmoddi4"];
  _pthread_self = Module["_pthread_self"] = asm["_pthread_self"];
  _i64Subtract = Module["_i64Subtract"] = asm["_i64Subtract"];
  _memset = Module["_memset"] = asm["_memset"];
  _malloc = Module["_malloc"] = asm["_malloc"];
  runPostSets = Module["runPostSets"] = asm["runPostSets"];
  _memcpy = Module["_memcpy"] = asm["_memcpy"];
  _llvm_cttz_i32 = Module["_llvm_cttz_i32"] = asm["_llvm_cttz_i32"];
  _bitshift64Lshr = Module["_bitshift64Lshr"] = asm["_bitshift64Lshr"];
  _fflush = Module["_fflush"] = asm["_fflush"];
  ___udivdi3 = Module["___udivdi3"] = asm["___udivdi3"];
  ___uremdi3 = Module["___uremdi3"] = asm["___uremdi3"];
  ___errno_location = Module["___errno_location"] = asm["___errno_location"];
  _bitshift64Shl = Module["_bitshift64Shl"] = asm["_bitshift64Shl"];
  dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
  dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
  dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
  dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
  dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
  dynCall_iiiii = Module["dynCall_iiiii"] = asm["dynCall_iiiii"];
  dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
;
}
if (!ENVIRONMENT_IS_BROWSIX)
  initReceiving();

function initRuntimeFuncs() {

  Runtime.stackAlloc = asm['stackAlloc'];
  Runtime.stackSave = asm['stackSave'];
  Runtime.stackRestore = asm['stackRestore'];
  Runtime.establishStackSpace = asm['establishStackSpace'];

  Runtime.setTempRet0 = asm['setTempRet0'];
  Runtime.getTempRet0 = asm['getTempRet0'];

}
if (!ENVIRONMENT_IS_BROWSIX)
  initRuntimeFuncs();



// === Auto-generated postamble setup entry stuff ===





function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {

  args = args || [];

  ensureInitRuntime();

  // build the environment here, because we're just going to malloc
  // what we need to back our environment.
  ___buildEnvironment(ENV);

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString(Module['thisProgram']), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);


  try {

    var ret = Module['_main'](argc, argv, HEAP32[_environ>>2]);


    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    return;
  }


  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    ensureInitRuntime();

    preMain();


    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (Module['_main'] && shouldRunNow) Module['callMain'](args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status, implicit) {
  if (implicit && Module['noExitRuntime']) {
    return;
  }

  // we don't care about noExitRuntime for explicit exit calls in Browsix()
  if (ENVIRONMENT_IS_BROWSIX) {
    EXITSTATUS = status;
    Runtime.process.exit(status);
    var ua = navigator.appVersion;
    if (ua.includes('Safari/') && !ua.includes('Chrom')) {
      // WebKit doesn't like ExitStatus being thrown, but this
      // infinite loop severly hurts perf on non-webkit browsers.
      for (;;) {}
    } else {
      // this will terminate the worker's execution as an uncaught
      // Exception, which is what we want.
      throw new ExitStatus(status);
    }
  }

  if (Module['noExitRuntime']) {
  } else {

    ABORT = true;
    EXITSTATUS = status;
    STACKTOP = initialStackTop;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  if (ENVIRONMENT_IS_NODE) {
    process['exit'](status);
  } else if (ENVIRONMENT_IS_SHELL && typeof quit === 'function') {
    quit(status);
  }
  // if we reach here, we must throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

var abortDecorators = [];

function abort(what) {
  if (what !== undefined) {
    Module.print(what);
    Module.printErr(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.';

  var output = 'abort(' + what + ') at ' + stackTrace() + extra;
  if (abortDecorators) {
    abortDecorators.forEach(function(decorator) {
      output = decorator(output, what);
    });
  }
  throw output;
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}


if (ENVIRONMENT_IS_BROWSIX) {
  self.onmessage = SYSCALLS.browsix.syscall.resultHandler.bind(SYSCALLS.browsix.syscall);
  Runtime.process.once('ready', function() {
    Module['thisProgram'] = Runtime.process.argv[0];
    for (var k in Runtime.process.env) {
      if (!Runtime.process.env.hasOwnProperty(k))
        continue;
      ENV[k] = Runtime.process.env[k];
    }
    ENV = Runtime.process.env;
    ENV['_'] = Runtime.process.argv[0];

    if (Runtime.process.pid) {
      abort('TODO: sync post-fork?');
    } else {
      run(Runtime.process.argv.slice(2));
    }
  });
}

if (!ENVIRONMENT_IS_BROWSIX) {
  var oldHEAP8 = HEAP8;
  ret = new ArrayBuffer(TOTAL_MEMORY);
  var temp = new Int8Array(ret);
  temp.set(oldHEAP8);
  _emscripten_replace_memory(ret);
  updateGlobalBuffer(ret);
  updateGlobalBufferViews();
  run();
}

// {{POST_RUN_ADDITIONS}}





// {{MODULE_ADDITIONS}}






